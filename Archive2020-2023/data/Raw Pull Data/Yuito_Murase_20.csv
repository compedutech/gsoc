pr_id,pr_title,pr_body,is_merged,pr_number,pr_url,pr_html_url,pr_state,additions,deletions,pr_changed_files,pr_commits_count,pr_comments_count,pr_review_comments_count,pr_labels_count,pr_assignees_count,pr_labels,pr_created_at,pr_closed_at,time_taken,time_delta,pr_review_comments,pr_commits,contributor,contributor_id,contributor_email,contributor_type,contributions,contributor_public_repos,contributor_private_repos,contributor_followings,contributor_followers
1445501545,[experimental feature] Support HOAS pattern with type variables for quote pattern matching,"This PR extends higher-order patterns inside quote patterns to allow type parameters. When this PR is merged, we'll be able to write quote patterns like the following example with an experimental flag `experimental.quotedPatternsWithPolymorphicFunctions`.

```scala
def decomposePoly(x: Expr[Any])(using Quotes): Expr[Int] =
  x match
    case '{ [A] => (x: List[A]) => $y[A](x) : Int } =>
      '{ $y[Int](List(1, 2, 3)) }
    case _ => Expr(0)
```

You can see that the higher-order pattern `$y[A](x)` carries an type parameter `A`. It states that this pattern matches a code fragment with occurrences of `A`, and `y` is assigned a polymorphic function type `[A] => List[A] => x`. 

This PR mainly changes two parts: type checker and quote pattern matcher. Those changes are based on the formalized type system defined in [Nicolas Stucki's thesis](https://github.com/nicolasstucki#thesis), and one can expect the soundness of the implementation.

## Type Dependency
If a higher-order pattern carries a value parameter with a type that has type parameters defined in the quoted pattern, those type parameters should also be captured in the higher-order pattern. For example, the following pattern will not be typed.

```
case '{ [A] => (x: List[A]) => $y(x) : Int } =>
```

In this case, `x` has the type `List[A]`, which includes a type variable `A` that is defined in the pattern. However, the higher-order pattern `$y(x)` does not have any type parameters. This should be ill-typed. One can always avoid this kind of type errors by adding type parameters, like `$y[A](x)`

## Implementation Restriction
Current implementation only allows type parameters that do not have bounds, because sound typing rules for such pattern is not clear yet.

```scala
case '{ [A] => (x: List[A]) => $y(x) : Int } => // Allowed
case '{ [A <: Int] => (x: List[A]) => $y(x) : Int } => // Disallowed",True,18271,https://api.github.com/repos/scala/scala3/pulls/18271,https://github.com/scala/scala3/pull/18271,closed,624,125,38,1,4,21,2,1,"[{'name': 'area:experimental'}, {'name': 'needs-minor-release'}]",2023-07-23 05:44:05+00:00,2024-07-22 11:39:51+00:00,31557346.0,"365 days, 5:55:46","[{'comment_id': 1278937692, 'comment_body': 'move typedTypeargs before typedArgs', 'comment_created': datetime.datetime(2023, 7, 31, 8, 13, 25, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1278941256, 'comment_body': 'We might want to move this logic to `checkPattern` because we have fully-typed tree.', 'comment_created': datetime.datetime(2023, 7, 31, 8, 16, 36, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1278958110, 'comment_body': 'Use `Set[Symbol]` instead', 'comment_created': datetime.datetime(2023, 7, 31, 8, 31, 4, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1278962215, 'comment_body': '* `... needs to be introduces ...` => `... needs to be defined ...`\r\n* Show type name\r\n', 'comment_created': datetime.datetime(2023, 7, 31, 8, 34, 56, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1278974056, 'comment_body': 'Two traversals\r\n* accumulator: collect all type variables (+ existing logic from traverser)\r\n* traverse: check occurrence\r\n\r\n', 'comment_created': datetime.datetime(2023, 7, 31, 8, 45, 28, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1285397190, 'comment_body': 'For Sync Aug 07: Now checkPattern detects two kinds of ill-formed hoas patterns', 'comment_created': datetime.datetime(2023, 8, 7, 5, 40, 39, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1285397650, 'comment_body': 'Sync Aug 07: How to check type bounds with fully typed tree?', 'comment_created': datetime.datetime(2023, 8, 7, 5, 41, 31, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1285398536, 'comment_body': 'Sync Aug 07: Now QuoteMatcher supports pattern match against TypeBoundsTree and TypeDef to match type parameters from DefDef', 'comment_created': datetime.datetime(2023, 8, 7, 5, 43, 20, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1285398912, 'comment_body': 'Sync Aug 07: Compare types up to the current environment', 'comment_created': datetime.datetime(2023, 8, 7, 5, 44, 7, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1285399485, 'comment_body': 'Sync Aug 07: Now freePatternVars collects type variables (Q: this is a decent way to collect type vars?)', 'comment_created': datetime.datetime(2023, 8, 7, 5, 45, 19, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1285399925, 'comment_body': 'Sync Aug 07: This implementation fails Typer.assertPositioned when enabling -XcheckMacros. How to avoid?', 'comment_created': datetime.datetime(2023, 8, 7, 5, 46, 15, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1285512723, 'comment_body': 'Sync Aug 07: Is this rule reasonable? (somewhat related to #18144)', 'comment_created': datetime.datetime(2023, 8, 7, 7, 54, 24, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1293136593, 'comment_body': 'better to have: Show example of expected code `$b[A](x)` in this case', 'comment_created': datetime.datetime(2023, 8, 14, 8, 12, 57, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1293139644, 'comment_body': 'more cases:\r\n* use test case with Map', 'comment_created': datetime.datetime(2023, 8, 14, 8, 16, 14, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1293153776, 'comment_body': 'Add test cases for this\r\n(maybe we want to impose a restriction that rhs1 and rhs2 are empty bounds?)', 'comment_created': datetime.datetime(2023, 8, 14, 8, 26, 33, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1293154574, 'comment_body': ""```\r\n[X <: T] => ...\r\ncase '{ [ A] => f[A]() } => f[Any]\r\n```"", 'comment_created': datetime.datetime(2023, 8, 14, 8, 27, 10, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1293180338, 'comment_body': 'Add check files to test error messages', 'comment_created': datetime.datetime(2023, 8, 14, 8, 51, 36, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1686400355, 'comment_body': 'Added `experimental` here and in other tests', 'comment_created': datetime.datetime(2024, 7, 22, 11, 30, 22, tzinfo=datetime.timezone.utc), 'commenter': 'jchyb', 'type': 'User'}, {'comment_id': 1686404030, 'comment_body': 'Adjusted pickling and unpicking of SplicePatterns as it was previously prepared for this PR by Nicolas', 'comment_created': datetime.datetime(2024, 7, 22, 11, 33, 49, tzinfo=datetime.timezone.utc), 'commenter': 'jchyb', 'type': 'User'}, {'comment_id': 1686404231, 'comment_body': 'Same here', 'comment_created': datetime.datetime(2024, 7, 22, 11, 34, 2, tzinfo=datetime.timezone.utc), 'commenter': 'jchyb', 'type': 'User'}]","[{'commit_sha': '41e2d52f661182b55efa07ed2dcd9b4bd7051985', 'committer_username': 'zeptometer', 'committer_name': 'Yuito Murase', 'committer_email': 'yuito@acupof.coffee', 'commit_date': datetime.datetime(2010, 10, 27, 12, 57, 11, tzinfo=datetime.timezone.utc)}]",Yuito Murase,456330,yuito@acupof.coffee,User,,58,,11,37
1445501545,[experimental feature] Support HOAS pattern with type variables for quote pattern matching,"This PR extends higher-order patterns inside quote patterns to allow type parameters. When this PR is merged, we'll be able to write quote patterns like the following example with an experimental flag `experimental.quotedPatternsWithPolymorphicFunctions`.

```scala
def decomposePoly(x: Expr[Any])(using Quotes): Expr[Int] =
  x match
    case '{ [A] => (x: List[A]) => $y[A](x) : Int } =>
      '{ $y[Int](List(1, 2, 3)) }
    case _ => Expr(0)
```

You can see that the higher-order pattern `$y[A](x)` carries an type parameter `A`. It states that this pattern matches a code fragment with occurrences of `A`, and `y` is assigned a polymorphic function type `[A] => List[A] => x`. 

This PR mainly changes two parts: type checker and quote pattern matcher. Those changes are based on the formalized type system defined in [Nicolas Stucki's thesis](https://github.com/nicolasstucki#thesis), and one can expect the soundness of the implementation.

## Type Dependency
If a higher-order pattern carries a value parameter with a type that has type parameters defined in the quoted pattern, those type parameters should also be captured in the higher-order pattern. For example, the following pattern will not be typed.

```
case '{ [A] => (x: List[A]) => $y(x) : Int } =>
```

In this case, `x` has the type `List[A]`, which includes a type variable `A` that is defined in the pattern. However, the higher-order pattern `$y(x)` does not have any type parameters. This should be ill-typed. One can always avoid this kind of type errors by adding type parameters, like `$y[A](x)`

## Implementation Restriction
Current implementation only allows type parameters that do not have bounds, because sound typing rules for such pattern is not clear yet.

```scala
case '{ [A] => (x: List[A]) => $y(x) : Int } => // Allowed
case '{ [A <: Int] => (x: List[A]) => $y(x) : Int } => // Disallowed",True,18271,https://api.github.com/repos/scala/scala3/pulls/18271,https://github.com/scala/scala3/pull/18271,closed,624,125,38,1,4,21,2,1,"[{'name': 'area:experimental'}, {'name': 'needs-minor-release'}]",2023-07-23 05:44:05+00:00,2024-07-22 11:39:51+00:00,31557346.0,"365 days, 5:55:46","[{'comment_id': 1278937692, 'comment_body': 'move typedTypeargs before typedArgs', 'comment_created': datetime.datetime(2023, 7, 31, 8, 13, 25, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1278941256, 'comment_body': 'We might want to move this logic to `checkPattern` because we have fully-typed tree.', 'comment_created': datetime.datetime(2023, 7, 31, 8, 16, 36, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1278958110, 'comment_body': 'Use `Set[Symbol]` instead', 'comment_created': datetime.datetime(2023, 7, 31, 8, 31, 4, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1278962215, 'comment_body': '* `... needs to be introduces ...` => `... needs to be defined ...`\r\n* Show type name\r\n', 'comment_created': datetime.datetime(2023, 7, 31, 8, 34, 56, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1278974056, 'comment_body': 'Two traversals\r\n* accumulator: collect all type variables (+ existing logic from traverser)\r\n* traverse: check occurrence\r\n\r\n', 'comment_created': datetime.datetime(2023, 7, 31, 8, 45, 28, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1285397190, 'comment_body': 'For Sync Aug 07: Now checkPattern detects two kinds of ill-formed hoas patterns', 'comment_created': datetime.datetime(2023, 8, 7, 5, 40, 39, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1285397650, 'comment_body': 'Sync Aug 07: How to check type bounds with fully typed tree?', 'comment_created': datetime.datetime(2023, 8, 7, 5, 41, 31, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1285398536, 'comment_body': 'Sync Aug 07: Now QuoteMatcher supports pattern match against TypeBoundsTree and TypeDef to match type parameters from DefDef', 'comment_created': datetime.datetime(2023, 8, 7, 5, 43, 20, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1285398912, 'comment_body': 'Sync Aug 07: Compare types up to the current environment', 'comment_created': datetime.datetime(2023, 8, 7, 5, 44, 7, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1285399485, 'comment_body': 'Sync Aug 07: Now freePatternVars collects type variables (Q: this is a decent way to collect type vars?)', 'comment_created': datetime.datetime(2023, 8, 7, 5, 45, 19, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1285399925, 'comment_body': 'Sync Aug 07: This implementation fails Typer.assertPositioned when enabling -XcheckMacros. How to avoid?', 'comment_created': datetime.datetime(2023, 8, 7, 5, 46, 15, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1285512723, 'comment_body': 'Sync Aug 07: Is this rule reasonable? (somewhat related to #18144)', 'comment_created': datetime.datetime(2023, 8, 7, 7, 54, 24, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1293136593, 'comment_body': 'better to have: Show example of expected code `$b[A](x)` in this case', 'comment_created': datetime.datetime(2023, 8, 14, 8, 12, 57, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1293139644, 'comment_body': 'more cases:\r\n* use test case with Map', 'comment_created': datetime.datetime(2023, 8, 14, 8, 16, 14, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1293153776, 'comment_body': 'Add test cases for this\r\n(maybe we want to impose a restriction that rhs1 and rhs2 are empty bounds?)', 'comment_created': datetime.datetime(2023, 8, 14, 8, 26, 33, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1293154574, 'comment_body': ""```\r\n[X <: T] => ...\r\ncase '{ [ A] => f[A]() } => f[Any]\r\n```"", 'comment_created': datetime.datetime(2023, 8, 14, 8, 27, 10, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1293180338, 'comment_body': 'Add check files to test error messages', 'comment_created': datetime.datetime(2023, 8, 14, 8, 51, 36, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1686400355, 'comment_body': 'Added `experimental` here and in other tests', 'comment_created': datetime.datetime(2024, 7, 22, 11, 30, 22, tzinfo=datetime.timezone.utc), 'commenter': 'jchyb', 'type': 'User'}, {'comment_id': 1686404030, 'comment_body': 'Adjusted pickling and unpicking of SplicePatterns as it was previously prepared for this PR by Nicolas', 'comment_created': datetime.datetime(2024, 7, 22, 11, 33, 49, tzinfo=datetime.timezone.utc), 'commenter': 'jchyb', 'type': 'User'}, {'comment_id': 1686404231, 'comment_body': 'Same here', 'comment_created': datetime.datetime(2024, 7, 22, 11, 34, 2, tzinfo=datetime.timezone.utc), 'commenter': 'jchyb', 'type': 'User'}]","[{'commit_sha': '41e2d52f661182b55efa07ed2dcd9b4bd7051985', 'committer_username': 'zeptometer', 'committer_name': 'Yuito Murase', 'committer_email': 'yuito@acupof.coffee', 'commit_date': datetime.datetime(2010, 10, 27, 12, 57, 11, tzinfo=datetime.timezone.utc)}]",Yuito Murase,456330,yuito@acupof.coffee,User,,58,,11,37
1362558506,Make HOAS Quote pattern match with def method capture ,"This PR will fix #17105 by extracting symbols from eta-expanded identifiers.

This fix enables the use of patterns such as
```scala
case '{ def f(...): T = ...; $g(f): U } => 
```
where `g` will match any expression that may contain references to `f`.",True,17567,https://api.github.com/repos/scala/scala3/pulls/17567,https://github.com/scala/scala3/pull/17567,closed,187,28,8,1,4,46,0,1,[],2023-05-24 07:37:11+00:00,2023-06-21 06:24:54+00:00,2414863.0,"27 days, 22:47:43","[{'comment_id': 1203690886, 'comment_body': '```suggestion\r\n              case Block((ddef: DefDef) :: _, _: Closure) => getCapturedIdent(ddef.rhs)\r\n```', 'comment_created': datetime.datetime(2023, 5, 24, 8, 29, 53, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1203692398, 'comment_body': '`getCapturedIdent` could return the `Symbol` directly. This way, we can avoid this extra `map`.', 'comment_created': datetime.datetime(2023, 5, 24, 8, 30, 53, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1203707708, 'comment_body': 'These outputs show that we need to adapt the type of `g` in the lambdas. For example `g: (y: scala.Int)scala.Int` should be `g: scala.Int => scala.Int`. We probably need to addapt the type here \r\nhttps://github.com/lampepfl/dotty/blob/main/compiler/src/scala/quoted/runtime/impl/QuoteMatcher.scala#LL468C13-L468C13. We need to convert `MethodType`s into funtion types. The `defn.FunctionOf` method might be useful here (defined in `Definitions.scala`).\r\n\r\nI would expect this output to look like\r\n```\r\n((g: scala.Int => scala.Int, n: scala.Int) => g(n))\r\n((g: (scala.Int, scala.Int) => scala.Int) => g(1, 2))\r\n((g2: (scala.math.Ordered[scala.Int]) => scala.Boolean, ord: scala.math.Ordered[scala.Int]) => (g2(ord).||(2.<(3)): scala.Boolean))\r\n```\r\n\r\n\r\n\r\n', 'comment_created': datetime.datetime(2023, 5, 24, 8, 40, 39, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1204258711, 'comment_body': 'Here I intended to use `capturedIds`  as a parameter to `matchedOpen` and we cannot omit it (we get compiler errors if we use `args` for `matchedOpen` instead).', 'comment_created': datetime.datetime(2023, 5, 24, 14, 27, 40, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1204261157, 'comment_body': ""According to your other comment on i17105.check, it's likely I need to change this part anyway."", 'comment_created': datetime.datetime(2023, 5, 24, 14, 28, 47, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1204262518, 'comment_body': ""Thank you, I'll try to fix this issue (and add appropriate test cases)"", 'comment_created': datetime.datetime(2023, 5, 24, 14, 29, 24, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1204272276, 'comment_body': 'TODO: Add case for `Typed(term)` @zeptometer ', 'comment_created': datetime.datetime(2023, 5, 24, 14, 33, 38, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1204276013, 'comment_body': '@nicolasstucki Do you think we should raise an error in this case (or what would be other options)? If so, what is a standard way to raise compiler errors?', 'comment_created': datetime.datetime(2023, 5, 24, 14, 35, 24, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1206928640, 'comment_body': 'The standard way to emit errors is `report.error(msg, pos)` or `report.error(msg, tree)`. ', 'comment_created': datetime.datetime(2023, 5, 26, 15, 5, 59, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1206932787, 'comment_body': 'In this case, I would remove the default case and let the compiler crash. If we reach that point, it is a compiler bug, not a user error. The default match error will show the tree that we missed, which is what we need to know to be able to add the missing case.', 'comment_created': datetime.datetime(2023, 5, 26, 15, 8, 44, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1208775548, 'comment_body': ""Got it, then I'll follow that way. Thank you!"", 'comment_created': datetime.datetime(2023, 5, 29, 2, 29, 24, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1209020630, 'comment_body': '`Int => Int` could also be `scala.Function1[scala.Int, scala.Int]`. From `Function0` up to `Function22` we have concrete `FnunctionN` classes that implement the lambda type. `T => R` is equivalent to `Function1[T, R]` in the Scala type system. This only applies to normal function parameters, not if the argument is implicit as in `def f(using T): R = ...` or `T ?=> R` (similar for functions that contain erased parameters).', 'comment_created': datetime.datetime(2023, 5, 29, 7, 41, 48, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1216732232, 'comment_body': 'Thank you, added in b120ffb32d40d6b684fdceacf3ff890fe984fad6', 'comment_created': datetime.datetime(2023, 6, 4, 14, 12, 54, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1216732325, 'comment_body': 'Done in b120ffb32d40d6b684fdceacf3ff890fe984fad6', 'comment_created': datetime.datetime(2023, 6, 4, 14, 13, 8, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1216732455, 'comment_body': 'Applied in b120ffb32d40d6b684fdceacf3ff890fe984fad6', 'comment_created': datetime.datetime(2023, 6, 4, 14, 13, 19, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1216735947, 'comment_body': 'Is this the right way to construct a typed tree?', 'comment_created': datetime.datetime(2023, 6, 4, 14, 17, 51, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1216736453, 'comment_body': 'Is this the right pattern to match against methods?', 'comment_created': datetime.datetime(2023, 6, 4, 14, 18, 24, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1216736810, 'comment_body': 'Is this the right pattern to construct typed tree?', 'comment_created': datetime.datetime(2023, 6, 4, 14, 18, 49, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1216742980, 'comment_body': 'With this test case, I got the following error.\r\n\r\n```\r\n-- [E172] Type Error: /home/yuito/code/dotty-workspace/issue-17105/macro_1.scala:39:56\r\n39 |    case \'{ def g(using s: String) = ""placeholder""; $a(g): String } =>\r\n   |                                                        ^\r\n   |  No given instance of type String was found for parameter s of method g\r\n```\r\n\r\nThis seems to be undesirable behavior considering that we don\'t necessarily resolve\r\ncontextual parameters at this point. If it\'s an issue, it should be fixed as another issue from this issue.', 'comment_created': datetime.datetime(2023, 6, 4, 14, 24, 27, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1217372308, 'comment_body': 'Do we want to use `fun.tpe.widenTermRefExpr` in this case?', 'comment_created': datetime.datetime(2023, 6, 5, 2, 32, 3, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1217647422, 'comment_body': 'Typing an untyped tree is dangerous. Depending on the context where this is typed, we could end up with different result. It is also a bit inefficient.\r\n\r\nThe correct way to do this is to create the typed tree directly. In this case you can use the `select` and `appliedToArgs` helper methods to construct this tree. The code should be `fnId.select(nme.apply).appliedToArgs(args))`.', 'comment_created': datetime.datetime(2023, 6, 5, 7, 32, 27, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1217651270, 'comment_body': 'Here it would be better to call `tp.paramInfos.map.apply(apply)`. Calling it through `adaptTypes` requires the creation of a new `TypeMap` in each recursion.', 'comment_created': datetime.datetime(2023, 6, 5, 7, 36, 1, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1217659117, 'comment_body': ""We do not want to do the recursion on all nested types. We only need to map the outermost `MethodType` (and `PolyType` in later on) into lambda types.\r\n\r\nNote that there are cases where we can encounter `MethodType` that we do not want to if we have refinement types. For example \r\n```scala\r\ncase '{\r\n  def f(x: { def g(i: Int): Int } ): Unit = ...\r\n  $h(f)\r\n}\r\n```\r\nwhere `h` would have type `Expr[({ def g(i: Int): Int }) => Unit]` where the `MethodType` of `g` would not be modified."", 'comment_created': datetime.datetime(2023, 6, 5, 7, 43, 7, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1217660679, 'comment_body': 'This is probably what we need\r\n```scala\r\n    def adaptTypes(tpe: Type)(using Context): Type = tpe match\r\n      case tp: MethodType =>\r\n        defn.FunctionOf(tp.paramInfos, adaptTypes(tp.resultType)/*, tp.isImplicitMethod*/) // or tp.isContextualMethod\r\n      case _ =>\r\n        tpe\r\n```', 'comment_created': datetime.datetime(2023, 6, 5, 7, 44, 30, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1218053170, 'comment_body': 'This code assumes that `tree` in this case is always in the form of `f(arg1)...(argn)`. Is it a safe assumption?\r\n', 'comment_created': datetime.datetime(2023, 6, 5, 13, 10, 14, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1220930902, 'comment_body': 'Yes. If not all arguments are applied in the source, the application is eta-expanded to provide the missing arguments explicitly to the call.', 'comment_created': datetime.datetime(2023, 6, 7, 6, 26, 7, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1220936312, 'comment_body': 'We should fix that in another PR.', 'comment_created': datetime.datetime(2023, 6, 7, 6, 29, 46, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1220939806, 'comment_body': '```suggestion\r\n                    case Apply(fun, args) => adaptMethodCalls(fun).select(nme.apply).appliedToArgs(args)\r\n```', 'comment_created': datetime.datetime(2023, 6, 7, 6, 32, 42, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1220941554, 'comment_body': '```suggestion\r\n              case Apply(fun, _) => getCapturedIdent(fun)\r\n```', 'comment_created': datetime.datetime(2023, 6, 7, 6, 34, 19, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1220942050, 'comment_body': '```suggestion\r\n              case Typed(expr, _) => getCapturedIdent(expr)\r\n```', 'comment_created': datetime.datetime(2023, 6, 7, 6, 34, 46, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1221526311, 'comment_body': 'Fixed, thank you', 'comment_created': datetime.datetime(2023, 6, 7, 12, 42, 53, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1221527073, 'comment_body': 'Fixed, thank you. I should add this test case.', 'comment_created': datetime.datetime(2023, 6, 7, 12, 43, 31, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1221527699, 'comment_body': 'Got it, thank you!', 'comment_created': datetime.datetime(2023, 6, 7, 12, 44, 1, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1221537090, 'comment_body': 'Note: I created another issue https://github.com/lampepfl/dotty/issues/17905', 'comment_created': datetime.datetime(2023, 6, 7, 12, 50, 3, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1230507349, 'comment_body': ""This method was necessary to match with nested dependent types such as\r\n```\r\ncase '{\r\n      def p(dsl: DSL)(a: dsl.N): dsl.N = a\r\n      $y(p): String\r\n    } =>\r\n      '{ $y((dsl: DSL) => (b2: dsl.N) => dsl.next(b2)) }\r\n```\r\nwhere second param types are dependent on first params.\r\nThis function pattern match the first parameters, generate new environment, and then succeed to matching rest parameters with the new environment.\r\n"", 'comment_created': datetime.datetime(2023, 6, 15, 6, 40, 42, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1230557378, 'comment_body': 'Nice. This example should be added as a test case.', 'comment_created': datetime.datetime(2023, 6, 15, 7, 24, 30, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1230812718, 'comment_body': ""Yes, I've added it to test cases. https://github.com/lampepfl/dotty/pull/17567/files#diff-f7f4e796d4ad68562b3441959fa979ec8c04b2ff8981ae8a9bf7c7f83555d389R12-R19"", 'comment_created': datetime.datetime(2023, 6, 15, 10, 43, 51, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1230841653, 'comment_body': '`ematch` is always `Seq.empty` and `pmatch` should also return `Seq.empty` on match.\r\nShould I remove the part `ematch &&& pmatch &&&` to simplify logic?', 'comment_created': datetime.datetime(2023, 6, 15, 11, 4, 46, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1230848042, 'comment_body': 'This file has two `notMatched`, one with debug print and another without (because `scrutinee` and `pattern` are not available). Is it acceptable, or should I unify them in some way? (Easy option would be removing debug-print, but I want to keep it in some way)', 'comment_created': datetime.datetime(2023, 6, 15, 11, 10, 45, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1230896337, 'comment_body': 'I considered the following approach, but catch with `boundary.Break` might not be very good idea (maintainability & performance). How do you think?\r\n\r\n```scala\r\n try {\r\n   val res = pattern match ...\r\n } catch {\r\n        case _: boundary.Break[MatchingExprs] =>\r\n          if (debug)\r\n            val quotes = QuotesImpl()\r\n            println(\r\n              s"""""">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\r\n                  |Scrutinee\r\n                  |  ${scrutinee.show}\r\n                  |did not match pattern\r\n                  |  ${pattern.show}\r\n                  |\r\n                  |with environment: ${summon[Env]}\r\n                  |\r\n                  |Scrutinee: ${quotes.reflect.Printer.TreeStructure.show(scrutinee.asInstanceOf)}\r\n                  |Pattern: ${quotes.reflect.Printer.TreeStructure.show(pattern.asInstanceOf)}\r\n                  |\r\n                  |"""""".stripMargin)\r\n          notMatched\r\n      }\r\n```', 'comment_created': datetime.datetime(2023, 6, 15, 11, 53, 47, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1233672795, 'comment_body': 'I think the condition `!tree.tpe.isInstanceOf[MethodicType]` is unnecessary (test cases pass without this).', 'comment_created': datetime.datetime(2023, 6, 19, 7, 59, 34, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1234091080, 'comment_body': ""After a discussion with @nicolasstucki, we decided to separate this part into another PR. I'll keep the original implementation in this PR."", 'comment_created': datetime.datetime(2023, 6, 19, 13, 45, 48, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1234814375, 'comment_body': '```suggestion\r\n```', 'comment_created': datetime.datetime(2023, 6, 20, 6, 51, 44, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1234815608, 'comment_body': '`defn` should have been imported by `import dotty.tools.dotc.core.Symbols.*`. This definition should be removed.', 'comment_created': datetime.datetime(2023, 6, 20, 6, 53, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1236012652, 'comment_body': 'Removed.', 'comment_created': datetime.datetime(2023, 6, 20, 23, 48, 38, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1236012947, 'comment_body': ""Thank you, I've followed your advice."", 'comment_created': datetime.datetime(2023, 6, 20, 23, 49, 15, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}]","[{'commit_sha': 'd819d9fdd5dc59a205e87596690ba092e71b647e', 'committer_username': 'zeptometer', 'committer_name': 'Yuito Murase', 'committer_email': 'yuito@acupof.coffee', 'commit_date': datetime.datetime(2010, 10, 27, 12, 57, 11, tzinfo=datetime.timezone.utc)}]",Yuito Murase,456330,yuito@acupof.coffee,User,,58,,11,37
1404534294,Inhibit typer to insert contextual arguments when it is inside arguments of HOAS patterns,"This will close #17905.

## Current behavior and issue

Consider the following macro:

```scala
// Macro_1.scala
import scala.quoted.*

inline def testCtxParam(inline body: Any) = ${ testCtxParamImpl('body) }
def testCtxParamImpl(body: Expr[Any])(using Quotes): Expr[String] =
  body match
    case '{ def g(using s: String) = ""placeholder""; $a(g): String } =>
      '{ $a((s: String) => s""(inside ${s})"") }
    case _ => Expr(""not matched"")
```

```scala
// Test_2.scala
@main def Test: Unit =
  given String = ""given""
  println(testCtxParam { def f(using t: String) = ""placeholder""; f + "" outside"" })
```

In theory, running this code should allow the quote '{ def f(using t: String)... } to match against the first clause of testCtxParamImpl, binding $a to '{ g => g + "" outside""}. As such, we'd expect Test_2.scala to output (inside given) outside.

However, compiling Macro_1.scala results in the following error:

```
-- Error: macro_1.scala:6:56 ---------------------------------------------------
6 |    case '{ def g(using s: String) = ""placeholder""; $a(g): String } =>
  |                                                        ^
  |    No given instance of type String was found for parameter s of method g
1 error found
```

The issue stems from the method symbol `g` in the HOAS pattern `$a(g)`. Here, `g` should represent a symbol that can appear in the pattern variable `$a`. It's not intended to mean a method call, yet the compiler treats it as such, attempts to insert explicit contextual arguments, and fails.

## Approach to fix this issue
It is `Typer.adaptNoArgs` that inserts explicit contextual arguments. I added the following condition `!ctx.mode.is(Mode.InQuotePatternHoasArgs)` to prevent it from inserting contextual arguments.

https://github.com/lampepfl/dotty/pull/18040/files#diff-8c9ece1772bd78160fc1c31e988664586c9df566a1d22ff99ef99dd6d5627a90R4064

`Mode.InQuotePatternHoasArgs`  is a new mode for typing arguments of a HOAS pattern. This solution works, as all existing tests have passed. However, considering that the number of Modes is limited to 32 in the current implementation, it might not be the most optimal approach.

## Discussion: Matching against contextual/implicit methods
An aspect to consider is how the quote pattern match should treat normal/contextual/implicit methods. For instance, consider this macro:

```scala
import scala.quoted.

inline def testMethods(inline body: Any) = ${ testMethodsImpl('body) }
def testMethodsImpl(body: Expr[Any])(using Quotes): Expr[String] =
  body match
    case '{ given i : Int = 0; def g(s: Int) = ""placeholder""; g(i) } =>
      Expr(""matched normal method"")
    case '{ given i : Int = 0; def g(using s: Int) = ""placeholder""; g } =>
      Expr(""matched contextual method"")
    case '{ given i : Int = 0; def g(implicit s: Int) = ""placeholder""; g } =>
      Expr(""matched implicit method"")
    case _ => Expr(""not matched"")
```

If we run `testMethods { given Int = 0; def f(implicit s: Int) = ""placeholder""; f }`, how should it be handled?

If pattern matching is done exactly, it should match the third pattern. However, given the similar behavior of using and implicit, it could reasonably match the second pattern. Alternatively, the pattern matcher can forget any information about context parameters, matching the first pattern -- which is the current behavior.

In the current implementation (even without this fix), `testMethods { given Int = 0; def f(implicit s: Any) = ""placeholder""; f(10) }` expands to `""matched normal method""`.  This suggests that quote pattern matching disregards whether method parameters are contextual or not.

This behavior has its merits; it removes the need to provide different patterns to match both normal and contextual methods. However, changing this behavior could disrupt macros dependent on the current behavior, potentially breaking the backward compatibility of quote pattern matching.

The question remains: should we maintain the current behavior, or alter the quote pattern matcher to differentiate between normal and contextual methods?",True,18040,https://api.github.com/repos/scala/scala3/pulls/18040,https://github.com/scala/scala3/pull/18040,closed,45,10,7,2,0,5,0,1,[],2023-06-23 06:09:11+00:00,2023-07-13 12:03:41+00:00,1749270.0,"20 days, 5:54:30","[{'comment_id': 1241771668, 'comment_body': ""I don't think this is far from clean code, but it's working, at least. We want to figure out how to refactor this."", 'comment_created': datetime.datetime(2023, 6, 26, 7, 49, 48, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1241772421, 'comment_body': 'This fixes a bug that was introduced by #17567 ', 'comment_created': datetime.datetime(2023, 6, 26, 7, 50, 31, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1241793792, 'comment_body': 'can be simplified to `!(resmatch && ctx.mode.is(Mode.QuotedPattern))`', 'comment_created': datetime.datetime(2023, 6, 26, 8, 7, 43, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1250374789, 'comment_body': 'This is a comment for #17567, might be better to separate PR ', 'comment_created': datetime.datetime(2023, 7, 3, 7, 16, 6, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1250435333, 'comment_body': 'A separate commit is enough.', 'comment_created': datetime.datetime(2023, 7, 3, 7, 59, 28, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}]","[{'commit_sha': 'f921b7c4a7154ccbdbdf4f60c1a4f1fe1a599e19', 'committer_username': 'zeptometer', 'committer_name': 'Yuito Murase', 'committer_email': 'yuito@acupof.coffee', 'commit_date': datetime.datetime(2010, 10, 27, 12, 57, 11, tzinfo=datetime.timezone.utc)}, {'commit_sha': '8519dea5e514b569eb98631aef9cdcbb2d100f45', 'committer_username': 'zeptometer', 'committer_name': 'Yuito Murase', 'committer_email': 'yuito@acupof.coffee', 'commit_date': datetime.datetime(2010, 10, 27, 12, 57, 11, tzinfo=datetime.timezone.utc)}]",Yuito Murase,456330,yuito@acupof.coffee,User,,58,,11,37
1362558506,Make HOAS Quote pattern match with def method capture ,"This PR will fix #17105 by extracting symbols from eta-expanded identifiers.

This fix enables the use of patterns such as
```scala
case '{ def f(...): T = ...; $g(f): U } => 
```
where `g` will match any expression that may contain references to `f`.",True,17567,https://api.github.com/repos/scala/scala3/pulls/17567,https://github.com/scala/scala3/pull/17567,closed,187,28,8,1,4,46,0,1,[],2023-05-24 07:37:11+00:00,2023-06-21 06:24:54+00:00,2414863.0,"27 days, 22:47:43","[{'comment_id': 1203690886, 'comment_body': '```suggestion\r\n              case Block((ddef: DefDef) :: _, _: Closure) => getCapturedIdent(ddef.rhs)\r\n```', 'comment_created': datetime.datetime(2023, 5, 24, 8, 29, 53, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1203692398, 'comment_body': '`getCapturedIdent` could return the `Symbol` directly. This way, we can avoid this extra `map`.', 'comment_created': datetime.datetime(2023, 5, 24, 8, 30, 53, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1203707708, 'comment_body': 'These outputs show that we need to adapt the type of `g` in the lambdas. For example `g: (y: scala.Int)scala.Int` should be `g: scala.Int => scala.Int`. We probably need to addapt the type here \r\nhttps://github.com/lampepfl/dotty/blob/main/compiler/src/scala/quoted/runtime/impl/QuoteMatcher.scala#LL468C13-L468C13. We need to convert `MethodType`s into funtion types. The `defn.FunctionOf` method might be useful here (defined in `Definitions.scala`).\r\n\r\nI would expect this output to look like\r\n```\r\n((g: scala.Int => scala.Int, n: scala.Int) => g(n))\r\n((g: (scala.Int, scala.Int) => scala.Int) => g(1, 2))\r\n((g2: (scala.math.Ordered[scala.Int]) => scala.Boolean, ord: scala.math.Ordered[scala.Int]) => (g2(ord).||(2.<(3)): scala.Boolean))\r\n```\r\n\r\n\r\n\r\n', 'comment_created': datetime.datetime(2023, 5, 24, 8, 40, 39, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1204258711, 'comment_body': 'Here I intended to use `capturedIds`  as a parameter to `matchedOpen` and we cannot omit it (we get compiler errors if we use `args` for `matchedOpen` instead).', 'comment_created': datetime.datetime(2023, 5, 24, 14, 27, 40, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1204261157, 'comment_body': ""According to your other comment on i17105.check, it's likely I need to change this part anyway."", 'comment_created': datetime.datetime(2023, 5, 24, 14, 28, 47, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1204262518, 'comment_body': ""Thank you, I'll try to fix this issue (and add appropriate test cases)"", 'comment_created': datetime.datetime(2023, 5, 24, 14, 29, 24, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1204272276, 'comment_body': 'TODO: Add case for `Typed(term)` @zeptometer ', 'comment_created': datetime.datetime(2023, 5, 24, 14, 33, 38, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1204276013, 'comment_body': '@nicolasstucki Do you think we should raise an error in this case (or what would be other options)? If so, what is a standard way to raise compiler errors?', 'comment_created': datetime.datetime(2023, 5, 24, 14, 35, 24, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1206928640, 'comment_body': 'The standard way to emit errors is `report.error(msg, pos)` or `report.error(msg, tree)`. ', 'comment_created': datetime.datetime(2023, 5, 26, 15, 5, 59, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1206932787, 'comment_body': 'In this case, I would remove the default case and let the compiler crash. If we reach that point, it is a compiler bug, not a user error. The default match error will show the tree that we missed, which is what we need to know to be able to add the missing case.', 'comment_created': datetime.datetime(2023, 5, 26, 15, 8, 44, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1208775548, 'comment_body': ""Got it, then I'll follow that way. Thank you!"", 'comment_created': datetime.datetime(2023, 5, 29, 2, 29, 24, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1209020630, 'comment_body': '`Int => Int` could also be `scala.Function1[scala.Int, scala.Int]`. From `Function0` up to `Function22` we have concrete `FnunctionN` classes that implement the lambda type. `T => R` is equivalent to `Function1[T, R]` in the Scala type system. This only applies to normal function parameters, not if the argument is implicit as in `def f(using T): R = ...` or `T ?=> R` (similar for functions that contain erased parameters).', 'comment_created': datetime.datetime(2023, 5, 29, 7, 41, 48, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1216732232, 'comment_body': 'Thank you, added in b120ffb32d40d6b684fdceacf3ff890fe984fad6', 'comment_created': datetime.datetime(2023, 6, 4, 14, 12, 54, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1216732325, 'comment_body': 'Done in b120ffb32d40d6b684fdceacf3ff890fe984fad6', 'comment_created': datetime.datetime(2023, 6, 4, 14, 13, 8, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1216732455, 'comment_body': 'Applied in b120ffb32d40d6b684fdceacf3ff890fe984fad6', 'comment_created': datetime.datetime(2023, 6, 4, 14, 13, 19, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1216735947, 'comment_body': 'Is this the right way to construct a typed tree?', 'comment_created': datetime.datetime(2023, 6, 4, 14, 17, 51, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1216736453, 'comment_body': 'Is this the right pattern to match against methods?', 'comment_created': datetime.datetime(2023, 6, 4, 14, 18, 24, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1216736810, 'comment_body': 'Is this the right pattern to construct typed tree?', 'comment_created': datetime.datetime(2023, 6, 4, 14, 18, 49, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1216742980, 'comment_body': 'With this test case, I got the following error.\r\n\r\n```\r\n-- [E172] Type Error: /home/yuito/code/dotty-workspace/issue-17105/macro_1.scala:39:56\r\n39 |    case \'{ def g(using s: String) = ""placeholder""; $a(g): String } =>\r\n   |                                                        ^\r\n   |  No given instance of type String was found for parameter s of method g\r\n```\r\n\r\nThis seems to be undesirable behavior considering that we don\'t necessarily resolve\r\ncontextual parameters at this point. If it\'s an issue, it should be fixed as another issue from this issue.', 'comment_created': datetime.datetime(2023, 6, 4, 14, 24, 27, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1217372308, 'comment_body': 'Do we want to use `fun.tpe.widenTermRefExpr` in this case?', 'comment_created': datetime.datetime(2023, 6, 5, 2, 32, 3, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1217647422, 'comment_body': 'Typing an untyped tree is dangerous. Depending on the context where this is typed, we could end up with different result. It is also a bit inefficient.\r\n\r\nThe correct way to do this is to create the typed tree directly. In this case you can use the `select` and `appliedToArgs` helper methods to construct this tree. The code should be `fnId.select(nme.apply).appliedToArgs(args))`.', 'comment_created': datetime.datetime(2023, 6, 5, 7, 32, 27, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1217651270, 'comment_body': 'Here it would be better to call `tp.paramInfos.map.apply(apply)`. Calling it through `adaptTypes` requires the creation of a new `TypeMap` in each recursion.', 'comment_created': datetime.datetime(2023, 6, 5, 7, 36, 1, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1217659117, 'comment_body': ""We do not want to do the recursion on all nested types. We only need to map the outermost `MethodType` (and `PolyType` in later on) into lambda types.\r\n\r\nNote that there are cases where we can encounter `MethodType` that we do not want to if we have refinement types. For example \r\n```scala\r\ncase '{\r\n  def f(x: { def g(i: Int): Int } ): Unit = ...\r\n  $h(f)\r\n}\r\n```\r\nwhere `h` would have type `Expr[({ def g(i: Int): Int }) => Unit]` where the `MethodType` of `g` would not be modified."", 'comment_created': datetime.datetime(2023, 6, 5, 7, 43, 7, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1217660679, 'comment_body': 'This is probably what we need\r\n```scala\r\n    def adaptTypes(tpe: Type)(using Context): Type = tpe match\r\n      case tp: MethodType =>\r\n        defn.FunctionOf(tp.paramInfos, adaptTypes(tp.resultType)/*, tp.isImplicitMethod*/) // or tp.isContextualMethod\r\n      case _ =>\r\n        tpe\r\n```', 'comment_created': datetime.datetime(2023, 6, 5, 7, 44, 30, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1218053170, 'comment_body': 'This code assumes that `tree` in this case is always in the form of `f(arg1)...(argn)`. Is it a safe assumption?\r\n', 'comment_created': datetime.datetime(2023, 6, 5, 13, 10, 14, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1220930902, 'comment_body': 'Yes. If not all arguments are applied in the source, the application is eta-expanded to provide the missing arguments explicitly to the call.', 'comment_created': datetime.datetime(2023, 6, 7, 6, 26, 7, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1220936312, 'comment_body': 'We should fix that in another PR.', 'comment_created': datetime.datetime(2023, 6, 7, 6, 29, 46, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1220939806, 'comment_body': '```suggestion\r\n                    case Apply(fun, args) => adaptMethodCalls(fun).select(nme.apply).appliedToArgs(args)\r\n```', 'comment_created': datetime.datetime(2023, 6, 7, 6, 32, 42, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1220941554, 'comment_body': '```suggestion\r\n              case Apply(fun, _) => getCapturedIdent(fun)\r\n```', 'comment_created': datetime.datetime(2023, 6, 7, 6, 34, 19, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1220942050, 'comment_body': '```suggestion\r\n              case Typed(expr, _) => getCapturedIdent(expr)\r\n```', 'comment_created': datetime.datetime(2023, 6, 7, 6, 34, 46, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1221526311, 'comment_body': 'Fixed, thank you', 'comment_created': datetime.datetime(2023, 6, 7, 12, 42, 53, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1221527073, 'comment_body': 'Fixed, thank you. I should add this test case.', 'comment_created': datetime.datetime(2023, 6, 7, 12, 43, 31, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1221527699, 'comment_body': 'Got it, thank you!', 'comment_created': datetime.datetime(2023, 6, 7, 12, 44, 1, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1221537090, 'comment_body': 'Note: I created another issue https://github.com/lampepfl/dotty/issues/17905', 'comment_created': datetime.datetime(2023, 6, 7, 12, 50, 3, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1230507349, 'comment_body': ""This method was necessary to match with nested dependent types such as\r\n```\r\ncase '{\r\n      def p(dsl: DSL)(a: dsl.N): dsl.N = a\r\n      $y(p): String\r\n    } =>\r\n      '{ $y((dsl: DSL) => (b2: dsl.N) => dsl.next(b2)) }\r\n```\r\nwhere second param types are dependent on first params.\r\nThis function pattern match the first parameters, generate new environment, and then succeed to matching rest parameters with the new environment.\r\n"", 'comment_created': datetime.datetime(2023, 6, 15, 6, 40, 42, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1230557378, 'comment_body': 'Nice. This example should be added as a test case.', 'comment_created': datetime.datetime(2023, 6, 15, 7, 24, 30, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1230812718, 'comment_body': ""Yes, I've added it to test cases. https://github.com/lampepfl/dotty/pull/17567/files#diff-f7f4e796d4ad68562b3441959fa979ec8c04b2ff8981ae8a9bf7c7f83555d389R12-R19"", 'comment_created': datetime.datetime(2023, 6, 15, 10, 43, 51, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1230841653, 'comment_body': '`ematch` is always `Seq.empty` and `pmatch` should also return `Seq.empty` on match.\r\nShould I remove the part `ematch &&& pmatch &&&` to simplify logic?', 'comment_created': datetime.datetime(2023, 6, 15, 11, 4, 46, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1230848042, 'comment_body': 'This file has two `notMatched`, one with debug print and another without (because `scrutinee` and `pattern` are not available). Is it acceptable, or should I unify them in some way? (Easy option would be removing debug-print, but I want to keep it in some way)', 'comment_created': datetime.datetime(2023, 6, 15, 11, 10, 45, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1230896337, 'comment_body': 'I considered the following approach, but catch with `boundary.Break` might not be very good idea (maintainability & performance). How do you think?\r\n\r\n```scala\r\n try {\r\n   val res = pattern match ...\r\n } catch {\r\n        case _: boundary.Break[MatchingExprs] =>\r\n          if (debug)\r\n            val quotes = QuotesImpl()\r\n            println(\r\n              s"""""">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\r\n                  |Scrutinee\r\n                  |  ${scrutinee.show}\r\n                  |did not match pattern\r\n                  |  ${pattern.show}\r\n                  |\r\n                  |with environment: ${summon[Env]}\r\n                  |\r\n                  |Scrutinee: ${quotes.reflect.Printer.TreeStructure.show(scrutinee.asInstanceOf)}\r\n                  |Pattern: ${quotes.reflect.Printer.TreeStructure.show(pattern.asInstanceOf)}\r\n                  |\r\n                  |"""""".stripMargin)\r\n          notMatched\r\n      }\r\n```', 'comment_created': datetime.datetime(2023, 6, 15, 11, 53, 47, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1233672795, 'comment_body': 'I think the condition `!tree.tpe.isInstanceOf[MethodicType]` is unnecessary (test cases pass without this).', 'comment_created': datetime.datetime(2023, 6, 19, 7, 59, 34, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1234091080, 'comment_body': ""After a discussion with @nicolasstucki, we decided to separate this part into another PR. I'll keep the original implementation in this PR."", 'comment_created': datetime.datetime(2023, 6, 19, 13, 45, 48, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1234814375, 'comment_body': '```suggestion\r\n```', 'comment_created': datetime.datetime(2023, 6, 20, 6, 51, 44, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1234815608, 'comment_body': '`defn` should have been imported by `import dotty.tools.dotc.core.Symbols.*`. This definition should be removed.', 'comment_created': datetime.datetime(2023, 6, 20, 6, 53, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1236012652, 'comment_body': 'Removed.', 'comment_created': datetime.datetime(2023, 6, 20, 23, 48, 38, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1236012947, 'comment_body': ""Thank you, I've followed your advice."", 'comment_created': datetime.datetime(2023, 6, 20, 23, 49, 15, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}]","[{'commit_sha': 'd819d9fdd5dc59a205e87596690ba092e71b647e', 'committer_username': 'zeptometer', 'committer_name': 'Yuito Murase', 'committer_email': 'yuito@acupof.coffee', 'commit_date': datetime.datetime(2010, 10, 27, 12, 57, 11, tzinfo=datetime.timezone.utc)}]",Yuito Murase,456330,yuito@acupof.coffee,User,,58,,11,37
1404534294,Inhibit typer to insert contextual arguments when it is inside arguments of HOAS patterns,"This will close #17905.

## Current behavior and issue

Consider the following macro:

```scala
// Macro_1.scala
import scala.quoted.*

inline def testCtxParam(inline body: Any) = ${ testCtxParamImpl('body) }
def testCtxParamImpl(body: Expr[Any])(using Quotes): Expr[String] =
  body match
    case '{ def g(using s: String) = ""placeholder""; $a(g): String } =>
      '{ $a((s: String) => s""(inside ${s})"") }
    case _ => Expr(""not matched"")
```

```scala
// Test_2.scala
@main def Test: Unit =
  given String = ""given""
  println(testCtxParam { def f(using t: String) = ""placeholder""; f + "" outside"" })
```

In theory, running this code should allow the quote '{ def f(using t: String)... } to match against the first clause of testCtxParamImpl, binding $a to '{ g => g + "" outside""}. As such, we'd expect Test_2.scala to output (inside given) outside.

However, compiling Macro_1.scala results in the following error:

```
-- Error: macro_1.scala:6:56 ---------------------------------------------------
6 |    case '{ def g(using s: String) = ""placeholder""; $a(g): String } =>
  |                                                        ^
  |    No given instance of type String was found for parameter s of method g
1 error found
```

The issue stems from the method symbol `g` in the HOAS pattern `$a(g)`. Here, `g` should represent a symbol that can appear in the pattern variable `$a`. It's not intended to mean a method call, yet the compiler treats it as such, attempts to insert explicit contextual arguments, and fails.

## Approach to fix this issue
It is `Typer.adaptNoArgs` that inserts explicit contextual arguments. I added the following condition `!ctx.mode.is(Mode.InQuotePatternHoasArgs)` to prevent it from inserting contextual arguments.

https://github.com/lampepfl/dotty/pull/18040/files#diff-8c9ece1772bd78160fc1c31e988664586c9df566a1d22ff99ef99dd6d5627a90R4064

`Mode.InQuotePatternHoasArgs`  is a new mode for typing arguments of a HOAS pattern. This solution works, as all existing tests have passed. However, considering that the number of Modes is limited to 32 in the current implementation, it might not be the most optimal approach.

## Discussion: Matching against contextual/implicit methods
An aspect to consider is how the quote pattern match should treat normal/contextual/implicit methods. For instance, consider this macro:

```scala
import scala.quoted.

inline def testMethods(inline body: Any) = ${ testMethodsImpl('body) }
def testMethodsImpl(body: Expr[Any])(using Quotes): Expr[String] =
  body match
    case '{ given i : Int = 0; def g(s: Int) = ""placeholder""; g(i) } =>
      Expr(""matched normal method"")
    case '{ given i : Int = 0; def g(using s: Int) = ""placeholder""; g } =>
      Expr(""matched contextual method"")
    case '{ given i : Int = 0; def g(implicit s: Int) = ""placeholder""; g } =>
      Expr(""matched implicit method"")
    case _ => Expr(""not matched"")
```

If we run `testMethods { given Int = 0; def f(implicit s: Int) = ""placeholder""; f }`, how should it be handled?

If pattern matching is done exactly, it should match the third pattern. However, given the similar behavior of using and implicit, it could reasonably match the second pattern. Alternatively, the pattern matcher can forget any information about context parameters, matching the first pattern -- which is the current behavior.

In the current implementation (even without this fix), `testMethods { given Int = 0; def f(implicit s: Any) = ""placeholder""; f(10) }` expands to `""matched normal method""`.  This suggests that quote pattern matching disregards whether method parameters are contextual or not.

This behavior has its merits; it removes the need to provide different patterns to match both normal and contextual methods. However, changing this behavior could disrupt macros dependent on the current behavior, potentially breaking the backward compatibility of quote pattern matching.

The question remains: should we maintain the current behavior, or alter the quote pattern matcher to differentiate between normal and contextual methods?",True,18040,https://api.github.com/repos/scala/scala3/pulls/18040,https://github.com/scala/scala3/pull/18040,closed,45,10,7,2,0,5,0,1,[],2023-06-23 06:09:11+00:00,2023-07-13 12:03:41+00:00,1749270.0,"20 days, 5:54:30","[{'comment_id': 1241771668, 'comment_body': ""I don't think this is far from clean code, but it's working, at least. We want to figure out how to refactor this."", 'comment_created': datetime.datetime(2023, 6, 26, 7, 49, 48, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1241772421, 'comment_body': 'This fixes a bug that was introduced by #17567 ', 'comment_created': datetime.datetime(2023, 6, 26, 7, 50, 31, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1241793792, 'comment_body': 'can be simplified to `!(resmatch && ctx.mode.is(Mode.QuotedPattern))`', 'comment_created': datetime.datetime(2023, 6, 26, 8, 7, 43, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1250374789, 'comment_body': 'This is a comment for #17567, might be better to separate PR ', 'comment_created': datetime.datetime(2023, 7, 3, 7, 16, 6, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1250435333, 'comment_body': 'A separate commit is enough.', 'comment_created': datetime.datetime(2023, 7, 3, 7, 59, 28, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}]","[{'commit_sha': 'f921b7c4a7154ccbdbdf4f60c1a4f1fe1a599e19', 'committer_username': 'zeptometer', 'committer_name': 'Yuito Murase', 'committer_email': 'yuito@acupof.coffee', 'commit_date': datetime.datetime(2010, 10, 27, 12, 57, 11, tzinfo=datetime.timezone.utc)}, {'commit_sha': '8519dea5e514b569eb98631aef9cdcbb2d100f45', 'committer_username': 'zeptometer', 'committer_name': 'Yuito Murase', 'committer_email': 'yuito@acupof.coffee', 'commit_date': datetime.datetime(2010, 10, 27, 12, 57, 11, tzinfo=datetime.timezone.utc)}]",Yuito Murase,456330,yuito@acupof.coffee,User,,58,,11,37
1400688607,Fix debug print of QuoteMatcher to work on match failure,"The current logic of debug print in `QuoteMatcher` is intended to show debug information when a pattern match fails. However, it does not work because `notMatched` invokes a global escape that skips debug-print logic.

This PR proposes to catch global escape when `debug=1` and show debug information.",True,18023,https://api.github.com/repos/scala/scala3/pulls/18023,https://github.com/scala/scala3/pull/18023,closed,33,26,3,1,7,10,0,1,[],2023-06-21 00:33:17+00:00,2023-07-05 09:47:29+00:00,1242852.0,"14 days, 9:14:12","[{'comment_id': 1238229644, 'comment_body': 'Just to make sure we only print this when the match fails due to a match error. Otherwise, we would get the stack trace.\r\n```suggestion\r\n          case e: util.boundary.Break[?] =>\r\n```\r\n', 'comment_created': datetime.datetime(2023, 6, 22, 9, 1, 51, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1238232057, 'comment_body': 'New style\r\n```suggestion\r\n      if ctx.settings.YdebugMacros.value then\r\n```', 'comment_created': datetime.datetime(2023, 6, 22, 9, 3, 50, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1239340304, 'comment_body': ""That's a good catch. Thank you."", 'comment_created': datetime.datetime(2023, 6, 23, 5, 39, 9, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}, {'comment_id': 1252680854, 'comment_body': '```suggestion\r\n      def runMatch(): optional[MatchingExprs] = pattern match\r\n```', 'comment_created': datetime.datetime(2023, 7, 5, 7, 35, 26, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1252681184, 'comment_body': '```suggestion\r\nclass QuoteMatcher(debug: Boolean) {\r\n```', 'comment_created': datetime.datetime(2023, 7, 5, 7, 35, 45, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1252683104, 'comment_body': '```suggestion\r\n  private val yDebugMacros: Boolean = ctx.settings.YdebugMacros.value\r\n```', 'comment_created': datetime.datetime(2023, 7, 5, 7, 37, 31, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1252683946, 'comment_body': '```suggestion\r\n      QuoteMatcher(yDebugMacros).treeMatch(reflect.asTerm(self), reflect.asTerm(that)).nonEmpty\r\n```', 'comment_created': datetime.datetime(2023, 7, 5, 7, 38, 14, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1252684096, 'comment_body': '```suggestion\r\n      QuoteMatcher(yDebugMacros).treeMatch(scrutineeTree, patternTree).asInstanceOf[Option[Tup]]\r\n```', 'comment_created': datetime.datetime(2023, 7, 5, 7, 38, 23, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1252684250, 'comment_body': '```suggestion\r\n      QuoteMatcher(yDebugMacros).treeMatch(scrutineeTree, patternTree).asInstanceOf[Option[Tup]]\r\n```', 'comment_created': datetime.datetime(2023, 7, 5, 7, 38, 31, tzinfo=datetime.timezone.utc), 'commenter': 'nicolasstucki', 'type': 'User'}, {'comment_id': 1252737447, 'comment_body': 'For future reference, can I ask the reason for this change? Is it the case where creating `QuoteMatcher` instance for each method call is not very costful?', 'comment_created': datetime.datetime(2023, 7, 5, 8, 20, 56, tzinfo=datetime.timezone.utc), 'commenter': 'zeptometer', 'type': 'User'}]","[{'commit_sha': 'be0c98ad3aea78ea171400e541261d7cd0c11fe9', 'committer_username': 'zeptometer', 'committer_name': 'Yuito Murase', 'committer_email': 'yuito@acupof.coffee', 'commit_date': datetime.datetime(2010, 10, 27, 12, 57, 11, tzinfo=datetime.timezone.utc)}]",Yuito Murase,456330,yuito@acupof.coffee,User,,58,,11,37
1430601176,Cleanup the unused symbol Definitions.QuotedRuntimePatterns_patternHi,This small PR simply removes the unused symbol `Definitions.QuotedRuntimePatterns_patternHigherOrderHole`.,True,18191,https://api.github.com/repos/scala/scala3/pulls/18191,https://github.com/scala/scala3/pull/18191,closed,0,1,1,1,0,0,0,0,[],2023-07-12 05:34:53+00:00,2023-07-12 06:48:26+00:00,4413.0,1:13:33,[],"[{'commit_sha': 'e5435847fa50caa37085faa5b77d697ebd39e0e2', 'committer_username': 'zeptometer', 'committer_name': 'Yuito Murase', 'committer_email': 'yuito@acupof.coffee', 'commit_date': datetime.datetime(2010, 10, 27, 12, 57, 11, tzinfo=datetime.timezone.utc)}]",Yuito Murase,456330,yuito@acupof.coffee,User,,58,,11,37

Project_ID,Name,Full_name,Language,Forks,Stars,Watchers,contributors,commits,issues,branches,PRs_count,contributor pullrequests
7035651,scala3,scala/scala3,Scala,1039,5776,210,519,38915,1558,75,169,"[{'id': 1445501545, 'number': 18271, 'closed': datetime.datetime(2024, 7, 22, 11, 39, 51, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 7, 23, 5, 44, 5, tzinfo=datetime.timezone.utc), 'time_taken': 31557346.0, 'time_delta': '365 days, 5:55:46', 'additions': 624, 'deletions': 125, 'state': 'closed'}, {'id': 1430601176, 'number': 18191, 'closed': datetime.datetime(2023, 7, 12, 6, 48, 26, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 7, 12, 5, 34, 53, tzinfo=datetime.timezone.utc), 'time_taken': 4413.0, 'time_delta': '1:13:33', 'additions': 0, 'deletions': 1, 'state': 'closed'}, {'id': 1404534294, 'number': 18040, 'closed': datetime.datetime(2023, 7, 13, 12, 3, 41, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 6, 23, 6, 9, 11, tzinfo=datetime.timezone.utc), 'time_taken': 1749270.0, 'time_delta': '20 days, 5:54:30', 'additions': 45, 'deletions': 10, 'state': 'closed'}, {'id': 1400688607, 'number': 18023, 'closed': datetime.datetime(2023, 7, 5, 9, 47, 29, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 6, 21, 0, 33, 17, tzinfo=datetime.timezone.utc), 'time_taken': 1242852.0, 'time_delta': '14 days, 9:14:12', 'additions': 33, 'deletions': 26, 'state': 'closed'}, {'id': 1362558506, 'number': 17567, 'closed': datetime.datetime(2023, 6, 21, 6, 24, 54, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 5, 24, 7, 37, 11, tzinfo=datetime.timezone.utc), 'time_taken': 2414863.0, 'time_delta': '27 days, 22:47:43', 'additions': 187, 'deletions': 28, 'state': 'closed'}, {'id': 1362556895, 'number': 17566, 'closed': datetime.datetime(2023, 5, 24, 7, 36, 32, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 5, 24, 7, 35, 47, tzinfo=datetime.timezone.utc), 'time_taken': 45.0, 'time_delta': '0:00:45', 'additions': 63, 'deletions': 3, 'state': 'closed'}]"
