pr_id,pr_title,pr_body,is_merged,pr_number,pr_url,pr_html_url,pr_state,additions,deletions,pr_changed_files,pr_commits_count,pr_comments_count,pr_review_comments_count,pr_labels_count,pr_assignees_count,pr_labels,pr_created_at,pr_closed_at,time_taken,time_delta,pr_review_comments,pr_commits,contributor,contributor_id,contributor_email,contributor_type,contributions,contributor_public_repos,contributor_private_repos,contributor_followings,contributor_followers
1358137986,Use marker to mark `SourceEdit`s,"This change is used to help us mark the changes in source file, which makes incremental parsing test easier.

See comments in https://github.com/apple/swift-syntax/pull/1662#issuecomment-1556110495",True,1684,https://api.github.com/repos/swiftlang/swift-syntax/pulls/1684,https://github.com/swiftlang/swift-syntax/pull/1684,closed,208,48,4,1,4,12,0,0,[],2023-05-21 07:48:03+00:00,2023-05-26 19:31:12+00:00,474189.0,"5 days, 11:43:09","[{'comment_id': 1200817019, 'comment_body': 'Just for some added performance: You can return make `editedSource` a `Substring` here. That way, no new allocation is necessary to return the string. Instead, it just references a substring in the already-allocated `source` string. To make this work in the function above, you will need to change `editedSource` to be a `Substring` as well: `var editedSource = source[...]` (the three dots are actual syntax here, not a placeholder).\r\n\r\n---\r\n\r\nAlso, instead of iterating over `source` twice, this function could return the original source as well. And at that point, it might even make it easier to read if the function is just inlined into `getConcurrentEditsAndSources` instead of being its own function. If you do this and base your distance calculations on `originalSouce` instead of `editedSource`, I think you can also just construct a `ConcurrentEdits` without needing to perform the translation `fromSequential`.', 'comment_created': datetime.datetime(2023, 5, 22, 17, 29, 26, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1200827918, 'comment_body': 'Technically, I think you want to find the first separate marker after the start marker, and end marker after the separate marker. Otherwise, you can get into weird issues of ranges where the end location is before the start location when someone uses an incorrect format string like `⏩️class⏪️struct⏸️ foo {`.\r\n\r\n```suggestion\r\n    let separateIndex = source[startIndex...].firstIndex(where: { $0.isSeperateMarker }),\r\n    let endIndex = source[separateIndex...].firstIndex(where: { $0.isEndMarker })\r\n```', 'comment_created': datetime.datetime(2023, 5, 22, 17, 35, 12, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1200832241, 'comment_body': 'String handling is hard. What `source.distance` will give you is the distance between the start of the string and the start index in Unicode Grapheme Clusters. But `SourceEdit.offset` is defined in terms of bytes relative to the start of the string when encoded as UTF-8, which you can get using `source.utf8.distance`\r\n\r\nYou can see the difference in this small example (the family emoji takes a lot of bytes)\r\n\r\n```swift\r\nlet source = ""👨\u200d👩\u200d👧\u200d👦⏩️""\r\nlet startIndex = source.firstIndex(of: ""⏩️"")!\r\nprint(source.distance(from: source.startIndex, to: startIndex))\r\nprint(source.utf8.distance(from: source.startIndex, to: startIndex))\r\n```', 'comment_created': datetime.datetime(2023, 5, 22, 17, 39, 18, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1200842512, 'comment_body': 'Could you add a comment here that describes the syntax of the edits, i.e. the marker and which part is considered part of the original source and which part is considered part of the edited source? ', 'comment_created': datetime.datetime(2023, 5, 22, 17, 51, 22, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1200843139, 'comment_body': 'I think you can drop the word `Concurrent` from the function name. If anyone cares about it, it’s guaranteed by the `ConcurrentEdits` type.', 'comment_created': datetime.datetime(2023, 5, 22, 17, 52, 5, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1205442068, 'comment_body': '> I think you can also just construct a ConcurrentEdits without needing to perform the translation fromSequential\r\n\r\nI prefer to call the `fromSequential` initializer since the `concurrent` initializer is throwable. I think not doing error handling inside the helper function just makes it looker nicer and easier.', 'comment_created': datetime.datetime(2023, 5, 25, 12, 25, 14, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1205708344, 'comment_body': 'You should be able to guarantee that the parameter you pass to `ConcurrentEdits.init(concurrent:)` is indeed an array of  concurrent edits array. If not, something is seriously wrong in the entire test setup and I think in that case I think it’s perfectly fine to crash the test case execution. That will point you directly to the issue. FWIW that’s also what the implementation of `ConcurrentEdits.init(formSequential:)` does', 'comment_created': datetime.datetime(2023, 5, 25, 15, 42, 35, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1205725558, 'comment_body': ""That makes sense. I've changed this part according to your suggestion."", 'comment_created': datetime.datetime(2023, 5, 25, 15, 56, 44, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1205732062, 'comment_body': 'I assume you want to create empty `Substring`s here, right? Can’t you just do the following?\r\n\r\n```suggestion\r\n  var editedSource = Substring()\r\n  var originalSource = Substring()\r\n```', 'comment_created': datetime.datetime(2023, 5, 25, 16, 2, 20, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1205735456, 'comment_body': 'Out of curiosity: Why did you choose to move `isStartMarker` etc into an extension of `Character` instead of just inlining that check here? Just seems like an unnecessary abstraction layer to me if we aren’t calling the computed properties anywhere else.', 'comment_created': datetime.datetime(2023, 5, 25, 16, 5, 34, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1205735864, 'comment_body': 'Line breaks before the parameter labels could help readability here IMO.', 'comment_created': datetime.datetime(2023, 5, 25, 16, 5, 58, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1205755597, 'comment_body': ""I thought that maybe these computed properties would be called elsewhere then. But it's just an unnecessary abstraction layer now. Already changed that."", 'comment_created': datetime.datetime(2023, 5, 25, 16, 22, 43, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}]","[{'commit_sha': 'b60576680fe945e570ebd7f468d2b495cda658c8', 'committer_username': 'StevenWong12', 'committer_name': 'Ziyang Huang', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 21, 11, 25, 44, tzinfo=datetime.timezone.utc)}]",Ziyang Huang,56827396,,User,,24,,0,6
1368076567,Add utils for incremental parse test,"This change should allow us to verify the correctness of incremental parse with a single function, containing round-trip, substructure, and reused nodes validation like `assertParse`.
",True,1712,https://api.github.com/repos/swiftlang/swift-syntax/pulls/1712,https://github.com/swiftlang/swift-syntax/pull/1712,closed,148,43,2,1,10,34,0,0,[],2023-05-28 17:22:11+00:00,2023-06-03 04:29:30+00:00,472039.0,"5 days, 11:07:19","[{'comment_id': 1210505828, 'comment_body': 'The naming convention for these assertion functions in swift-syntax would be `assertIncrementalParse`.', 'comment_created': datetime.datetime(2023, 5, 30, 16, 5, 52, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1210507116, 'comment_body': 'If you look at e.g. `assertParse`, it takes a defaulted `file` and `line` parameter that is passed to all `XCTAssert*` functions. That way, if an assertion fails, it is shown at the `assertIncrementalParse` call instead of inside this function, which generally makes it a lot easier to debug.', 'comment_created': datetime.datetime(2023, 5, 30, 16, 7, 1, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1210508501, 'comment_body': 'What do you think about passing the marked source to the `verifyIncrementalParse` function and running `extractMarkersForIncrementParseTest` from here. That should simplify the assert invocations.', 'comment_created': datetime.datetime(2023, 5, 30, 16, 8, 15, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1210510917, 'comment_body': 'Could you also set `includeTrivia: true` to verify that the trivia between of `newTree` and `incrementallyParsedNewTree` match?', 'comment_created': datetime.datetime(2023, 5, 30, 16, 10, 21, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1210512114, 'comment_body': 'Do you need this special case? To me it looks like this is covered by the `else` branch as well', 'comment_created': datetime.datetime(2023, 5, 30, 16, 11, 24, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1210513556, 'comment_body': 'You could just make this function `throws` and then you don’t need to deal with `do {} catch {}` blocks', 'comment_created': datetime.datetime(2023, 5, 30, 16, 12, 24, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1210522645, 'comment_body': 'I feel like we are getting into marker hell here with the two different kinds of markers. Just an idea: What do you think about adding a `reused: String...` parameter to `assertIncrementalParse`. In this case you would be passing `let value1 = 👨\u200d👩\u200d👧\u200d👧` to that parameter to assert that a node with that source text has been reused. We do something similar with the `highlight` parameter on `DiagnosticSpec`.', 'comment_created': datetime.datetime(2023, 5, 30, 16, 18, 55, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1211455004, 'comment_body': ""Well, I just want to keep this the same as `assertParse`. We do error handling here so that we don't have to mark test cases throwable or add some do-catch blocks there, which looks nicer IMO."", 'comment_created': datetime.datetime(2023, 5, 31, 10, 9, 27, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1211470666, 'comment_body': 'Yeah, I also added a `ReusedNodeSpec` in the new commit, which makes the usage of this function very much like `assertParse`.', 'comment_created': datetime.datetime(2023, 5, 31, 10, 15, 29, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1211471316, 'comment_body': ""That's because in the previous design, we have to zip the re-used range and re-used nodes in the test case on our own. So I just separate this two functions.\r\n\r\nI have changed this in the new commit."", 'comment_created': datetime.datetime(2023, 5, 31, 10, 16, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1212018101, 'comment_body': 'I think this comment would make more sense on `ReusedNodeSpec.sourceString`.', 'comment_created': datetime.datetime(2023, 5, 31, 16, 49, 7, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1212023589, 'comment_body': 'One thing that’s actually a really nice and clever design trick with `DiagnosticSpec` is that it stores the file and line that the `DiagnosticSpec` was declared. That way, any failure related to it can be displayed at the place where the `DiagnosticSpec` was defined and we don’t need to include too much context here because that’s apparent from the definition of the `DiagnosticSpec` itself.\r\n\r\nSo, my proposal would be to change this to\r\n\r\n```suggestion\r\n      XCTFail(""Fail to find string in original source"", file: targetNode.file, line: targetNode.line)\r\n```', 'comment_created': datetime.datetime(2023, 5, 31, 16, 52, 20, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1212024509, 'comment_body': 'Similar to the comment above, would be nice to use `file` and `line` from where the `ReusedNodeSpec` is defined.', 'comment_created': datetime.datetime(2023, 5, 31, 16, 53, 13, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1212025086, 'comment_body': 'And here, use `file` and `line` from the `ReusedNodeSpec`.', 'comment_created': datetime.datetime(2023, 5, 31, 16, 53, 49, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1212025461, 'comment_body': 'I think we could just `continue` here and check the other specs', 'comment_created': datetime.datetime(2023, 5, 31, 16, 54, 9, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1212026926, 'comment_body': 'Nit: Superfluous newline', 'comment_created': datetime.datetime(2023, 5, 31, 16, 55, 34, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1212027078, 'comment_body': 'Nitpick\r\n\r\n```suggestion\r\nprivate func getByteSourceRange(for substring: String, in sourceString: String) -> ByteSourceRange? {\r\n```', 'comment_created': datetime.datetime(2023, 5, 31, 16, 55, 42, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1212027359, 'comment_body': 'Superfluous newline', 'comment_created': datetime.datetime(2023, 5, 31, 16, 56, 1, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1212027746, 'comment_body': 'Did you run `swift-format`? I would expect it to place the last `)` on a new line.', 'comment_created': datetime.datetime(2023, 5, 31, 16, 56, 26, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1212030202, 'comment_body': 'There’s no real need to repeat `String` here because the variable is already of type `String`. I’d go for `source` or `reusedSource`. \r\n\r\nAlso: Could you add a doc comment to all public types/variables?', 'comment_created': datetime.datetime(2023, 5, 31, 16, 58, 44, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1212031720, 'comment_body': 'Just an idea to make the tests a little bit more readable: I’d make the first parameter unlabeled. But that’s very much personal preference.', 'comment_created': datetime.datetime(2023, 5, 31, 17, 0, 6, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1212034125, 'comment_body': '```suggestion\r\n  let newTree = Parser.parse(source: editedString)\r\n```', 'comment_created': datetime.datetime(2023, 5, 31, 17, 2, 34, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1212034731, 'comment_body': 'These look so nice and short now 🤩 ', 'comment_created': datetime.datetime(2023, 5, 31, 17, 3, 10, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1212035169, 'comment_body': 'Thanks. It’s looking very good', 'comment_created': datetime.datetime(2023, 5, 31, 17, 3, 39, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1212035475, 'comment_body': 'Ah, yeah. Makes absolute sense. Thanks for clarifying.', 'comment_created': datetime.datetime(2023, 5, 31, 17, 3, 58, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1212035971, 'comment_body': 'Thanks. Writing test cases looks really easy now 😍 ', 'comment_created': datetime.datetime(2023, 5, 31, 17, 4, 30, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1212711218, 'comment_body': 'Oh, apparently I forgot to run `swift-format`. Sorry for that.', 'comment_created': datetime.datetime(2023, 6, 1, 7, 28, 45, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1212716493, 'comment_body': 'This reminds me that we actually are not using these variables outside of `init`, so I made these variables internal and left the `init` public. I still added comments for these though.', 'comment_created': datetime.datetime(2023, 6, 1, 7, 33, 3, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1213405550, 'comment_body': 'No problem at all', 'comment_created': datetime.datetime(2023, 6, 1, 16, 26, 49, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1213408416, 'comment_body': 'You can write `Trivia` in double backticks and docc should create links for them. Similar for all other type names that you’re mentioning in comments.', 'comment_created': datetime.datetime(2023, 6, 1, 16, 29, 35, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1213409669, 'comment_body': 'OK, great!', 'comment_created': datetime.datetime(2023, 6, 1, 16, 30, 49, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1213416286, 'comment_body': 'In my experience, when the count of the diagnostics (and in this case reused ranges) doesn’t match, it doesn’t make sense to show how the specified ranges mismatched. So in that case, I would just not continue to the `for` loop below, similar to \r\n\r\nhttps://github.com/apple/swift-syntax/blob/873cbce8a3cde64807dba55e016ae2745cfcb5d8/Tests/SwiftParserTest/Assertions.swift#L589\r\n\r\nTo make this actionable, we should instead show the actually reused pieces of the source code as in\r\n\r\nhttps://github.com/apple/swift-syntax/blob/873cbce8a3cde64807dba55e016ae2745cfcb5d8/Tests/SwiftParserTest/Assertions.swift#L593', 'comment_created': datetime.datetime(2023, 6, 1, 16, 36, 7, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1213418613, 'comment_body': 'These aren’t really nodes, right? Nitpick: `targetNode` is a little ambiguous. What do you think about `expectedReusedNode`?', 'comment_created': datetime.datetime(2023, 6, 1, 16, 38, 18, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1213879330, 'comment_body': ""Yeah, these aren't actually nodes. I just can't come up with a more proper name for them😂. Do you have any idea about the name? I've renamed `targetNode` to `expectedReusedNode`."", 'comment_created': datetime.datetime(2023, 6, 2, 3, 29, 8, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}]","[{'commit_sha': '259542b9b4bc011d1bbca7f17da4904e041c4c45', 'committer_username': 'StevenWong12', 'committer_name': 'Ziyang Huang', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 21, 11, 25, 44, tzinfo=datetime.timezone.utc)}]",Ziyang Huang,56827396,,User,,24,,0,6
1392452479,Translate `lit_tests/incrParse` with `assertIncrementalParse`,This should make it easier to read and run test cases in lit_tests/incrParse with `assertIncrementalParse`.,True,1782,https://api.github.com/repos/swiftlang/swift-syntax/pulls/1782,https://github.com/swiftlang/swift-syntax/pull/1782,closed,391,0,1,1,3,5,0,0,[],2023-06-14 13:42:47+00:00,2023-06-21 07:45:38+00:00,583371.0,"6 days, 18:02:51","[{'comment_id': 1229868779, 'comment_body': 'Forgot to translate this one?', 'comment_created': datetime.datetime(2023, 6, 14, 16, 11, 26, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1229871341, 'comment_body': '`assertIncrementalParse` will apply all of these edits concurrently, while `lit_tests/incrParse/funcs.swift` specified multiple independent test cases where only a single edit was applied. I would split this case up into multiple `assertIncrementalParse` calls where each one only has a single edit.\r\n\r\nSame for most of the test cases below. `NESTED_INITIALIZERS` performs a multi-edit but I think none of the others do, but please double-check.', 'comment_created': datetime.datetime(2023, 6, 14, 16, 13, 24, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1230306574, 'comment_body': ""If we split these up, do you think should we maintain all other text in in that file? I'm not quite sure how much these context will affect our test."", 'comment_created': datetime.datetime(2023, 6, 15, 0, 57, 27, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1230404340, 'comment_body': 'I would just keep the immediate parent contexts. E.g. here, I would just keep `class InvalidFuncDecls {`', 'comment_created': datetime.datetime(2023, 6, 15, 4, 19, 14, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1233900325, 'comment_body': 'I don’t recall why but in reuse.swift it has the following comment and `let a` is indented by four spaces. I think we should maintain that indentation and comment.\r\n\r\n```swift\r\n// The indentation on these lines is important for the test case\r\n```', 'comment_created': datetime.datetime(2023, 6, 19, 11, 6, 22, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}]","[{'commit_sha': 'd0fe5347bb795a2ef0cf47b7f022edf28ec408bf', 'committer_username': 'StevenWong12', 'committer_name': 'Ziyang Huang', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 21, 11, 25, 44, tzinfo=datetime.timezone.utc)}]",Ziyang Huang,56827396,,User,,24,,0,6
1358152980,Port incremental parsing ability to `CodeBlockItem`,"I want to make this pr as a start effort to port incremental parsing ability to `SwiftParser`.
",True,1685,https://api.github.com/repos/swiftlang/swift-syntax/pulls/1685,https://github.com/swiftlang/swift-syntax/pull/1685,closed,380,62,12,1,10,94,0,0,[],2023-05-21 08:59:14+00:00,2023-07-11 17:04:17+00:00,4435503.0,"51 days, 8:05:03","[{'comment_id': 1235661470, 'comment_body': '```suggestion\r\n  fileprivate var lookaheadBytes: [RawSyntax.ID: Int] = [:]\r\n```', 'comment_created': datetime.datetime(2023, 6, 20, 18, 32, 7, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1235661648, 'comment_body': 'Split `IncrementalParseTransition` into two types as discussed offline.', 'comment_created': datetime.datetime(2023, 6, 20, 18, 32, 19, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1235664343, 'comment_body': 'As discussed offline: Is it faster to have `cursor` as a member of `IncrementalParseLookup` or always generate it in `cursorLookup`. I would expect the former to be faster, but I might be wrong.', 'comment_created': datetime.datetime(2023, 6, 20, 18, 35, 9, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1235666885, 'comment_body': 'Maybe the reuse delegate can just receive the reused node instead of the reused range now that everything is implemented in Swift.', 'comment_created': datetime.datetime(2023, 6, 20, 18, 37, 27, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1235668386, 'comment_body': 'Not part of this PR: Can we use `getOffsetToStart` instead of `offset(of:)`.', 'comment_created': datetime.datetime(2023, 6, 20, 18, 38, 59, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1235674414, 'comment_body': 'As discussed offline, we could store `furthestOffset` in a standalone `struct` and pass that over here as an `UnsafeMutablePointer`.', 'comment_created': datetime.datetime(2023, 6, 20, 18, 40, 30, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1235677705, 'comment_body': 'We can probably delete this.', 'comment_created': datetime.datetime(2023, 6, 20, 18, 41, 27, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1235679830, 'comment_body': 'I would put `parseTransition` before `arena` because `arena` is always the last parameter.', 'comment_created': datetime.datetime(2023, 6, 20, 18, 42, 9, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1235683634, 'comment_body': 'I would add a flag to decide whether we want to do incremental parsing on subsequent iterations.', 'comment_created': datetime.datetime(2023, 6, 20, 18, 44, 18, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1241171546, 'comment_body': 'I think making `cursor` a member of `IncrementalParseLookup` is a little bit faster than generating it in `cursorLookup`.', 'comment_created': datetime.datetime(2023, 6, 25, 13, 5, 34, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1241172281, 'comment_body': ""Yeah, I've made this change."", 'comment_created': datetime.datetime(2023, 6, 25, 13, 6, 31, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1241172507, 'comment_body': 'I add a `IncrementalParseNodeAffectRangeCollector` to collect this and make it as a trigger to enable incremental parse.', 'comment_created': datetime.datetime(2023, 6, 25, 13, 7, 36, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1241172900, 'comment_body': 'Since we have to record the offset in both `Parser.peek()` and `Lookahead.consumeAnyToken()`, I make this pointer a member of `LexemeSequence`.', 'comment_created': datetime.datetime(2023, 6, 25, 13, 8, 43, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1241173631, 'comment_body': ""I've added a flag about this, but I'm not quite sure whether the code is still a bit hacky."", 'comment_created': datetime.datetime(2023, 6, 25, 13, 10, 24, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1241476622, 'comment_body': 'I use `node.byteLength + currentToken.byteLength` here since we may encounter some cases that we lookahead only when we are at some specific tokens. e.g. we lookahead to find valid trailing closure only when we are at `leftBrace`.\r\n\r\nSo this ensures the parser take the length of next token into account no matter we call `Lookahead` or `Parser.peek` or not. And this should be more efficient than moving cursor to find next token when we call `nodeAtCursorCanBeReused`.', 'comment_created': datetime.datetime(2023, 6, 26, 3, 42, 56, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1241860470, 'comment_body': 'Is it still necessary to change these properties to `var`?', 'comment_created': datetime.datetime(2023, 6, 26, 9, 3, 2, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1241861400, 'comment_body': 'Is there any reason why you made this property non-optional? I think having an `IncrementalParseReusedNodeDelegate` is mostly interesting for testing and I don’t expect many real clients to pass it.', 'comment_created': datetime.datetime(2023, 6, 26, 9, 3, 53, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1241862620, 'comment_body': 'Is it still necessary to change this property to be optional?', 'comment_created': datetime.datetime(2023, 6, 26, 9, 4, 58, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1241867063, 'comment_body': 'AFAICT you only use this property once. I would just replace the use of it with `nodeAffectRangeCollector.nodeAffectRange`', 'comment_created': datetime.datetime(2023, 6, 26, 9, 8, 47, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1241867822, 'comment_body': 'Doc comment is out-of-date now', 'comment_created': datetime.datetime(2023, 6, 26, 9, 9, 27, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1241869534, 'comment_body': 'Could you add a doc-comment for this property?', 'comment_created': datetime.datetime(2023, 6, 26, 9, 10, 21, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1241876300, 'comment_body': 'If I understand the documentation of `allocate` correctly, it allocates a memory region to hold one `LookaheadTracker` but it makes no guarantees about its contents. In debug builds it will most likely be zero-initialized but in general it could contain arbitrary memory content. So, I think you need to initialize it\r\n\r\n```swift\r\nself.lookaheadTracker.initialize(to: LookaheadTracker())\r\n```', 'comment_created': datetime.datetime(2023, 6, 26, 9, 14, 52, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1241878024, 'comment_body': 'Does this need to be `public`? I think `internal` would be sufficient.', 'comment_created': datetime.datetime(2023, 6, 26, 9, 16, 14, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1241884483, 'comment_body': 'Could you check if we get better performance if you mark this method as `mutating` (even though it doesn’t mutate `self`). I found a performance problem at some point when calling non-mutating functions from mutating functions https://github.com/apple/swift-syntax/commit/f9b3139e6c75d80911dac70d3ae033b002ad21ce', 'comment_created': datetime.datetime(2023, 6, 26, 9, 21, 32, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1241885332, 'comment_body': 'Just an idea: You could use `guard let` here instead of nesting with `if`.', 'comment_created': datetime.datetime(2023, 6, 26, 9, 22, 16, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1241898178, 'comment_body': '`IncrementalParseLookup` is currently designed with `SyntaxCursor` to be long-lived for the entire parse. The idea is that `SyntaxCursor` stores the position in the syntax tree that it performed the last lookup at and looks for the next node from that position. This has the benefit that it doesn’t need to iterate over e.g. the first item in a tree every time it performs a lookup.\r\n\r\nWhen we create a new `IncrementalParseLookup` for every `loadCurrentSyntaxNodeFromCache` we have that complexity from `SyntaxCursor` without getting any of the benefits from it. Could you check if we can get improved performance by creating the `IncrementalParseLookup` when initializing `Parser` and then continue to use it? AFAICT if we do that we also wouldn’t need to store `parseTransition` in `Parser` anymore.', 'comment_created': datetime.datetime(2023, 6, 26, 9, 32, 46, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1241900213, 'comment_body': 'Does this have to be `var` or could it be a `let`?', 'comment_created': datetime.datetime(2023, 6, 26, 9, 34, 7, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1241902191, 'comment_body': 'Does this type have to be `public`? Wouldn’t `internal` be sufficient?', 'comment_created': datetime.datetime(2023, 6, 26, 9, 35, 35, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1241904995, 'comment_body': 'Doing the `max` in the setter here seems a little magical to me because it breaks the invariant that after assigning `furthestOffset` to a value and reading it immediately afterwards, I get that value back. What I would do is the following\r\n\r\n```suggestion\r\n  private(set) var furthestOffset: Int\r\n\r\n  public func recordFurthestOffset(_ furthestOffset: Int) { \r\n    furthestOffset = max(newValue, furthestOffset)\r\n  }\r\n```\r\n\r\nThat way you also have a function on which you can put a doc comment describing the `max` behavior.', 'comment_created': datetime.datetime(2023, 6, 26, 9, 37, 20, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1241906339, 'comment_body': 'Is there any use case where we want to initialize `furthestOffset` to anything but `0`? I don’t see any right now.', 'comment_created': datetime.datetime(2023, 6, 26, 9, 37, 56, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1241913625, 'comment_body': 'I am a little worried that the ID might get used for some weird pointer arithmetic in the future while really it should just be a unique value. What I would do is introduce a new type that wraps the `UnsafeRawPointer` in a way that you can’t access it\r\n\r\n```suggestion\r\n  public struct ID: Hashable {\r\n    /// The pointer to the start of the `RawSyntax` node.\r\n    private var pointer: UnsafeRawPointer\r\n\r\n    fileprivate init(_ raw: RawSyntax) {\r\n      self.pointer = UnsafeRawPointer(raw.pointer)\r\n    }\r\n  }\r\n\r\n  @_spi(RawSyntax)\r\n  public var id: ID {\r\n    return ID(self)\r\n  }\r\n```', 'comment_created': datetime.datetime(2023, 6, 26, 9, 43, 20, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1241916260, 'comment_body': 'AFAICT we only use this in IncrementalParseTestUtils.swift. I would just define it as a `fileprivate extension` there. That way it doesn’t become part of SwiftSyntax’s public API surface that we need to maintain.', 'comment_created': datetime.datetime(2023, 6, 26, 9, 44, 58, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1241920604, 'comment_body': 'These variables could be local to the loop, right?', 'comment_created': datetime.datetime(2023, 6, 26, 9, 47, 44, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1241923131, 'comment_body': 'The instruction counter counts all instructions including those of the initial (non-incremental) parse, while `totalTime` only counts the time of the incremental parse. This might explain the discrepancies between instruction counter and measured time that you saw.', 'comment_created': datetime.datetime(2023, 6, 26, 9, 49, 21, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1241932606, 'comment_body': 'Instead of storing a `(SourceFileSyntax, IncrementalParseNodeAffectRangeCollector?)` for each file and then doing checks for `iter != 0`, what do you think about storing `[Data: IncrementalParseTransition]`? I think that would be simpler.', 'comment_created': datetime.datetime(2023, 6, 26, 9, 55, 22, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1241936374, 'comment_body': 'Instead of doing this check for `iter != 0`, what do you think about doing an initial iteration over `files` before the actual performance test and doing all the full parses in that loop. Then this look that performs `self.iterations` would just be performing incremental parses and also you wouldn’t need to add `totalTime` in every iteration but could just get a start and end date before the entire loop.', 'comment_created': datetime.datetime(2023, 6, 26, 9, 58, 2, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1241938545, 'comment_body': 'Oh, great that we’re able to re-use `bar(1)` here. \r\n\r\nBut actually looking at the test case, I very much suspect that the `o ` has been a typo in the lit-based tests already. So I would prefer to adjust the test case and remove `o `.', 'comment_created': datetime.datetime(2023, 6, 26, 9, 59, 49, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1242445461, 'comment_body': ""Ah, these are redundant. I've changed back to `let`.\r\n\r\nSame for other redundant changes below."", 'comment_created': datetime.datetime(2023, 6, 26, 16, 19, 8, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1242447649, 'comment_body': ""Yeah, I've made `IncrementalParseLookup` a member and removed `IncrementalParseTransition`. That looks good."", 'comment_created': datetime.datetime(2023, 6, 26, 16, 21, 9, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1242451310, 'comment_body': ""Ah, the `o ` seems very much like a typo here to me too. I've adjusted the test case, `bar(1)` is no longer re-usable though."", 'comment_created': datetime.datetime(2023, 6, 26, 16, 24, 35, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1242453802, 'comment_body': 'Add an initial parse is a great idea! But I still store a `(SourceFileSyntax, IncrementalParseNodeAffectRangeCollector)` here since I think we could not get the collector from `IncrementalParseTransition`.', 'comment_created': datetime.datetime(2023, 6, 26, 16, 26, 27, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1242480443, 'comment_body': 'It really gets better performance if we mark it as `mutating`.😮 It reduces the overhead from 4-5% to 2-3%.', 'comment_created': datetime.datetime(2023, 6, 26, 16, 51, 59, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1242485725, 'comment_body': 'I think we should still store a `(SourceFileSyntax, IncrementalParseNodeAffectRangeCollector)` here since we could not get the collector from `IncrementalParseTransition`.', 'comment_created': datetime.datetime(2023, 6, 26, 16, 56, 21, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1242491693, 'comment_body': 'Ah, that makes sense. But I still encounter this problem when I revert the changes about how we measure time.', 'comment_created': datetime.datetime(2023, 6, 26, 17, 0, 46, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1242778964, 'comment_body': 'We only need to do the initial parse if `self.incrementalParse` is `true`, right? You could just put the entire loop in a `if self.incrementalParse` and then you don’t need to check that variable inside the loop.', 'comment_created': datetime.datetime(2023, 6, 26, 21, 15, 56, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1242780315, 'comment_body': 'OK, interesting. But given that instructions can take different durations to execute based on cache hits, it is reasonable that they could diverge slightly.', 'comment_created': datetime.datetime(2023, 6, 26, 21, 17, 35, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1242781282, 'comment_body': 'Could you add labels to the tuple elements. It makes the access a lot easier to read IMO.', 'comment_created': datetime.datetime(2023, 6, 26, 21, 18, 46, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1242782504, 'comment_body': 'But we could just pass `nil` for the `parseNodeAffectRange` because we aren’t doing another incremental parse based on the tree produced in this loop, right?', 'comment_created': datetime.datetime(2023, 6, 26, 21, 20, 14, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1242782958, 'comment_body': 'We don’t need this, right? We could just perform `self.iterations` incremental parses based on the tree generation in the initial parse loop.', 'comment_created': datetime.datetime(2023, 6, 26, 21, 20, 48, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1242783208, 'comment_body': 'Yes, that makes sense.', 'comment_created': datetime.datetime(2023, 6, 26, 21, 21, 7, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1243049037, 'comment_body': 'Ah, yeah.', 'comment_created': datetime.datetime(2023, 6, 27, 2, 0, 48, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1243053708, 'comment_body': 'Yeah, but we still need to store a `IncrementalParseNodeAffectRangeCollector ` for every file if we are doing incremental parse, right? I store a `(IncrementalParseTransition, IncrementalParseNodeAffectRangeCollector)` here in the new commit and it should make the actual performance test loop simpler.', 'comment_created': datetime.datetime(2023, 6, 27, 2, 7, 17, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1243206425, 'comment_body': 'Why do we need to store an `IncrementalParseNodeAffetRangeCollector`? Can’t you just change the call in the performance measurement loop to pass `nil` for `parseNodeAffectRange` because we aren’t doing another incremental parse based on the tree that’s generated in the performance measurement loop?', 'comment_created': datetime.datetime(2023, 6, 27, 6, 33, 7, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1243353273, 'comment_body': 'But if we pass `--incremental-parse` to performance test, we would need to use the `IncrementalParseNodeAffetRangeCollector` set up in the initial parse to enable incremental parse in the performance measurement loop. Do you mean we would not measure the performance of incremental parse when `self.iterations` > 1?', 'comment_created': datetime.datetime(2023, 6, 27, 8, 38, 32, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1254448603, 'comment_body': 'What do you think about just naming this type `LookaheadRanges`? My thought on the terms are:\r\n- `Incremental`: Yes, incremental parsing is the main use case for this, but really, the parser can return the lookahead ranges independent of incremental parsing, so we can drop it\r\n- `Parse`: Well, it’s all about parsing in this module so maybe we can drop it. Also, if we include `Lookahead` in the name, I think it’s kind of obvious that we’re talking about parsing\r\n- `NodeAffectRange`: The way that a node is affected is through lookahead and also I didn’t like “affect” because it’s a wonderful ambiguous term. And really, what we are recording, are the lengths (or ranges) that the parser looked ahead while parsing\r\n- `Collector`: This isn’t all about collecting, e.g. `IncrementalParseTransition.nodeAffectRangeCollector` just reads from it, instead of writing to it.\r\n\r\nI would then rename `IncrementalParseTransition.nodeAffectRangeCollector` to `lookaheadRanges` and `Parser.parseNodeAffectRange` to `lookaheadRangesCollector`.', 'comment_created': datetime.datetime(2023, 7, 6, 13, 31, 59, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1254464304, 'comment_body': 'I would add some more details about incremental parsing. Also, to avoid making `parse(source: ""abc"")` ambiguous, I would name this function `parseIncrementally`. And then, if this function is all about incremental parsing, I think we should remove the default value for `parseTransition`.\r\n\r\n```suggestion\r\n    /// Parse the source code in the given string as Swift source file with support\r\n      /// for incremental parsing.\r\n      ///\r\n      /// When parsing a source file for the first time, invoke `parseIncrementally`\r\n      /// with `parseTransition: nil`. This returns the initial tree as well as\r\n      /// ``LookaheadRanges``. If an edit is made to the source file, an\r\n      /// ``IncrementalParseTransition`` can be constructed from the initial tree\r\n      /// and its ``LookaheadRanges``. When invoking `parseIncrementally` again with\r\n      /// the post-edit source and that parse transition, the parser will re-use\r\n      /// nodes that haven’t changed.\r\n      ///\r\n      /// - Parameters:\r\n      ///   - source: The source code to parse\r\n      ///   - parseTransition: If a similar source file has already been parsed, the\r\n      ///     ``IncrementalParseTransition`` that contains the previous tree as well\r\n      ///     as the edits that were performed to it.\r\n      /// - Returns: The parsed tree as well as the ``LookaheadRanges`` that describe\r\n      ///            how far the parser looked ahead while parsing a node, which is\r\n      ///            necessary to construct an ``IncrementalParseTransition`` for a\r\n      ///            subsequent incremental parse\r\n      public static func parseIncrementally(\r\n        source: String,\r\n        parseTransition: IncrementalParseTransition?\r\n      ) -> (tree: SourceFileSyntax, nodeAffectRangeCollector: IncrementalParseNodeAffectRangeCollector) {\r\n```', 'comment_created': datetime.datetime(2023, 7, 6, 13, 44, 14, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1254465986, 'comment_body': 'Definitely not part of this PR but I think we should consider change `IncrementalParseReusedNodeDelegate` to just be a callback function on `IncrementalParseTransition`, i.e. removing this protocol altogether. That’s more swifty than the Objective-C delegate pattern.', 'comment_created': datetime.datetime(2023, 7, 6, 13, 45, 30, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1254469532, 'comment_body': 'A naming and comment suggestion\r\n\r\n```suggestion\r\n  /// For each node that is recorded for re-use, the number of UTF-8 bytes that the parser looked ahead to parse the node, measured from the start of the node’s leading trivia. \r\n  /// This information is used to determine whether a node can be reused. A node can only be re-used if no byte in its looked range has changed.\r\n  fileprivate var lookaheadLengths: [RawSyntax.ID: Int] = [:]\r\n```', 'comment_created': datetime.datetime(2023, 7, 6, 13, 48, 14, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1254469989, 'comment_body': 'To be consistent with my other naming suggestions.\r\n\r\n```suggestion\r\n  public mutating func registerNodeForIncrementalParse(node: RawSyntax, lookaheadLength: Int) {\r\n```', 'comment_created': datetime.datetime(2023, 7, 6, 13, 48, 34, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1254470902, 'comment_body': 'AFAICT we only use this once so I’m not sure if it’s worth defining. ', 'comment_created': datetime.datetime(2023, 7, 6, 13, 49, 14, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1254474749, 'comment_body': '```suggestion\r\n    /// The offset of the end trailing trivia of `nextToken` relative to the source buffer’s start.\r\n```', 'comment_created': datetime.datetime(2023, 7, 6, 13, 51, 41, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1254482391, 'comment_body': '```suggestion\r\n    /// See doc comments in ``LookaheadTracker``\r\n    ///\r\n    /// This is an `UnsafeMutablePointer` for two reasons\r\n    ///  - When `LexemeSequence` gets copied (e.g. when a ``Lookahead`` gets created), it should still reference the same ``LookaheadTracker`` so that any lookahead performed in the ``Lookahead`` also affects the original ``Parser``. It thus needs to be a reference type\r\n    ///  - ``LookaheadTracker`` is not a class to avoid reference counting it. The ``Parser`` that creates the ``LexemeSequence`` will always outlive any ``Lookahead`` created for it.\r\n```', 'comment_created': datetime.datetime(2023, 7, 6, 13, 57, 13, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1254490942, 'comment_body': 'Why does this need to be a `var`. Wouldn’t a `let` also work?', 'comment_created': datetime.datetime(2023, 7, 6, 14, 2, 32, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1254492450, 'comment_body': 'I just realized that we also need to deallocate the memory from `lookaheadTracker`. Currently, we are leaking the `LookaheadTracker`. \r\n\r\nThe design I would choose is to create a class `LookaheadTrackerOwner` that creates a `LookaheadTracker` and destroys it once the `LookaheadTrackerOwner` is deinitialized. `Parser` will then own the `LookaheadTrackerOwner`. And `LexemeSequence.init` will need to take a `UnsafeMutablePointer<LookaheadTracker>` as parameter. I.e. something like the following\r\n\r\n```swift\r\n/// Owns a ``LookaheadTracker``. \r\n///\r\n/// Once the ``LookeaheadTrackerOwner`` is deinitialized, the ``LookaheadTracker`` is also destroyed.\r\nclass LookaheadTrackerOwner {\r\n  var lookaheadTracker: UnsafeMutablePointer<LookaheadTracker>\r\n\r\n  init() {\r\n    self.lookaheadTracker = .allocate(capacity: 1)\r\n    self.lookaheadTracker.initialize(to: LookaheadTracker())\r\n  }\r\n\r\n  deinit {\r\n    self.lookaheadTracker.deallocate()\r\n  }\r\n}\r\n```\r\n\r\n```swift\r\npublic struct Parser {\r\n  …\r\n  let lookaheadTrackerOwner = LookaheadTrackerOwner()\r\n}\r\n```', 'comment_created': datetime.datetime(2023, 7, 6, 14, 3, 43, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1254493592, 'comment_body': 'I prefer to use `nextToken` instead of `next token` just to clarify what we mean by `next token`.\r\n\r\n```suggestion\r\n    /// Record the offset of the end of `nextToken` as the furthest offset in ``LookaheadTracker``\r\n```', 'comment_created': datetime.datetime(2023, 7, 6, 14, 4, 37, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1254496423, 'comment_body': '```suggestion\r\n    /// Get the offset of the leading trivia start of `token` relative to `sourceBufferStart`.\r\n```', 'comment_created': datetime.datetime(2023, 7, 6, 14, 6, 45, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1254497249, 'comment_body': '```suggestion\r\n    /// Advance the the cursor by `offset` and reset `currentToken`\r\n    ///\r\n    /// - Important: This should only be used for incremental parsing.\r\n```', 'comment_created': datetime.datetime(2023, 7, 6, 14, 7, 20, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1254499540, 'comment_body': 'I think we should make this public so that you can retrieve the `lookaheadRanges` if you create the `Parser` instance manually instead of calling one of the functions in `Parser+Entry.swift`.', 'comment_created': datetime.datetime(2023, 7, 6, 14, 9, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1254505475, 'comment_body': 'What do you think about naming this `recordNextTokenInLookaheadTracker`? I think that’s a little clearer, if only because it mentions `LookaheadTracker`. If you’ve got better naming ideas, I’m open to them.', 'comment_created': datetime.datetime(2023, 7, 6, 14, 13, 33, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1254507635, 'comment_body': 'Just something that crossed my mind: Can’t we just call `recordFurthestOffset` from `LexemeSequences.advance` and `LexemeSequence.peek`? That way we can’t forget to call it from any `Parser` or `Lookahead` functions that interact with `LexemeSequence`. Or is there a performance regression associated with that?', 'comment_created': datetime.datetime(2023, 7, 6, 14, 15, 11, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1254512119, 'comment_body': 'This won’t actually get any of the `SyntaxCursor` benefits because what you are modifying when calling `lookUp` below is the copy of `parseLookup` that you created above.\r\n\r\nCould you check how the performance changes if you do the following? If there’s no performance win, we should consider removing `SyntaxCursor` entirely in a follow-up PR.\r\n\r\n```suggestion\r\n    guard parseLookup != nil else {\r\n      return nil\r\n    }\r\n\r\n    let currentOffset = self.lexemes.getOffsetToStart(self.currentToken)\r\n    if let node = self.parseLookup!.lookUp(currentOffset, kind: kind) {\r\n```', 'comment_created': datetime.datetime(2023, 7, 6, 14, 18, 37, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1254513649, 'comment_body': 'You are only using this once so I don’t think we need it. Also: In any case, this shouldn’t be public.', 'comment_created': datetime.datetime(2023, 7, 6, 14, 19, 43, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1254514878, 'comment_body': 'Typo in `peek. Also, since `peek` isn’t public, it can’t be a docc reference.\r\n\r\n```suggestion\r\n/// Record the furthest offset to `sourceBufferStart` that is reached by  `Parser.peek()` or ``Lookahead`` in ``Lexer/LexemeSequence``\r\n```', 'comment_created': datetime.datetime(2023, 7, 6, 14, 20, 35, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1254519903, 'comment_body': '```suggestion\r\n      /// The initial parse for incremental parsing\r\n```', 'comment_created': datetime.datetime(2023, 7, 6, 14, 24, 13, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1257296301, 'comment_body': ""Ah, I think that's great. I also move this to `Parser.swift` considering its general purpose."", 'comment_created': datetime.datetime(2023, 7, 8, 15, 29, 51, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1257299365, 'comment_body': ""Ah, I didn't do that because I was trap into some weird bugs and fail the tests then. And it turned out that it was because I called `recordNextTokenInLookaheadTracker` in the wrong time\U0001f979.\r\n\r\n> Or is there a performance regression associated with that?\r\n\r\nAbout the performance, see my comments below."", 'comment_created': datetime.datetime(2023, 7, 8, 15, 45, 29, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1257299490, 'comment_body': 'Oh, I forgot `parseLookup` is a struct. About the performance, see my comments below. ', 'comment_created': datetime.datetime(2023, 7, 8, 15, 46, 22, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1257978349, 'comment_body': '`above` doesn’t refer to anything when viewing the generated documentation, e.g. on https://swiftpackageindex.com/apple/swift-syntax/main/documentation/swiftsyntax. Can you change this to a docc-link? Something like `Parser/parseIncrementally(source:parseTransition)`. Xcode should offer you code completion to make the link work.', 'comment_created': datetime.datetime(2023, 7, 10, 9, 27, 47, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1257981475, 'comment_body': 'I forgot this in my suggestion as well but we should should have a newline between the summary and discussion for this property.\r\n\r\n```suggestion\r\n  /// For each node that is recorded for re-use, the number of UTF-8 bytes that the parser looked ahead to parse the node, measured from the start of the node’s leading trivia.\r\n  ///\r\n  /// This information can be used to determine whether a node can be reused in incremental parse. A node can only be re-used if no byte in its looked range has changed.\r\n```', 'comment_created': datetime.datetime(2023, 7, 10, 9, 30, 36, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1257981938, 'comment_body': 'I think this method could be internal.', 'comment_created': datetime.datetime(2023, 7, 10, 9, 31, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1257983006, 'comment_body': 'Depending on whether `LexemeSequence` or `Parser`/`Lookahead` is responsible fro calling `recordFurthestOffset`', 'comment_created': datetime.datetime(2023, 7, 10, 9, 31, 53, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1257983321, 'comment_body': 'Does this method have to be public or could it be internal?', 'comment_created': datetime.datetime(2023, 7, 10, 9, 32, 11, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1257986819, 'comment_body': '```suggestion\r\n    /// The offset of the trailing trivia end of `nextToken` relative to the source buffer’s start.\r\n```', 'comment_created': datetime.datetime(2023, 7, 10, 9, 35, 20, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1257991199, 'comment_body': 'Ah I just realized that actually there’s no reason to make it publicly writable. Not sure if \r\n\r\n```suggestion\r\n  public internal(set) var lookaheadRanges = LookaheadRanges()\r\n```\r\n', 'comment_created': datetime.datetime(2023, 7, 10, 9, 39, 18, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1257999561, 'comment_body': 'As the second part of my comment https://github.com/apple/swift-syntax/pull/1685#discussion_r1254507635:\r\n\r\nCould we also call `recordNextTokenInLookaheadTracker` from `LexemeSequence.advance` so that we never need to call it from `Lookahead` or `Parser` (and could maybe even make that method `private`)? Or is there a performance regression associated with it because we’d now effectively also be calling `recordNextTokenInLookaheadTracker` from `Parser.consumeAnyToken`.\r\n\r\nIn either case, I think we should be consistent about who’s responsible for calling `recordNextTokenInLookaheadTracker`. Either `LexemeSequence` calls it from both `advance` and `peek` or `Lookahead` and `Parser` are responsible for calling it. I don’t think we should end up in a situation where `LexemeSequence` calls it on `peek` but `Lookeahead`/`Parser` need to call it on `advance` because that sort of inconsistency is a source of bugs.', 'comment_created': datetime.datetime(2023, 7, 10, 9, 46, 50, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1257999858, 'comment_body': '```suggestion\r\n  /// See comments in ``IncrementalParseLookup``\r\n```', 'comment_created': datetime.datetime(2023, 7, 10, 9, 47, 4, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1258001397, 'comment_body': 'I don’t think this call is necessary anymore if `LexemeSequence.peek` calls `recordNextTokenInLookaheadTracker`.', 'comment_created': datetime.datetime(2023, 7, 10, 9, 48, 27, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1258003909, 'comment_body': 'What do you think about moving all of the incremental-parsing functions to its own file? It just keeps them nicely grouped and maybe we can even mark some functions as `fileprivate`.', 'comment_created': datetime.datetime(2023, 7, 10, 9, 50, 40, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1258007585, 'comment_body': 'Just a bit of Swift style: You can add this as a `defer`-block right after `allocate`. That way it’s even easier to verify that all allocated memory gets deallocated as well.\r\n\r\nSame in `LexerTests.swift`', 'comment_created': datetime.datetime(2023, 7, 10, 9, 53, 59, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1258224666, 'comment_body': ""Oops, I think that's something I forgot to delete after doing the performance test. `recordNextTokenInLookaheadTracker` is already added to `LexemeSequence.advance`."", 'comment_created': datetime.datetime(2023, 7, 10, 12, 58, 57, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1258226905, 'comment_body': ""Ah, that's also what I forgot as in `Lookahead.consumeAnyToken`"", 'comment_created': datetime.datetime(2023, 7, 10, 13, 0, 38, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1258307184, 'comment_body': ""I think that's great. And I also make `IncrementalParseLookup.lookup` an `fileprivate` function.\r\n\r\nI didn't move functions in `LexemeSequence` since `LexemeSequence.cursor` and `LexemeSequence.sourceBufferStart` are already `fileprivate` and we need to use them."", 'comment_created': datetime.datetime(2023, 7, 10, 13, 53, 14, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1258358717, 'comment_body': 'Can this be `private` now if it’s only being called from `LexemeSequence`?', 'comment_created': datetime.datetime(2023, 7, 10, 14, 31, 11, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1258371700, 'comment_body': 'Sure.', 'comment_created': datetime.datetime(2023, 7, 10, 14, 40, 43, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}]","[{'commit_sha': '1e6406dc6c57f0f728736adcd3068b52839e8fb2', 'committer_username': 'StevenWong12', 'committer_name': 'Ziyang Huang', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 21, 11, 25, 44, tzinfo=datetime.timezone.utc)}]",Ziyang Huang,56827396,,User,,24,,0,6
1392588875,Move `IncrementalParseTransition` to `SwiftParser`,"Also move `ConcurrentEdits` to `SwiftSyntax/Utils.swift`, since it might have its own value other than incremental parse in the future.",True,1783,https://api.github.com/repos/swiftlang/swift-syntax/pulls/1783,https://github.com/swiftlang/swift-syntax/pull/1783,closed,149,146,4,1,6,4,0,0,[],2023-06-14 14:53:30+00:00,2023-06-15 17:09:46+00:00,94576.0,"1 day, 2:16:16","[{'comment_id': 1229856825, 'comment_body': 'Is there any reason why we can’t use `SourceLength` anymore? It is pretty useful just to ensure everybody is talking about lengths in terms of UTF-8 bytes and we don’t accidentally sneak lengths in terms of Unicode grapheme clusters `String.count` in.', 'comment_created': datetime.datetime(2023, 6, 14, 16, 1, 28, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1230294895, 'comment_body': ""I think that's something left when I hacked around. I've changed this to `SourceLength`."", 'comment_created': datetime.datetime(2023, 6, 15, 0, 27, 26, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1230403164, 'comment_body': 'As discussed offline, can you move this test case to SwiftParserTest because the tested classes now live in the SwiftParser module?', 'comment_created': datetime.datetime(2023, 6, 15, 4, 16, 21, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1230457475, 'comment_body': 'Yes, sure.', 'comment_created': datetime.datetime(2023, 6, 15, 5, 39, 12, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}]","[{'commit_sha': 'e31933933bc0037fe673ab9e3753ab2bca286737', 'committer_username': 'StevenWong12', 'committer_name': 'Ziyang Huang', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 21, 11, 25, 44, tzinfo=datetime.timezone.utc)}]",Ziyang Huang,56827396,,User,,24,,0,6
1434131919,Make `MemberDeclListItemSyntax` re-usable in `SwiftParser`,,True,1906,https://api.github.com/repos/swiftlang/swift-syntax/pulls/1906,https://github.com/swiftlang/swift-syntax/pull/1906,closed,16,5,2,1,1,0,0,0,[],2023-07-14 04:32:55+00:00,2023-07-14 16:53:19+00:00,44424.0,12:20:24,[],"[{'commit_sha': 'a1c3376561ef937b0ccf2c33d2bcee40cb5ffe1b', 'committer_username': 'StevenWong12', 'committer_name': 'Ziyang Huang', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 21, 11, 25, 44, tzinfo=datetime.timezone.utc)}]",Ziyang Huang,56827396,,User,,24,,0,6
1417867027,Port incremental parse ability to sourcekit-lsp,"To sync changes in https://github.com/apple/swift-syntax/pull/1685

This feature will be used when we call `changeDocument` in SwiftLanguageServer.

TODO: 
- [x] Add test cases for it",True,761,https://api.github.com/repos/swiftlang/sourcekit-lsp/pulls/761,https://github.com/swiftlang/sourcekit-lsp/pull/761,closed,84,7,3,1,1,18,0,0,[],2023-07-03 10:41:41+00:00,2023-07-14 16:53:07+00:00,972686.0,"11 days, 6:11:26","[{'comment_id': 1255417400, 'comment_body': 'We already store the tree in `DocumentSnapshot`. I think the cleaner design would be to also store the `IncrementalParseNodeAffectRangeCollector` there instead of adding this dictionary to `SwiftLanguageServer`.', 'comment_created': datetime.datetime(2023, 7, 7, 8, 3, 12, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1255422209, 'comment_body': 'We shouldn’t be recording which nodes got re-used nodes unless it’s needed for testing purposes. I would suggest that we change `IncrementalParseReusedNodeCollector` from a delegate to a closure as I commented in https://github.com/apple/swift-syntax/pull/1685/files#r1254465986. Then this one could be an optional closure as well and you need to explicitly set it in the test cases to make it be called.\r\n\r\nI would also add a comment that it’s for testing purposes only.', 'comment_created': datetime.datetime(2023, 7, 7, 8, 6, 50, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1255424022, 'comment_body': 'Why not make this parameter `ConcurrentEdits?` instead of `[IncrementalEdit]?`. That way the caller can decide whether the edits are sequential or concurrent.', 'comment_created': datetime.datetime(2023, 7, 7, 8, 8, 23, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1255425727, 'comment_body': '```suggestion\r\n          edits.append(IncrementalEdit(offset: offset, length: length, replacementLength: edit.text.utf8.count))\r\n```', 'comment_created': datetime.datetime(2023, 7, 7, 8, 9, 48, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1255427747, 'comment_body': 'Have you checked whether the LSP edits are sequential or concurrent? I’m not sure if the spec defines it so you might need to just check what kind of edits VSCode sends when you do a multi-cursor edit.', 'comment_created': datetime.datetime(2023, 7, 7, 8, 11, 26, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1255431959, 'comment_body': 'This seems racy to me. IIRC the `SwiftLanguageServer` executes `updateSyntaxTree` asynchronously when receiving the note and thus might not have performed the re-parse when you are getting the re-used nodes. This should be easy to fix if you wait for the first `PublishDiagnosticsNotification`.', 'comment_created': datetime.datetime(2023, 7, 7, 8, 14, 53, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1259204274, 'comment_body': 'The [spec](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#didChangeTextDocumentParams) indicates that the edits are sequential IIUC.', 'comment_created': datetime.datetime(2023, 7, 11, 5, 27, 35, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1259223802, 'comment_body': ""I've added a `*For Testing*` comment there.\r\n\r\nI will sync this design change here when I change the delegate to a closure in `SwiftParser`."", 'comment_created': datetime.datetime(2023, 7, 11, 5, 58, 33, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1259244001, 'comment_body': 'Oh, nice. That’s delightfully specific for the LSP spec. I agree that the edits are sequential. 👍🏽 ', 'comment_created': datetime.datetime(2023, 7, 11, 6, 26, 14, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1259245627, 'comment_body': 'Could you document what `edits = nil` means?', 'comment_created': datetime.datetime(2023, 7, 11, 6, 28, 2, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1259246514, 'comment_body': 'The variable is now incorrectly named. It doesn’t contain any parse transitions.', 'comment_created': datetime.datetime(2023, 7, 11, 6, 29, 1, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1259247672, 'comment_body': 'You can do `self.expectation` here. That way we will get an error if you don’t wait for the expectation\r\n\r\n```suggestion\r\n    let didChangeTextDocumentExpectation = self.expectation(description: ""didChangeTextDocument"")\r\n```\r\n\r\n', 'comment_created': datetime.datetime(2023, 7, 11, 6, 30, 27, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1259248229, 'comment_body': 'And if you’re using `self.expectation`, you should also be using `self.wait`. IIRC it will fail the test if the expectation isn’t fulfilled, so you don’t need to check `result` either.\r\n\r\n```suggestion\r\n    let result = self.wait(for: [didChangeTextDocumentExpectation], timeout: defaultTimeout)\r\n```', 'comment_created': datetime.datetime(2023, 7, 11, 6, 31, 5, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1259251121, 'comment_body': '```suggestion\r\n    let nodes = try XCTUnwrap(swiftLanguageServer.documentReusedNodeCollector[uri]?.nodes)\r\n```', 'comment_created': datetime.datetime(2023, 7, 11, 6, 34, 28, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1260970955, 'comment_body': 'I think we should store the `LookaheadRanges` in the `DocumentSnapshot` as I mentioned here: https://github.com/apple/sourcekit-lsp/pull/761#discussion_r1255417400\r\n\r\nOr is there a reason why we can’t do that?\r\n\r\nI noticed this just now again by trying to write a doc comment for it and I couldn’t come up with a very nice explanation for it.', 'comment_created': datetime.datetime(2023, 7, 12, 10, 32, 14, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1262754371, 'comment_body': 'Ah, seems I mis-understood that comment.', 'comment_created': datetime.datetime(2023, 7, 13, 15, 49, 30, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1263313187, 'comment_body': 'We also need to store the `LookaheadRanges` in the `DocumentSnapshot`. At the moment, you could get into the following race condition: \r\n\r\n- We get a document snapshot and which stores its syntax tree (in `DocumentSnapshot.tokens` in `SwiftLanguageServer.changeDocument`)\r\n- Now an edit is processed, which modifies the `Document` that’s underlying the `DocumentSnapshot`\r\n- If we access `snapshot.lookaheadRanges`, we now get the `LookaheadRanges` from the updated document, which is out-of-sync with the syntax tree stored in the `DocumentSnapshot` and the text stored in the `DocumentSnapshot`\r\n\r\nI would just store the `LookaheadRanges` in `DocumentTokens`. That way it’s stored right next to the syntax tree they belong to and you also don’t need the `updateLookaheadRanges` method to update them independently of the syntax tree.\r\n\r\n---\r\n\r\nEdit: On second thought, the race condition won’t actually happen because `updateSyntaxTree` is always executed on `SwiftLangaugeServer.queue` but still, we shouldn’t be relying on that invariant.', 'comment_created': datetime.datetime(2023, 7, 14, 5, 39, 33, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1263360774, 'comment_body': 'I think storing `lookaheadRanges` in `DocumentTokens` is a good idea. 👍 ', 'comment_created': datetime.datetime(2023, 7, 14, 6, 42, 54, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}]","[{'commit_sha': 'f1d182e1a5517daa00a514c67310be239745693d', 'committer_username': 'StevenWong12', 'committer_name': 'Ziyang Huang', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 21, 11, 25, 44, tzinfo=datetime.timezone.utc)}]",Ziyang Huang,56827396,,User,,24,,0,6
1421257505,Sync api change in `IncrementalParseTransition`,To sync changes in https://github.com/apple/swift-syntax/pull/1685,True,242,https://api.github.com/repos/swiftlang/swift-stress-tester/pulls/242,https://github.com/swiftlang/swift-stress-tester/pull/242,closed,3,2,1,1,1,2,0,0,[],2023-07-05 14:49:57+00:00,2023-07-11 17:04:15+00:00,526458.0,"6 days, 2:14:18","[{'comment_id': 1259222753, 'comment_body': 'Real nitpick: We should be consistently using or not using `self.` here. Can you either drop it from `self.lookaheadRanges` or add it to `tree`?', 'comment_created': datetime.datetime(2023, 7, 11, 5, 56, 53, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1259226016, 'comment_body': 'Sure. ', 'comment_created': datetime.datetime(2023, 7, 11, 6, 1, 53, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}]","[{'commit_sha': '590249922e9ef05a09b70e08c3f0192895d2acf2', 'committer_username': 'StevenWong12', 'committer_name': 'Ziyang Huang', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 21, 11, 25, 44, tzinfo=datetime.timezone.utc)}]",Ziyang Huang,56827396,,User,,24,,0,6
1397030959,Delete incremental parse related `lit`-based tests,"Since we translate these test cases in #1782, I open this to delete the codes we would not use anymore.",True,1807,https://api.github.com/repos/swiftlang/swift-syntax/pulls/1807,https://github.com/swiftlang/swift-syntax/pull/1807,closed,0,1158,14,1,2,0,0,0,[],2023-06-18 07:46:29+00:00,2023-06-21 09:48:43+00:00,266534.0,"3 days, 2:02:14",[],"[{'commit_sha': 'f2c0ad0c8a7af65e642e7a535b0f638670f4d048', 'committer_username': 'StevenWong12', 'committer_name': 'Ziyang Huang', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 21, 11, 25, 44, tzinfo=datetime.timezone.utc)}]",Ziyang Huang,56827396,,User,,24,,0,6
1437617695,Add `assertClassification` for `ClassificationTests`,"I made use of some infrastructure we have in `IncrementalParseTestUtils.swift` to add a `assertClassification` function to make `ClassificationTests` look nicer.

This could also be a start effort to translate the `coloring_*` `lit`-based test cases into XCTest.

(This pr is based on https://github.com/apple/swift-syntax/pull/1905)",True,1916,https://api.github.com/repos/swiftlang/swift-syntax/pulls/1916,https://github.com/swiftlang/swift-syntax/pull/1916,closed,189,165,3,1,6,8,0,0,[],2023-07-17 16:07:36+00:00,2023-07-25 00:32:37+00:00,635101.0,"7 days, 8:25:01","[{'comment_id': 1265686117, 'comment_body': 'I don’t think the default value of `[]` makes sense for any of the `assertClassification` functions. If you use them, you almost certainly want to check that some classifications are produced.\r\n\r\n---\r\n\r\nWhat you think of naming this parameter `expected`. I think that would clean up the calls a little.', 'comment_created': datetime.datetime(2023, 7, 17, 17, 31, 21, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1265688444, 'comment_body': 'I don’t think this function should exist. We should be using `assertClassification` for all test cases.', 'comment_created': datetime.datetime(2023, 7, 17, 17, 33, 55, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1265688760, 'comment_body': 'Is this needed?', 'comment_created': datetime.datetime(2023, 7, 17, 17, 34, 17, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1265690237, 'comment_body': 'Could we unify this with `assertClassification` above by having `range` be optional and defaulted to `nil`? Then we also wouldn’t need `assertClassificationImpl` anymore if we get rid of `assertTokensClassification`.', 'comment_created': datetime.datetime(2023, 7, 17, 17, 35, 59, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1265692551, 'comment_body': 'I generally prefer to spell this as `ClassificaitonSpec`. Then you’re not left wondering what object you’re constructing here while reading the code.', 'comment_created': datetime.datetime(2023, 7, 17, 17, 38, 35, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1266042967, 'comment_body': 'The reason why I have an empty array as default value for classification spec is there are some test cases that gives a certain `ByteSourceRange` and there are only trivia in that range. And our `assertClassification` function filter out trivia.', 'comment_created': datetime.datetime(2023, 7, 18, 0, 28, 12, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1269733489, 'comment_body': 'I would change the order of these parameters because to me the `range` is an input parameter for the test whereas `expected` is the expected output. Just think that it reads nicer that way.\r\n\r\nAnd also remember to change the order of the doc comments.', 'comment_created': datetime.datetime(2023, 7, 20, 16, 58, 49, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1269739280, 'comment_body': 'We aren’t actually filtering out the trivia. We do have classifications for comments. We are just not including any `none` classifications.\r\n```suggestion\r\n/// Parse `source` and checks its `classifications` is the same as `expected`. \r\n/// \r\n/// The `expected` classifications should only contain classifications that are not `none`. All uncovered ranges are expected to have no classification.\r\n```', 'comment_created': datetime.datetime(2023, 7, 20, 17, 3, 55, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}]","[{'commit_sha': '889fd0ba0ef3df15ef3d62b4bd9af5ca2c1c63f2', 'committer_username': 'StevenWong12', 'committer_name': 'Ziyang Huang', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 21, 11, 25, 44, tzinfo=datetime.timezone.utc)}]",Ziyang Huang,56827396,,User,,24,,0,6
1452182967,Convert `lit`-based syntax classification test to XCTest,"We should use the `assertClassification` to make these test cases look nicer and get rid of the dependency on `FileCheck` eventually.

I converted a subset of the original `lit`-tests since I think most of them are mutually covered. There are some tests not producing the expected results and I wrote down the reasons in `XCTExpectFailure`. Maybe we should determine whether changing the test cases or marking these as bugs to fix.",True,1953,https://api.github.com/repos/swiftlang/swift-syntax/pulls/1953,https://github.com/swiftlang/swift-syntax/pull/1953,closed,509,16,6,1,4,29,0,0,[],2023-07-27 15:07:56+00:00,2023-08-03 17:55:44+00:00,614868.0,"7 days, 2:47:48","[{'comment_id': 1276695925, 'comment_body': 'Good catch 👍🏽 ', 'comment_created': datetime.datetime(2023, 7, 27, 18, 49, 32, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1276696639, 'comment_body': '```suggestion\r\n  public func testEmptyDocBlockComment() {\r\n```', 'comment_created': datetime.datetime(2023, 7, 27, 18, 50, 22, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1276697907, 'comment_body': 'This is expected now that we have macros because `#error` and `#warning` are just normal macros now. Can you update the expected classifications?\r\n\r\nSame for all the other tests you annotated with https://github.com/apple/swift-syntax/issues/1044.', 'comment_created': datetime.datetime(2023, 7, 27, 18, 51, 39, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1276769666, 'comment_body': 'Hmm, this is expected by the way the syntax tree gets represented because by now we always model the name of an attribute as a type. Also the lines between builtin attributes (like `@availablable`) with completely custom syntax, user-defined attributes that are types (like result builders and property wrappers) and user-defined types that aren’t types (attached macros) are blurring. So, what I would expect is `available` to be classified as an `attribute`. \r\n\r\nYou should be able to achieve that by changing `\\AttributeSyntax.attributeName` to return `(.attribute, false)` in `SyntaxClassification.classify(_ keyPath:)`\r\n\r\nSame for `testAttribute2` where `objc` and `IBOutlet` should be classified as `attribute`.', 'comment_created': datetime.datetime(2023, 7, 27, 20, 7, 26, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1276770787, 'comment_body': 'This should get correct classification if you wrap it inside an `enum`.\r\n\r\n```swift\r\nenum List {\r\n  indirect case cons(T, List)\r\n}\r\n```\r\n\r\nAnd while you’re at it, you can change the case to be lowercase to reflect the naming guidelines which changed around Swift 3.', 'comment_created': datetime.datetime(2023, 7, 27, 20, 8, 43, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1276771475, 'comment_body': 'I think you need to run `format.py` to format this correctly.', 'comment_created': datetime.datetime(2023, 7, 27, 20, 9, 35, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1276771941, 'comment_body': 'That’s OK. You can change the test', 'comment_created': datetime.datetime(2023, 7, 27, 20, 10, 11, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1276772440, 'comment_body': 'That’s also OK. Just remove the classification. I don’t really care about the classification of `_` and classifying it as a keyword never really made sense anyway.', 'comment_created': datetime.datetime(2023, 7, 27, 20, 10, 49, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1276772994, 'comment_body': 'I think if you write this as a raw string `#""` or a multiline string, it becomes easier to read because you don’t need to do any escaping. \r\n\r\nSame in the `ClassificationSpec` below', 'comment_created': datetime.datetime(2023, 7, 27, 20, 11, 33, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1276774603, 'comment_body': 'I think we weren’t handling closure capture lists properly for a long time (but that’s years in the past). What classification does it produce now?', 'comment_created': datetime.datetime(2023, 7, 27, 20, 13, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1278282983, 'comment_body': 'Since that, do we still need the `objectLiteral` type? `#fileLiteral`, `#imageLiteral`, etc.. are also classified as identifier now.', 'comment_created': datetime.datetime(2023, 7, 29, 10, 30, 30, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1278283422, 'comment_body': ""> You should be able to achieve that by changing \\AttributeSyntax.attributeName to return (.attribute, false)\r\n\r\nDo you mean we changing this to `(.attribute, true)`? Since `\\AttributeSyntax.attributeName` already returns `(.attribute, false)` now. \r\n\r\nIf so, we may need to make some changes on `handleLayout` (as my new commits) since `\\AttributeSyntax.attributeName` is not a `TokenSyntax` and the second return value of `SyntaxClassification.classify(_ keyPath:)` only has effects in `handleToken`.\r\n\r\nBut I can't find a proper workaround for classifying the trivia pieces in a layout node for now though.\r\n\r\n---\r\n\r\nOn a second thought, what do you think about refactor `ClassificationVisitor` as a subclass of `SyntaxAnyVisitor` like `ParseDiagnosticsGenerator`. That should make this case handled easier. And the `8.0` and `10.10` can be specified as `floatingLiteral` rather that some `integerLiteral`s in a version tuple."", 'comment_created': datetime.datetime(2023, 7, 29, 10, 36, 28, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1278283635, 'comment_body': 'It just produces normal `SyntaxClassification` i.e. `weak` as a keyword, `x` as an identifier, etc..', 'comment_created': datetime.datetime(2023, 7, 29, 10, 39, 9, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1278345694, 'comment_body': 'I believe we can delete it, yes.', 'comment_created': datetime.datetime(2023, 7, 29, 17, 27, 24, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1278348041, 'comment_body': '> Do you mean we changing this to `(.attribute, true)`? Since `\\AttributeSyntax.attributeName` already returns `(.attribute, false)` now.\r\n>\r\n> If so, we may need to make some changes on `handleLayout` (as my new commits) since `\\AttributeSyntax.attributeName` is not a `TokenSyntax` and the second return value of `SyntaxClassification.classify(_ keyPath:)` only has effects in `handleToken`.\r\n\r\nYes, that’s what I meant. But I didn’t realize it only had an effect on tokens 😢 \r\n\r\n> On a second thought, what do you think about refactor `ClassificationVisitor` as a subclass of `SyntaxAnyVisitor` like `ParseDiagnosticsGenerator`. That should make this case handled easier. And the `8.0` and `10.10` can be specified as `floatingLiteral` rather that some `integerLiteral`s in a version tuple.\r\n\r\nI think that would be a good idea and should make the classifier easier to maintain. If the `SyntaxAnyVisitor`-based implementation is significantly slower than the current one, we should look into why that is and see if we can make `SyntaxAnyVisitor` faster.\r\n\r\nIn any case, I would prefer to do this in a follow-up PR. We can just keep the test case disabled for now. One note though: `XCTExpectFailure` is not supported on Linux IIRC, so you would need to do `try XCTSkipIf(true, <message>)`', 'comment_created': datetime.datetime(2023, 7, 29, 17, 34, 10, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1278348081, 'comment_body': 'That sounds good to me 👍🏽 Can you just adjust the expected and remove the XFail?', 'comment_created': datetime.datetime(2023, 7, 29, 17, 34, 23, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1278348154, 'comment_body': 'If this has no effect, I’d prefer to revert it.', 'comment_created': datetime.datetime(2023, 7, 29, 17, 34, 59, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1278348229, 'comment_body': 'Oh, did you find a solution to https://github.com/apple/swift-syntax/pull/1953#discussion_r1276769666 after all? Or doesn’t this work?\r\n', 'comment_created': datetime.datetime(2023, 7, 29, 17, 36, 13, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1278348309, 'comment_body': '`== true` seems redundant to me.', 'comment_created': datetime.datetime(2023, 7, 29, 17, 37, 8, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1278348365, 'comment_body': 'If you are subtracting `child.leadingTriviaByteLength` from `length` you need to add it to `offset`', 'comment_created': datetime.datetime(2023, 7, 29, 17, 37, 24, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1278350786, 'comment_body': 'LGTM. I would just prefer to also classify the `@` as `attribute`. AFAICT you just need revert one of the changes you did above.', 'comment_created': datetime.datetime(2023, 7, 29, 17, 40, 21, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1278584077, 'comment_body': ""That could be a solution if we don't refactor`ClassificationVisitor`,  and that works.😉"", 'comment_created': datetime.datetime(2023, 7, 30, 15, 39, 28, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1279778409, 'comment_body': 'We should also classify the trivia for doc comments (both leading and trailing). A test case to test that would be.\r\n\r\n```swift\r\n@MyAttribute // some comment\r\nfunc foo() {}\r\n```\r\n\r\nTo do that, I think you should factor out the following and call it to classify the trivia.\r\n\r\nhttps://github.com/apple/swift-syntax/blob/e04c5c117bdf5a92ddc309ac4ce8e33fe302db41/Sources/SwiftIDEUtils/SyntaxClassifier.swift#L168-L173', 'comment_created': datetime.datetime(2023, 7, 31, 19, 33, 6, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1279779579, 'comment_body': 'I think that’s a fine solution. Good idea 👍🏽 ', 'comment_created': datetime.datetime(2023, 7, 31, 19, 33, 28, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1280495597, 'comment_body': 'Ah, yeah. But we also have to add two public properties `leadingTriviaPieces` and `trailingTriviaPieces` in `RawSyntax` to get the trivia pieces as in my new commit. ', 'comment_created': datetime.datetime(2023, 8, 1, 11, 32, 44, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1280835192, 'comment_body': 'Oh, I thought we could have a function to classify the trivia pieces so we don’t need to repeat this loop everywhere. \r\n\r\nSomething like\r\n\r\n```swift\r\n/// Classifies `trivia` and returns the number of bytes the trivia took up in the source\r\nfunc classify(trivia: [RawTriviaPiece]) -> Int {\r\n  var classifiedBytes = 0\r\n  for triviaPiece in triviaPieces {\r\n    let range = triviaPiece.classify(offset: byteOffset)\r\n    report(range: range)\r\n    classifiedBytes += triviaPiece.byteLength\r\n  }\r\n  return classifiedBytes\r\n}\r\n```\r\n\r\nAnd then here you can just do\r\n\r\n```swift\r\nif let triviaPieces = child.leadingTriviaPieces {\r\n  byteOffset += classify(trivia: triviaPieces)\r\n}\r\n```\r\n\r\nAnd you can also use the function in `handleToken`.\r\n\r\nMy thinking is that repeating an implementation twice is still OK but as soon as we reach 3 or more copies, we should really factor it out.', 'comment_created': datetime.datetime(2023, 8, 1, 15, 45, 23, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1280835655, 'comment_body': 'I think you’re classifying `leadingTriviaPieces` twice: Once in the `for` loop above and then once here.', 'comment_created': datetime.datetime(2023, 8, 1, 15, 45, 47, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1282172683, 'comment_body': 'Ah, I think that looks nice. 👍 ', 'comment_created': datetime.datetime(2023, 8, 2, 16, 41, 26, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1282172983, 'comment_body': 'Oops, I forgot to delete this one.', 'comment_created': datetime.datetime(2023, 8, 2, 16, 41, 45, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}]","[{'commit_sha': '462b69b046eafabcd99a2bf0d805af4354d9aae9', 'committer_username': 'StevenWong12', 'committer_name': 'Ziyang Huang', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 21, 11, 25, 44, tzinfo=datetime.timezone.utc)}]",Ziyang Huang,56827396,,User,,24,,0,6
1455556958,Remove syntax classification `lit`-based tests,"The follow-up PR for https://github.com/apple/swift-syntax/pull/1953.

Also remove the `lit-test-helper` in codebase. 🥳",True,1966,https://api.github.com/repos/swiftlang/swift-syntax/pulls/1966,https://github.com/swiftlang/swift-syntax/pull/1966,closed,0,1340,10,1,5,2,0,0,[],2023-07-31 05:06:12+00:00,2023-08-04 23:32:04+00:00,411952.0,"4 days, 18:25:52","[{'comment_id': 1279810677, 'comment_body': 'I think some test case with escaped identifiers would be good to keep.', 'comment_created': datetime.datetime(2023, 7, 31, 19, 48, 16, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1280497274, 'comment_body': ""I think that's good👍. I added two in my new commit in https://github.com/apple/swift-syntax/pull/1953."", 'comment_created': datetime.datetime(2023, 8, 1, 11, 34, 37, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}]","[{'commit_sha': 'da586f2bd47052f8786bd1de91ac8305076b109e', 'committer_username': 'StevenWong12', 'committer_name': 'Ziyang Huang', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 21, 11, 25, 44, tzinfo=datetime.timezone.utc)}]",Ziyang Huang,56827396,,User,,24,,0,6
1476198088,Remove the remaining file in `lit-test-helper`,That's definitely something we forgot before.,True,2064,https://api.github.com/repos/swiftlang/swift-syntax/pulls/2064,https://github.com/swiftlang/swift-syntax/pull/2064,closed,0,69,1,1,1,0,0,0,[],2023-08-15 16:52:27+00:00,2023-08-15 21:52:26+00:00,17999.0,4:59:59,[],"[{'commit_sha': '133ffdf2ed04dbb19e1162abafc36f54040b43e6', 'committer_username': 'StevenWong12', 'committer_name': 'Ziyang Huang', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 21, 11, 25, 44, tzinfo=datetime.timezone.utc)}]",Ziyang Huang,56827396,,User,,24,,0,6
1430707760,Replace `offset(of: )` with `getOffsetToStart`,`LexemeSequence.offset(of: )` and `LexemeSequence.getOffsetToStart` perform the same function and this should make the usage more consistent.,True,1899,https://api.github.com/repos/swiftlang/swift-syntax/pulls/1899,https://github.com/swiftlang/swift-syntax/pull/1899,closed,5,23,3,1,1,1,0,0,[],2023-07-12 07:12:40+00:00,2023-07-13 07:44:23+00:00,88303.0,"1 day, 0:31:43","[{'comment_id': 1260964462, 'comment_body': 'One nitpick since you’re changing this (I think I thought about this before but apparently never left a comment): Could you rename the function to `offsetToStart`. Swift generally doesn’t use the term `get` in function names.', 'comment_created': datetime.datetime(2023, 7, 12, 10, 26, 40, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}]","[{'commit_sha': 'd0cca3248357c2b36372c677fc08b5a59d373c61', 'committer_username': 'StevenWong12', 'committer_name': 'Ziyang Huang', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 21, 11, 25, 44, tzinfo=datetime.timezone.utc)}]",Ziyang Huang,56827396,,User,,24,,0,6
1430827705,Replace `IncrementalParseReusedNodeDelegate` with `ReusedNodeCallback`,Resolves comments in https://github.com/apple/swift-syntax/pull/1685/files#r1254465986,True,1900,https://api.github.com/repos/swiftlang/swift-syntax/pulls/1900,https://github.com/swiftlang/swift-syntax/pull/1900,closed,17,42,3,1,1,2,0,0,[],2023-07-12 08:37:58+00:00,2023-07-13 10:38:59+00:00,93661.0,"1 day, 2:01:01","[{'comment_id': 1260965293, 'comment_body': 'The callback only takes a single node.\r\n\r\n```suggestion\r\npublic typealias ReusedNodeCallback = (_ node: Syntax) -> ()\r\n```', 'comment_created': datetime.datetime(2023, 7, 12, 10, 27, 23, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1260965592, 'comment_body': 'Could you update the documentation as well? Something like\r\n\r\n```\r\nFor each node that gets re-used `reusedNodeCallback` is called.\r\n```', 'comment_created': datetime.datetime(2023, 7, 12, 10, 27, 39, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}]","[{'commit_sha': '0e5a32eaa605de0e3fdd1580e4cffa47a9e1e4f3', 'committer_username': 'StevenWong12', 'committer_name': 'Ziyang Huang', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 21, 11, 25, 44, tzinfo=datetime.timezone.utc)}]",Ziyang Huang,56827396,,User,,24,,0,6
1434129014,Enable some skipped tests in `IncrementalParsingTests.swift`,"Since we now enable re-using on `codeBlockItem`, I think we should not skip these test but modify the `reusedNodes` for these test cases.

To let this happen, I also made some tiny changes on `assertIncrementalParse` to make the `ByteSourceRange` correctly match in test cases have same substring in source. e.g.
```swift
func foo() {}
foo()
```

Also make some naming improvements:
* `getEditsAndSources()` -> `extractEditsAndSources(from: source)`
* `getByteSourceRange` -> `byteSourceRange`",True,1905,https://api.github.com/repos/swiftlang/swift-syntax/pulls/1905,https://github.com/swiftlang/swift-syntax/pull/1905,closed,48,31,3,1,1,2,0,0,[],2023-07-14 04:28:44+00:00,2023-07-17 16:50:24+00:00,303700.0,"3 days, 12:21:40","[{'comment_id': 1263627551, 'comment_body': 'Nit, just to maintain the indentation of `parameter` which makes it easier to read. Also the source should be in backticks to make it render nicely in docc\r\n\r\n\r\n```suggestion\r\n///\r\n/// - parameter reusedNodes: The element order should respect to the order of  `ReusedNodeSpec.source` in `source`.\r\n///   e.g. for `source` \r\n///   ```\r\n///   func foo() {}\r\n///    foo()\r\n///    ```\r\n///    The `reusedNodes` should be \r\n///    ```\r\n///    [\r\n///      ReusedNodeSpec(""func foo() {}"", kind: .codeBlockItem),\r\n///      ReusedNodeSpec(""foo()"", kind: .codeBlockItem)\r\n///    ]\r\n///    ```\r\n```', 'comment_created': datetime.datetime(2023, 7, 14, 11, 30, 20, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1263636762, 'comment_body': 'Instead of doing all these index manipulations (which seem fairly brittle to me), I would keep everything as is and add a `after` parameter to `byteSourceRange`\r\n\r\n```swift\r\nfileprivate func byteSourceRange(for substring: String, in sourceString: String, after: String.Index) -> ByteSourceRange? {\r\n  if let range = sourceString[after...].range(of: substring) {\r\n    return ByteSourceRange(\r\n      offset: sourceString.utf8.distance(from: sourceString.startIndex, to: range.lowerBound),\r\n      length: sourceString.utf8.distance(from: range.lowerBound, to: range.upperBound)\r\n    )\r\n  }\r\n  return nil\r\n}\r\n```\r\n\r\nYou can then call `byteSourceRange` above as\r\n\r\n```swift\r\nbyteSourceRange(for: expectedReusedNode.source, in: originalString, after: lastRangeUpperBound)\r\n```', 'comment_created': datetime.datetime(2023, 7, 14, 11, 40, 47, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}]","[{'commit_sha': '8b77cb65c2c43c27d0d437a98ae2b72289bb10d0', 'committer_username': 'StevenWong12', 'committer_name': 'Ziyang Huang', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 21, 11, 25, 44, tzinfo=datetime.timezone.utc)}]",Ziyang Huang,56827396,,User,,24,,0,6
1460085341,Parse hashbang as a child of `SourceFileSyntax`,"Resolves https://github.com/apple/swift-syntax/issues/1825.

Instead of parsing hashbang into a token list, I think the easier way is to parse the whole as an identifier-like token since we don't care about the content of it.  

Also, we could make use of `Lexer.Cursor.advanceToEndOfLine` to lex the first line as a hashbang token instead of doing this in the parser. 

What do you think about it?",True,1979,https://api.github.com/repos/swiftlang/swift-syntax/pulls/1979,https://github.com/swiftlang/swift-syntax/pull/1979,closed,166,105,27,1,6,8,0,0,[],2023-08-02 16:25:07+00:00,2023-08-14 14:36:18+00:00,1030271.0,"11 days, 22:11:11","[{'comment_id': 1282214304, 'comment_body': 'Could you add some documentation for this child? Just briefly describe in which cases the shebang can exist and what it means in terms of Swift.', 'comment_created': datetime.datetime(2023, 8, 2, 17, 23, 46, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1282215527, 'comment_body': 'This would need to be `HashbangToken`, right? Because you’re not parsing this as an `IdentifierToken`. This should fail if you compile swift-syntax with `SWIFTSYNTAX_ENABLE_RAWSYNTAX_VALIDATION`.', 'comment_created': datetime.datetime(2023, 8, 2, 17, 24, 59, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1282216247, 'comment_body': 'I’m not sure that makes sense because it’s not a pound directive in the Swift sense. I would just classify it as `none`.', 'comment_created': datetime.datetime(2023, 8, 2, 17, 25, 45, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1282216749, 'comment_body': 'Oh, nice. That’s so simple.', 'comment_created': datetime.datetime(2023, 8, 2, 17, 26, 17, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1283417985, 'comment_body': ""Oh, that's because I found hashbang is colored the same as other macros in Xcode so I think we could classify it as `.poundDirective` and make it highlighted the same as other macros in sourcekit-lsp."", 'comment_created': datetime.datetime(2023, 8, 3, 16, 4, 3, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1283451556, 'comment_body': 'Hmm, I think we can deviate here. `poundDirective` might make sense now but it makes less sense if we rename `poundDirective` to `ifConfigDirective` as discussed offline. \r\n\r\nIf you do want to color it, I would color it as a line comment, because that’s kind-of what it is: The `#` indicates a comment in bash, I think that’s what the `#!` has evolved from and Swift just supports it as well.', 'comment_created': datetime.datetime(2023, 8, 3, 16, 33, 1, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1285232730, 'comment_body': ""Ah, that makes sense. I'll just leave it as `none` for now."", 'comment_created': datetime.datetime(2023, 8, 6, 15, 25, 31, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1286131959, 'comment_body': 'Actually, now that I read this again, we can just add `UInt8(ascii: ""#"")` to the `Punctuation` section a few lines further below. It doesn’t need its own case anymore.', 'comment_created': datetime.datetime(2023, 8, 7, 16, 31, 47, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}]","[{'commit_sha': '605a5b8847eec8b18710afef0c48781c51bf1aa0', 'committer_username': 'StevenWong12', 'committer_name': 'Ziyang Huang', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 21, 11, 25, 44, tzinfo=datetime.timezone.utc)}]",Ziyang Huang,56827396,,User,,24,,0,6
1463064204,Rename some `SyntaxClassification`,Rename some `SyntaxClassification` and deprecate some out-of-date types.,True,1998,https://api.github.com/repos/swiftlang/swift-syntax/pulls/1998,https://github.com/swiftlang/swift-syntax/pull/1998,closed,86,78,4,1,7,5,0,0,[],2023-08-04 14:45:23+00:00,2023-08-11 00:21:24+00:00,552961.0,"6 days, 9:36:01","[{'comment_id': 1284519718, 'comment_body': 'I think `#sourceLocation` being classified as `.identifier` makes more sense than `.ifConfigDirective` after the renaming. What do you think?', 'comment_created': datetime.datetime(2023, 8, 4, 14, 46, 45, tzinfo=datetime.timezone.utc), 'commenter': 'StevenWong12', 'type': 'User'}, {'comment_id': 1284808961, 'comment_body': '```suggestion\r\n  @available(*, deprecated, message: ""String interpolation anchors are now classified as .none"")\r\n```', 'comment_created': datetime.datetime(2023, 8, 4, 20, 6, 38, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1284809045, 'comment_body': '```suggestion\r\n  @available(*, deprecated, renamed: ""type"")\r\n```', 'comment_created': datetime.datetime(2023, 8, 4, 20, 6, 47, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1284809614, 'comment_body': 'I think we can just remove these two cases because parentheses are classified as `.none` by default, so there’s nothing to override', 'comment_created': datetime.datetime(2023, 8, 4, 20, 7, 49, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}, {'comment_id': 1284815444, 'comment_body': 'I think that `keyword` might be the best classification, actually.\r\n\r\n1. `#sourceLocation` is different than macros in that it modifies global state (namely the evaluation of `#file` and `#line` for all following lines)\r\n2. `file` and `line` are also classified as keywords\r\n3. It’s what we get by default, so it’s the least amount of work 😉 ', 'comment_created': datetime.datetime(2023, 8, 4, 20, 17, 20, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}]","[{'commit_sha': 'd7caad1bc3549fd9d9201ba336419e7d9ed4c362', 'committer_username': 'StevenWong12', 'committer_name': 'Ziyang Huang', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 21, 11, 25, 44, tzinfo=datetime.timezone.utc)}]",Ziyang Huang,56827396,,User,,24,,0,6
1463067693,Rename some `SyntaxClassification`,To sync changes in https://github.com/apple/swift-syntax/pull/1998,True,794,https://api.github.com/repos/swiftlang/sourcekit-lsp/pulls/794,https://github.com/swiftlang/sourcekit-lsp/pull/794,closed,4,8,1,1,1,0,0,0,[],2023-08-04 14:47:51+00:00,2023-08-11 00:21:26+00:00,552815.0,"6 days, 9:33:35",[],"[{'commit_sha': '86ee25418a82bc0545c58a228008c253121f7e77', 'committer_username': 'StevenWong12', 'committer_name': 'Ziyang Huang', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 21, 11, 25, 44, tzinfo=datetime.timezone.utc)}]",Ziyang Huang,56827396,,User,,24,,0,6
1476191384,Move `swift-parser-cli` to its own package,"This should remove `swift-syntax`'s dependency on `swift-argument-parser`.🥳

I'll add a REAME and sync the changes in the build script later.",True,2063,https://api.github.com/repos/swiftlang/swift-syntax/pulls/2063,https://github.com/swiftlang/swift-syntax/pull/2063,closed,127,26,20,4,31,1,0,0,[],2023-08-15 16:46:41+00:00,2023-10-15 00:22:05+00:00,5211324.0,"60 days, 7:35:24","[{'comment_id': 1295150898, 'comment_body': 'I would add a newline between the tools version and the `import` to match the style of the top level Package.swift', 'comment_created': datetime.datetime(2023, 8, 15, 21, 50, 48, tzinfo=datetime.timezone.utc), 'commenter': 'ahoppen', 'type': 'User'}]","[{'commit_sha': 'bdca1a46e5da084228841ff8e5d209f0cc0bd533', 'committer_username': 'StevenWong12', 'committer_name': 'Ziyang Huang', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 21, 11, 25, 44, tzinfo=datetime.timezone.utc)}, {'commit_sha': '264f676224989a127894146c933ae0c2da221a64', 'committer_username': 'StevenWong12', 'committer_name': 'Ziyang Huang', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 21, 11, 25, 44, tzinfo=datetime.timezone.utc)}, {'commit_sha': '280fc3e765bd5f42eebc33abcb266fbf2ab29c1b', 'committer_username': 'StevenWong12', 'committer_name': 'Ziyang Huang', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 21, 11, 25, 44, tzinfo=datetime.timezone.utc)}, {'commit_sha': '657f2e1d4bb396dc3c743f62a22d95de54dacda8', 'committer_username': 'StevenWong12', 'committer_name': 'Ziyang Huang', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 21, 11, 25, 44, tzinfo=datetime.timezone.utc)}]",Ziyang Huang,56827396,,User,,24,,0,6

Project_ID,Name,Full_name,Language,Forks,Stars,Watchers,contributors,commits,issues,branches,PRs_count,contributor pullrequests
143079594,swift-syntax,swiftlang/swift-syntax,Swift,400,3155,184,174,5310,96,42,35,"[{'id': 1484868292, 'number': 2087, 'closed': None, 'created': datetime.datetime(2023, 8, 22, 14, 24, 27, tzinfo=datetime.timezone.utc), 'time_taken': 0.0, 'time_delta': '', 'additions': 134, 'deletions': 135, 'state': 'open'}, {'id': 1476198088, 'number': 2064, 'closed': datetime.datetime(2023, 8, 15, 21, 52, 26, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 8, 15, 16, 52, 27, tzinfo=datetime.timezone.utc), 'time_taken': 17999.0, 'time_delta': '4:59:59', 'additions': 0, 'deletions': 69, 'state': 'closed'}, {'id': 1476191384, 'number': 2063, 'closed': datetime.datetime(2023, 10, 15, 0, 22, 5, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 8, 15, 16, 46, 41, tzinfo=datetime.timezone.utc), 'time_taken': 5211324.0, 'time_delta': '60 days, 7:35:24', 'additions': 127, 'deletions': 26, 'state': 'closed'}, {'id': 1466102227, 'number': 2025, 'closed': datetime.datetime(2024, 3, 19, 15, 12, 49, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 8, 8, 1, 28, 33, tzinfo=datetime.timezone.utc), 'time_taken': 19403056.0, 'time_delta': '224 days, 13:44:16', 'additions': 197, 'deletions': 162, 'state': 'closed'}, {'id': 1463064204, 'number': 1998, 'closed': datetime.datetime(2023, 8, 11, 0, 21, 24, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 8, 4, 14, 45, 23, tzinfo=datetime.timezone.utc), 'time_taken': 552961.0, 'time_delta': '6 days, 9:36:01', 'additions': 86, 'deletions': 78, 'state': 'closed'}, {'id': 1460085341, 'number': 1979, 'closed': datetime.datetime(2023, 8, 14, 14, 36, 18, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 8, 2, 16, 25, 7, tzinfo=datetime.timezone.utc), 'time_taken': 1030271.0, 'time_delta': '11 days, 22:11:11', 'additions': 166, 'deletions': 105, 'state': 'closed'}, {'id': 1455556958, 'number': 1966, 'closed': datetime.datetime(2023, 8, 4, 23, 32, 4, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 7, 31, 5, 6, 12, tzinfo=datetime.timezone.utc), 'time_taken': 411952.0, 'time_delta': '4 days, 18:25:52', 'additions': 0, 'deletions': 1340, 'state': 'closed'}, {'id': 1452182967, 'number': 1953, 'closed': datetime.datetime(2023, 8, 3, 17, 55, 44, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 7, 27, 15, 7, 56, tzinfo=datetime.timezone.utc), 'time_taken': 614868.0, 'time_delta': '7 days, 2:47:48', 'additions': 509, 'deletions': 16, 'state': 'closed'}, {'id': 1437617695, 'number': 1916, 'closed': datetime.datetime(2023, 7, 25, 0, 32, 37, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 7, 17, 16, 7, 36, tzinfo=datetime.timezone.utc), 'time_taken': 635101.0, 'time_delta': '7 days, 8:25:01', 'additions': 189, 'deletions': 165, 'state': 'closed'}, {'id': 1434131919, 'number': 1906, 'closed': datetime.datetime(2023, 7, 14, 16, 53, 19, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 7, 14, 4, 32, 55, tzinfo=datetime.timezone.utc), 'time_taken': 44424.0, 'time_delta': '12:20:24', 'additions': 16, 'deletions': 5, 'state': 'closed'}, {'id': 1434129014, 'number': 1905, 'closed': datetime.datetime(2023, 7, 17, 16, 50, 24, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 7, 14, 4, 28, 44, tzinfo=datetime.timezone.utc), 'time_taken': 303700.0, 'time_delta': '3 days, 12:21:40', 'additions': 48, 'deletions': 31, 'state': 'closed'}, {'id': 1430827705, 'number': 1900, 'closed': datetime.datetime(2023, 7, 13, 10, 38, 59, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 7, 12, 8, 37, 58, tzinfo=datetime.timezone.utc), 'time_taken': 93661.0, 'time_delta': '1 day, 2:01:01', 'additions': 17, 'deletions': 42, 'state': 'closed'}, {'id': 1430707760, 'number': 1899, 'closed': datetime.datetime(2023, 7, 13, 7, 44, 23, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 7, 12, 7, 12, 40, tzinfo=datetime.timezone.utc), 'time_taken': 88303.0, 'time_delta': '1 day, 0:31:43', 'additions': 5, 'deletions': 23, 'state': 'closed'}, {'id': 1425994357, 'number': 1893, 'closed': datetime.datetime(2023, 7, 10, 10, 1, 31, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 7, 8, 16, 43, tzinfo=datetime.timezone.utc), 'time_taken': 148711.0, 'time_delta': '1 day, 17:18:31', 'additions': 0, 'deletions': 18, 'state': 'closed'}, {'id': 1397030959, 'number': 1807, 'closed': datetime.datetime(2023, 6, 21, 9, 48, 43, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 6, 18, 7, 46, 29, tzinfo=datetime.timezone.utc), 'time_taken': 266534.0, 'time_delta': '3 days, 2:02:14', 'additions': 0, 'deletions': 1158, 'state': 'closed'}, {'id': 1395326762, 'number': 1798, 'closed': datetime.datetime(2023, 6, 16, 13, 28, 35, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 6, 16, 8, 46, 30, tzinfo=datetime.timezone.utc), 'time_taken': 16925.0, 'time_delta': '4:42:05', 'additions': 1, 'deletions': 1, 'state': 'closed'}, {'id': 1395318743, 'number': 1797, 'closed': datetime.datetime(2023, 6, 16, 14, 37, 50, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 6, 16, 8, 40, 22, tzinfo=datetime.timezone.utc), 'time_taken': 21448.0, 'time_delta': '5:57:28', 'additions': 49, 'deletions': 23, 'state': 'closed'}, {'id': 1392588875, 'number': 1783, 'closed': datetime.datetime(2023, 6, 15, 17, 9, 46, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 6, 14, 14, 53, 30, tzinfo=datetime.timezone.utc), 'time_taken': 94576.0, 'time_delta': '1 day, 2:16:16', 'additions': 149, 'deletions': 146, 'state': 'closed'}, {'id': 1392452479, 'number': 1782, 'closed': datetime.datetime(2023, 6, 21, 7, 45, 38, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 6, 14, 13, 42, 47, tzinfo=datetime.timezone.utc), 'time_taken': 583371.0, 'time_delta': '6 days, 18:02:51', 'additions': 391, 'deletions': 0, 'state': 'closed'}, {'id': 1387596555, 'number': 1766, 'closed': datetime.datetime(2023, 7, 11, 12, 19, 38, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 6, 11, 16, 16, 10, tzinfo=datetime.timezone.utc), 'time_taken': 2577808.0, 'time_delta': '29 days, 20:03:28', 'additions': 86, 'deletions': 9, 'state': 'closed'}, {'id': 1368076567, 'number': 1712, 'closed': datetime.datetime(2023, 6, 3, 4, 29, 30, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 5, 28, 17, 22, 11, tzinfo=datetime.timezone.utc), 'time_taken': 472039.0, 'time_delta': '5 days, 11:07:19', 'additions': 148, 'deletions': 43, 'state': 'closed'}, {'id': 1358152980, 'number': 1685, 'closed': datetime.datetime(2023, 7, 11, 17, 4, 17, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 5, 21, 8, 59, 14, tzinfo=datetime.timezone.utc), 'time_taken': 4435503.0, 'time_delta': '51 days, 8:05:03', 'additions': 380, 'deletions': 62, 'state': 'closed'}, {'id': 1358137986, 'number': 1684, 'closed': datetime.datetime(2023, 5, 26, 19, 31, 12, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 5, 21, 7, 48, 3, tzinfo=datetime.timezone.utc), 'time_taken': 474189.0, 'time_delta': '5 days, 11:43:09', 'additions': 208, 'deletions': 48, 'state': 'closed'}, {'id': 1350046894, 'number': 1662, 'closed': datetime.datetime(2023, 5, 23, 7, 7, 6, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 5, 15, 3, 19, 46, tzinfo=datetime.timezone.utc), 'time_taken': 704840.0, 'time_delta': '8 days, 3:47:20', 'additions': 179, 'deletions': 47, 'state': 'closed'}, {'id': 1324312682, 'number': 1574, 'closed': datetime.datetime(2023, 5, 8, 23, 3, 20, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 4, 23, 9, 28, 24, tzinfo=datetime.timezone.utc), 'time_taken': 1344896.0, 'time_delta': '15 days, 13:34:56', 'additions': 1940, 'deletions': 247, 'state': 'closed'}, {'id': 1291403222, 'number': 1454, 'closed': datetime.datetime(2023, 4, 12, 21, 43, 4, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 3, 27, 13, 58, 55, tzinfo=datetime.timezone.utc), 'time_taken': 1410249.0, 'time_delta': '16 days, 7:44:09', 'additions': 753, 'deletions': 350, 'state': 'closed'}, {'id': 1290229843, 'number': 1448, 'closed': datetime.datetime(2023, 5, 31, 10, 54, 34, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 3, 26, 4, 18, 48, tzinfo=datetime.timezone.utc), 'time_taken': 5726146.0, 'time_delta': '66 days, 6:35:46', 'additions': 457, 'deletions': 342, 'state': 'closed'}, {'id': 1283568347, 'number': 1426, 'closed': datetime.datetime(2023, 5, 8, 16, 44, 8, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 3, 21, 3, 36, 48, tzinfo=datetime.timezone.utc), 'time_taken': 4194440.0, 'time_delta': '48 days, 13:07:20', 'additions': 93, 'deletions': 0, 'state': 'closed'}, {'id': 1269118731, 'number': 1397, 'closed': datetime.datetime(2023, 3, 12, 1, 57, 1, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 3, 9, 8, 22, 50, tzinfo=datetime.timezone.utc), 'time_taken': 236051.0, 'time_delta': '2 days, 17:34:11', 'additions': 87, 'deletions': 18, 'state': 'closed'}, {'id': 1260329143, 'number': 1381, 'closed': datetime.datetime(2023, 3, 8, 20, 38, 41, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 3, 2, 11, 54, 36, tzinfo=datetime.timezone.utc), 'time_taken': 549845.0, 'time_delta': '6 days, 8:44:05', 'additions': 34, 'deletions': 12, 'state': 'closed'}]"
154773196,sourcekit-lsp,swiftlang/sourcekit-lsp,Swift,268,3245,163,113,2953,82,26,12,"[{'id': 1463067693, 'number': 794, 'closed': datetime.datetime(2023, 8, 11, 0, 21, 26, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 8, 4, 14, 47, 51, tzinfo=datetime.timezone.utc), 'time_taken': 552815.0, 'time_delta': '6 days, 9:33:35', 'additions': 4, 'deletions': 8, 'state': 'closed'}, {'id': 1460626638, 'number': 788, 'closed': datetime.datetime(2023, 8, 3, 17, 55, 41, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 8, 3, 1, 15, 54, tzinfo=datetime.timezone.utc), 'time_taken': 59987.0, 'time_delta': '16:39:47', 'additions': 1, 'deletions': 1, 'state': 'closed'}, {'id': 1417867027, 'number': 761, 'closed': datetime.datetime(2023, 7, 14, 16, 53, 7, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 7, 3, 10, 41, 41, tzinfo=datetime.timezone.utc), 'time_taken': 972686.0, 'time_delta': '11 days, 6:11:26', 'additions': 84, 'deletions': 7, 'state': 'closed'}]"
124606805,swift-stress-tester,swiftlang/swift-stress-tester,Swift,46,211,114,20,517,1,29,1,"[{'id': 1421257505, 'number': 242, 'closed': datetime.datetime(2023, 7, 11, 17, 4, 15, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 7, 5, 14, 49, 57, tzinfo=datetime.timezone.utc), 'time_taken': 526458.0, 'time_delta': '6 days, 2:14:18', 'additions': 3, 'deletions': 2, 'state': 'closed'}]"
