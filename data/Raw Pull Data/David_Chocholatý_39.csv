pr_id,pr_title,pr_body,is_merged,pr_number,pr_url,pr_html_url,pr_state,additions,deletions,pr_changed_files,pr_commits_count,pr_comments_count,pr_review_comments_count,pr_labels_count,pr_assignees_count,pr_labels,pr_created_at,pr_closed_at,time_taken,time_delta,pr_review_comments,pr_commits,contributor,contributor_id,contributor_email,contributor_type,contributions,contributor_public_repos,contributor_private_repos,contributor_followings,contributor_followers
971290657,EngineEffectsDelay: effects chain delay handling,"Solves the delay issue for the effects chain. The solution
is useful for the dry/wet or dry+wet mode. If the effects chain
has a specific delay based on the effects processing latency,
the dry signal is delayed to ensure dry and wet signals overlap.
To delay the dry signal, the sum of all chain effects group delay
is calculated. In the current version, the solution is especially used
for the Pitch shift effect. The known issue is, that the Pitch shift
effect doesn't provide the right amount of latency and the delay
is pretty huge. This problem has to be solved for the Pitch shift
effect implementation first. The effect group delay propagation
was implemented through the use of the EffectProcessorImpl,
EffectProcessor and EngineEffect. The special class wasn't created
for the purpose to preserve the hierarchy of effects implementation
as much as possible.",True,4810,https://api.github.com/repos/mixxxdj/mixxx/pulls/4810,https://github.com/mixxxdj/mixxx/pull/4810,closed,686,2,12,40,70,154,2,1,"[{'name': 'build'}, {'name': 'code quality'}]",2022-06-18 14:20:49+00:00,2022-08-14 22:32:56+00:00,4954327.0,"57 days, 8:12:07","[{'comment_id': 901002888, 'comment_body': ""It would make more sense to enforce the fact that this can't be the case in the caller. Use the `M_RESTRICT` macro from `util/platform.h`\r\nhttps://en.wikipedia.org/wiki/Restrict"", 'comment_created': datetime.datetime(2022, 6, 18, 18, 17, 17, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 901003047, 'comment_body': ""I don't see much use in a private setter to be honest. "", 'comment_created': datetime.datetime(2022, 6, 18, 18, 19, 18, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 901003107, 'comment_body': 'Use SINT for indexing or quantities of samples.\r\n```suggestion\r\nSINT PitchShiftEffect::getGroupDelay() {\r\n    return m_groupDelay;\r\n}\r\n```', 'comment_created': datetime.datetime(2022, 6, 18, 18, 20, 3, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 901003192, 'comment_body': 'Can you explain this a bit better? why the method exists and what its return value means and how its supposed to be used?', 'comment_created': datetime.datetime(2022, 6, 18, 18, 21, 15, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 901003221, 'comment_body': 'implement in the header instead?', 'comment_created': datetime.datetime(2022, 6, 18, 18, 21, 44, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 901003489, 'comment_body': 'make class final and implement the simple setter here to allow for inlining.', 'comment_created': datetime.datetime(2022, 6, 18, 18, 25, 4, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 901003571, 'comment_body': 'is this class supposed to be inherited from? If not make it final and its protected member private.', 'comment_created': datetime.datetime(2022, 6, 18, 18, 25, 55, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 901061037, 'comment_body': 'I think it would be better to format this in frames.\r\nCan this ever be a float? Can we put the unit into the function name? ', 'comment_created': datetime.datetime(2022, 6, 19, 7, 27, 36, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 901061326, 'comment_body': 'We need to be careful not to swap stereo channels.\r\nI think if we make the group delay by frames it is solved automatically.', 'comment_created': datetime.datetime(2022, 6, 19, 7, 30, 8, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 901061988, 'comment_body': 'New is locking and must not be called from the engine.\r\nJust allocated a reasonable maximum during the constructor.', 'comment_created': datetime.datetime(2022, 6, 19, 7, 35, 43, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 901130872, 'comment_body': ""> I think it would be better to format this in frames.\r\n\r\nI think it could be maybe possible. Anyway, I would like to mention a few reasons, why the samples option was used.\r\n\r\nFirst is, that the EngineEffectsDelay is based on the [EngineFilterDelay,](https://github.com/mixxxdj/mixxx/blob/935ba94f7e498eebd7c3710b2f0df35d989d9a7d/src/engine/filters/enginefilterdelay.h#L34) which uses samples and the thought was to keep the structure as similar as possible.\r\n\r\nThe second reason was, that for now the stereo signal is kept as default. If I would like to keep the other possible options in mind for maybe some extensions in the future, in the EngineEffectChain it isn't possible to get the number of channels, at least not straight. The information on the number of channels is possible to get via EngineParameters ([created later](https://github.com/mixxxdj/mixxx/blob/935ba94f7e498eebd7c3710b2f0df35d989d9a7d/src/engine/effects/engineeffect.cpp#L181) through process() method call in EngineEffectChain).\r\n\r\nAnd at least the last third and the main reason based on the second one, in the EngineEffectsDelay process() method, it is necessary to work with samples in the work with audio buffers, not with the frames. It can be used frames if it would be possible in EngineEffectsDelay to get information about the number of channels of input audio signal.\r\n\r\nSo, I would like to summarize the main idea. It is possible if I can get information about the number of channels in the EngineEffectChain process() method, or at least in the EngineEffectsDelay process() method.\r\n\r\n> Can this ever be a float?\r\n\r\nIf I assume, that it will be worked with the samples or frames, it isn't possible. It can be possible if we thought of to option to work with the delay in milliseconds, but IMO it doesn't make much sense. If I'm wrong, please correct me.\r\n\r\n> Can we put the unit into the function name?\r\n\r\nYeah, of course. \r\n"", 'comment_created': datetime.datetime(2022, 6, 19, 16, 35, 4, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 901131479, 'comment_body': ""That's a good point. If the effectChainGroupDelay isn't right to the number of channels, the channels could be swapped (for stereo signal an odd number of samples). This situation isn't handled internally for now. As I mentioned for the PitchShiftEffect setGroupDelay() method, it is necessary to have the information about the number of channels, if I wouldn't assume, that it will be worked only with the stereo audio signal."", 'comment_created': datetime.datetime(2022, 6, 19, 16, 41, 29, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 901131842, 'comment_body': ""Okay, thank you. It will be a better option. I will fix it. The buffer size wasn't allocated in the constructor due to the huge amount of delay of the Pitch shift effect, but it will be solved."", 'comment_created': datetime.datetime(2022, 6, 19, 16, 45, 23, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 901134269, 'comment_body': 'Ok, that sounds reasonable. \r\nIf we put an assertion that the stereo signal is it swapped it works for me as well.', 'comment_created': datetime.datetime(2022, 6, 19, 17, 7, 30, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 901301007, 'comment_body': ""Okay, thank you. Good idea. Still, I see now on my solution and proposal of using samples rather than frames maybe a little problem, that if it will be worked in the future with other numbers of channels than the stereo signal, it would be harder to assert the invalid number of samples. To check the invalid value the number of samples has to be divisible by the number of channels. And because of that, the information about the number of channels has to be accessible in the EngineEffectChannel or EngineEffectsDelay, so this situation isn't still solved."", 'comment_created': datetime.datetime(2022, 6, 20, 6, 36, 56, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 906721702, 'comment_body': ""It would be interesting to see whats faster.\r\n1. Copying and making use of vectorization\r\n2. Doing the mutation in place and possibly don't get vectorization\r\n\r\nMy guess would be that it depends on buffer size. "", 'comment_created': datetime.datetime(2022, 6, 25, 20, 34, 1, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 906721959, 'comment_body': 'what if we take two `gsl::span`s instead? Do we suffer a significant performance penalty because of the runtime bounds checking? ', 'comment_created': datetime.datetime(2022, 6, 25, 20, 37, 8, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 906722379, 'comment_body': 'Also a documentation header would be nice', 'comment_created': datetime.datetime(2022, 6, 25, 20, 42, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 906799892, 'comment_body': 'since the group delay is an offset in sample, using `SINT` makes more sense.\r\n```suggestion\r\n    virtual SINT getGroupDelay() override {\r\n```', 'comment_created': datetime.datetime(2022, 6, 26, 11, 33, 1, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 906802503, 'comment_body': 'Agree, reporting the latency in Frames is better than samples because samples depend on the number of channels. ', 'comment_created': datetime.datetime(2022, 6, 26, 11, 53, 45, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 906803708, 'comment_body': ""I don't understand this case. Is it when the delay hasn't changed and the buffer is large enough? Why do we need this exception?"", 'comment_created': datetime.datetime(2022, 6, 26, 12, 1, 44, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 906837576, 'comment_body': ""Okay, I agree. If it is ok, the setter will recalculate the number of the frames into samples by using [mixxx::kEngineChannelCount](https://github.com/mixxxdj/mixxx/blob/1cd826af252c51f96db17f8a27cd3599828aa946/src/engine/engine.h#L8), I'm fine with that. The reason why the number of frames has to be recalculated in the setter is, that the inner process() method structure works with samples and it doesn't make sense to recalculate samples for every delay value usage."", 'comment_created': datetime.datetime(2022, 6, 26, 15, 46, 32, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 906838317, 'comment_body': ""Sure, if I think about it again, it really doesn't make much sense."", 'comment_created': datetime.datetime(2022, 6, 26, 15, 52, 56, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 906842856, 'comment_body': 'Yes, of course.', 'comment_created': datetime.datetime(2022, 6, 26, 16, 29, 42, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 906863005, 'comment_body': '> is this class supposed to be inherited from?\r\n\r\nIf I think about it again, probably not.\r\n\r\n', 'comment_created': datetime.datetime(2022, 6, 26, 19, 45, 3, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 907102979, 'comment_body': ""It's alright, the second condition part (`m_delayBufferSize == iBufferSize + m_delaySamples`) was added, because it looked to me not so clean to rely on that the `iBufferSize`, which is the input parameter, is always the same. If it wouldn't the same, the `m_delayBufferSize` would contain a bad value. Anyway, the buffer size is set now in the new version in the constructor and is known in compile time, so the condition for this part will be that just the delay hasn't changed (`m_oldDelaySamples == m_delaySamples`)."", 'comment_created': datetime.datetime(2022, 6, 27, 8, 16, 16, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 907336919, 'comment_body': 'In fact, I see the `gsl::span` for the first time. I studied some information about that. It looks like it could be cool. However, the `process()` method overrides the method from [EngineObjectConstIn,](https://github.com/mixxxdj/mixxx/blob/d209239967f2f4709d03c05261f8fef07ba47f75/src/engine/engineobject.h#L23) so for now, it doesn\'t fit well into the current structure. To still preserve hierarchy, I think that the new class should be created in `engineobject.h,` which will use `gsl::span` instead of `CSAMPLE*`, from which will the `EngineEffectsDelay` inherit. Another thing to the implementation, the use of span is great when using iterator. If I\'m right, for optimal use of gsl::span in `EngineEffectsDelay`, there have to be two iterators for one for cycle for input and output buffer, if we will use the ""two buffers"" version.', 'comment_created': datetime.datetime(2022, 6, 27, 12, 34, 38, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 907414744, 'comment_body': 'Since #4803 just got merged, you can also use `std::span` (which should be exactly equivalent to the pointer-based implementation because it doesn\'t perform bounds checking unlike `gsl::span`). Since this is somewhat performance-critical code, it would make sense to use implementation without bounds checking.\r\n\r\ntransforming `void process(const CSAMPLE* pIn, CSAMPLE* pOutput, const int iBufferSize)` to `void process(std::span<CSAMPLE> in, std::span<CSAMPLE> out);` and vice versa is trivial. We can provide a virtual method in the baseclass that has a default implementation and implements one in term of the other. Then mark the pointer-based method deprecated and then we can gradually change all implementations.\r\n\r\n> If I\'m right, for optimal use of gsl::span in EngineEffectsDelay, there have to be two iterators for one for cycle for input and output buffer, if we will use the ""two buffers"" version.\r\n\r\nWhy do you think so? The elements within spans are mutable, you can just change them in-place. So you can just create a span over the single mutable buffer. ', 'comment_created': datetime.datetime(2022, 6, 27, 13, 51, 7, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 907426193, 'comment_body': 'No need for heap allocation here imo. And if there is prefer unique_ptr. https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es60-avoid-new-and-delete-outside-resource-management-functions', 'comment_created': datetime.datetime(2022, 6, 27, 14, 1, 30, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 907703415, 'comment_body': ""> Since this is somewhat performance-critical code, it would make sense to use implementation without bounds checking.\r\n\r\nI agree, sounds good to me of using std::span.\r\n\r\n> Why do you think so? The elements within spans are mutable, you can just change them in-place. So you can just create a span over the single mutable buffer.\r\n\r\nOh, right right. I just didn't realize that while reading the documentation.\r\n"", 'comment_created': datetime.datetime(2022, 6, 27, 18, 57, 27, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 909674298, 'comment_body': 'basic getter still belongs in the header.', 'comment_created': datetime.datetime(2022, 6, 29, 14, 0, 53, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 909676537, 'comment_body': 'Can you explain why the heap allocation is needed?', 'comment_created': datetime.datetime(2022, 6, 29, 14, 2, 44, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 909678290, 'comment_body': '```suggestion\r\nconstexpr int kiMaxDelay = static_cast<int>(0.508 *\r\n        mixxx::audio::SampleRate::kValueMax * mixxx::kEngineChannelCount);\r\n```', 'comment_created': datetime.datetime(2022, 6, 29, 14, 4, 13, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 909679517, 'comment_body': 'Have you considered inheriting from `EngineObject` instead?', 'comment_created': datetime.datetime(2022, 6, 29, 14, 5, 14, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 909686120, 'comment_body': 'These pre-conditions must hold no matter which branch is actually taken. Can you deduplicate them outside the `if`?', 'comment_created': datetime.datetime(2022, 6, 29, 14, 10, 32, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 909706798, 'comment_body': 'why the ramping in the first place?', 'comment_created': datetime.datetime(2022, 6, 29, 14, 19, 47, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 910297407, 'comment_body': '```suggestion\r\n    /// The method returns the number of frames by which the dry signal\r\n```', 'comment_created': datetime.datetime(2022, 6, 29, 18, 52, 56, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 910299203, 'comment_body': '```suggestion\r\n    /// needs to be delayed so that buffers for the dry and wet signal (output\r\n    /// of the effect) overlap. The return value represents the current effect\r\n```', 'comment_created': datetime.datetime(2022, 6, 29, 18, 55, 4, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 910302493, 'comment_body': 'Can we give the buffer a better name? ', 'comment_created': datetime.datetime(2022, 6, 29, 18, 59, 6, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 910310417, 'comment_body': 'It feels scary that pIn is not const. I think It should be, because messing around with the input buffer feels wrong. \r\n\r\nThere is also no need for this copy. We can use m_tmpBuffer below. \r\n\r\n\r\n', 'comment_created': datetime.datetime(2022, 6, 29, 19, 8, 38, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 910313208, 'comment_body': 'We have also no definition for a i prefix. 0.508 is a magic number can we name it? What is the unit of kMaxDelay?', 'comment_created': datetime.datetime(2022, 6, 29, 19, 12, 3, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 910324383, 'comment_body': 'it looks like clang-format needs your help here:\r\n```suggestion\r\n        int delaySourcePos = \r\n                (m_delayPos + kiMaxDelay - m_delaySamples + iBufferSize / 2) %\r\n                kiMaxDelay;\r\n```\r\nDoes this work? ', 'comment_created': datetime.datetime(2022, 6, 29, 19, 27, 6, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 910328141, 'comment_body': 'Does this need to be with double precision? I can Imagine that a float calculation is sufficient, but faster on a 32 bit CPU.   ', 'comment_created': datetime.datetime(2022, 6, 29, 19, 31, 58, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 910334627, 'comment_body': 'if you feel lucky you may fiddle around to either use factorized functions or make this loop vetcorized. \r\nThis can be checked like described here: https://github.com/mixxxdj/mixxx/blob/0ad01b6ccc744045fb727eb4e775aa0e52bf4998/src/util/sample.cpp#L14\r\n\r\nThis requires that you chop the loop in chunks to get around the % kiMaxDelay on every sample. \r\n\r\n\r\n\r\n', 'comment_created': datetime.datetime(2022, 6, 29, 19, 40, 43, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 910804485, 'comment_body': 'The ramping is required, to remove click sounds form the stream. This happens due to the steep slope when concatenate two unrelated steams after changing the delay. A peace is cut out or doubled.   \r\nNot ramping in the first half is not relevant here. That was required in the bessel EQ, because it contains an unwanted settling sound of the filter after changing the cut of frequencies. \r\nHere the dry signal is all the way good. ', 'comment_created': datetime.datetime(2022, 6, 30, 9, 21, 15, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 910918145, 'comment_body': 'Mhmm ok, yeah makes sense. But yes, the ramping should be done over the entire buffer (not branching on the index helps with autovectorization) and it should be accomplished using `RampingValue`.', 'comment_created': datetime.datetime(2022, 6, 30, 11, 36, 41, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 910919758, 'comment_body': 'We should refine this anyways. Also rounding up to the next power of 2 helps the optimizer because the expensive modulo operation can be transformed into a binary AND.', 'comment_created': datetime.datetime(2022, 6, 30, 11, 38, 51, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 910973987, 'comment_body': 'Maybe I am a little bit confused. What I think is to construct an object by which I use the class methods. Can you please describe your proposal or what solution you propose?', 'comment_created': datetime.datetime(2022, 6, 30, 12, 35, 49, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 910986284, 'comment_body': ""Yes, I mentioned it few messages [earlier](https://github.com/mixxxdj/mixxx/pull/4810#issuecomment-1167068213). The difference is that the `process()` method works in place and doesn't need a temporary buffer and IMO fits better for the usage in the `EngineEffectChain`."", 'comment_created': datetime.datetime(2022, 6, 30, 12, 48, 48, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 910990916, 'comment_body': 'The reason, why are they duplicated is because of the difference in the `delaySourcePos` value calculation. See [R27](https://github.com/mixxxdj/mixxx/pull/4810/files/f40e7967a7f4b4988342e0930bbd2c8959db07e2#diff-8a31dfcb8638a3ad83fe1f01bcc3403c5918447ac9c8bd62f067c7d8debd1972R27) and [R55](https://github.com/mixxxdj/mixxx/pull/4810/files/f40e7967a7f4b4988342e0930bbd2c8959db07e2#diff-8a31dfcb8638a3ad83fe1f01bcc3403c5918447ac9c8bd62f067c7d8debd1972R55).', 'comment_created': datetime.datetime(2022, 6, 30, 12, 53, 26, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 910999120, 'comment_body': 'Thank you @daschuer for your answer. I agree that the ramping can be done through the whole buffer and `RampingValue` can be used.', 'comment_created': datetime.datetime(2022, 6, 30, 13, 1, 23, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 911133624, 'comment_body': 'You could add a reminder in this commit by adding a `static_assert(mixxx::kEngineChannelCount == 2);` somewhere. Then the compilation would fail if the stereo assumption is violated.', 'comment_created': datetime.datetime(2022, 6, 30, 14, 58, 34, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 911287312, 'comment_body': ""I'm really struggling to read the algorithm in the process function because these membernames don't really explain their purpose. Can you try to name them better?"", 'comment_created': datetime.datetime(2022, 6, 30, 17, 30, 56, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 911467278, 'comment_body': 'Trivial functions like that benefit greatly from inlining which is usually achieved by being implemented in the header.', 'comment_created': datetime.datetime(2022, 6, 30, 21, 44, 49, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 911474242, 'comment_body': 'Not in this case, because it is a virtual function that cannot be inline. ', 'comment_created': datetime.datetime(2022, 6, 30, 21, 57, 55, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 911477421, 'comment_body': ""Right. but what you are doing right now is that you are allocating an instance of `EngineEffectsDelay` on the heap and then storing the point in the `EngineEffectChain`. But you don't have to allocate on the heap. You can just construct the object as part of the owning object. \r\nSince `EngineEffectChain` lives in the audio engine thread, using heap-allocation is a nogo.\r\nNow:\r\n```\r\n ┌─────────────────┐       ┌─────────────────┐\r\n │EngineEffectChain│   ┌──►│EngineEffectDelay│\r\n │                 │   │   │                 │\r\n │m_pEffectDelay ──┼───┘   │...              │\r\n │                 │       └─────────────────┘\r\n │...              │\r\n └─────────────────┘\r\n``` \r\nWhat I propose:\r\n```\r\n\r\n ┌─────────────────────┐\r\n │EngineEffectChain    │\r\n │ ┌─────────────────┐ │\r\n │ │EngineEffectDelay│ │\r\n │ │                 │ │\r\n │ │...              │ │\r\n │ └─────────────────┘ │\r\n │...                  │\r\n └─────────────────────┘\r\n\r\n```\r\nI don't even think that the member would have to be constructed explicitly as it can be default constructed. So I'm basically just proposing to remove the line in question and change the class definition from `std::unique_ptr<EngineEffectsDelay> m_pEffectsDelay;` to `EngineEffectsDelay m_effectsDelay;`."", 'comment_created': datetime.datetime(2022, 6, 30, 22, 4, 14, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 911479677, 'comment_body': 'Yes. I actually thought about it too and IMO it makes more sense from not only a usage but also a performance perspective. Just append the input to `m_pDelayBuffer` in one pass, then copy from the older offset position. That would be vectorizer friendly. The only caveat is that `m_pDelayBuffer` would have to be big enough but that should be trivial to assert.', 'comment_created': datetime.datetime(2022, 6, 30, 22, 9, 16, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 911480068, 'comment_body': 'Mhmm ok, I have not looked much into that because I struggle to understand the arithmetic (as pointed out in the latest review below)', 'comment_created': datetime.datetime(2022, 6, 30, 22, 10, 8, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 911625924, 'comment_body': 'Yes, I can. I used the same names as in the `EngineFilterDelay`, but I agree that names are not quite telling of their purpose.', 'comment_created': datetime.datetime(2022, 7, 1, 5, 29, 42, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 911657029, 'comment_body': 'What do you think about this proposal:\r\n\r\n- _m_delaySamples -> m_newDelaySamples_\r\n\r\n  The purpose of the variable is to keep the actual setting of the number of samples saved. When the delay has changed (via `EngineEffectsDelay::setDelayFrames`), this variable is changed too and the value before the change is kept saved in the m_oldDelaySamples.\r\n\r\n  For the `EngineEffectsDelay` usage in the `EngineEffectChain` it makes sense to use the word ""new"" because before every `EngineEffectsDelay::process` call the delay value is set via `EngineEffectsDelay::setDelayFrames`.\r\n\r\n- _m_oldDelaySamples -> m_prevDelaySamples_\r\n\r\n  The purpose of the variable is to hold the number of delay samples before the last change (""previous delay value""). This value is kept saved for use in ramping when the delay has changed. If the delay hasn\'t changed between two `EngineEffectsDelay::process` calls, the `m_oldDelaySamples` and `m_delaySamples` hold the same value.\r\n\r\n- _m_delayPos -> m_delayBufferWritePos_\r\n\r\n  The purpose of the variable is to hold the position where should be new samples written into the delay buffer (like ""write pointer"" for a ring buffer).\r\n\r\n- _m_pDelayBuffer -> keep the same name_\r\n\r\nWe can discuss the clearness later while the new names will be used in the code, however, I would like to avoid multiple commits that rename variable names only.', 'comment_created': datetime.datetime(2022, 7, 1, 6, 36, 53, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 911680466, 'comment_body': 'Thank you for the tip. Sounds good.', 'comment_created': datetime.datetime(2022, 7, 1, 7, 14, 11, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 911685971, 'comment_body': 'If I am thinking about it again, the calculations will be the same, while the ramping will be changed for the whole buffer version (not only for the second half), which we agreed on before. The code will be much cleaner and we will avoid these statements duplication too.', 'comment_created': datetime.datetime(2022, 7, 1, 7, 22, 9, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 911760194, 'comment_body': '> We have also no definition for a i prefix. 0.508 is a magic number can we name it? What is the unit of kMaxDelay?\r\n\r\nI agree that is a magic number. The value was used from the [EngineDelay](https://github.com/mixxxdj/mixxx/blob/bf98de330910c38bd9b3cf51fb50dbe0188f4690/src/engine/enginedelay.cpp#L11) using maximum delay pot. The value can be changed.', 'comment_created': datetime.datetime(2022, 7, 1, 8, 52, 35, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 911761095, 'comment_body': ""> We should refine this anyways. Also rounding up to the next power of 2 helps the optimizer because the expensive modulo operation can be transformed into a binary AND.\r\n\r\nI agree. That's a good point, thank you."", 'comment_created': datetime.datetime(2022, 7, 1, 8, 53, 35, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 911768012, 'comment_body': ""I agree, it doesn't have to be double and float is a better option."", 'comment_created': datetime.datetime(2022, 7, 1, 9, 1, 30, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 911792910, 'comment_body': ""> The value can be changed.\r\n\r\nYes we should probably change it, which is why I didn't complain about it being a magic constant yet."", 'comment_created': datetime.datetime(2022, 7, 1, 9, 30, 19, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 911830850, 'comment_body': 'Yes, it works.', 'comment_created': datetime.datetime(2022, 7, 1, 10, 17, 58, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 911865870, 'comment_body': 'Oh, clear. Thank you very much for this perfect explanation. It makes much more sense to me now.', 'comment_created': datetime.datetime(2022, 7, 1, 11, 7, 27, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 913253412, 'comment_body': '> m_delaySamples -> m_newDelaySamples\r\n\r\nI would name that `m_currentDelaySamples`. I agree with the rest.', 'comment_created': datetime.datetime(2022, 7, 4, 20, 17, 17, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 913256453, 'comment_body': 'IMO ideal usecase for `std::span` here. \r\n```suggestion\r\n    void AssertIdenticalBufferEquals(const std::span<CSAMPLE> buffer, \r\n            const std::span<CSAMPLE> referenceBuffer) {\r\n```', 'comment_created': datetime.datetime(2022, 7, 4, 20, 28, 42, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 913258100, 'comment_body': 'I\'m not sure if its a good idea to test debug behavior like this. I agree that it makes sense to test whether a type correctly fails when its preconditions are violated, but I don\'t know if its a good idea to test this conditionally. Especially if the ""handling"" of violated pre-conditions is a controlled crash. What are your thoughts @daschuer?', 'comment_created': datetime.datetime(2022, 7, 4, 20, 34, 43, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 913830560, 'comment_body': 'Okay, thank you for this tip.', 'comment_created': datetime.datetime(2022, 7, 5, 13, 56, 56, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 913864188, 'comment_body': 'At least it would be a new pattern in out test code.\r\n\r\nI think it is a kind of paranoia to test test code, on the other hand it is a fixture that guarantees that a certain assertion is not removed and the code is already written. \r\nI have no strong opinion here. Maybe keep the code but not invest time to introduce similar test elsewhere. \r\n\r\n\r\n\r\n ', 'comment_created': datetime.datetime(2022, 7, 5, 14, 27, 15, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 913991841, 'comment_body': ""Well, if this was Rust code with explicit error types, or even C++ with proper exception use, I'd be in favor of testing failure modes. But in mixxx, our error handling is almost non-existent. We just have our `DEBUG_ASSERT`s so we're not flying completely blind in debug builds and in release builds we're just praying nothing will happen. I don't know if it makes sense to test `DEBUG_ASSERT`s which are already a hack in the first place.\r\n\r\nSince the code is already written, lets just keep it as long as the test don't turn out to be flaky. "", 'comment_created': datetime.datetime(2022, 7, 5, 16, 35, 28, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 914057660, 'comment_body': ""I would like to ask you whether you thought `gsl::span` instead of `std::span` from the standard library. I ask this question because Mixxx works with the C++17 standard, but if I'm right, the [span](https://en.cppreference.com/w/cpp/container/span) is in the standard library by C++20."", 'comment_created': datetime.datetime(2022, 7, 5, 18, 0, 57, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 914064758, 'comment_body': ""Okay, I understand your reason for the question if it is a good idea. So, as you wrote, for now, I will keep this code as-is. On the other hand, it isn't a problem to change it."", 'comment_created': datetime.datetime(2022, 7, 5, 18, 10, 6, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 914068776, 'comment_body': 'Well it depends. the main branch now does target C++20 (see #4803) (you might need to rebase on the newest commit). For performance-sensitive code, std::span is preferred because it does not do bounds-checking while the safety-focused gsl::span does. \r\nSee https://github.com/microsoft/GSL/wiki/gsl::span-and-std::span\r\n\r\nI think if you are still on ubuntu 20.04 you might be stuck with an old gcc version that still lacks adequate c++20 support. ', 'comment_created': datetime.datetime(2022, 7, 5, 18, 13, 57, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 914126320, 'comment_body': 'Oh, thank you for the explanation. I am using Ubuntu 22.04.', 'comment_created': datetime.datetime(2022, 7, 5, 19, 11, 10, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 915090833, 'comment_body': ""The code duplication is resolved. Just one thing to the `VERIFY_OR_DEBUG_ASSERT`. IMO after a code change from `unsigned int` to the new variable `kiMaxDelay`, which is a `const int` data type (`constexpr int` after fix), the `static_cast` is not necessary. Anyway, I'm not sure how the checks will react to it."", 'comment_created': datetime.datetime(2022, 7, 6, 17, 27, 7, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 915659655, 'comment_body': 'So, just for summarizing an easy calculation. Following the current calculation, with magic constant 0.508 from `enginedelay.cpp` and using `mixxx::audio::SampleRate::kValueMax`(which is 192 000) and `mixxx::kEngineChannelCount` (which is stereo), the following power of two is 2^18 (262 144) or next 2^19 (524 288). I am thinking about whether it makes sense to think about a greater buffer because the following power of two (2^20) is over 1 million.', 'comment_created': datetime.datetime(2022, 7, 7, 9, 24, 39, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 915925900, 'comment_body': 'Mhmmm. The fact that we need to account for the (unlikely) worstcase (192Khz samplingrate) makes this tradeoff somewhat difficult to evaluate. I wish we could allocate the buffer based on the actual buffer size currently being used instead of the worst case.\r\nWhat do we think is an acceptable maximum delay factor? 2x the current buffer size?', 'comment_created': datetime.datetime(2022, 7, 7, 14, 14, 11, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 915931186, 'comment_body': 'Just make it compile IMO. though try to avoid unnecessary casts.', 'comment_created': datetime.datetime(2022, 7, 7, 14, 18, 51, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 915933194, 'comment_body': ""I'm not sure how much vectorizing potential there actually is. I think the `n % kiMaxDelay` always breaks the autovectorizer because you can't use vectorizing instructions when `n` is at the wrap-around boundary."", 'comment_created': datetime.datetime(2022, 7, 7, 14, 20, 37, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 916177482, 'comment_body': ""Yeah, I agree that it is a little bit tricky, that so big buffer size is possible, but not so common. For the current pitch shift effect version, the delay is about 4 buffer sizes, or more, which is unacceptable. For now, I don't have a specific amount of maximum delay. I think, that about 2 buffer sizes are a good tradeoff. Anyway, I will test the different delay settings, what is maximum delay by ear and feeling (with only using dry signal and cross-fading). I will inform you about the results."", 'comment_created': datetime.datetime(2022, 7, 7, 18, 38, 23, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 916197633, 'comment_body': 'This loop does double the work compared to the non-crossfading benchmarks which I find confusing.', 'comment_created': datetime.datetime(2022, 7, 7, 19, 5, 4, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 916201130, 'comment_body': 'not needed anymore\r\n```suggestion\r\nvoid EngineEffectsDelay::process(CSAMPLE* pInOut,\r\n```', 'comment_created': datetime.datetime(2022, 7, 7, 19, 10, 8, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 916212572, 'comment_body': '```suggestion\r\n    const int delaySourcePos = (m_delayBufferWritePos - m_currentDelaySamples) % kiMaxDelay;\r\n```\r\n$$(b + c - d) \\bmod c \\iff \\\\  (b \\bmod c + c \\bmod c - d \\bmod c) \\bmod c \\iff  (b \\bmod c + 0 - d \\bmod c) \\bmod c \\iff (b - d) \\bmod c$$', 'comment_created': datetime.datetime(2022, 7, 7, 19, 26, 13, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 916221047, 'comment_body': ""> This requires that you chop the loop in chunks to get around the % kiMaxDelay on every sample.\r\n\r\nI missed that in my last note in this thread (which is why that note essentially repeated what you just said). The problem I see is that we simply can't do that. At least the current interface and implementation allows the delay to be any frame frame number. I don't think we can make the interface more granular so we'd have to find a workaround in the implementation."", 'comment_created': datetime.datetime(2022, 7, 7, 19, 38, 19, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 916603864, 'comment_body': 'I agree, that from a mathematical point of view you\'re right. Anyway, from the C++ point of view, the modulo operator for negative values (for example, x % y, where x is a negative value) produces negative values (but in math result value is positive). The addition of delay buffer size is used to ensure positive values, otherwise, the calculation fails on the `""delaySourcePos >= 0""` debug assert.', 'comment_created': datetime.datetime(2022, 7, 8, 8, 49, 11, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 916756331, 'comment_body': 'Do you plan to get rid of this % ? I would prefer a memcpy() based solution:\r\nhttps://github.com/mixxxdj/mixxx/blob/b58dd5bc990a1f6afe7a400e9b9451882c78112a/src/util/sample.h#L53\r\n', 'comment_created': datetime.datetime(2022, 7, 8, 12, 10, 59, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 916829855, 'comment_body': ""Right, good point. I really don't like that we make sure its not negative like this though. I'm sure in the future someone would come along and make the same buggy optimization as I just proposed. Can you at least document that the `+ kiMaxDelay` is necessary?"", 'comment_created': datetime.datetime(2022, 7, 8, 13, 42, 52, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 916835898, 'comment_body': 'use the RAII type `SampleBuffer` instead please. Manual (de-)allocation is error-prone.', 'comment_created': datetime.datetime(2022, 7, 8, 13, 49, 16, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 916837970, 'comment_body': 'IMO this requires some more complicated code to be safe, but it would be a worthwhile optimization too look into. ', 'comment_created': datetime.datetime(2022, 7, 8, 13, 51, 29, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 916871886, 'comment_body': ""Of course, I would like to avoid using these modulo operations. However, as the next step, I will implement the mentioned ring buffer, and then I can try to solve this optimization problem, so for now I still don't have a complete idea of the solution. Thank you for the tip with memcpy(). "", 'comment_created': datetime.datetime(2022, 7, 8, 14, 27, 2, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 916958547, 'comment_body': ""Yes, of course. I think I will create a new PR and document the same tricky part for `EngineDelay` and `EngineFilterDelay` because all these calculations are the same. As you wrote, it could be cool to solve this problem differently, but for now, I can't think of the more optimal solution."", 'comment_created': datetime.datetime(2022, 7, 8, 16, 8, 3, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 917012982, 'comment_body': 'This may serve as a model: \r\nhttps://github.com/mixxxdj/mixxx/blob/b58dd5bc990a1f6afe7a400e9b9451882c78112a/lib/portaudio/pa_ringbuffer.c#L198\r\ncopy in two steps form the current position to the ring wrap around and then the remaining samples.  ', 'comment_created': datetime.datetime(2022, 7, 8, 17, 27, 18, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 917069437, 'comment_body': 'Thank you very much for this tip. It seems like it could be really helpful.', 'comment_created': datetime.datetime(2022, 7, 8, 18, 57, 20, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 917966515, 'comment_body': ""I'm not familiar enough with virtual inheritance but this seems unnecessary to me.\r\n```suggestion\r\n```"", 'comment_created': datetime.datetime(2022, 7, 11, 13, 58, 35, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 917968145, 'comment_body': ""most methods on this class could be const but aren't right now. \r\n```suggestion\r\n    bool isFull() const {\r\n        return getWriteAvailable() == 0;\r\n    }\r\n```\r\n"", 'comment_created': datetime.datetime(2022, 7, 11, 14, 0, 5, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 917972903, 'comment_body': 'Ideally this would be generic, but that would essentially make this about as complex as `std::vector` with all the required SFINAE (or C++20 concepts work)...', 'comment_created': datetime.datetime(2022, 7, 11, 14, 4, 17, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 917974866, 'comment_body': ""You don't need to store that IMO. its already part of the `SampleBuffer` object."", 'comment_created': datetime.datetime(2022, 7, 11, 14, 6, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 917988404, 'comment_body': ""I'm not sure this is correct. I think `sizeof(m_buffer)` only yields the size of the control block (so 16 bytes on x64 because the control block is just a pointer and size)."", 'comment_created': datetime.datetime(2022, 7, 11, 14, 14, 57, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 917995240, 'comment_body': 'Please avoid invasive manipulation like this. Manual handling of sizes and memsetting is prone to cause buffer overflow problems. \r\n```suggestion\r\n    m_buffer.fill(0);\r\n```', 'comment_created': datetime.datetime(2022, 7, 11, 14, 21, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 920172776, 'comment_body': 'please separate this into its own `src/util/span.h` header', 'comment_created': datetime.datetime(2022, 7, 13, 14, 47, 50, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 921023143, 'comment_body': '```suggestion\r\n        return mixxx::span<CSAMPLE>{m_data, static_cast<mixxx::span<CSAMPLE>::index_type>>(m_size)};\r\n```', 'comment_created': datetime.datetime(2022, 7, 14, 10, 52, 52, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 921023354, 'comment_body': '```suggestion\r\n        return mixxx::span<CSAMPLE>{m_data, static_cast<mixxx::span<CSAMPLE>::index_type>>(m_size)};\r\n```', 'comment_created': datetime.datetime(2022, 7, 14, 10, 53, 11, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 922081396, 'comment_body': 'Thank you. Anyway, I think it depends on the version of the system too. On GitHub CI the `index_type` is required, anyway, for example, on my system the `std::size_t` is required. IMO it may depend on the [GSL issue](https://github.com/microsoft/GSL/issues/782).', 'comment_created': datetime.datetime(2022, 7, 15, 11, 32, 33, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 922109704, 'comment_body': 'Yeah... the resulting code is quite verbose but what daniel proposed should work in all cases, we just need to hide that complexity with a couple helper methods.', 'comment_created': datetime.datetime(2022, 7, 15, 12, 16, 8, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 922220871, 'comment_body': 'Oh, okay. Thank you.', 'comment_created': datetime.datetime(2022, 7, 15, 14, 27, 8, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 923543868, 'comment_body': ""since std::transform always does a map. I don't think this is appropriate here... I think you'll just have to iterate over the two spans manually."", 'comment_created': datetime.datetime(2022, 7, 18, 15, 59, 58, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 923652712, 'comment_body': 'more concise IMO\r\n```suggestion\r\n      auto pBufferIterator = std::cbegin(buffer);\r\n      auto pReferenceBufferIterator = std::cbegin(referenceBuffer);\r\n```', 'comment_created': datetime.datetime(2022, 7, 18, 17, 45, 23, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 923653952, 'comment_body': ""Simple by-index for loop would've been okay too."", 'comment_created': datetime.datetime(2022, 7, 18, 17, 46, 4, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 923676951, 'comment_body': 'Okay, so can I use it instead and avoid using iterators in this special case? IMO more readable solution.', 'comment_created': datetime.datetime(2022, 7, 18, 18, 8, 5, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 923682250, 'comment_body': 'Yes, but only because we asserted that the sizes were the same. Alternatively you can use the bounds-checked accessor `span.at(i)` in the loop.', 'comment_created': datetime.datetime(2022, 7, 18, 18, 14, 58, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 923684289, 'comment_body': ""Maybe not so clear, as I expected. The data type has to be explicitly written (can't use auto), to avoid casting, so the solution looks like this:\r\n\r\n```\r\nfor (std::span<CSAMPLE>::size_type i = 0; i < buffer.size(); i++) {\r\n    EXPECT_FLOAT_EQ(buffer[i], referenceBuffer[i]);\r\n}\r\n```\r\n\r\nWhat would you prefer?"", 'comment_created': datetime.datetime(2022, 7, 18, 18, 17, 31, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 923700795, 'comment_body': 'Are you sure, it works for me...\r\nhttps://compiler-explorer.com/z/q77Eaa8jq', 'comment_created': datetime.datetime(2022, 7, 18, 18, 38, 31, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 923701674, 'comment_body': 'Even works on gcc 10', 'comment_created': datetime.datetime(2022, 7, 18, 18, 39, 41, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 923781718, 'comment_body': ""Yeah, it works, that's right. The compiler shows this warning only:\r\n```\r\n/home/david/Documents/CodingFiles/GitWorkspace/Mixxx/mixxx/src/test/engineeffectsdelay_test.cpp: In member function ‘void {anonymous}::EngineEffectsDelayTest::AssertIdenticalBufferEquals(std::span<float>, std::span<const float>)’:\r\n/home/david/Documents/CodingFiles/GitWorkspace/Mixxx/mixxx/src/test/engineeffectsdelay_test.cpp:33:28: warning: comparison of integer expressions of different signedness: ‘int’ and ‘std::span<float>::size_type’ {aka ‘long unsigned int’} [-Wsign-compare]\r\n   33 |         for (auto i = 0; i < buffer.size(); i++) {\r\n      |                          ~~^~~~~~~~~~~~~~~\r\n```\r\n\r\nbut I suppose that the clazy test on CI will fail after updating on Ubuntu 22 still."", 'comment_created': datetime.datetime(2022, 7, 18, 19, 31, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 925605285, 'comment_body': 'Mhmm, its odd that auto defaults to `int` instead of `unsigned int`. Then use the `std::span<CSAMPLE>::size_type` I guess. If you need it more than once, you can hide it behind a `using` alias.', 'comment_created': datetime.datetime(2022, 7, 20, 13, 26, 12, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 925651912, 'comment_body': 'easy optimization / warning workaround (cuz the compiler will warn if you check `size >= 0` on an unsigned type). \r\n`#include <type_traits>`\r\n```suggestion\r\n        if constexpr (std::is_signed_v<S>) {\r\n          VERIFY_OR_DEBUG_ASSERT(size >= 0) {\r\n              size = 0;\r\n          }\r\n        }\r\n```', 'comment_created': datetime.datetime(2022, 7, 20, 14, 6, 10, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 925652994, 'comment_body': 'IMO prefer a namespace over a class with static member functions. ', 'comment_created': datetime.datetime(2022, 7, 20, 14, 7, 5, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 926025327, 'comment_body': 'Oh, thank you. Looks good.', 'comment_created': datetime.datetime(2022, 7, 20, 20, 25, 57, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 926759490, 'comment_body': '```suggestion\r\n```', 'comment_created': datetime.datetime(2022, 7, 21, 14, 38, 19, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 926763112, 'comment_body': '```suggestion\r\n        ASSERT_EQ(buffer.size(), referenceBuffer.size());\r\n```\r\nOtherwise the loop below would overrun. ', 'comment_created': datetime.datetime(2022, 7, 21, 14, 40, 52, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 926965624, 'comment_body': 'Lets just remove this constant for now.\r\n```suggestion\r\nconstexpr int kMaxDelay = mixxx::audio::SampleRate::kValueMax * mixxx::kEngineChannelCount;\r\n```', 'comment_created': datetime.datetime(2022, 7, 21, 18, 1, 15, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 927080542, 'comment_body': ""Oh, thank you. I'm sorry, I overlooked it."", 'comment_created': datetime.datetime(2022, 7, 21, 20, 35, 3, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 927098841, 'comment_body': 'No problem. Thats what code review is for.', 'comment_created': datetime.datetime(2022, 7, 21, 20, 59, 50, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 928140206, 'comment_body': 'great that you were able to figure out the reason the tests failed. I think if you fix this test, we can merge (theoretically, we still need to wait for 22.04).', 'comment_created': datetime.datetime(2022, 7, 23, 16, 19, 44, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 928142827, 'comment_body': 'Okay, I just would like to fix the mentioned delay value issue in this PR too (clamping the delay to [0;kMaxDelay]).', 'comment_created': datetime.datetime(2022, 7, 23, 16, 48, 55, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 928296964, 'comment_body': ""You're subtracting here, isn't that a bug? Also I'd just add another constexpr variable `kMaxDelayFrames` instead. "", 'comment_created': datetime.datetime(2022, 7, 24, 18, 36, 48, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 928297052, 'comment_body': 'please add a comment that this actually tests the clamping of the delay value. ', 'comment_created': datetime.datetime(2022, 7, 24, 18, 37, 45, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 928307394, 'comment_body': ""****\r\n\r\n> You're subtracting here, isn't that a bug? Also I'd just add another constexpr variable kMaxDelayFrames instead.\r\n\r\nThe inspiration was by [EngineDelay](https://github.com/mixxxdj/mixxx/blob/0d1dc9fa448181db8714425b424a754227bc0e1b/src/engine/enginedelay.cpp#L41). The reason of subtraction is, that last valid delay value is `kMaxDelay - 1`. However, clamping delay to this value will cause a switch between channels (for example stereo channels will be swapped). However, with your proposal of `kMaxDelayFrames`, the subtraction wouldn't be needed and only frames value will be compared."", 'comment_created': datetime.datetime(2022, 7, 24, 20, 17, 12, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 939638952, 'comment_body': 'I am unsure about this. Why does this work? I assume it also did not work above with data().\r\nFor my view ""const std::span<CSAMPLE>"" is a ""smart pointer to the non-const CAMPLE.  \r\nIsn\'t a Span() allways const. I think all sub-span functions are const anyway. \r\nIn C++ returning an value type as const does not really make sense. \r\n\r\nConclusion:  I think we can delete replace both functions and replace it with:\r\n `std::span<CSAMPLE> span() const {`\r\n', 'comment_created': datetime.datetime(2022, 8, 7, 9, 45, 49, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 939639254, 'comment_body': 'Can this whole one become a constexpr', 'comment_created': datetime.datetime(2022, 8, 7, 9, 47, 49, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 939639309, 'comment_body': 'and this also constexpr?', 'comment_created': datetime.datetime(2022, 8, 7, 9, 48, 27, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 939639501, 'comment_body': 'By the way, this function is unused. ', 'comment_created': datetime.datetime(2022, 8, 7, 9, 49, 55, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 939670021, 'comment_body': ""> Isn't a Span() allways const.\r\n\r\nNo its not. its a view into contiguous chunk of memory. Whether the memory should be seen as const or non const is defined by the template parameter. \r\n\r\n>  In C++ returning an value type as const does not really make sense.\r\n\r\nYes, sorry that slipped through it should be this instead:\r\n\r\n```suggestion\r\n    std::span<const CSAMPLE> span() const {\r\n```\r\n\r\n> Conclusion: I think we can delete replace both functions and replace it with:\r\n`std::span<CSAMPLE> span() const {`\r\n\r\nNo, that won't work. `std::span<T>` and `std::span<const T>` are different types. In the const member function, all class members are const, so you'd essentially try to construct mutable span into a type that is `const`. Here's a godbolt to demonstrate it: https://compiler-explorer.com/z/KaEcWxGYh\r\n\r\nIts unfortunately a flaw of the language that you can't be generic over the constness. So we have to duplicate the function here with two different signatures in regards to constness. (Rust has the same problem [but is trying to fix that](https://blog.rust-lang.org/inside-rust/2022/07/27/keyword-generics.html))\r\n\r\n> By the way, this function is unused.\r\n\r\nYes, but that doesn't matter because its intended as a library function to be used in the future. Its essentially supposed to replace `Samplebuffer::ReadableSlice`\r\n"", 'comment_created': datetime.datetime(2022, 8, 7, 13, 40, 50, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 939674111, 'comment_body': ""You demonstration is not valid for our case, because the T[100] in your test is also const, because it is part of the constant object memory. In the case of SampleBuffer only the pointer is part of the (const) object. See: \r\nhttps://compiler-explorer.com/z/9To5fvK7P  \r\n\r\nThis means 'std::span<CSAMPLE> span() const {' is valid in the same way like subspan returns a non const template type with a const function: https://en.cppreference.com/w/cpp/container/span/subspan "", 'comment_created': datetime.datetime(2022, 8, 7, 14, 9, 18, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 939675048, 'comment_body': 'I do not relay see the use case for `std::span<const CSAMPLE> span() const {` because SampleBuffer is more used as a factory. \r\nI think we will convert `std::span<CSAMPLE>` to `std::span<const CSAMPLE>` implicit on the fly via function parameters. \r\n', 'comment_created': datetime.datetime(2022, 8, 7, 14, 15, 43, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 939676146, 'comment_body': ""Can you show me the code that achieves that? If we have a const samplebuffer, and we want a view into it. We need an implementation of `std::span<const CSAMPLE> span() const`. If you want example where we'd use that in the mixxx codebase, grep for `SampleBuffer::ReadableSlice`. "", 'comment_created': datetime.datetime(2022, 8, 7, 14, 23, 35, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 939677181, 'comment_body': ""> You demonstration is not valid for our case, because the T[100] in your test is also const, because it is part of the constant object memory. In the case of SampleBuffer only the pointer is part of the (const) object. See:\r\n\r\nOh wow, thats even worse then IMO. that means we have a const object that allows mutable access to the resource it manages. In Rust that's called the interior mutability pattern and its used to provide safe mutable access when otherwise prohibited. In C++ we can not enforce the safety guarantees. SampleBuffer seems to be intentionally written with the RAII guideline in mind that if you have a const Samplebuffer, you can not alter the contents of the buffer within. Your proposal explicitly breaks that if I understand correctly."", 'comment_created': datetime.datetime(2022, 8, 7, 14, 31, 6, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 939677811, 'comment_body': ""> This means 'std::span span() const {' is valid in the same way like subspan returns a non const template type with a const function: https://en.cppreference.com/w/cpp/container/span/subspan\r\n\r\nThats not entirely true. while `std::span::subspan` is a const member func (which makes sense), the span it returns is templated on the `element_type`. So the `decltype(std::span<const T>:subspan())` is still `const T`. With samplebuffer its not the case, we have no way to specify that the underlying buffer is const, so we can only specify it for the SampleBuffer itself. Again, most of the samplebuffer code already explicitly makes that assumption, if the SampleBuffer is const, then the access to the underyling buffer is only const as well. So to follow that convention, we need to provide a `std::span<const CSAMPLE> span() const`. "", 'comment_created': datetime.datetime(2022, 8, 7, 14, 35, 44, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 939678495, 'comment_body': '> SampleBuffer is more used as a factory.\r\n\r\nCan you elaborate? IMO `SampleBuffer` is explicitly not intended as a glorified alligned_malloc. Its supposed to allocate once and then own its content. All access should either be directly through `operator[]` or the Readable-/WriteableSlice classes. `SampleBuffer::data` is an escape hatch and thus should be avoided unless absolutely necessary. ', 'comment_created': datetime.datetime(2022, 8, 7, 14, 40, 41, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 939679086, 'comment_body': '> If we have a const samplebuffer\r\n\r\nWe never have a const samplebuffer, because it always points to non-const samples.   \r\nhttps://github.com/mixxxdj/mixxx/blob/828a189b045050ca6ad5aa053e528e92ce0b8653/src/util/samplebuffer.h#L179\r\n\r\nI have found this: \r\nhttps://github.com/mixxxdj/mixxx/blob/b0a7c9e3ce9996e87146c27ca0c766c8622134a0/src/sources/soundsourcem4a.cpp#L602\r\n\r\nBut this is another class. \r\n\r\nBut anyway, I am in general in favor to only add functions that are used. If you are really sure we need it, we need to rename it because otherwise it makes zero difference due to the implicit conversion between `std::span<CSAMPLE>` to `std::span<const CSAMPLE>` \r\n\r\n\r\n\r\n', 'comment_created': datetime.datetime(2022, 8, 7, 14, 45, 12, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 939680377, 'comment_body': '> Your proposal explicitly breaks that if I understand correctly.\r\n\r\nI think you have mixed up some things. std::span not a container it is ""just"" a pointer which does not own the memory it is pointed to. \r\nWe have: \r\n```\r\nconst std::span<const CSAMPLE> constPointerToConstSampe; // it always points to the same buffer and can\'t change it \r\nstd::span<const CSAMPLE> mutablePointerToConstSampe;  // this allows to let it point to different memory but cant change it  \r\nconst std::span<CSAMPLE> mutablePointerToConstSampe;  // it alwasy points to the same memory, which can be changed.   \r\nstd::span<CSAMPLE> mutablePointerToConstSampe;  // this allows to let it point to different memory, which can be changed\r\n```\r\nIndependent of this most memory functions are also const, that prevents to alter the control structure of std::span.\r\n  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', 'comment_created': datetime.datetime(2022, 8, 7, 14, 54, 34, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 939681653, 'comment_body': ""\r\n> We never have a const samplebuffer, because it always points to non-const samples.\r\n\r\n\r\nYES. But SampleBuffer is supposed to hide that! Thats the entire point of the class! And we do have loads of SampleBuffer::ReadableSlices in our codebase. And we should have more in the future. Its intended as the de-facto way of passing immutable audio buffers. \r\n\r\n> \r\n> I have found this:\r\n> \r\n> https://github.com/mixxxdj/mixxx/blob/b0a7c9e3ce9996e87146c27ca0c766c8622134a0/src/sources/soundsourcem4a.cpp#L602\r\n> \r\n> But this is another class.\r\n> \r\n\r\n`SampleBuffer::ReadableSlice` is just a more boilerplate version of `std::span<const CSAMPLE>`. So we need a way of getting a std::span<const CSAMPLE> in our codebase. If you look at the constructor of `SampleBuffer::ReadableSlice`, it takes a `const SampleBuffer&` so its supposed to be compatible to be used with `const SampleBuffer`s. \r\n\r\n> But anyway, I am in general in favor to only add functions that are used. If you are really sure we need it, we need to rename it because otherwise it makes zero difference due to the implicit conversion between std::span<CSAMPLE> to std::span<const CSAMPLE>\r\n\r\nThis is not a matter of which functions are used and which aren't. Its a question of API and class design and if we don't provide these functions the API is incomplete and its usage will be clunky."", 'comment_created': datetime.datetime(2022, 8, 7, 15, 3, 42, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 939681856, 'comment_body': '> > Your proposal explicitly breaks that if I understand correctly.\r\n> \r\n> I think you have mixed up some things. std::span not a container it is ""just"" a pointer which does not own the memory it is pointed to. We have:\r\n> \r\n> ```\r\n> const std::span<const CSAMPLE> constPointerToConstSampe; // it always points to the same buffer and can\'t change it \r\n> std::span<const CSAMPLE> mutablePointerToConstSampe;  // this allows to let it point to different memory but cant change it  \r\n> const std::span<CSAMPLE> mutablePointerToConstSampe;  // it alwasy points to the same memory, which can be changed.   \r\n> std::span<CSAMPLE> mutablePointerToConstSampe;  // this allows to let it point to different memory, which can be changed\r\n> ```\r\n> \r\n> Independent of this most memory functions are also const, that prevents to alter the control structure of std::span.\r\n\r\nI simply don\'t understand what you are trying to say here. \r\n\r\nI understand what you are saying from a technical perspective, but I don\'t know how that relates to the discussion of providing a `std::span<const CSAMPLE> span() const` overload. ', 'comment_created': datetime.datetime(2022, 8, 7, 15, 5, 15, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 939683708, 'comment_body': 'Ok I think I kinda wrapped my head around this. But I that still leaves major issues:\r\n1. if we implement a `std:span<CSAMPLE> span() const` we allow mutable access to an object which has been crated by const object. While not leading to correctness issues, it goes explicitly against the entire rest of the SampleBuffer API. It breaks consistency severely. \r\n2. The proposed api correctness relies on the coercion with explicit type annotations. Take this code:\r\n```cpp\r\nconst SampleBuffer a{};\r\nconst auto b = a.span();\r\n// const everywhere, still we get mutable access just\r\n// because of the `auto` above. Combine that with\r\n// the former point and we have a severly confusing API\r\nb[0] = 1;\r\n```', 'comment_created': datetime.datetime(2022, 8, 7, 15, 19, 17, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 939692096, 'comment_body': ""Here's another example on how the API would get confusing with your proposal: \r\n\r\n```cpp\r\nconst SampleBuffer a{};\r\n// a[0] = 1; // compile error\r\na.span()[0] = 1; // legal\r\n```"", 'comment_created': datetime.datetime(2022, 8, 7, 16, 26, 48, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 939902113, 'comment_body': '> if we implement a std:span<CSAMPLE> span() const we allow mutable access to an object which has been crated by const object. \r\n\r\nAh OK, that is your point. I was not aware that you are planning to use a ""const SampleBuffer"". For my understanding the std::span should be used to pass the samples around and the SampleBuffer serves only the purpose as a Factory and owner of the memory. So in that case I agree that the pair: \r\n```\r\nstd::span<CSAMPLE> span() {...}\r\nstd::span<const CSAMPLE> span() const {...}\r\n```\r\nIs sensible ', 'comment_created': datetime.datetime(2022, 8, 8, 7, 22, 9, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 940157675, 'comment_body': ""Well, I know that we currently don't really pass `const SampleBuffer`s around, but SampleBuffer is still a container and its written as if it were. So for simplicity's sake I'd follow that API. I agree that views into SampleBuffers should be passed around as `std::span<CSAMPLE>`, I overall still think that the two method API results in a simpler and more predictable API (which we should value IMO). "", 'comment_created': datetime.datetime(2022, 8, 8, 12, 1, 47, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 940159096, 'comment_body': ""Seems like we've found consensus. Thank you very much. "", 'comment_created': datetime.datetime(2022, 8, 8, 12, 3, 29, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 944603237, 'comment_body': 'small oversight from my side\r\n```suggestion\r\n    if constexpr (std::is_signed_v<S> && std::is_unsigned_v<T2>) {\r\n        VERIFY_OR_DEBUG_ASSERT(size >= 0) {\r\n            size = 0;\r\n        }\r\n```', 'comment_created': datetime.datetime(2022, 8, 12, 15, 55, 46, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}]","[{'commit_sha': '461f6f78f181ac82532ba9c57b34f4683ba25ce0', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ad76619f3c5708aa9aa44a467c6ef650b9a1b41b', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'f40e7967a7f4b4988342e0930bbd2c8959db07e2', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '93d2d1923a0f56216dd058a336d60b577f2b88b9', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '97fdb392c1d303a160a6f5daaae94bed167156da', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'a1456a62a196f0004452bf6d8de20630affc4926', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'cc5abdd308af916c0cb77c8e47c092b4d0c91465', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'e958a081d15d784e6a8c2a671f16c345cdd8811b', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '5d2d560a3c98f07fccd4a96d237ea4c37120c5a4', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '4f7515ba26fd352e0bebcee8dd62b2e7c58eab15', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '755c714eb6327783319c91d138290f46f558e35e', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '164e2005dfcca2c0ac25fa73d784057ad0827c57', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'bc7834487758a1b3c4c04aa81566db0b3d98e7e8', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '5f1ea3676f9d815f33ea5a657e07a6521269c63c', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '1b88485b04c6a2d6a725904a9702ce238c0f5e89', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'af331857351c4fe6fa944973ba13fae691223ffb', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '5892a7e9f55038589546a311bc6455cd84e04437', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ea7d77c3ba327c59723758f45c07b676ff054ec3', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '047c3e2cb91f41f7be86554308099a37c62383f5', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '1db08fd1acf465bed95e7c9efb5624d96fb4092f', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'e84b0967cfa795fe6f243ee15d829d73b38d7c90', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '3da53da0d0c96127044385ab1f7bf5cd1848fc55', 'committer_username': 'Swiftb0y', 'committer_name': None, 'committer_email': None, 'commit_date': datetime.datetime(2015, 5, 10, 11, 0, 12, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'b0ed62c573787794aea782b1387db43162f5e785', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ff2fefe09ab3525fd5a68ff9d17bba67c3b60496', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '7107c873fc2f348a6a0e4ec34e290a799561b81f', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ef31bfb06de75e7e349997934fa63bbb3b634712', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '11a83a81215066d80d8e4025b5426214fa9a53fd', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'f40707c89960f7b4d9c4cc5788b57d8d2c0b0936', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '42487b27f4599b9bd13a7c6311f93941001e7ca1', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '79e6681bcc098269f0494a90b2f0d091319daa00', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '1e2d0f2ced42f9b66c143cb5c575bb85c77dbb7c', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '8e193131066bfaa27b15fb058aa17e1e586a69c9', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'f7a38c933a4b669018f2fbb62a4f51e097752e1d', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ad6569110f938699edb9472a95b4846380f9f34a', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '2e14db163e781fcfda687fd46f852a1cf0f85fc4', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '7f00a1aa7e92dfa0a7eb63690a2f8828a2b7ec28', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '8945f3df9e5ec484a8be4f25dba340024c31408e', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '9ffdb1122a242c2300c94015603cb54f2a9f72ea', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '80b92095da3b0c2d9919ddcdba2e4b22e4521412', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '5342307e2d64ffdd7a95e061e2dbb033485eabe2', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}]",David Chocholatý,84876095,,User,,44,,15,14
994329335,RingDelayBuffer: ring buffer for delay handling,"The new ring buffer is introduced. The use case for the ring buffer is
for delay handling, but it also could be used as a classic ring buffer
with a jumping option with the reading position. It is based
on the classic known ring buffer. The extensions are,
that the ring delay buffer allows moving with the reading position
subject to certain rules. Another difference between the classic
ring buffer is, that the ring delay buffer offers to read zero values,
which were not written by using the write method and write position.
Both of these two specific properties are based on the cross-fading
between changes of two delays.",True,4852,https://api.github.com/repos/mixxxdj/mixxx/pulls/4852,https://github.com/mixxxdj/mixxx/pull/4852,closed,408,0,4,43,16,78,2,0,"[{'name': 'build'}, {'name': 'code quality'}]",2022-07-12 13:57:57+00:00,2022-08-29 19:53:10+00:00,4168513.0,"48 days, 5:55:13","[{'comment_id': 919560729, 'comment_body': ""I'm severely struggling to understand this. \r\nWhy can't we just do `m_readPos = (position + itemsToRead) % m_bufferSize`?\r\nThat removes the power-of-two size limitation, make the bit-twiddling stuff unnecessary, etc.\r\nWe're not calculating the integer mod for each sample, but only once per write call, we can afford that."", 'comment_created': datetime.datetime(2022, 7, 13, 1, 23, 30, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 919562625, 'comment_body': '```suggestion\r\n```\r\ninstead add explanation down below that this is actually only intended to be single-threaded.', 'comment_created': datetime.datetime(2022, 7, 13, 1, 28, 23, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 919563202, 'comment_body': ""The complexity introduced by the current scheme makes it very, very hard for me to review the rest of the code, so I'll refrain from that until we can clear this up."", 'comment_created': datetime.datetime(2022, 7, 13, 1, 30, 5, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 920776566, 'comment_body': 'this can become an unique_ptr', 'comment_created': datetime.datetime(2022, 7, 14, 5, 54, 49, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 920778635, 'comment_body': 'You probably already now this function:\r\nhttps://github.com/mixxxdj/mixxx/blob/9b9fbaafc404f8cfc822f64d356ed3c37e8778c1/src/util/math.h#L41', 'comment_created': datetime.datetime(2022, 7, 14, 5, 58, 32, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 920779550, 'comment_body': 'This should be not necessary. The buffer should never return uninitialized zeros. In out of memory situation the usage code needs to fade to zero to avoid clicks. ', 'comment_created': datetime.datetime(2022, 7, 14, 6, 0, 25, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 920786046, 'comment_body': 'I am not sure if the concept of a member variable m_readPos is still suitable. \r\n\r\nFor my understanding we have the current sample at m_writePos - 1 and the delayed samples before that so the actual read position is m_writePos - ""current delay"" - itemsToRead  \r\n\r\nWe need to make sure this does not hit the end of the buffer. \r\n\r\nIdea: Pass the delay along to the read function?', 'comment_created': datetime.datetime(2022, 7, 14, 6, 12, 37, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 921587514, 'comment_body': ""IMO not needed, also there is `std::bit_ceil` in C++20's `<bit>` header. It's constexpr and also likely faster."", 'comment_created': datetime.datetime(2022, 7, 14, 21, 31, 3, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 921708884, 'comment_body': ""Benchmark supports that its at least equal, though I guess the performance of `bit_ceil` depends very much on whats available on the target architecture (which you can't specify on Quickbench). https://quick-bench.com/q/3FOpFZ_ZaAfJOtWWl1Xx7MFC7JQ"", 'comment_created': datetime.datetime(2022, 7, 15, 0, 20, 50, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 921915348, 'comment_body': ""Initializing values on zero was created, due to it is possible to move with `m_readPos` to left over the left delay buffer bound. For the current code version, it is allowed in the beginning too. Depending on that, the read position can read values, which weren't written by `m_writePos`. If I'm thinking about it, not a good practice. It is possible to allow skipping to the left only if the items were written by `m_writePos` with `VERIFY_OR_DEBUG_ASSERT`."", 'comment_created': datetime.datetime(2022, 7, 15, 7, 59, 57, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 922120709, 'comment_body': 'I think this post is a little bit of coherence with the [post ](https://github.com/mixxxdj/mixxx/pull/4852#discussion_r920779550)by @daschuer. Both of them work with the beginning situation, that the delay is set (the previous delay is zero). New data are written classically from the start of the (ring) buffer. Anyway, for the delay value, it may happen, that the reader will read uninitialized (zero values), probably from the end of (ring buffer), because the read pointer circle to the end through the left buffer border. This situation was allowed because it was possible in the previous delay handling version and in [EngineFilterDelay](https://github.com/mixxxdj/mixxx/blob/main/src/engine/filters/enginefilterdelay.h) too.', 'comment_created': datetime.datetime(2022, 7, 15, 12, 31, 59, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 922122150, 'comment_body': 'To your advice that the modulo operation can be used instead of the bitwise operation. If we do not allow the reading of uninitialized values, it may be used.', 'comment_created': datetime.datetime(2022, 7, 15, 12, 33, 55, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 922243479, 'comment_body': ""Thank you so much for this idea. Sounds cool and I think it cleans up the code a lot. I have just one thing on my mind for two cases. Based on the proposed new version, the ring delay buffer will behave a little bit differently.\r\n\r\n1. If, for example, 8 samples will be written into the ring delay buffer, and then the different amount of samples will be read with zero delays, just propose 4 samples, so, for the previous version, the ring buffer will read the first half of the written samples by index 0, however, the new version will read the second half of the written samples (8 - 0 - 4).\r\n\r\n2. If the write method will be called two times in a row without calling the read method, the situation will be quite similar to the first one.\r\n\r\nFor our future use case for `EngineEffectsDelay`, this cannot happen. Anyway, if I will think only about `RingDelayBuffer`, it may be possible. What do you think about that? I don't want to throw down somehow this idea, I really like it and I would like to use it. I'm only thinking about possible cases, which can happen."", 'comment_created': datetime.datetime(2022, 7, 15, 14, 51, 41, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 933589780, 'comment_body': 'Thank you both for your recommendations. Anyway, after code refactorization which removes the binary operations, the ""power of two"" condition is no longer required.', 'comment_created': datetime.datetime(2022, 7, 29, 20, 17, 26, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 939568546, 'comment_body': 'I would like to re-open a discussion about this idea. I would like to discuss just one thing which I noticed. If the new version will be used, then a lot of checks of delay value have to be run for every `read()` call, probably all code in `moveReadPositionBy()`. Can I ask what is your view on this situation?', 'comment_created': datetime.datetime(2022, 8, 6, 19, 40, 36, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 940230191, 'comment_body': ""It doesn't really make sense to pass value types like SINT as const, especially if you need to copy again afterwards. \r\n```suggestion\r\nSINT RingDelayBuffer::read(CSAMPLE* pBuffer, SINT itemsToRead) {\r\n    const SINT available = getReadAvailable();\r\n```"", 'comment_created': datetime.datetime(2022, 8, 8, 13, 20, 34, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 940236530, 'comment_body': '```suggestion\r\n// The RingDelayBuffer is designed to be single-threaded\r\n// and based on that IS NOT THREAD-SAFE.\r\n```', 'comment_created': datetime.datetime(2022, 8, 8, 13, 26, 33, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 944168198, 'comment_body': 'I do not understand the comment. ', 'comment_created': datetime.datetime(2022, 8, 12, 6, 58, 40, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 944179656, 'comment_body': 'This function is hard to use, because the using code need to keep track of the old and the new delay. \r\nDid you consider to wrap it into a \r\n`SINT read(CSAMPLE* pBuffer, const SINT numItems, const SINT delayItems)` \r\nor such?', 'comment_created': datetime.datetime(2022, 8, 12, 7, 17, 20, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 944205910, 'comment_body': 'I am in doubt that this is correct. m_fullFlag is only relevant when m_readPos = m_writePos;\r\nThe same below. \r\n', 'comment_created': datetime.datetime(2022, 8, 12, 7, 54, 14, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 944210834, 'comment_body': 'The buffer is full if itemsToWrite >= available, not due to crossing the boundaries. ', 'comment_created': datetime.datetime(2022, 8, 12, 8, 0, 39, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 944226807, 'comment_body': 'I think you should zero out the remaining buffer. It does not really make sense to put that work to the using code. \r\nWe may also consider to just return without touching the buffer, or zero out the whole buffer. ', 'comment_created': datetime.datetime(2022, 8, 12, 8, 20, 51, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 945330093, 'comment_body': 'I disagree with this proposal. I see where you are coming from, but IMO designing the read position in a way that you need the delay value to use it is exactly what this ring buffer abstraction is supposed to avoid. ', 'comment_created': datetime.datetime(2022, 8, 14, 19, 1, 15, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 945330643, 'comment_body': 'I think the non-contiguous read and write deserve to be deduplicated by using a helper function.', 'comment_created': datetime.datetime(2022, 8, 14, 19, 6, 30, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 945330918, 'comment_body': 'IMO both read and write methods could be simplified if we used `moveReadPositionBy` internally as well. ', 'comment_created': datetime.datetime(2022, 8, 14, 19, 9, 31, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 945337332, 'comment_body': ""I don't understand the arithmetic here. \r\nlogically it seems to me `readAvailableLeft = getWriteAvailable` would hold."", 'comment_created': datetime.datetime(2022, 8, 14, 20, 14, 47, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 945343008, 'comment_body': 'I came up with this optimization to minimize branch misspredictions. Idk if it actually improves things. I guess just try locally and test if you see a difference in the benchmarks.\r\n```suggestion\r\n    SINT getReadAvailable() const {\r\n        const SINT delta = m_writePos - m_readPos;\r\n        if (delta == 0) [[unlikely]] {\r\n          return m_fullFlag ? m_buffer.size() : 0;\r\n        }\r\n        const SINT range = std::abs(delta);\r\n        return range == delta ? range : m_buffer.size() - range;\r\n    }\r\n```', 'comment_created': datetime.datetime(2022, 8, 14, 21, 11, 11, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 945343156, 'comment_body': '```suggestion\r\n        m_fullFlag = m_readPos==m_writePos;\r\n```', 'comment_created': datetime.datetime(2022, 8, 14, 21, 13, 23, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 945347707, 'comment_body': ""I don't understand why we should require the user code to do book keeping about the read position. The read position is IMHO an implementation detail that should be hidden. The user code has the desired delay already. \r\n "", 'comment_created': datetime.datetime(2022, 8, 14, 22, 1, 38, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 945350579, 'comment_body': 'I think I see what you are saying. In the specific context, this does make sense, but we have an important tradeoff to make here then. If we shift the delay book-keeping into the ringbuffer, the ringbuffer will loose its generality. The only advantage gained by this is possibly nicer code in the consumer, while sacrificing simplicity of the ringbuffer API. IMO there is a good chance the consumer will have to keep track of the latency anyways. And in that case, the only extra code required by the consumer is to call `moveReadPositionBy(oldDelay - newDelay)`.', 'comment_created': datetime.datetime(2022, 8, 14, 22, 30, 8, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 945442595, 'comment_body': 'I would like to join this discussion. As @daschuer mentioned I agree that this code version is a little bit harder to use and the inner implementation is not so hidden. On the other side, as @Swiftb0y mentioned, my first goal was to make the API as general as possible. Anyway, if I\'m thinking about it again, I can\'t think of any other specific use at the moment. If you can think of one, please share. IMO the RingDelayBuffer should be optimized for the purpose it was created first. It can be used as a normal ring buffer too, but I think, that for this purpose it should be better to use the [CircularBuffer](https://github.com/mixxxdj/mixxx/blob/070a475cdddf67b2423c564e3f7cc29ee8d8d455/src/util/circularbuffer.h). The `CircularBuffer` can be extended and improved as well of course for the ""classic"" purpose and I can take this task. But to my main thought which I would like to mention, the previous delay value for the purposed new version has to be stored in the `RingDelayBuffer` to avoid running a complicated structure of reading position checks for every read run (as was mentioned in the discussion the check has to be in user code for the current version or in RingDelayBuffer code for the purposed version, so this check is the same). However, the `EngineEffectsDelay`, for which is RingDelayBuffer actually implemented, stores the previous delay value, so for the current use case the previous delay value information will be duplicated.', 'comment_created': datetime.datetime(2022, 8, 15, 5, 57, 59, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 945487755, 'comment_body': 'Calling `moveReadPositionBy(oldDelay - newDelay)` is probably not what you want, because you need to read a buffer with the old delay first and than with the new delay for crossfading. So we require a `moveReadPositionBy(oldDelay - newDelay - numItems)`. The order of calls is also important. This is IMHO not understandable, without looking into the implementation. You need to understand what the read position is, and where it is initial. Otherwise the boundary checks may hit. \r\n\r\nThe class is `RingDelayBuffer` and the API has nothing with delay in it, I am sure the first time user will expect a function with a delay parameter. Please keep also in mind that we need two consecutive reads, in case the delay has changed. \r\n\r\nThinking about the proposed function again, It turns out that it will even release the implementation from keeping read position and a delay value as member. It allows to freely call API functions without order restrictions: \r\n\r\n```\r\nSINT read(CSAMPLE* pBuffer, const SINT numItems, const SINT delayItems) {\r\n    SINT readPos = m_writePos - numItems - delayItems;\r\n    if (readPos < 0) {\r\n       readPos + m_buffer.size(); \r\n    }\r\n    ....\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n', 'comment_created': datetime.datetime(2022, 8, 15, 7, 34, 18, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 945652633, 'comment_body': 'Sure lets give the delay optimized version a try.', 'comment_created': datetime.datetime(2022, 8, 15, 11, 50, 53, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 945688982, 'comment_body': ""Right, thank you for this point, it really didn't make much sense and was hard to understand the flag handling. The new version should fix this based on the proposed change."", 'comment_created': datetime.datetime(2022, 8, 15, 12, 48, 37, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 945691247, 'comment_body': 'Yeah, it was over-complicated. The comment is removed for the new version.', 'comment_created': datetime.datetime(2022, 8, 15, 12, 50, 56, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 945693332, 'comment_body': 'Based on the new version proposed by @daschuer, this line of code was removed.', 'comment_created': datetime.datetime(2022, 8, 15, 12, 53, 10, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 946045447, 'comment_body': 'If you are interested in it, I have the results on my system:\r\n\r\n**Previous version**\r\n```\r\n----------------------------------------------------------------------------------------------\r\nBenchmark                                                    Time             CPU   Iterations\r\n----------------------------------------------------------------------------------------------\r\nBM_WriteReadWholeBufferNoSkip/64_mean                      528 ns          531 ns           20\r\nBM_WriteReadWholeBufferNoSkip/64_median                    528 ns          531 ns           20\r\nBM_WriteReadWholeBufferNoSkip/64_stddev                  0.513 ns        0.478 ns           20\r\nBM_WriteReadWholeBufferNoSkip/64_cv                       0.10 %          0.09 %            20\r\nBM_WriteReadWholeBufferNoSkip/512_mean                     612 ns          616 ns           20\r\nBM_WriteReadWholeBufferNoSkip/512_median                   613 ns          616 ns           20\r\nBM_WriteReadWholeBufferNoSkip/512_stddev                 0.880 ns        0.988 ns           20\r\nBM_WriteReadWholeBufferNoSkip/512_cv                      0.14 %          0.16 %            20\r\nBM_WriteReadWholeBufferNoSkip/4096_mean                   1339 ns         1370 ns           20\r\nBM_WriteReadWholeBufferNoSkip/4096_median                 1341 ns         1373 ns           20\r\nBM_WriteReadWholeBufferNoSkip/4096_stddev                 6.57 ns         8.56 ns           20\r\nBM_WriteReadWholeBufferNoSkip/4096_cv                     0.49 %          0.62 %            20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/64_mean            535 ns          539 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/64_median          534 ns          538 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/64_stddev         1.03 ns        0.994 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/64_cv             0.19 %          0.18 %            20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/512_mean           617 ns          621 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/512_median         616 ns          621 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/512_stddev        2.98 ns         2.97 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/512_cv            0.48 %          0.48 %            20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/4096_mean         1371 ns         1397 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/4096_median       1375 ns         1405 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/4096_stddev       9.64 ns         12.8 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/4096_cv           0.70 %          0.91 %            20\r\nBM_WriteReadWholeBufferSkipLeftCircle/64_mean              538 ns          542 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/64_median            538 ns          541 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/64_stddev           1.37 ns         1.20 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/64_cv               0.25 %          0.22 %            20\r\nBM_WriteReadWholeBufferSkipLeftCircle/512_mean             621 ns          626 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/512_median           621 ns          626 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/512_stddev         0.396 ns        0.412 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/512_cv              0.06 %          0.07 %            20\r\nBM_WriteReadWholeBufferSkipLeftCircle/4096_mean           1427 ns         1467 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/4096_median         1456 ns         1497 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/4096_stddev         40.4 ns         40.9 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/4096_cv             2.83 %          2.78 %            20\r\n```\r\n**Optimized version**\r\n```\r\n----------------------------------------------------------------------------------------------\r\nBenchmark                                                    Time             CPU   Iterations\r\n----------------------------------------------------------------------------------------------\r\nBM_WriteReadWholeBufferNoSkip/64_mean                      528 ns          532 ns           20\r\nBM_WriteReadWholeBufferNoSkip/64_median                    528 ns          531 ns           20\r\nBM_WriteReadWholeBufferNoSkip/64_stddev                   2.03 ns         1.91 ns           20\r\nBM_WriteReadWholeBufferNoSkip/64_cv                       0.38 %          0.36 %            20\r\nBM_WriteReadWholeBufferNoSkip/512_mean                     619 ns          623 ns           20\r\nBM_WriteReadWholeBufferNoSkip/512_median                   618 ns          622 ns           20\r\nBM_WriteReadWholeBufferNoSkip/512_stddev                  3.65 ns         3.61 ns           20\r\nBM_WriteReadWholeBufferNoSkip/512_cv                      0.59 %          0.58 %            20\r\nBM_WriteReadWholeBufferNoSkip/4096_mean                   1345 ns         1375 ns           20\r\nBM_WriteReadWholeBufferNoSkip/4096_median                 1342 ns         1372 ns           20\r\nBM_WriteReadWholeBufferNoSkip/4096_stddev                 7.18 ns         7.49 ns           20\r\nBM_WriteReadWholeBufferNoSkip/4096_cv                     0.53 %          0.54 %            20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/64_mean            532 ns          537 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/64_median          531 ns          536 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/64_stddev         2.00 ns         1.55 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/64_cv             0.38 %          0.29 %            20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/512_mean           617 ns          621 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/512_median         616 ns          620 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/512_stddev        1.08 ns         1.07 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/512_cv            0.18 %          0.17 %            20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/4096_mean         1366 ns         1395 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/4096_median       1363 ns         1395 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/4096_stddev       5.43 ns         3.70 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/4096_cv           0.40 %          0.27 %            20\r\nBM_WriteReadWholeBufferSkipLeftCircle/64_mean              537 ns          542 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/64_median            535 ns          539 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/64_stddev           5.06 ns         5.09 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/64_cv               0.94 %          0.94 %            20\r\nBM_WriteReadWholeBufferSkipLeftCircle/512_mean             625 ns          631 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/512_median           624 ns          630 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/512_stddev          2.83 ns         2.74 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/512_cv              0.45 %          0.43 %            20\r\nBM_WriteReadWholeBufferSkipLeftCircle/4096_mean           1387 ns         1425 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/4096_median         1388 ns         1424 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/4096_stddev         2.15 ns         2.00 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/4096_cv             0.15 %          0.14 %            20\r\n```', 'comment_created': datetime.datetime(2022, 8, 15, 19, 10, 18, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 946049197, 'comment_body': 'I agree, sounds reasonable and good. It will be a lot cleaner approach. Thank you @daschuer.', 'comment_created': datetime.datetime(2022, 8, 15, 19, 15, 15, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 946055858, 'comment_body': 'Could be. To me, the version that it will be just returned from the function without touching the buffer looks more intuitively. The zero value will be returned and the user code can handle this situation on its own. IMO clearing the buffer looks like a little bit of unexpected behaviour to me, but that is just my view about it.', 'comment_created': datetime.datetime(2022, 8, 15, 19, 24, 53, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 946087871, 'comment_body': 'Interesting. So at least its not a pessimization. What are your thoughts @daschuer?', 'comment_created': datetime.datetime(2022, 8, 15, 20, 12, 15, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 946169918, 'comment_body': 'Sorry, but according the benchmarks, it is a pessimization. \r\nI think it is because we have now three branches, instead of one. The if, inside std::abs() and the conditional assignment.\r\nEvery branch is likely flushing the pipeline. The [[unlikely]] may help here though. \r\n\r\nThe best optimization is to dispose the whole function. Because we actually have always size() readable. This is true even after initialization where we have zeros available. \r\n', 'comment_created': datetime.datetime(2022, 8, 15, 22, 13, 5, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 946206606, 'comment_body': ""> Sorry, but according the benchmarks, it is a pessimization.\r\n\r\nWell, IMO the difference is not clear enough to make a clear decision.\r\n\r\n> I think it is because we have now three branches, instead of one. The if, inside std::abs() and the conditional assignment.\r\n\r\nOptimistically speaking, the resulting code could only have a single branch.\r\n```cpp\r\nif (delta == 0) [[unlikely]] {\r\n  return m_fullFlag ? m_buffer.size() : 0;\r\n}\r\n```\r\nThis results in a single branch which is very unlikely (the `[[unlikely]]` attribute probably doesn't change that, the branch predictor could pick that up by itself). The ternary statement afterwards is just a `cmove` (assuming `m_buffer.size()` is inlined). This branch is still cheap though because we can assume its taken so seldomly, so we only pay the cost of the compare. \r\n```\r\nconst SINT range = std::abs(delta);\r\n```\r\n\r\nTheoretically, std::abs can be implemented branchless for integers. Not sure how the standard does it.  My guess is that std::abs is probably the bottleneck if it can't get inlined (which is the case for some c apis).\r\n\r\n```cpp\r\nreturn range == delta ? range : m_buffer.size() - range;\r\n```\r\nthis results in a branch because I was careless. If we pull out the `m_buffer.size() - range` and compute that unconditionally, this ternary could be a `cmove` as well. \r\n\r\n\r\nIn the end, the branchless version probably has less mispredictions, though it probably suffers from data-dependency problems which also lead to bubbles in the pipeline. \r\n\r\nIn the end, it doesn't seem to matter what method we use. If for some reason the alternative implementation wouldve been >2x faster, than I'd advocate for using that, but since it doesn't make a difference, the previous version is probably better because its code is much more readable."", 'comment_created': datetime.datetime(2022, 8, 15, 23, 3, 30, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 946341102, 'comment_body': ""> If for some reason the alternative implementation wouldve been >2x faster, than I'd advocate for using that, but since it doesn't make a difference, the previous version is probably better because its code is much more readable.\r\n\r\nI am on the same. It is not a problem to use the optimised version. Anyway, I expected better results for that, so, I agree to keep the first more readable version. \r\n"", 'comment_created': datetime.datetime(2022, 8, 16, 5, 8, 16, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 946376062, 'comment_body': 'Ok', 'comment_created': datetime.datetime(2022, 8, 16, 6, 19, 42, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 948253711, 'comment_body': 'Due to optimizing the `RingDelayBuffer::read` this line of code was removed.', 'comment_created': datetime.datetime(2022, 8, 17, 17, 48, 57, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 948254817, 'comment_body': 'Due to optimizing the `RingDelayBuffer::read` the `moveReadPositionBy` function was removed.', 'comment_created': datetime.datetime(2022, 8, 17, 17, 50, 10, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 948300539, 'comment_body': 'Could be. I would like to propose, that another option is to move the whole data read/write handling into the helper function (contiguous and non-contiguous). This code part is in fact same for the read and write but just with swapped destination and source buffer (input/output buffer and inner ring buffer). What do you think about it?', 'comment_created': datetime.datetime(2022, 8, 17, 18, 46, 14, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 949552975, 'comment_body': 'Right that was exactly why I proposed to deduplicate it.', 'comment_created': datetime.datetime(2022, 8, 18, 20, 10, 37, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 950881003, 'comment_body': ' Since this is a free function now, we this can go to an an anonymous namespace or if we think we can use it elsewhere, it can be moved sample.cpp. \r\nThis is not a plain copy it is a `copyRing()` or such. \r\n\r\nDoes it work if the source sourcePos AND destPos are not 0? I think not. We may either assert that or add the case with three copy calls. ', 'comment_created': datetime.datetime(2022, 8, 21, 18, 3, 51, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 950882090, 'comment_body': '```suggestion\r\n    VERIFY_OR_DEBUG_ASSERT(shift <= m_buffer.size()) {\r\n```', 'comment_created': datetime.datetime(2022, 8, 21, 18, 14, 20, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 950882164, 'comment_body': '```suggestion\r\n    VERIFY_OR_DEBUG_ASSERT(itemsToWrite <= m_buffer.size()) {\r\n```', 'comment_created': datetime.datetime(2022, 8, 21, 18, 15, 3, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 950882965, 'comment_body': 'This makes assumption of the behavior of copy() and is not correct in the case of an early return.\r\nOne option is to pass m_writePos by pointer. The same goes for itemsToRead above. ', 'comment_created': datetime.datetime(2022, 8, 21, 18, 22, 37, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 951574842, 'comment_body': 'The mentioned problems should be fixed, to summarise:\r\n- `copy() `renamed to `copyRing()`\r\n- `copyRing()` is moved into an anonymous namespace and serves as a helper function only\r\n\r\n> Does it work if the source sourcePos AND destPos are not 0? I think not. We may either assert that or add the case with three copy calls.\r\n\r\nI think I understand, what you mean. IMO for the case that such a huge `numItems` value will be provided, which will be many times greater than the size of the source and destination buffer too, it would be needed much more copies than just three. It cannot occur for the actual usage but may be possible. Based on that multiple copies would not be used now, I would prefer the assert-way solution.', 'comment_created': datetime.datetime(2022, 8, 22, 15, 21, 59, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 951606126, 'comment_body': 'Right, thank you for this hint. Based on the latest changes for the `copyRing()` the fix for this bug should be included.', 'comment_created': datetime.datetime(2022, 8, 22, 15, 51, 36, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 951643505, 'comment_body': ""I have an other (unused) case in mind for three copies: Copy from a ring to a ring.\r\n\r\nSource:\r\n123456789\r\n\r\nDestination\r\n123456789\r\n\r\nCopy 8 samples \r\nRead pointer at 5 write pointer at 7\r\nCopy\r\n5...7 to 7...9 (3)\r\n7...9 to 1..3 (3)\r\n1..2 to 4..5\r\n\r\nThis can't happen if one of the pointers points to the start. \r\n\r\n"", 'comment_created': datetime.datetime(2022, 8, 22, 16, 28, 12, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 951644386, 'comment_body': 'Asserting that this not happens works for me.', 'comment_created': datetime.datetime(2022, 8, 22, 16, 29, 10, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 951649055, 'comment_body': 'Oh I missed that you did it already.\r\nThank you. ', 'comment_created': datetime.datetime(2022, 8, 22, 16, 34, 15, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 952803016, 'comment_body': ""shouldn't this just do the contiguous copy instead of returning early?"", 'comment_created': datetime.datetime(2022, 8, 23, 15, 48, 33, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 952807765, 'comment_body': ""I'm planning to deprecate `mixxx::SampleBuffer::*Slice`. Why not use `std::span` instead?"", 'comment_created': datetime.datetime(2022, 8, 23, 15, 52, 12, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 952822843, 'comment_body': 'I think this breaks if both buffers would requires non-contigous reads. \r\n```\r\ncopying 6 items of a buffer of length 8:\r\ninput:\r\n0000|00 00xxxx\r\n1111 11|11xxxx\r\nafter first copy:\r\n 000000|00xxxx\r\n|111111 00xxxx\r\nafter second copy:\r\n0000 0000xx|xx\r\n00xx|1100\r\n``` \r\nxx is out-of-bounds data/memory', 'comment_created': datetime.datetime(2022, 8, 23, 16, 3, 26, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 952824174, 'comment_body': 'same here, this should just be a non-contiguous read imo', 'comment_created': datetime.datetime(2022, 8, 23, 16, 4, 31, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 952825095, 'comment_body': '```suggestion\r\n    SINT copiedItems = 0;\r\n```\r\navoid potentially uninitialized memory (in case on of the below branches change).', 'comment_created': datetime.datetime(2022, 8, 23, 16, 5, 17, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 952838033, 'comment_body': 'Than we have half the destied result which may worse. Since this is a not used case in this anonymous namespace function, asset and return 0 is a good choice. IMHO \r\n', 'comment_created': datetime.datetime(2022, 8, 23, 16, 15, 32, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 952839318, 'comment_body': 'That is why we asset that is does not happen above. ', 'comment_created': datetime.datetime(2022, 8, 23, 16, 16, 33, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 952840153, 'comment_body': 'For what? ', 'comment_created': datetime.datetime(2022, 8, 23, 16, 17, 13, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 952845772, 'comment_body': 'Ah yes, I misinterpreted the code above. That makes sense now. ', 'comment_created': datetime.datetime(2022, 8, 23, 16, 21, 18, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 952848628, 'comment_body': 'My mistake. I got the behavior of `VERIFY_OR_DEBUG_ASSERT` mixed up.', 'comment_created': datetime.datetime(2022, 8, 23, 16, 23, 33, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 952934875, 'comment_body': 'Of course, `std::span` can be used. I thought, that I should rather work with span through `SampleBuffer` and forgot, that I can call the `mixxx::spanutil::spanFromPtrLen()` directly.', 'comment_created': datetime.datetime(2022, 8, 23, 17, 35, 8, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 952951627, 'comment_body': ""Okay, I'm not just sure how the checks will react on it due to my IDE shows me, that _the value is never used_. I will try it."", 'comment_created': datetime.datetime(2022, 8, 23, 17, 54, 35, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 952954315, 'comment_body': 'Such preventive initialization will hide real errors (variable not set in one branch) from the static code analysis done by the compiler.', 'comment_created': datetime.datetime(2022, 8, 23, 17, 57, 36, tzinfo=datetime.timezone.utc), 'commenter': 'JoergAtGithub', 'type': 'User'}, {'comment_id': 952983747, 'comment_body': ""To be honest, I wouldn't bet on the fact that static analysis will catch this. Technically it can, in practice it might (assuming we even set the right compiler flags). IMO its better to analyze a variable early than possibly not all. If we really want to avoid this entirely, we can do a instead use an IILE and return the value instead, then I'd be confident for the compiler to catch the issue."", 'comment_created': datetime.datetime(2022, 8, 23, 18, 32, 27, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 952985621, 'comment_body': ""> Okay, I'm not just sure how the checks will react on it due to my IDE shows me, that _the value is never used_. I will try it.\r\n\r\nMhmm interesting. \r\nThen here is the lambda solution I mentioned:\r\n```cpp\r\nconst int numItems = [&]() {\r\nif (m_firstInputBuffer) {\r\n        // If the first input buffer is written, the first sample is on the index 0.\r\n        // Based on the checking of an available number of samples, the situation,\r\n        // that the writing will be non-contiguous cannot occur.\r\n        // The itemsToWrite value is multiply by 2 to\r\n        SampleUtil::copyWithRampingGain(m_buffer.data(), pBuffer, 0.0f, 1.0f, itemsToWrite);\r\n        m_firstInputBuffer = false;\r\n        return itemsToWrite;\r\n    } else {\r\n        return copyRing(ReadableSlice(pBuffer, itemsToWrite),\r\n                0,\r\n                WritableSlice(m_buffer.data(), m_buffer.size()),\r\n                m_writePos,\r\n                itemsToWrite);\r\n    }\r\n\r\n}();\r\n```"", 'comment_created': datetime.datetime(2022, 8, 23, 18, 34, 51, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 953020669, 'comment_body': 'However, all CI tests passed, but based on the previous discussion, I would prefer the lambda solution. I thought about it too and it looked like it can look overcomplicated, but when I see your solution now, IMO it is quite clean.', 'comment_created': datetime.datetime(2022, 8, 23, 19, 19, 9, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 953040319, 'comment_body': 'Just one thing, I changed the `int` to `SINT` due to it is returned from the lambda expression and the same type returns the `RingDelayBuffer::write` function. Just please a little clear up for me, what do you mean by this phrase: _""The itemsToWrite value is multiply by 2 to""_?', 'comment_created': datetime.datetime(2022, 8, 23, 19, 34, 28, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 953048731, 'comment_body': 'I ask myself the same. I just copy pasted the comment from the source. ', 'comment_created': datetime.datetime(2022, 8, 23, 19, 46, 9, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 955104073, 'comment_body': 'Right, you just use `spanFromPtrLen` as an adapter so to speak and then try to use std::span as much as possible in any APIs that take the usual `(pointer, size)` pair. ', 'comment_created': datetime.datetime(2022, 8, 25, 15, 20, 6, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 957384499, 'comment_body': '```suggestion\r\n    SINT read(std::span<CSAMPLE> destinationBuffer, const SINT delayItems);\r\n\r\n    /// The method writes items from the pBuffer into the ring buffer.\r\n    /// The number of items that will be written is passed through\r\n    /// the itemsToWrite parameter. This value has to be smaller or equal\r\n    /// to the ring buffer size. Otherwise, the items are not written\r\n    /// and the method returns the zero value. The first chunk of items\r\n    /// after creating of ring delay buffer or after clean-up is ramped\r\n    /// by using fading-in.\r\n    SINT write(std::span<const CSAMPLE> sourceBuffer);\r\n```\r\nsmall nitpick to use spans in the API as well... ', 'comment_created': datetime.datetime(2022, 8, 29, 14, 8, 1, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 957574929, 'comment_body': ""Didn't we already merge the PR containing `SampleBuffer::span`?\r\nIt would cut down on boilerplate code considerably in all tests. \r\n```suggestion\r\n        m_ringDelayBuffer.write(input.span());\r\n        m_ringDelayBuffer.read(output.span(), 0);\r\n        m_ringDelayBuffer.write(input.span());\r\n        m_ringDelayBuffer.read(output.span(), 0);\r\n```"", 'comment_created': datetime.datetime(2022, 8, 29, 16, 53, 53, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}]","[{'commit_sha': '88a160b74e128148ca8b49debfb8c69f885c9c3f', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ccb96508c38dbbd4b34eb136928c51743c5ab451', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '207d26f608a966dff636901caeecd69a3d734c4d', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '785f636ead9679a85445741bf9fe6c6779141760', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'a1551578794b2adc3ed1bc10d7d0182bc2beac8d', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'eeb6e6d11b3a89057589ec00d08a899b3bbd8caa', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'cb2d57bf0c1ce9d54e7f277769655ba629b0ace7', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '1dd8830499153b3c809a569da427f4cca26d1ff4', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '8f264388b25bf598d835c1975f6ac41fb58803ef', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '36d92d268e044876ad05bbd9739c6c45a66f798b', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '248f38e95885000e2f658be01c590bcf711e3619', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '4e6a1ef02303346ab68e8fc721b2ed68a3cc79f9', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'd6565e7868c2379276af5e8b69ebeea27679e780', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '0bfd1683ead56e69413d417a3833070923990353', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '9ef5752878b95ef59c5831a0bbeb3ebfcb17fbab', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '5772334d8446365c84394b269544355d95eb5705', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'de60af2f9227226eec9611df728f84391e4fdc2d', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '77181a8036a04981b1021c3ef517a0ac19ed703e', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '1df0fbbc10878624923e87f8ad6e7afcf900bc0b', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '7c2610e2efde5cc6d01d1bd98e8bb5142851fa5d', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '95182eab054f9014abd4498832fcf691150d2f1e', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '90f9772d7a1573fb4fe3236fe8513df82121b6e5', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'dd4980a0a9cb7be0ec4f306a899009f3ea88a387', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'adf2454662208b572bd55d55a054538df6afdb97', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '0a61a7ba1638f3b17da41a8cd437cb22a7ac9820', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'c6a6c3a86fd10f107e9612fed4152a6848c7038d', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'e3638b4ec5e369c65ead2724c65c39a760caa2a8', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'b95d6be89a0b332bb42576cadc240ad2956555dd', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'b73a2b58d79db0d6a1cc6a8166dd2d67e6ff901c', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '2b2a7a3f3a4dbea0a6e9c5de898b4a086a10e09b', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '0f4729f0b6d674a1439681dba668a78750ca6c34', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'c683b41e6382b89122970aeb603378383f468c3e', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '08285352d095186c7dfa558886d86f6148f0f347', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '6e212af7a4299d7c2a0ed91c26fa08aa1a5a604d', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ac546948dbd3dfea9f09e8fb6b8e21255d9363bf', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '6ee66034e668c3d3ed59b37be4516e658b46dbfc', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'bc6240a51099b4da8090d2e081d192be46880510', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '74b52eac92d2d1b36855ad6c8d649b9f277c6590', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '9addec279ae6ce23745fd0bdb2d60231b09fcd15', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '8076e29572e06acacd624c132d1646dc32791327', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'd886d09bc4ec48c88a9dd5abb36ef96939a86a07', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '6c22c409e027bec8883295788c7928251126f601', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'b686546eaf55a71024c88badba5c053c2a2424c2', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}]",David Chocholatý,84876095,,User,,44,,15,14
951145635,PitchShiftEffect: add independent effect,"Adds a new independent pitch shift effect.
The pitch shift effect contains for now one knob for setting up
the pitch of a sound. The knob has a fixed range for one octave
up or down and works in linear continuous mode.

The known issue is, that the RubberBand library processing latency
needs to be taken into account for different pitch values.
Based on that the effect works with an amount of latency.

Implements: [lp:1299035 ""Add a Transpose / Pitch shift effect""](https://bugs.launchpad.net/mixxx/+bug/1299035)
Reported by: RJ Skerry-Ryan",True,4775,https://api.github.com/repos/mixxxdj/mixxx/pulls/4775,https://github.com/mixxxdj/mixxx/pull/4775,closed,177,0,4,4,20,64,1,0,[{'name': 'build'}],2022-05-30 15:56:21+00:00,2022-06-10 08:27:47+00:00,923486.0,"10 days, 16:31:26","[{'comment_id': 884974319, 'comment_body': ""Here's a little trick that you can use to improve const-correctness.\r\n\r\n```suggestion\r\n    const double pitch = 1.0 + [=]{\r\n        if (pitchParameter < 0.0) {\r\n            return pitchParameter / 2.0;\r\n        } else {\r\n            return pitchParameter;\r\n        }\r\n    }();\r\n```\r\nTo explain the syntax: We're using a immediately invoked lambda expression (you might be familiar with this from JS). The `[=]` says that we're just capturing everything by value, even though it really doesn't matter here since the lambda gets immediately inlined and executed anyways. "", 'comment_created': datetime.datetime(2022, 5, 30, 16, 25, 24, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 884979461, 'comment_body': ""Avoid C-Style casts in C++, they are essentially `reinterpret_cast`s which are highly unsafe if misused (and the compiler can't warn you if you misuse it). https://www.youtube.com/watch?v=L06nbZXD2D0\r\nAlways try `static_cast`s first."", 'comment_created': datetime.datetime(2022, 5, 30, 16, 35, 35, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 884981169, 'comment_body': 'marking this class `final` potentially improves performance because the compiler can avoid the virtual dispatch.', 'comment_created': datetime.datetime(2022, 5, 30, 16, 39, 8, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 884995142, 'comment_body': ""Shouldn't we tell RubberBand here how many samples we can ever give it?\r\n```suggestion\r\n        m_pRubberBand->setMaxProcessSize(engineParameters.framesPerBuffer());\r\n```"", 'comment_created': datetime.datetime(2022, 5, 30, 17, 9, 42, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 884995774, 'comment_body': ""can't these be stack-allocated in `processChannel` instead or is there some persistent data between invocations which I didn't spot?"", 'comment_created': datetime.datetime(2022, 5, 30, 17, 11, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 885002258, 'comment_body': 'why inverted?\r\n```suggestion\r\n    pitch->setDefaultLinkInversion(EffectManifestParameter::LinkInversion::NotInverted);\r\n```', 'comment_created': datetime.datetime(2022, 5, 30, 17, 26, 15, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 885048292, 'comment_body': 'Oh, interesting. Looks good to me.', 'comment_created': datetime.datetime(2022, 5, 30, 19, 33, 17, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 885050968, 'comment_body': 'I agree, that it should be not inverted which is the default value.', 'comment_created': datetime.datetime(2022, 5, 30, 19, 41, 48, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 885051781, 'comment_body': 'True, I will fix it.', 'comment_created': datetime.datetime(2022, 5, 30, 19, 44, 8, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 885061312, 'comment_body': ""There isn't any necessity to have persistent data between invocations. It's only for the storage of buffer samples in the form which uses the RubberBand library. It could be saved on a stack. Anyway, the same amount of memory will be allocated for every function call (buffer). That's the reason, why this code part was implemented like this."", 'comment_created': datetime.datetime(2022, 5, 30, 20, 13, 16, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 885085468, 'comment_body': 'Using a lambda expression here would be overly complex and is unusal. Why not simply the ternary `?:` operator?', 'comment_created': datetime.datetime(2022, 5, 30, 21, 34, 59, tzinfo=datetime.timezone.utc), 'commenter': 'uklotzde', 'type': 'User'}, {'comment_id': 885087572, 'comment_body': ""Right, but stack allocation is constant time while `SampleUtil::alloc(MAX_BUFFER_LEN)` is possibly unbounded. So unless you need to **dynamically** (meaning you don't know the size at compile time) allocate memory, I would refrain from doing so. The usage of `MAX_BUFFER_LEN` is hacky anyways because we can't guarantee that Rubberband will need more than that while we also wasting a bunch of memory if its doesn't need more than that."", 'comment_created': datetime.datetime(2022, 5, 30, 21, 43, 24, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 885088043, 'comment_body': 'I assumed that the our [Coding Guidlines](https://github.com/mixxxdj/mixxx/wiki/Coding-Guidelines) already included the *no C-style casts* rule, but it does not!?', 'comment_created': datetime.datetime(2022, 5, 30, 21, 45, 17, tzinfo=datetime.timezone.utc), 'commenter': 'uklotzde', 'type': 'User'}, {'comment_id': 885088235, 'comment_body': 'I tried both and found the ternary more difficult to read to be honest. Yes, lambdas are a complex feature, but they result in very readable code when used in this way IMO.', 'comment_created': datetime.datetime(2022, 5, 30, 21, 46, 15, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 885088728, 'comment_body': 'All this code is probably redundant.', 'comment_created': datetime.datetime(2022, 5, 30, 21, 48, 3, tzinfo=datetime.timezone.utc), 'commenter': 'uklotzde', 'type': 'User'}, {'comment_id': 885089016, 'comment_body': 'This could become a constant.', 'comment_created': datetime.datetime(2022, 5, 30, 21, 49, 16, tzinfo=datetime.timezone.utc), 'commenter': 'uklotzde', 'type': 'User'}, {'comment_id': 885089620, 'comment_body': ""@davidchocholaty Please move this and other non-trivial function definitions into the .cpp file. They don't need to be inlined in the header.\r\n\r\n@Swiftb0y `SampleUtil::alloc()` is probably needed for alignment of the buffers?"", 'comment_created': datetime.datetime(2022, 5, 30, 21, 52, 2, tzinfo=datetime.timezone.utc), 'commenter': 'uklotzde', 'type': 'User'}, {'comment_id': 885089839, 'comment_body': 'Nope, not a single mention of the word ""cast"". I guess feel free to add a paragraph to the wiki then.', 'comment_created': datetime.datetime(2022, 5, 30, 21, 52, 50, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 885092825, 'comment_body': ""> @Swiftb0y `SampleUtil::alloc()` is probably needed for alignment of the buffers?\r\n\r\nI can't spot any requirement for alignment in the Rubberband API docs. Parts of this code were copied from `enginebufferscalerrubberband.cpp` but I can't see any reason why this is done. There must be better ways of achieving getting aligned storage other than dynamically allocating it. It seems the currently accepted way is using `alignas` https://en.cppreference.com/w/cpp/language/alignas"", 'comment_created': datetime.datetime(2022, 5, 30, 22, 7, 10, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 885093151, 'comment_body': 'And also a `QLatin1String`', 'comment_created': datetime.datetime(2022, 5, 30, 22, 8, 55, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 885108962, 'comment_body': 'I am unsure, maybe the clazy or clang-tidy task will detect it.', 'comment_created': datetime.datetime(2022, 5, 30, 23, 28, 43, tzinfo=datetime.timezone.utc), 'commenter': 'uklotzde', 'type': 'User'}, {'comment_id': 885109209, 'comment_body': 'Tbh, I have never seen lambas used  in C++ for this purpose. We should not use uncommon patterns. If it is recommended by the C++ Core Guidelines I am ok with it, otherwise not.', 'comment_created': datetime.datetime(2022, 5, 30, 23, 29, 52, tzinfo=datetime.timezone.utc), 'commenter': 'uklotzde', 'type': 'User'}, {'comment_id': 885109874, 'comment_body': 'SampleUtil::alloc() is only needed when using functions from SampleUtil.', 'comment_created': datetime.datetime(2022, 5, 30, 23, 33, 1, tzinfo=datetime.timezone.utc), 'commenter': 'uklotzde', 'type': 'User'}, {'comment_id': 885110424, 'comment_body': 'I guess the result is expected to be a `QString` so using `QLatin1String` would not make sense here.', 'comment_created': datetime.datetime(2022, 5, 30, 23, 35, 45, tzinfo=datetime.timezone.utc), 'commenter': 'uklotzde', 'type': 'User'}, {'comment_id': 885124571, 'comment_body': 'Mhmm, we are using `SampleUtil::deinterleaveBuffer`... Should we just leave it as is and make a comment that this could be changed when we migrate away from interleaved buffers?', 'comment_created': datetime.datetime(2022, 5, 31, 0, 42, 40, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 885125939, 'comment_body': 'Mhmm I figured it was faster but looking at the Qt implemenation, you are right its not. We should change that in the future.', 'comment_created': datetime.datetime(2022, 5, 31, 0, 48, 34, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 885126995, 'comment_body': 'It is: https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-lambda-init\r\nAlso see: https://rigtorp.se/iife/', 'comment_created': datetime.datetime(2022, 5, 31, 0, 53, 1, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 885131547, 'comment_body': 'Nevertheless, this particular case doesn\'t qualify for ""complex initialization"" and the ternary operator should be preferred.', 'comment_created': datetime.datetime(2022, 5, 31, 1, 10, 24, tzinfo=datetime.timezone.utc), 'commenter': 'uklotzde', 'type': 'User'}, {'comment_id': 885134346, 'comment_body': 'Godbolt: https://compiler-explorer.com/z/Yd899MKMz', 'comment_created': datetime.datetime(2022, 5, 31, 1, 20, 5, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 885255911, 'comment_body': ""Yeah, this part of the code is based on `enginebufferscalerrubberband.cpp,` so the same functions `SampleUtil::interleaveBuffer` and `SampleUtil::deinterleaveBuffer` are used. Anyway, I'm a little bit sceptic about these functions' implementations for this purpose. In my opinion, these mentioned functions work with firmly set channel count to stereo and other parts of effect code use `engineParameters.channelCount(),` so, it isn't probably the best solution, for now, I agree. "", 'comment_created': datetime.datetime(2022, 5, 31, 6, 42, 15, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 885337314, 'comment_body': ""@Swiftb0y Thanks for the comprehensive write-up!! I didn't expect the IIFE variants to be both more readable and harder to get wrong. The generated ASM doesn't really matter, compilers will get better while the code remains.\r\n\r\nWell, I guess you forgot one version that would safe us from wasting our precious time with these discussions ;) https://compiler-explorer.com/z/dqWM64d8x\r\n(The ASM code needs to be compared to C++/clang 14, not C++/gcc)"", 'comment_created': datetime.datetime(2022, 5, 31, 8, 14, 59, tzinfo=datetime.timezone.utc), 'commenter': 'uklotzde', 'type': 'User'}, {'comment_id': 885490637, 'comment_body': ""> In my opinion, these mentioned functions work with firmly set channel count to stereo and other parts of effect code use engineParameters.channelCount(), so, it isn't probably the best solution, for now, I agree.\r\n\r\nWell, right now, you can pretty much assume that we only have interleaved stereo samples in our engine. We already discussed to change that in the future but that is not an easy task since so much or our code relies on that assumption."", 'comment_created': datetime.datetime(2022, 5, 31, 10, 49, 59, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 885564686, 'comment_body': 'I think you mean a `QStringLiteral`', 'comment_created': datetime.datetime(2022, 5, 31, 12, 18, 17, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 885570267, 'comment_body': 'I think it is ""The pitch shift applied to the sound""', 'comment_created': datetime.datetime(2022, 5, 31, 12, 22, 6, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 885574029, 'comment_body': 'You may also consider to extend unitsHint. I am afraid it is currently unused but we may consider to inform the user about the units. ', 'comment_created': datetime.datetime(2022, 5, 31, 12, 26, 9, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 885604986, 'comment_body': 'Is this cast required at all? A parameter of  `const float*` is just the confirmation that the function will not touch the content. \r\nthe second const is pointless in a function interface, because the caller does not care if the pointer itself copied by value is changed internally or not.   ', 'comment_created': datetime.datetime(2022, 5, 31, 12, 57, 38, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 885606690, 'comment_body': 'Remove the cast here as well. ', 'comment_created': datetime.datetime(2022, 5, 31, 12, 59, 20, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 885615411, 'comment_body': ""Right. We have discussed to move away from the stereo assumption when supporting Stems. However, this will probably only apply to the sound sources up to a stereo down mix in EngineBuffer. So even after that we will have a stereo effect engine. At least I can't see a use case for it right now. \r\n "", 'comment_created': datetime.datetime(2022, 5, 31, 13, 7, 41, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 885655415, 'comment_body': ""Yes, but once the EngineBuffer stops using interleaved samples, it would be a good idea to make the effects aware of that too. And once they got converted into stereo non-interleaved, we can work on removing the stereo assumption. But that's irrelevant for this GSoC project."", 'comment_created': datetime.datetime(2022, 5, 31, 13, 41, 52, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 885658278, 'comment_body': 'This is the type [`RubberbandStretcher::process`](https://breakfastquay.com/rubberband/code-doc/classRubberBand_1_1RubberBandStretcher.html#a0af91755d71eecfce5781f2cd759db85) wants. A `static_cast` is suffice.', 'comment_created': datetime.datetime(2022, 5, 31, 13, 44, 11, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 885660852, 'comment_body': '> Nevertheless, this particular case doesn\'t qualify for ""complex initialization"" and the ternary operator should be preferred.\r\n\r\n> I didn\'t expect the IIFE variants to be both more readable and harder to get wrong.\r\n\r\nSo for David, do we have consensus that using an IIFE makes sense here?', 'comment_created': datetime.datetime(2022, 5, 31, 13, 46, 28, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 885664159, 'comment_body': 'IMO we can tweak the exact wording later. Discussing this is bikeshedding.', 'comment_created': datetime.datetime(2022, 5, 31, 13, 49, 12, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 885664935, 'comment_body': 'I agree, a percentage or a ratio UnitsHint would make sense, but we can do that later.', 'comment_created': datetime.datetime(2022, 5, 31, 13, 49, 51, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 885688984, 'comment_body': 'Yes I know. But we never cast a non const to const just because a function takes const.  ', 'comment_created': datetime.datetime(2022, 5, 31, 14, 9, 1, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 885709722, 'comment_body': ""Use whatever is readable. I'm fine with both."", 'comment_created': datetime.datetime(2022, 5, 31, 14, 25, 36, tzinfo=datetime.timezone.utc), 'commenter': 'uklotzde', 'type': 'User'}, {'comment_id': 886061145, 'comment_body': 'Okay, thank you. So I will keep the mentioned methods, which presuppose stereo samples.', 'comment_created': datetime.datetime(2022, 5, 31, 19, 32, 7, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 886065652, 'comment_body': 'I used `QString` because all other built-in effects use it too.', 'comment_created': datetime.datetime(2022, 5, 31, 19, 37, 15, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 886068804, 'comment_body': ""That's true, that I planned to improve effect descriptions a little bit later. Anyway, the proposal by @daschuer sounds better, than my version. I will use it. Thank you."", 'comment_created': datetime.datetime(2022, 5, 31, 19, 41, 42, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 886083514, 'comment_body': 'Okay, thank you. IMO, the first IIFE is the most readable, at least for me.', 'comment_created': datetime.datetime(2022, 5, 31, 20, 2, 29, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 886107526, 'comment_body': 'Ok. So, I will remove unnecessary casts.', 'comment_created': datetime.datetime(2022, 5, 31, 20, 35, 39, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 887567223, 'comment_body': ""I couldn't find the other part of the code, where it should be done. This code was based on how other built-in effects use `SampleUtil::free` in their destructors. For example, see:\r\n\r\nhttps://github.com/mixxxdj/mixxx/blob/5158e6259cfbba2f71e4f112d642259c48659354/src/effects/backends/builtin/linkwitzriley8eqeffect.cpp#L53\r\n\r\nor\r\n\r\nhttps://github.com/mixxxdj/mixxx/blob/5158e6259cfbba2f71e4f112d642259c48659354/src/effects/backends/builtin/lvmixeqbase.h#L47"", 'comment_created': datetime.datetime(2022, 6, 2, 5, 21, 18, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 888260278, 'comment_body': ""I'm re-creating [this thread](https://github.com/mixxxdj/mixxx/pull/4775#discussion_r884995774) so it doesn't get lost in github. \r\nI've looked a bit into this and IMO there are essentially two best options:\r\n1. We statically allocate both buffers on the stack (aligned). Which would be two massive MAX_BUFFER_LEN (`160,000` bytes) stack allocation. This could simply be a `aligned(32) std::array<float, MAX_BUFFER_LEN> buf1;`. \r\n2. We allocate just enough memory on the heap. So `SampleUtil::alloc(engineParameters.framesPerBuffer())`;\r\n\r\nWdyt?"", 'comment_created': datetime.datetime(2022, 6, 2, 18, 20, 4, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 888272409, 'comment_body': ""Rubberband can't assume the buffers are aligned anyways. It just might check that at runtime and then branch to use aligned and unaligned vector instructions. Also, we can't communicate alignment over function boundaries, unless we use type that takes care of that, at which point we should be using xsimd again.\r\nThe only benefit of I alignment I see is that aligning to cache lines can reduce the number of cache misses and general cache pressure."", 'comment_created': datetime.datetime(2022, 6, 2, 18, 36, 17, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 888362303, 'comment_body': ""Wow, thank you for the research. IMO I prefer the second one. I think, that it's about 1024 frames per buffer which I currently have, but it can change of course. Do you agree? Can I just ask, why isn't possible to allocate `engineParameters.framesPerBuffer()` size on the stack? Is it about the alignment?"", 'comment_created': datetime.datetime(2022, 6, 2, 19, 54, 23, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 888362930, 'comment_body': ""In this case it is more a question to make them fixed size arrays that live in the opject's memory, the group state object, that is also heap allocated from the GUI thread. This would save use from allocation individual smaller memory chunks.\r\n\r\nBut the class has no control if it is allocated on stack or heap, and that might change later on.\r\n\r\nStack is not designed for big data objects there is always a subtile risk of a stack overflow if the call tree becomes too deep. On Ubuntu it is 8 MB and on Windows only 1 MB \r\n\r\nSince stack allocations are lock free and blazing fast, it is a good rule of thump to use the stack for short living and small object and the heap for the big once or dynamic resizing. \r\n\r\nIn general, we should consider to put much more on the stack, but these buffers are Imho better placed on the heap. This helps also to have the buffers alligned for vectorization, without a ramp up loop. \r\n"", 'comment_created': datetime.datetime(2022, 6, 2, 19, 55, 13, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 888377509, 'comment_body': ""Thank you for the detailed description. That makes sense. I'm just not sure if I didn't lose in the main opinion for these buffers. So, do you agree with the `SampleUtil::alloc(engineParameters.framesPerBuffer())` version too?"", 'comment_created': datetime.datetime(2022, 6, 2, 20, 16, 3, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 888390042, 'comment_body': 'Yes.', 'comment_created': datetime.datetime(2022, 6, 2, 20, 33, 32, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 888402676, 'comment_body': 'By the way: \r\n`aligned(32) std::vector<float, MAX_BUFFER_LEN> buf1;` Dos not exist. The second parameter is an allocator  function. \r\nhttps://stackoverflow.com/questions/354442/looking-for-c-stl-like-vector-class-but-using-stack-storage\r\n \r\naligned(32) will only align the control structure of std::vector by 32 byte. The play load is still unaligned on the heap. \r\n`sizeof(std::vector<float>) = 24;`\r\n\r\nThe alternative that locates the memory in place is QVarLengthArray, \r\n\r\n\r\n\r\n', 'comment_created': datetime.datetime(2022, 6, 2, 20, 50, 41, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 888413507, 'comment_body': '> In general, we should consider to put much more on the stack, but these buffers are Imho better placed on the heap. \r\n\r\nI made some mistakes in the initial comment: yes, allocating buffers this big on the stack is not a good idea. Simply allocating the buffers once outside the audio thread is probably the best idea.\r\n\r\n> This helps also to have the buffers alligned for vectorization, without a ramp up loop.\r\n\r\nDepending on the architecture, there is no ""rampup-loop"". Most compilers will usually just use the slight worse-performing instructions that can load values which are just aligned to their type (default allocation in C++), not the the vector-register size. If we really want to use those aligned instructions (which will crash when used unaligned), we probably need something handwritten (or a wrapper library). \r\n', 'comment_created': datetime.datetime(2022, 6, 2, 21, 6, 24, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 888417045, 'comment_body': '>  aligned(32) std::vector<float, MAX_BUFFER_LEN> buf1; Dos not exist. The second parameter is an allocator function.\r\n\r\nSorry, yes I just noticed that as well, I meant `std::array`\r\n\r\n> aligned(32) will only align the control structure of std::vector by 32 byte. The play load is still unaligned on the heap.\r\n\r\nYes, thats the case with `std::vector` but obviously not with the `std::array`. With vector, you would provide a custom aligned allocator (xsimd provides one for example).', 'comment_created': datetime.datetime(2022, 6, 2, 21, 11, 9, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 888606119, 'comment_body': 'This is redundant, because it will be called anyway invisibility. No need to care abeut the whole thing of an unique_ptr.', 'comment_created': datetime.datetime(2022, 6, 3, 4, 48, 28, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 888607219, 'comment_body': 'This can be a normal debug assert.', 'comment_created': datetime.datetime(2022, 6, 3, 4, 51, 33, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 888863246, 'comment_body': ""Can you elaborate? This calls `RubberBandStretcher::reset()` not, `unique_ptr::reset()`... `RubberBandStretcher::reset()` will not be called implicitly, it still might be redundant though since we're in the dtor anyways."", 'comment_created': datetime.datetime(2022, 6, 3, 11, 36, 47, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 888891911, 'comment_body': 'Oh, yes I have actually misread the code as `m_pRubberBand.reset()` sorry. \r\n\r\nBut you assumption that it is redundant anyway is also correct. It all ends here \r\nhttps://github.com/breakfastquay/rubberband/blob/bad529f81e8ae66bd4535a6af392efa38c7fc6b1/src/StretcherImpl.cpp#L222 with almost the same code in the destructor. ', 'comment_created': datetime.datetime(2022, 6, 3, 12, 20, 27, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}]","[{'commit_sha': '4fbbabf37b57827ab6aa9f9b9857bfb579fa23d1', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'e67de25f84181cda77e0959af613ec7d56977147', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'c6fd6710043575740926be57ef1a01ed620c6e2f', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'b8c1d4c87b044909b2fa23c397e6876445707dce', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}]",David Chocholatý,84876095,,User,,44,,15,14
971290657,EngineEffectsDelay: effects chain delay handling,"Solves the delay issue for the effects chain. The solution
is useful for the dry/wet or dry+wet mode. If the effects chain
has a specific delay based on the effects processing latency,
the dry signal is delayed to ensure dry and wet signals overlap.
To delay the dry signal, the sum of all chain effects group delay
is calculated. In the current version, the solution is especially used
for the Pitch shift effect. The known issue is, that the Pitch shift
effect doesn't provide the right amount of latency and the delay
is pretty huge. This problem has to be solved for the Pitch shift
effect implementation first. The effect group delay propagation
was implemented through the use of the EffectProcessorImpl,
EffectProcessor and EngineEffect. The special class wasn't created
for the purpose to preserve the hierarchy of effects implementation
as much as possible.",True,4810,https://api.github.com/repos/mixxxdj/mixxx/pulls/4810,https://github.com/mixxxdj/mixxx/pull/4810,closed,686,2,12,40,70,154,2,1,"[{'name': 'build'}, {'name': 'code quality'}]",2022-06-18 14:20:49+00:00,2022-08-14 22:32:56+00:00,4954327.0,"57 days, 8:12:07","[{'comment_id': 901002888, 'comment_body': ""It would make more sense to enforce the fact that this can't be the case in the caller. Use the `M_RESTRICT` macro from `util/platform.h`\r\nhttps://en.wikipedia.org/wiki/Restrict"", 'comment_created': datetime.datetime(2022, 6, 18, 18, 17, 17, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 901003047, 'comment_body': ""I don't see much use in a private setter to be honest. "", 'comment_created': datetime.datetime(2022, 6, 18, 18, 19, 18, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 901003107, 'comment_body': 'Use SINT for indexing or quantities of samples.\r\n```suggestion\r\nSINT PitchShiftEffect::getGroupDelay() {\r\n    return m_groupDelay;\r\n}\r\n```', 'comment_created': datetime.datetime(2022, 6, 18, 18, 20, 3, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 901003192, 'comment_body': 'Can you explain this a bit better? why the method exists and what its return value means and how its supposed to be used?', 'comment_created': datetime.datetime(2022, 6, 18, 18, 21, 15, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 901003221, 'comment_body': 'implement in the header instead?', 'comment_created': datetime.datetime(2022, 6, 18, 18, 21, 44, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 901003489, 'comment_body': 'make class final and implement the simple setter here to allow for inlining.', 'comment_created': datetime.datetime(2022, 6, 18, 18, 25, 4, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 901003571, 'comment_body': 'is this class supposed to be inherited from? If not make it final and its protected member private.', 'comment_created': datetime.datetime(2022, 6, 18, 18, 25, 55, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 901061037, 'comment_body': 'I think it would be better to format this in frames.\r\nCan this ever be a float? Can we put the unit into the function name? ', 'comment_created': datetime.datetime(2022, 6, 19, 7, 27, 36, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 901061326, 'comment_body': 'We need to be careful not to swap stereo channels.\r\nI think if we make the group delay by frames it is solved automatically.', 'comment_created': datetime.datetime(2022, 6, 19, 7, 30, 8, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 901061988, 'comment_body': 'New is locking and must not be called from the engine.\r\nJust allocated a reasonable maximum during the constructor.', 'comment_created': datetime.datetime(2022, 6, 19, 7, 35, 43, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 901130872, 'comment_body': ""> I think it would be better to format this in frames.\r\n\r\nI think it could be maybe possible. Anyway, I would like to mention a few reasons, why the samples option was used.\r\n\r\nFirst is, that the EngineEffectsDelay is based on the [EngineFilterDelay,](https://github.com/mixxxdj/mixxx/blob/935ba94f7e498eebd7c3710b2f0df35d989d9a7d/src/engine/filters/enginefilterdelay.h#L34) which uses samples and the thought was to keep the structure as similar as possible.\r\n\r\nThe second reason was, that for now the stereo signal is kept as default. If I would like to keep the other possible options in mind for maybe some extensions in the future, in the EngineEffectChain it isn't possible to get the number of channels, at least not straight. The information on the number of channels is possible to get via EngineParameters ([created later](https://github.com/mixxxdj/mixxx/blob/935ba94f7e498eebd7c3710b2f0df35d989d9a7d/src/engine/effects/engineeffect.cpp#L181) through process() method call in EngineEffectChain).\r\n\r\nAnd at least the last third and the main reason based on the second one, in the EngineEffectsDelay process() method, it is necessary to work with samples in the work with audio buffers, not with the frames. It can be used frames if it would be possible in EngineEffectsDelay to get information about the number of channels of input audio signal.\r\n\r\nSo, I would like to summarize the main idea. It is possible if I can get information about the number of channels in the EngineEffectChain process() method, or at least in the EngineEffectsDelay process() method.\r\n\r\n> Can this ever be a float?\r\n\r\nIf I assume, that it will be worked with the samples or frames, it isn't possible. It can be possible if we thought of to option to work with the delay in milliseconds, but IMO it doesn't make much sense. If I'm wrong, please correct me.\r\n\r\n> Can we put the unit into the function name?\r\n\r\nYeah, of course. \r\n"", 'comment_created': datetime.datetime(2022, 6, 19, 16, 35, 4, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 901131479, 'comment_body': ""That's a good point. If the effectChainGroupDelay isn't right to the number of channels, the channels could be swapped (for stereo signal an odd number of samples). This situation isn't handled internally for now. As I mentioned for the PitchShiftEffect setGroupDelay() method, it is necessary to have the information about the number of channels, if I wouldn't assume, that it will be worked only with the stereo audio signal."", 'comment_created': datetime.datetime(2022, 6, 19, 16, 41, 29, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 901131842, 'comment_body': ""Okay, thank you. It will be a better option. I will fix it. The buffer size wasn't allocated in the constructor due to the huge amount of delay of the Pitch shift effect, but it will be solved."", 'comment_created': datetime.datetime(2022, 6, 19, 16, 45, 23, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 901134269, 'comment_body': 'Ok, that sounds reasonable. \r\nIf we put an assertion that the stereo signal is it swapped it works for me as well.', 'comment_created': datetime.datetime(2022, 6, 19, 17, 7, 30, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 901301007, 'comment_body': ""Okay, thank you. Good idea. Still, I see now on my solution and proposal of using samples rather than frames maybe a little problem, that if it will be worked in the future with other numbers of channels than the stereo signal, it would be harder to assert the invalid number of samples. To check the invalid value the number of samples has to be divisible by the number of channels. And because of that, the information about the number of channels has to be accessible in the EngineEffectChannel or EngineEffectsDelay, so this situation isn't still solved."", 'comment_created': datetime.datetime(2022, 6, 20, 6, 36, 56, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 906721702, 'comment_body': ""It would be interesting to see whats faster.\r\n1. Copying and making use of vectorization\r\n2. Doing the mutation in place and possibly don't get vectorization\r\n\r\nMy guess would be that it depends on buffer size. "", 'comment_created': datetime.datetime(2022, 6, 25, 20, 34, 1, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 906721959, 'comment_body': 'what if we take two `gsl::span`s instead? Do we suffer a significant performance penalty because of the runtime bounds checking? ', 'comment_created': datetime.datetime(2022, 6, 25, 20, 37, 8, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 906722379, 'comment_body': 'Also a documentation header would be nice', 'comment_created': datetime.datetime(2022, 6, 25, 20, 42, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 906799892, 'comment_body': 'since the group delay is an offset in sample, using `SINT` makes more sense.\r\n```suggestion\r\n    virtual SINT getGroupDelay() override {\r\n```', 'comment_created': datetime.datetime(2022, 6, 26, 11, 33, 1, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 906802503, 'comment_body': 'Agree, reporting the latency in Frames is better than samples because samples depend on the number of channels. ', 'comment_created': datetime.datetime(2022, 6, 26, 11, 53, 45, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 906803708, 'comment_body': ""I don't understand this case. Is it when the delay hasn't changed and the buffer is large enough? Why do we need this exception?"", 'comment_created': datetime.datetime(2022, 6, 26, 12, 1, 44, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 906837576, 'comment_body': ""Okay, I agree. If it is ok, the setter will recalculate the number of the frames into samples by using [mixxx::kEngineChannelCount](https://github.com/mixxxdj/mixxx/blob/1cd826af252c51f96db17f8a27cd3599828aa946/src/engine/engine.h#L8), I'm fine with that. The reason why the number of frames has to be recalculated in the setter is, that the inner process() method structure works with samples and it doesn't make sense to recalculate samples for every delay value usage."", 'comment_created': datetime.datetime(2022, 6, 26, 15, 46, 32, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 906838317, 'comment_body': ""Sure, if I think about it again, it really doesn't make much sense."", 'comment_created': datetime.datetime(2022, 6, 26, 15, 52, 56, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 906842856, 'comment_body': 'Yes, of course.', 'comment_created': datetime.datetime(2022, 6, 26, 16, 29, 42, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 906863005, 'comment_body': '> is this class supposed to be inherited from?\r\n\r\nIf I think about it again, probably not.\r\n\r\n', 'comment_created': datetime.datetime(2022, 6, 26, 19, 45, 3, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 907102979, 'comment_body': ""It's alright, the second condition part (`m_delayBufferSize == iBufferSize + m_delaySamples`) was added, because it looked to me not so clean to rely on that the `iBufferSize`, which is the input parameter, is always the same. If it wouldn't the same, the `m_delayBufferSize` would contain a bad value. Anyway, the buffer size is set now in the new version in the constructor and is known in compile time, so the condition for this part will be that just the delay hasn't changed (`m_oldDelaySamples == m_delaySamples`)."", 'comment_created': datetime.datetime(2022, 6, 27, 8, 16, 16, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 907336919, 'comment_body': 'In fact, I see the `gsl::span` for the first time. I studied some information about that. It looks like it could be cool. However, the `process()` method overrides the method from [EngineObjectConstIn,](https://github.com/mixxxdj/mixxx/blob/d209239967f2f4709d03c05261f8fef07ba47f75/src/engine/engineobject.h#L23) so for now, it doesn\'t fit well into the current structure. To still preserve hierarchy, I think that the new class should be created in `engineobject.h,` which will use `gsl::span` instead of `CSAMPLE*`, from which will the `EngineEffectsDelay` inherit. Another thing to the implementation, the use of span is great when using iterator. If I\'m right, for optimal use of gsl::span in `EngineEffectsDelay`, there have to be two iterators for one for cycle for input and output buffer, if we will use the ""two buffers"" version.', 'comment_created': datetime.datetime(2022, 6, 27, 12, 34, 38, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 907414744, 'comment_body': 'Since #4803 just got merged, you can also use `std::span` (which should be exactly equivalent to the pointer-based implementation because it doesn\'t perform bounds checking unlike `gsl::span`). Since this is somewhat performance-critical code, it would make sense to use implementation without bounds checking.\r\n\r\ntransforming `void process(const CSAMPLE* pIn, CSAMPLE* pOutput, const int iBufferSize)` to `void process(std::span<CSAMPLE> in, std::span<CSAMPLE> out);` and vice versa is trivial. We can provide a virtual method in the baseclass that has a default implementation and implements one in term of the other. Then mark the pointer-based method deprecated and then we can gradually change all implementations.\r\n\r\n> If I\'m right, for optimal use of gsl::span in EngineEffectsDelay, there have to be two iterators for one for cycle for input and output buffer, if we will use the ""two buffers"" version.\r\n\r\nWhy do you think so? The elements within spans are mutable, you can just change them in-place. So you can just create a span over the single mutable buffer. ', 'comment_created': datetime.datetime(2022, 6, 27, 13, 51, 7, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 907426193, 'comment_body': 'No need for heap allocation here imo. And if there is prefer unique_ptr. https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es60-avoid-new-and-delete-outside-resource-management-functions', 'comment_created': datetime.datetime(2022, 6, 27, 14, 1, 30, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 907703415, 'comment_body': ""> Since this is somewhat performance-critical code, it would make sense to use implementation without bounds checking.\r\n\r\nI agree, sounds good to me of using std::span.\r\n\r\n> Why do you think so? The elements within spans are mutable, you can just change them in-place. So you can just create a span over the single mutable buffer.\r\n\r\nOh, right right. I just didn't realize that while reading the documentation.\r\n"", 'comment_created': datetime.datetime(2022, 6, 27, 18, 57, 27, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 909674298, 'comment_body': 'basic getter still belongs in the header.', 'comment_created': datetime.datetime(2022, 6, 29, 14, 0, 53, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 909676537, 'comment_body': 'Can you explain why the heap allocation is needed?', 'comment_created': datetime.datetime(2022, 6, 29, 14, 2, 44, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 909678290, 'comment_body': '```suggestion\r\nconstexpr int kiMaxDelay = static_cast<int>(0.508 *\r\n        mixxx::audio::SampleRate::kValueMax * mixxx::kEngineChannelCount);\r\n```', 'comment_created': datetime.datetime(2022, 6, 29, 14, 4, 13, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 909679517, 'comment_body': 'Have you considered inheriting from `EngineObject` instead?', 'comment_created': datetime.datetime(2022, 6, 29, 14, 5, 14, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 909686120, 'comment_body': 'These pre-conditions must hold no matter which branch is actually taken. Can you deduplicate them outside the `if`?', 'comment_created': datetime.datetime(2022, 6, 29, 14, 10, 32, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 909706798, 'comment_body': 'why the ramping in the first place?', 'comment_created': datetime.datetime(2022, 6, 29, 14, 19, 47, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 910297407, 'comment_body': '```suggestion\r\n    /// The method returns the number of frames by which the dry signal\r\n```', 'comment_created': datetime.datetime(2022, 6, 29, 18, 52, 56, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 910299203, 'comment_body': '```suggestion\r\n    /// needs to be delayed so that buffers for the dry and wet signal (output\r\n    /// of the effect) overlap. The return value represents the current effect\r\n```', 'comment_created': datetime.datetime(2022, 6, 29, 18, 55, 4, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 910302493, 'comment_body': 'Can we give the buffer a better name? ', 'comment_created': datetime.datetime(2022, 6, 29, 18, 59, 6, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 910310417, 'comment_body': 'It feels scary that pIn is not const. I think It should be, because messing around with the input buffer feels wrong. \r\n\r\nThere is also no need for this copy. We can use m_tmpBuffer below. \r\n\r\n\r\n', 'comment_created': datetime.datetime(2022, 6, 29, 19, 8, 38, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 910313208, 'comment_body': 'We have also no definition for a i prefix. 0.508 is a magic number can we name it? What is the unit of kMaxDelay?', 'comment_created': datetime.datetime(2022, 6, 29, 19, 12, 3, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 910324383, 'comment_body': 'it looks like clang-format needs your help here:\r\n```suggestion\r\n        int delaySourcePos = \r\n                (m_delayPos + kiMaxDelay - m_delaySamples + iBufferSize / 2) %\r\n                kiMaxDelay;\r\n```\r\nDoes this work? ', 'comment_created': datetime.datetime(2022, 6, 29, 19, 27, 6, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 910328141, 'comment_body': 'Does this need to be with double precision? I can Imagine that a float calculation is sufficient, but faster on a 32 bit CPU.   ', 'comment_created': datetime.datetime(2022, 6, 29, 19, 31, 58, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 910334627, 'comment_body': 'if you feel lucky you may fiddle around to either use factorized functions or make this loop vetcorized. \r\nThis can be checked like described here: https://github.com/mixxxdj/mixxx/blob/0ad01b6ccc744045fb727eb4e775aa0e52bf4998/src/util/sample.cpp#L14\r\n\r\nThis requires that you chop the loop in chunks to get around the % kiMaxDelay on every sample. \r\n\r\n\r\n\r\n', 'comment_created': datetime.datetime(2022, 6, 29, 19, 40, 43, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 910804485, 'comment_body': 'The ramping is required, to remove click sounds form the stream. This happens due to the steep slope when concatenate two unrelated steams after changing the delay. A peace is cut out or doubled.   \r\nNot ramping in the first half is not relevant here. That was required in the bessel EQ, because it contains an unwanted settling sound of the filter after changing the cut of frequencies. \r\nHere the dry signal is all the way good. ', 'comment_created': datetime.datetime(2022, 6, 30, 9, 21, 15, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 910918145, 'comment_body': 'Mhmm ok, yeah makes sense. But yes, the ramping should be done over the entire buffer (not branching on the index helps with autovectorization) and it should be accomplished using `RampingValue`.', 'comment_created': datetime.datetime(2022, 6, 30, 11, 36, 41, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 910919758, 'comment_body': 'We should refine this anyways. Also rounding up to the next power of 2 helps the optimizer because the expensive modulo operation can be transformed into a binary AND.', 'comment_created': datetime.datetime(2022, 6, 30, 11, 38, 51, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 910973987, 'comment_body': 'Maybe I am a little bit confused. What I think is to construct an object by which I use the class methods. Can you please describe your proposal or what solution you propose?', 'comment_created': datetime.datetime(2022, 6, 30, 12, 35, 49, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 910986284, 'comment_body': ""Yes, I mentioned it few messages [earlier](https://github.com/mixxxdj/mixxx/pull/4810#issuecomment-1167068213). The difference is that the `process()` method works in place and doesn't need a temporary buffer and IMO fits better for the usage in the `EngineEffectChain`."", 'comment_created': datetime.datetime(2022, 6, 30, 12, 48, 48, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 910990916, 'comment_body': 'The reason, why are they duplicated is because of the difference in the `delaySourcePos` value calculation. See [R27](https://github.com/mixxxdj/mixxx/pull/4810/files/f40e7967a7f4b4988342e0930bbd2c8959db07e2#diff-8a31dfcb8638a3ad83fe1f01bcc3403c5918447ac9c8bd62f067c7d8debd1972R27) and [R55](https://github.com/mixxxdj/mixxx/pull/4810/files/f40e7967a7f4b4988342e0930bbd2c8959db07e2#diff-8a31dfcb8638a3ad83fe1f01bcc3403c5918447ac9c8bd62f067c7d8debd1972R55).', 'comment_created': datetime.datetime(2022, 6, 30, 12, 53, 26, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 910999120, 'comment_body': 'Thank you @daschuer for your answer. I agree that the ramping can be done through the whole buffer and `RampingValue` can be used.', 'comment_created': datetime.datetime(2022, 6, 30, 13, 1, 23, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 911133624, 'comment_body': 'You could add a reminder in this commit by adding a `static_assert(mixxx::kEngineChannelCount == 2);` somewhere. Then the compilation would fail if the stereo assumption is violated.', 'comment_created': datetime.datetime(2022, 6, 30, 14, 58, 34, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 911287312, 'comment_body': ""I'm really struggling to read the algorithm in the process function because these membernames don't really explain their purpose. Can you try to name them better?"", 'comment_created': datetime.datetime(2022, 6, 30, 17, 30, 56, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 911467278, 'comment_body': 'Trivial functions like that benefit greatly from inlining which is usually achieved by being implemented in the header.', 'comment_created': datetime.datetime(2022, 6, 30, 21, 44, 49, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 911474242, 'comment_body': 'Not in this case, because it is a virtual function that cannot be inline. ', 'comment_created': datetime.datetime(2022, 6, 30, 21, 57, 55, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 911477421, 'comment_body': ""Right. but what you are doing right now is that you are allocating an instance of `EngineEffectsDelay` on the heap and then storing the point in the `EngineEffectChain`. But you don't have to allocate on the heap. You can just construct the object as part of the owning object. \r\nSince `EngineEffectChain` lives in the audio engine thread, using heap-allocation is a nogo.\r\nNow:\r\n```\r\n ┌─────────────────┐       ┌─────────────────┐\r\n │EngineEffectChain│   ┌──►│EngineEffectDelay│\r\n │                 │   │   │                 │\r\n │m_pEffectDelay ──┼───┘   │...              │\r\n │                 │       └─────────────────┘\r\n │...              │\r\n └─────────────────┘\r\n``` \r\nWhat I propose:\r\n```\r\n\r\n ┌─────────────────────┐\r\n │EngineEffectChain    │\r\n │ ┌─────────────────┐ │\r\n │ │EngineEffectDelay│ │\r\n │ │                 │ │\r\n │ │...              │ │\r\n │ └─────────────────┘ │\r\n │...                  │\r\n └─────────────────────┘\r\n\r\n```\r\nI don't even think that the member would have to be constructed explicitly as it can be default constructed. So I'm basically just proposing to remove the line in question and change the class definition from `std::unique_ptr<EngineEffectsDelay> m_pEffectsDelay;` to `EngineEffectsDelay m_effectsDelay;`."", 'comment_created': datetime.datetime(2022, 6, 30, 22, 4, 14, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 911479677, 'comment_body': 'Yes. I actually thought about it too and IMO it makes more sense from not only a usage but also a performance perspective. Just append the input to `m_pDelayBuffer` in one pass, then copy from the older offset position. That would be vectorizer friendly. The only caveat is that `m_pDelayBuffer` would have to be big enough but that should be trivial to assert.', 'comment_created': datetime.datetime(2022, 6, 30, 22, 9, 16, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 911480068, 'comment_body': 'Mhmm ok, I have not looked much into that because I struggle to understand the arithmetic (as pointed out in the latest review below)', 'comment_created': datetime.datetime(2022, 6, 30, 22, 10, 8, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 911625924, 'comment_body': 'Yes, I can. I used the same names as in the `EngineFilterDelay`, but I agree that names are not quite telling of their purpose.', 'comment_created': datetime.datetime(2022, 7, 1, 5, 29, 42, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 911657029, 'comment_body': 'What do you think about this proposal:\r\n\r\n- _m_delaySamples -> m_newDelaySamples_\r\n\r\n  The purpose of the variable is to keep the actual setting of the number of samples saved. When the delay has changed (via `EngineEffectsDelay::setDelayFrames`), this variable is changed too and the value before the change is kept saved in the m_oldDelaySamples.\r\n\r\n  For the `EngineEffectsDelay` usage in the `EngineEffectChain` it makes sense to use the word ""new"" because before every `EngineEffectsDelay::process` call the delay value is set via `EngineEffectsDelay::setDelayFrames`.\r\n\r\n- _m_oldDelaySamples -> m_prevDelaySamples_\r\n\r\n  The purpose of the variable is to hold the number of delay samples before the last change (""previous delay value""). This value is kept saved for use in ramping when the delay has changed. If the delay hasn\'t changed between two `EngineEffectsDelay::process` calls, the `m_oldDelaySamples` and `m_delaySamples` hold the same value.\r\n\r\n- _m_delayPos -> m_delayBufferWritePos_\r\n\r\n  The purpose of the variable is to hold the position where should be new samples written into the delay buffer (like ""write pointer"" for a ring buffer).\r\n\r\n- _m_pDelayBuffer -> keep the same name_\r\n\r\nWe can discuss the clearness later while the new names will be used in the code, however, I would like to avoid multiple commits that rename variable names only.', 'comment_created': datetime.datetime(2022, 7, 1, 6, 36, 53, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 911680466, 'comment_body': 'Thank you for the tip. Sounds good.', 'comment_created': datetime.datetime(2022, 7, 1, 7, 14, 11, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 911685971, 'comment_body': 'If I am thinking about it again, the calculations will be the same, while the ramping will be changed for the whole buffer version (not only for the second half), which we agreed on before. The code will be much cleaner and we will avoid these statements duplication too.', 'comment_created': datetime.datetime(2022, 7, 1, 7, 22, 9, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 911760194, 'comment_body': '> We have also no definition for a i prefix. 0.508 is a magic number can we name it? What is the unit of kMaxDelay?\r\n\r\nI agree that is a magic number. The value was used from the [EngineDelay](https://github.com/mixxxdj/mixxx/blob/bf98de330910c38bd9b3cf51fb50dbe0188f4690/src/engine/enginedelay.cpp#L11) using maximum delay pot. The value can be changed.', 'comment_created': datetime.datetime(2022, 7, 1, 8, 52, 35, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 911761095, 'comment_body': ""> We should refine this anyways. Also rounding up to the next power of 2 helps the optimizer because the expensive modulo operation can be transformed into a binary AND.\r\n\r\nI agree. That's a good point, thank you."", 'comment_created': datetime.datetime(2022, 7, 1, 8, 53, 35, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 911768012, 'comment_body': ""I agree, it doesn't have to be double and float is a better option."", 'comment_created': datetime.datetime(2022, 7, 1, 9, 1, 30, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 911792910, 'comment_body': ""> The value can be changed.\r\n\r\nYes we should probably change it, which is why I didn't complain about it being a magic constant yet."", 'comment_created': datetime.datetime(2022, 7, 1, 9, 30, 19, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 911830850, 'comment_body': 'Yes, it works.', 'comment_created': datetime.datetime(2022, 7, 1, 10, 17, 58, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 911865870, 'comment_body': 'Oh, clear. Thank you very much for this perfect explanation. It makes much more sense to me now.', 'comment_created': datetime.datetime(2022, 7, 1, 11, 7, 27, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 913253412, 'comment_body': '> m_delaySamples -> m_newDelaySamples\r\n\r\nI would name that `m_currentDelaySamples`. I agree with the rest.', 'comment_created': datetime.datetime(2022, 7, 4, 20, 17, 17, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 913256453, 'comment_body': 'IMO ideal usecase for `std::span` here. \r\n```suggestion\r\n    void AssertIdenticalBufferEquals(const std::span<CSAMPLE> buffer, \r\n            const std::span<CSAMPLE> referenceBuffer) {\r\n```', 'comment_created': datetime.datetime(2022, 7, 4, 20, 28, 42, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 913258100, 'comment_body': 'I\'m not sure if its a good idea to test debug behavior like this. I agree that it makes sense to test whether a type correctly fails when its preconditions are violated, but I don\'t know if its a good idea to test this conditionally. Especially if the ""handling"" of violated pre-conditions is a controlled crash. What are your thoughts @daschuer?', 'comment_created': datetime.datetime(2022, 7, 4, 20, 34, 43, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 913830560, 'comment_body': 'Okay, thank you for this tip.', 'comment_created': datetime.datetime(2022, 7, 5, 13, 56, 56, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 913864188, 'comment_body': 'At least it would be a new pattern in out test code.\r\n\r\nI think it is a kind of paranoia to test test code, on the other hand it is a fixture that guarantees that a certain assertion is not removed and the code is already written. \r\nI have no strong opinion here. Maybe keep the code but not invest time to introduce similar test elsewhere. \r\n\r\n\r\n\r\n ', 'comment_created': datetime.datetime(2022, 7, 5, 14, 27, 15, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 913991841, 'comment_body': ""Well, if this was Rust code with explicit error types, or even C++ with proper exception use, I'd be in favor of testing failure modes. But in mixxx, our error handling is almost non-existent. We just have our `DEBUG_ASSERT`s so we're not flying completely blind in debug builds and in release builds we're just praying nothing will happen. I don't know if it makes sense to test `DEBUG_ASSERT`s which are already a hack in the first place.\r\n\r\nSince the code is already written, lets just keep it as long as the test don't turn out to be flaky. "", 'comment_created': datetime.datetime(2022, 7, 5, 16, 35, 28, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 914057660, 'comment_body': ""I would like to ask you whether you thought `gsl::span` instead of `std::span` from the standard library. I ask this question because Mixxx works with the C++17 standard, but if I'm right, the [span](https://en.cppreference.com/w/cpp/container/span) is in the standard library by C++20."", 'comment_created': datetime.datetime(2022, 7, 5, 18, 0, 57, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 914064758, 'comment_body': ""Okay, I understand your reason for the question if it is a good idea. So, as you wrote, for now, I will keep this code as-is. On the other hand, it isn't a problem to change it."", 'comment_created': datetime.datetime(2022, 7, 5, 18, 10, 6, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 914068776, 'comment_body': 'Well it depends. the main branch now does target C++20 (see #4803) (you might need to rebase on the newest commit). For performance-sensitive code, std::span is preferred because it does not do bounds-checking while the safety-focused gsl::span does. \r\nSee https://github.com/microsoft/GSL/wiki/gsl::span-and-std::span\r\n\r\nI think if you are still on ubuntu 20.04 you might be stuck with an old gcc version that still lacks adequate c++20 support. ', 'comment_created': datetime.datetime(2022, 7, 5, 18, 13, 57, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 914126320, 'comment_body': 'Oh, thank you for the explanation. I am using Ubuntu 22.04.', 'comment_created': datetime.datetime(2022, 7, 5, 19, 11, 10, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 915090833, 'comment_body': ""The code duplication is resolved. Just one thing to the `VERIFY_OR_DEBUG_ASSERT`. IMO after a code change from `unsigned int` to the new variable `kiMaxDelay`, which is a `const int` data type (`constexpr int` after fix), the `static_cast` is not necessary. Anyway, I'm not sure how the checks will react to it."", 'comment_created': datetime.datetime(2022, 7, 6, 17, 27, 7, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 915659655, 'comment_body': 'So, just for summarizing an easy calculation. Following the current calculation, with magic constant 0.508 from `enginedelay.cpp` and using `mixxx::audio::SampleRate::kValueMax`(which is 192 000) and `mixxx::kEngineChannelCount` (which is stereo), the following power of two is 2^18 (262 144) or next 2^19 (524 288). I am thinking about whether it makes sense to think about a greater buffer because the following power of two (2^20) is over 1 million.', 'comment_created': datetime.datetime(2022, 7, 7, 9, 24, 39, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 915925900, 'comment_body': 'Mhmmm. The fact that we need to account for the (unlikely) worstcase (192Khz samplingrate) makes this tradeoff somewhat difficult to evaluate. I wish we could allocate the buffer based on the actual buffer size currently being used instead of the worst case.\r\nWhat do we think is an acceptable maximum delay factor? 2x the current buffer size?', 'comment_created': datetime.datetime(2022, 7, 7, 14, 14, 11, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 915931186, 'comment_body': 'Just make it compile IMO. though try to avoid unnecessary casts.', 'comment_created': datetime.datetime(2022, 7, 7, 14, 18, 51, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 915933194, 'comment_body': ""I'm not sure how much vectorizing potential there actually is. I think the `n % kiMaxDelay` always breaks the autovectorizer because you can't use vectorizing instructions when `n` is at the wrap-around boundary."", 'comment_created': datetime.datetime(2022, 7, 7, 14, 20, 37, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 916177482, 'comment_body': ""Yeah, I agree that it is a little bit tricky, that so big buffer size is possible, but not so common. For the current pitch shift effect version, the delay is about 4 buffer sizes, or more, which is unacceptable. For now, I don't have a specific amount of maximum delay. I think, that about 2 buffer sizes are a good tradeoff. Anyway, I will test the different delay settings, what is maximum delay by ear and feeling (with only using dry signal and cross-fading). I will inform you about the results."", 'comment_created': datetime.datetime(2022, 7, 7, 18, 38, 23, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 916197633, 'comment_body': 'This loop does double the work compared to the non-crossfading benchmarks which I find confusing.', 'comment_created': datetime.datetime(2022, 7, 7, 19, 5, 4, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 916201130, 'comment_body': 'not needed anymore\r\n```suggestion\r\nvoid EngineEffectsDelay::process(CSAMPLE* pInOut,\r\n```', 'comment_created': datetime.datetime(2022, 7, 7, 19, 10, 8, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 916212572, 'comment_body': '```suggestion\r\n    const int delaySourcePos = (m_delayBufferWritePos - m_currentDelaySamples) % kiMaxDelay;\r\n```\r\n$$(b + c - d) \\bmod c \\iff \\\\  (b \\bmod c + c \\bmod c - d \\bmod c) \\bmod c \\iff  (b \\bmod c + 0 - d \\bmod c) \\bmod c \\iff (b - d) \\bmod c$$', 'comment_created': datetime.datetime(2022, 7, 7, 19, 26, 13, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 916221047, 'comment_body': ""> This requires that you chop the loop in chunks to get around the % kiMaxDelay on every sample.\r\n\r\nI missed that in my last note in this thread (which is why that note essentially repeated what you just said). The problem I see is that we simply can't do that. At least the current interface and implementation allows the delay to be any frame frame number. I don't think we can make the interface more granular so we'd have to find a workaround in the implementation."", 'comment_created': datetime.datetime(2022, 7, 7, 19, 38, 19, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 916603864, 'comment_body': 'I agree, that from a mathematical point of view you\'re right. Anyway, from the C++ point of view, the modulo operator for negative values (for example, x % y, where x is a negative value) produces negative values (but in math result value is positive). The addition of delay buffer size is used to ensure positive values, otherwise, the calculation fails on the `""delaySourcePos >= 0""` debug assert.', 'comment_created': datetime.datetime(2022, 7, 8, 8, 49, 11, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 916756331, 'comment_body': 'Do you plan to get rid of this % ? I would prefer a memcpy() based solution:\r\nhttps://github.com/mixxxdj/mixxx/blob/b58dd5bc990a1f6afe7a400e9b9451882c78112a/src/util/sample.h#L53\r\n', 'comment_created': datetime.datetime(2022, 7, 8, 12, 10, 59, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 916829855, 'comment_body': ""Right, good point. I really don't like that we make sure its not negative like this though. I'm sure in the future someone would come along and make the same buggy optimization as I just proposed. Can you at least document that the `+ kiMaxDelay` is necessary?"", 'comment_created': datetime.datetime(2022, 7, 8, 13, 42, 52, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 916835898, 'comment_body': 'use the RAII type `SampleBuffer` instead please. Manual (de-)allocation is error-prone.', 'comment_created': datetime.datetime(2022, 7, 8, 13, 49, 16, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 916837970, 'comment_body': 'IMO this requires some more complicated code to be safe, but it would be a worthwhile optimization too look into. ', 'comment_created': datetime.datetime(2022, 7, 8, 13, 51, 29, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 916871886, 'comment_body': ""Of course, I would like to avoid using these modulo operations. However, as the next step, I will implement the mentioned ring buffer, and then I can try to solve this optimization problem, so for now I still don't have a complete idea of the solution. Thank you for the tip with memcpy(). "", 'comment_created': datetime.datetime(2022, 7, 8, 14, 27, 2, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 916958547, 'comment_body': ""Yes, of course. I think I will create a new PR and document the same tricky part for `EngineDelay` and `EngineFilterDelay` because all these calculations are the same. As you wrote, it could be cool to solve this problem differently, but for now, I can't think of the more optimal solution."", 'comment_created': datetime.datetime(2022, 7, 8, 16, 8, 3, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 917012982, 'comment_body': 'This may serve as a model: \r\nhttps://github.com/mixxxdj/mixxx/blob/b58dd5bc990a1f6afe7a400e9b9451882c78112a/lib/portaudio/pa_ringbuffer.c#L198\r\ncopy in two steps form the current position to the ring wrap around and then the remaining samples.  ', 'comment_created': datetime.datetime(2022, 7, 8, 17, 27, 18, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 917069437, 'comment_body': 'Thank you very much for this tip. It seems like it could be really helpful.', 'comment_created': datetime.datetime(2022, 7, 8, 18, 57, 20, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 917966515, 'comment_body': ""I'm not familiar enough with virtual inheritance but this seems unnecessary to me.\r\n```suggestion\r\n```"", 'comment_created': datetime.datetime(2022, 7, 11, 13, 58, 35, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 917968145, 'comment_body': ""most methods on this class could be const but aren't right now. \r\n```suggestion\r\n    bool isFull() const {\r\n        return getWriteAvailable() == 0;\r\n    }\r\n```\r\n"", 'comment_created': datetime.datetime(2022, 7, 11, 14, 0, 5, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 917972903, 'comment_body': 'Ideally this would be generic, but that would essentially make this about as complex as `std::vector` with all the required SFINAE (or C++20 concepts work)...', 'comment_created': datetime.datetime(2022, 7, 11, 14, 4, 17, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 917974866, 'comment_body': ""You don't need to store that IMO. its already part of the `SampleBuffer` object."", 'comment_created': datetime.datetime(2022, 7, 11, 14, 6, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 917988404, 'comment_body': ""I'm not sure this is correct. I think `sizeof(m_buffer)` only yields the size of the control block (so 16 bytes on x64 because the control block is just a pointer and size)."", 'comment_created': datetime.datetime(2022, 7, 11, 14, 14, 57, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 917995240, 'comment_body': 'Please avoid invasive manipulation like this. Manual handling of sizes and memsetting is prone to cause buffer overflow problems. \r\n```suggestion\r\n    m_buffer.fill(0);\r\n```', 'comment_created': datetime.datetime(2022, 7, 11, 14, 21, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 920172776, 'comment_body': 'please separate this into its own `src/util/span.h` header', 'comment_created': datetime.datetime(2022, 7, 13, 14, 47, 50, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 921023143, 'comment_body': '```suggestion\r\n        return mixxx::span<CSAMPLE>{m_data, static_cast<mixxx::span<CSAMPLE>::index_type>>(m_size)};\r\n```', 'comment_created': datetime.datetime(2022, 7, 14, 10, 52, 52, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 921023354, 'comment_body': '```suggestion\r\n        return mixxx::span<CSAMPLE>{m_data, static_cast<mixxx::span<CSAMPLE>::index_type>>(m_size)};\r\n```', 'comment_created': datetime.datetime(2022, 7, 14, 10, 53, 11, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 922081396, 'comment_body': 'Thank you. Anyway, I think it depends on the version of the system too. On GitHub CI the `index_type` is required, anyway, for example, on my system the `std::size_t` is required. IMO it may depend on the [GSL issue](https://github.com/microsoft/GSL/issues/782).', 'comment_created': datetime.datetime(2022, 7, 15, 11, 32, 33, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 922109704, 'comment_body': 'Yeah... the resulting code is quite verbose but what daniel proposed should work in all cases, we just need to hide that complexity with a couple helper methods.', 'comment_created': datetime.datetime(2022, 7, 15, 12, 16, 8, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 922220871, 'comment_body': 'Oh, okay. Thank you.', 'comment_created': datetime.datetime(2022, 7, 15, 14, 27, 8, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 923543868, 'comment_body': ""since std::transform always does a map. I don't think this is appropriate here... I think you'll just have to iterate over the two spans manually."", 'comment_created': datetime.datetime(2022, 7, 18, 15, 59, 58, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 923652712, 'comment_body': 'more concise IMO\r\n```suggestion\r\n      auto pBufferIterator = std::cbegin(buffer);\r\n      auto pReferenceBufferIterator = std::cbegin(referenceBuffer);\r\n```', 'comment_created': datetime.datetime(2022, 7, 18, 17, 45, 23, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 923653952, 'comment_body': ""Simple by-index for loop would've been okay too."", 'comment_created': datetime.datetime(2022, 7, 18, 17, 46, 4, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 923676951, 'comment_body': 'Okay, so can I use it instead and avoid using iterators in this special case? IMO more readable solution.', 'comment_created': datetime.datetime(2022, 7, 18, 18, 8, 5, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 923682250, 'comment_body': 'Yes, but only because we asserted that the sizes were the same. Alternatively you can use the bounds-checked accessor `span.at(i)` in the loop.', 'comment_created': datetime.datetime(2022, 7, 18, 18, 14, 58, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 923684289, 'comment_body': ""Maybe not so clear, as I expected. The data type has to be explicitly written (can't use auto), to avoid casting, so the solution looks like this:\r\n\r\n```\r\nfor (std::span<CSAMPLE>::size_type i = 0; i < buffer.size(); i++) {\r\n    EXPECT_FLOAT_EQ(buffer[i], referenceBuffer[i]);\r\n}\r\n```\r\n\r\nWhat would you prefer?"", 'comment_created': datetime.datetime(2022, 7, 18, 18, 17, 31, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 923700795, 'comment_body': 'Are you sure, it works for me...\r\nhttps://compiler-explorer.com/z/q77Eaa8jq', 'comment_created': datetime.datetime(2022, 7, 18, 18, 38, 31, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 923701674, 'comment_body': 'Even works on gcc 10', 'comment_created': datetime.datetime(2022, 7, 18, 18, 39, 41, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 923781718, 'comment_body': ""Yeah, it works, that's right. The compiler shows this warning only:\r\n```\r\n/home/david/Documents/CodingFiles/GitWorkspace/Mixxx/mixxx/src/test/engineeffectsdelay_test.cpp: In member function ‘void {anonymous}::EngineEffectsDelayTest::AssertIdenticalBufferEquals(std::span<float>, std::span<const float>)’:\r\n/home/david/Documents/CodingFiles/GitWorkspace/Mixxx/mixxx/src/test/engineeffectsdelay_test.cpp:33:28: warning: comparison of integer expressions of different signedness: ‘int’ and ‘std::span<float>::size_type’ {aka ‘long unsigned int’} [-Wsign-compare]\r\n   33 |         for (auto i = 0; i < buffer.size(); i++) {\r\n      |                          ~~^~~~~~~~~~~~~~~\r\n```\r\n\r\nbut I suppose that the clazy test on CI will fail after updating on Ubuntu 22 still."", 'comment_created': datetime.datetime(2022, 7, 18, 19, 31, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 925605285, 'comment_body': 'Mhmm, its odd that auto defaults to `int` instead of `unsigned int`. Then use the `std::span<CSAMPLE>::size_type` I guess. If you need it more than once, you can hide it behind a `using` alias.', 'comment_created': datetime.datetime(2022, 7, 20, 13, 26, 12, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 925651912, 'comment_body': 'easy optimization / warning workaround (cuz the compiler will warn if you check `size >= 0` on an unsigned type). \r\n`#include <type_traits>`\r\n```suggestion\r\n        if constexpr (std::is_signed_v<S>) {\r\n          VERIFY_OR_DEBUG_ASSERT(size >= 0) {\r\n              size = 0;\r\n          }\r\n        }\r\n```', 'comment_created': datetime.datetime(2022, 7, 20, 14, 6, 10, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 925652994, 'comment_body': 'IMO prefer a namespace over a class with static member functions. ', 'comment_created': datetime.datetime(2022, 7, 20, 14, 7, 5, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 926025327, 'comment_body': 'Oh, thank you. Looks good.', 'comment_created': datetime.datetime(2022, 7, 20, 20, 25, 57, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 926759490, 'comment_body': '```suggestion\r\n```', 'comment_created': datetime.datetime(2022, 7, 21, 14, 38, 19, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 926763112, 'comment_body': '```suggestion\r\n        ASSERT_EQ(buffer.size(), referenceBuffer.size());\r\n```\r\nOtherwise the loop below would overrun. ', 'comment_created': datetime.datetime(2022, 7, 21, 14, 40, 52, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 926965624, 'comment_body': 'Lets just remove this constant for now.\r\n```suggestion\r\nconstexpr int kMaxDelay = mixxx::audio::SampleRate::kValueMax * mixxx::kEngineChannelCount;\r\n```', 'comment_created': datetime.datetime(2022, 7, 21, 18, 1, 15, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 927080542, 'comment_body': ""Oh, thank you. I'm sorry, I overlooked it."", 'comment_created': datetime.datetime(2022, 7, 21, 20, 35, 3, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 927098841, 'comment_body': 'No problem. Thats what code review is for.', 'comment_created': datetime.datetime(2022, 7, 21, 20, 59, 50, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 928140206, 'comment_body': 'great that you were able to figure out the reason the tests failed. I think if you fix this test, we can merge (theoretically, we still need to wait for 22.04).', 'comment_created': datetime.datetime(2022, 7, 23, 16, 19, 44, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 928142827, 'comment_body': 'Okay, I just would like to fix the mentioned delay value issue in this PR too (clamping the delay to [0;kMaxDelay]).', 'comment_created': datetime.datetime(2022, 7, 23, 16, 48, 55, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 928296964, 'comment_body': ""You're subtracting here, isn't that a bug? Also I'd just add another constexpr variable `kMaxDelayFrames` instead. "", 'comment_created': datetime.datetime(2022, 7, 24, 18, 36, 48, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 928297052, 'comment_body': 'please add a comment that this actually tests the clamping of the delay value. ', 'comment_created': datetime.datetime(2022, 7, 24, 18, 37, 45, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 928307394, 'comment_body': ""****\r\n\r\n> You're subtracting here, isn't that a bug? Also I'd just add another constexpr variable kMaxDelayFrames instead.\r\n\r\nThe inspiration was by [EngineDelay](https://github.com/mixxxdj/mixxx/blob/0d1dc9fa448181db8714425b424a754227bc0e1b/src/engine/enginedelay.cpp#L41). The reason of subtraction is, that last valid delay value is `kMaxDelay - 1`. However, clamping delay to this value will cause a switch between channels (for example stereo channels will be swapped). However, with your proposal of `kMaxDelayFrames`, the subtraction wouldn't be needed and only frames value will be compared."", 'comment_created': datetime.datetime(2022, 7, 24, 20, 17, 12, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 939638952, 'comment_body': 'I am unsure about this. Why does this work? I assume it also did not work above with data().\r\nFor my view ""const std::span<CSAMPLE>"" is a ""smart pointer to the non-const CAMPLE.  \r\nIsn\'t a Span() allways const. I think all sub-span functions are const anyway. \r\nIn C++ returning an value type as const does not really make sense. \r\n\r\nConclusion:  I think we can delete replace both functions and replace it with:\r\n `std::span<CSAMPLE> span() const {`\r\n', 'comment_created': datetime.datetime(2022, 8, 7, 9, 45, 49, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 939639254, 'comment_body': 'Can this whole one become a constexpr', 'comment_created': datetime.datetime(2022, 8, 7, 9, 47, 49, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 939639309, 'comment_body': 'and this also constexpr?', 'comment_created': datetime.datetime(2022, 8, 7, 9, 48, 27, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 939639501, 'comment_body': 'By the way, this function is unused. ', 'comment_created': datetime.datetime(2022, 8, 7, 9, 49, 55, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 939670021, 'comment_body': ""> Isn't a Span() allways const.\r\n\r\nNo its not. its a view into contiguous chunk of memory. Whether the memory should be seen as const or non const is defined by the template parameter. \r\n\r\n>  In C++ returning an value type as const does not really make sense.\r\n\r\nYes, sorry that slipped through it should be this instead:\r\n\r\n```suggestion\r\n    std::span<const CSAMPLE> span() const {\r\n```\r\n\r\n> Conclusion: I think we can delete replace both functions and replace it with:\r\n`std::span<CSAMPLE> span() const {`\r\n\r\nNo, that won't work. `std::span<T>` and `std::span<const T>` are different types. In the const member function, all class members are const, so you'd essentially try to construct mutable span into a type that is `const`. Here's a godbolt to demonstrate it: https://compiler-explorer.com/z/KaEcWxGYh\r\n\r\nIts unfortunately a flaw of the language that you can't be generic over the constness. So we have to duplicate the function here with two different signatures in regards to constness. (Rust has the same problem [but is trying to fix that](https://blog.rust-lang.org/inside-rust/2022/07/27/keyword-generics.html))\r\n\r\n> By the way, this function is unused.\r\n\r\nYes, but that doesn't matter because its intended as a library function to be used in the future. Its essentially supposed to replace `Samplebuffer::ReadableSlice`\r\n"", 'comment_created': datetime.datetime(2022, 8, 7, 13, 40, 50, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 939674111, 'comment_body': ""You demonstration is not valid for our case, because the T[100] in your test is also const, because it is part of the constant object memory. In the case of SampleBuffer only the pointer is part of the (const) object. See: \r\nhttps://compiler-explorer.com/z/9To5fvK7P  \r\n\r\nThis means 'std::span<CSAMPLE> span() const {' is valid in the same way like subspan returns a non const template type with a const function: https://en.cppreference.com/w/cpp/container/span/subspan "", 'comment_created': datetime.datetime(2022, 8, 7, 14, 9, 18, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 939675048, 'comment_body': 'I do not relay see the use case for `std::span<const CSAMPLE> span() const {` because SampleBuffer is more used as a factory. \r\nI think we will convert `std::span<CSAMPLE>` to `std::span<const CSAMPLE>` implicit on the fly via function parameters. \r\n', 'comment_created': datetime.datetime(2022, 8, 7, 14, 15, 43, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 939676146, 'comment_body': ""Can you show me the code that achieves that? If we have a const samplebuffer, and we want a view into it. We need an implementation of `std::span<const CSAMPLE> span() const`. If you want example where we'd use that in the mixxx codebase, grep for `SampleBuffer::ReadableSlice`. "", 'comment_created': datetime.datetime(2022, 8, 7, 14, 23, 35, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 939677181, 'comment_body': ""> You demonstration is not valid for our case, because the T[100] in your test is also const, because it is part of the constant object memory. In the case of SampleBuffer only the pointer is part of the (const) object. See:\r\n\r\nOh wow, thats even worse then IMO. that means we have a const object that allows mutable access to the resource it manages. In Rust that's called the interior mutability pattern and its used to provide safe mutable access when otherwise prohibited. In C++ we can not enforce the safety guarantees. SampleBuffer seems to be intentionally written with the RAII guideline in mind that if you have a const Samplebuffer, you can not alter the contents of the buffer within. Your proposal explicitly breaks that if I understand correctly."", 'comment_created': datetime.datetime(2022, 8, 7, 14, 31, 6, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 939677811, 'comment_body': ""> This means 'std::span span() const {' is valid in the same way like subspan returns a non const template type with a const function: https://en.cppreference.com/w/cpp/container/span/subspan\r\n\r\nThats not entirely true. while `std::span::subspan` is a const member func (which makes sense), the span it returns is templated on the `element_type`. So the `decltype(std::span<const T>:subspan())` is still `const T`. With samplebuffer its not the case, we have no way to specify that the underlying buffer is const, so we can only specify it for the SampleBuffer itself. Again, most of the samplebuffer code already explicitly makes that assumption, if the SampleBuffer is const, then the access to the underyling buffer is only const as well. So to follow that convention, we need to provide a `std::span<const CSAMPLE> span() const`. "", 'comment_created': datetime.datetime(2022, 8, 7, 14, 35, 44, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 939678495, 'comment_body': '> SampleBuffer is more used as a factory.\r\n\r\nCan you elaborate? IMO `SampleBuffer` is explicitly not intended as a glorified alligned_malloc. Its supposed to allocate once and then own its content. All access should either be directly through `operator[]` or the Readable-/WriteableSlice classes. `SampleBuffer::data` is an escape hatch and thus should be avoided unless absolutely necessary. ', 'comment_created': datetime.datetime(2022, 8, 7, 14, 40, 41, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 939679086, 'comment_body': '> If we have a const samplebuffer\r\n\r\nWe never have a const samplebuffer, because it always points to non-const samples.   \r\nhttps://github.com/mixxxdj/mixxx/blob/828a189b045050ca6ad5aa053e528e92ce0b8653/src/util/samplebuffer.h#L179\r\n\r\nI have found this: \r\nhttps://github.com/mixxxdj/mixxx/blob/b0a7c9e3ce9996e87146c27ca0c766c8622134a0/src/sources/soundsourcem4a.cpp#L602\r\n\r\nBut this is another class. \r\n\r\nBut anyway, I am in general in favor to only add functions that are used. If you are really sure we need it, we need to rename it because otherwise it makes zero difference due to the implicit conversion between `std::span<CSAMPLE>` to `std::span<const CSAMPLE>` \r\n\r\n\r\n\r\n', 'comment_created': datetime.datetime(2022, 8, 7, 14, 45, 12, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 939680377, 'comment_body': '> Your proposal explicitly breaks that if I understand correctly.\r\n\r\nI think you have mixed up some things. std::span not a container it is ""just"" a pointer which does not own the memory it is pointed to. \r\nWe have: \r\n```\r\nconst std::span<const CSAMPLE> constPointerToConstSampe; // it always points to the same buffer and can\'t change it \r\nstd::span<const CSAMPLE> mutablePointerToConstSampe;  // this allows to let it point to different memory but cant change it  \r\nconst std::span<CSAMPLE> mutablePointerToConstSampe;  // it alwasy points to the same memory, which can be changed.   \r\nstd::span<CSAMPLE> mutablePointerToConstSampe;  // this allows to let it point to different memory, which can be changed\r\n```\r\nIndependent of this most memory functions are also const, that prevents to alter the control structure of std::span.\r\n  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', 'comment_created': datetime.datetime(2022, 8, 7, 14, 54, 34, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 939681653, 'comment_body': ""\r\n> We never have a const samplebuffer, because it always points to non-const samples.\r\n\r\n\r\nYES. But SampleBuffer is supposed to hide that! Thats the entire point of the class! And we do have loads of SampleBuffer::ReadableSlices in our codebase. And we should have more in the future. Its intended as the de-facto way of passing immutable audio buffers. \r\n\r\n> \r\n> I have found this:\r\n> \r\n> https://github.com/mixxxdj/mixxx/blob/b0a7c9e3ce9996e87146c27ca0c766c8622134a0/src/sources/soundsourcem4a.cpp#L602\r\n> \r\n> But this is another class.\r\n> \r\n\r\n`SampleBuffer::ReadableSlice` is just a more boilerplate version of `std::span<const CSAMPLE>`. So we need a way of getting a std::span<const CSAMPLE> in our codebase. If you look at the constructor of `SampleBuffer::ReadableSlice`, it takes a `const SampleBuffer&` so its supposed to be compatible to be used with `const SampleBuffer`s. \r\n\r\n> But anyway, I am in general in favor to only add functions that are used. If you are really sure we need it, we need to rename it because otherwise it makes zero difference due to the implicit conversion between std::span<CSAMPLE> to std::span<const CSAMPLE>\r\n\r\nThis is not a matter of which functions are used and which aren't. Its a question of API and class design and if we don't provide these functions the API is incomplete and its usage will be clunky."", 'comment_created': datetime.datetime(2022, 8, 7, 15, 3, 42, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 939681856, 'comment_body': '> > Your proposal explicitly breaks that if I understand correctly.\r\n> \r\n> I think you have mixed up some things. std::span not a container it is ""just"" a pointer which does not own the memory it is pointed to. We have:\r\n> \r\n> ```\r\n> const std::span<const CSAMPLE> constPointerToConstSampe; // it always points to the same buffer and can\'t change it \r\n> std::span<const CSAMPLE> mutablePointerToConstSampe;  // this allows to let it point to different memory but cant change it  \r\n> const std::span<CSAMPLE> mutablePointerToConstSampe;  // it alwasy points to the same memory, which can be changed.   \r\n> std::span<CSAMPLE> mutablePointerToConstSampe;  // this allows to let it point to different memory, which can be changed\r\n> ```\r\n> \r\n> Independent of this most memory functions are also const, that prevents to alter the control structure of std::span.\r\n\r\nI simply don\'t understand what you are trying to say here. \r\n\r\nI understand what you are saying from a technical perspective, but I don\'t know how that relates to the discussion of providing a `std::span<const CSAMPLE> span() const` overload. ', 'comment_created': datetime.datetime(2022, 8, 7, 15, 5, 15, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 939683708, 'comment_body': 'Ok I think I kinda wrapped my head around this. But I that still leaves major issues:\r\n1. if we implement a `std:span<CSAMPLE> span() const` we allow mutable access to an object which has been crated by const object. While not leading to correctness issues, it goes explicitly against the entire rest of the SampleBuffer API. It breaks consistency severely. \r\n2. The proposed api correctness relies on the coercion with explicit type annotations. Take this code:\r\n```cpp\r\nconst SampleBuffer a{};\r\nconst auto b = a.span();\r\n// const everywhere, still we get mutable access just\r\n// because of the `auto` above. Combine that with\r\n// the former point and we have a severly confusing API\r\nb[0] = 1;\r\n```', 'comment_created': datetime.datetime(2022, 8, 7, 15, 19, 17, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 939692096, 'comment_body': ""Here's another example on how the API would get confusing with your proposal: \r\n\r\n```cpp\r\nconst SampleBuffer a{};\r\n// a[0] = 1; // compile error\r\na.span()[0] = 1; // legal\r\n```"", 'comment_created': datetime.datetime(2022, 8, 7, 16, 26, 48, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 939902113, 'comment_body': '> if we implement a std:span<CSAMPLE> span() const we allow mutable access to an object which has been crated by const object. \r\n\r\nAh OK, that is your point. I was not aware that you are planning to use a ""const SampleBuffer"". For my understanding the std::span should be used to pass the samples around and the SampleBuffer serves only the purpose as a Factory and owner of the memory. So in that case I agree that the pair: \r\n```\r\nstd::span<CSAMPLE> span() {...}\r\nstd::span<const CSAMPLE> span() const {...}\r\n```\r\nIs sensible ', 'comment_created': datetime.datetime(2022, 8, 8, 7, 22, 9, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 940157675, 'comment_body': ""Well, I know that we currently don't really pass `const SampleBuffer`s around, but SampleBuffer is still a container and its written as if it were. So for simplicity's sake I'd follow that API. I agree that views into SampleBuffers should be passed around as `std::span<CSAMPLE>`, I overall still think that the two method API results in a simpler and more predictable API (which we should value IMO). "", 'comment_created': datetime.datetime(2022, 8, 8, 12, 1, 47, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 940159096, 'comment_body': ""Seems like we've found consensus. Thank you very much. "", 'comment_created': datetime.datetime(2022, 8, 8, 12, 3, 29, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 944603237, 'comment_body': 'small oversight from my side\r\n```suggestion\r\n    if constexpr (std::is_signed_v<S> && std::is_unsigned_v<T2>) {\r\n        VERIFY_OR_DEBUG_ASSERT(size >= 0) {\r\n            size = 0;\r\n        }\r\n```', 'comment_created': datetime.datetime(2022, 8, 12, 15, 55, 46, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}]","[{'commit_sha': '461f6f78f181ac82532ba9c57b34f4683ba25ce0', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ad76619f3c5708aa9aa44a467c6ef650b9a1b41b', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'f40e7967a7f4b4988342e0930bbd2c8959db07e2', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '93d2d1923a0f56216dd058a336d60b577f2b88b9', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '97fdb392c1d303a160a6f5daaae94bed167156da', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'a1456a62a196f0004452bf6d8de20630affc4926', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'cc5abdd308af916c0cb77c8e47c092b4d0c91465', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'e958a081d15d784e6a8c2a671f16c345cdd8811b', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '5d2d560a3c98f07fccd4a96d237ea4c37120c5a4', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '4f7515ba26fd352e0bebcee8dd62b2e7c58eab15', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '755c714eb6327783319c91d138290f46f558e35e', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '164e2005dfcca2c0ac25fa73d784057ad0827c57', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'bc7834487758a1b3c4c04aa81566db0b3d98e7e8', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '5f1ea3676f9d815f33ea5a657e07a6521269c63c', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '1b88485b04c6a2d6a725904a9702ce238c0f5e89', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'af331857351c4fe6fa944973ba13fae691223ffb', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '5892a7e9f55038589546a311bc6455cd84e04437', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ea7d77c3ba327c59723758f45c07b676ff054ec3', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '047c3e2cb91f41f7be86554308099a37c62383f5', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '1db08fd1acf465bed95e7c9efb5624d96fb4092f', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'e84b0967cfa795fe6f243ee15d829d73b38d7c90', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '3da53da0d0c96127044385ab1f7bf5cd1848fc55', 'committer_username': 'Swiftb0y', 'committer_name': None, 'committer_email': None, 'commit_date': datetime.datetime(2015, 5, 10, 11, 0, 12, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'b0ed62c573787794aea782b1387db43162f5e785', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ff2fefe09ab3525fd5a68ff9d17bba67c3b60496', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '7107c873fc2f348a6a0e4ec34e290a799561b81f', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ef31bfb06de75e7e349997934fa63bbb3b634712', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '11a83a81215066d80d8e4025b5426214fa9a53fd', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'f40707c89960f7b4d9c4cc5788b57d8d2c0b0936', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '42487b27f4599b9bd13a7c6311f93941001e7ca1', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '79e6681bcc098269f0494a90b2f0d091319daa00', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '1e2d0f2ced42f9b66c143cb5c575bb85c77dbb7c', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '8e193131066bfaa27b15fb058aa17e1e586a69c9', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'f7a38c933a4b669018f2fbb62a4f51e097752e1d', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ad6569110f938699edb9472a95b4846380f9f34a', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '2e14db163e781fcfda687fd46f852a1cf0f85fc4', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '7f00a1aa7e92dfa0a7eb63690a2f8828a2b7ec28', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '8945f3df9e5ec484a8be4f25dba340024c31408e', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '9ffdb1122a242c2300c94015603cb54f2a9f72ea', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '80b92095da3b0c2d9919ddcdba2e4b22e4521412', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '5342307e2d64ffdd7a95e061e2dbb033485eabe2', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}]",David Chocholatý,84876095,,User,,44,,15,14
992170912,Fix EngineDelay and EngineFilterDelay modulo calculation documentation,"Adds documentation for the modulo calculation in the EngineDelay::process and EngineFilterDelay::process.

The mentioned documentation explains the usage of the addition. The added value is the size of the delay buffer, which is used for the modulo operator as well (as a divisor for division). From a mathematical point of view, this addition can be removed.

Anyway, from the cpp point of view, the delay buffer size addition is necessary based on an otherwise negative result using the cpp modulo operator.",True,4848,https://api.github.com/repos/mixxxdj/mixxx/pulls/4848,https://github.com/mixxxdj/mixxx/pull/4848,closed,15,0,2,2,0,0,0,0,[],2022-07-09 07:53:39+00:00,2022-07-09 13:31:40+00:00,20281.0,5:38:01,[],"[{'commit_sha': '0da24c95eb60c319084dcd057c704d4e9f850780', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '8c9294e2b3a28ac3733b8c032547b0e353026a90', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}]",David Chocholatý,84876095,,User,,44,,15,14
994329335,RingDelayBuffer: ring buffer for delay handling,"The new ring buffer is introduced. The use case for the ring buffer is
for delay handling, but it also could be used as a classic ring buffer
with a jumping option with the reading position. It is based
on the classic known ring buffer. The extensions are,
that the ring delay buffer allows moving with the reading position
subject to certain rules. Another difference between the classic
ring buffer is, that the ring delay buffer offers to read zero values,
which were not written by using the write method and write position.
Both of these two specific properties are based on the cross-fading
between changes of two delays.",True,4852,https://api.github.com/repos/mixxxdj/mixxx/pulls/4852,https://github.com/mixxxdj/mixxx/pull/4852,closed,408,0,4,43,16,78,2,0,"[{'name': 'build'}, {'name': 'code quality'}]",2022-07-12 13:57:57+00:00,2022-08-29 19:53:10+00:00,4168513.0,"48 days, 5:55:13","[{'comment_id': 919560729, 'comment_body': ""I'm severely struggling to understand this. \r\nWhy can't we just do `m_readPos = (position + itemsToRead) % m_bufferSize`?\r\nThat removes the power-of-two size limitation, make the bit-twiddling stuff unnecessary, etc.\r\nWe're not calculating the integer mod for each sample, but only once per write call, we can afford that."", 'comment_created': datetime.datetime(2022, 7, 13, 1, 23, 30, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 919562625, 'comment_body': '```suggestion\r\n```\r\ninstead add explanation down below that this is actually only intended to be single-threaded.', 'comment_created': datetime.datetime(2022, 7, 13, 1, 28, 23, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 919563202, 'comment_body': ""The complexity introduced by the current scheme makes it very, very hard for me to review the rest of the code, so I'll refrain from that until we can clear this up."", 'comment_created': datetime.datetime(2022, 7, 13, 1, 30, 5, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 920776566, 'comment_body': 'this can become an unique_ptr', 'comment_created': datetime.datetime(2022, 7, 14, 5, 54, 49, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 920778635, 'comment_body': 'You probably already now this function:\r\nhttps://github.com/mixxxdj/mixxx/blob/9b9fbaafc404f8cfc822f64d356ed3c37e8778c1/src/util/math.h#L41', 'comment_created': datetime.datetime(2022, 7, 14, 5, 58, 32, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 920779550, 'comment_body': 'This should be not necessary. The buffer should never return uninitialized zeros. In out of memory situation the usage code needs to fade to zero to avoid clicks. ', 'comment_created': datetime.datetime(2022, 7, 14, 6, 0, 25, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 920786046, 'comment_body': 'I am not sure if the concept of a member variable m_readPos is still suitable. \r\n\r\nFor my understanding we have the current sample at m_writePos - 1 and the delayed samples before that so the actual read position is m_writePos - ""current delay"" - itemsToRead  \r\n\r\nWe need to make sure this does not hit the end of the buffer. \r\n\r\nIdea: Pass the delay along to the read function?', 'comment_created': datetime.datetime(2022, 7, 14, 6, 12, 37, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 921587514, 'comment_body': ""IMO not needed, also there is `std::bit_ceil` in C++20's `<bit>` header. It's constexpr and also likely faster."", 'comment_created': datetime.datetime(2022, 7, 14, 21, 31, 3, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 921708884, 'comment_body': ""Benchmark supports that its at least equal, though I guess the performance of `bit_ceil` depends very much on whats available on the target architecture (which you can't specify on Quickbench). https://quick-bench.com/q/3FOpFZ_ZaAfJOtWWl1Xx7MFC7JQ"", 'comment_created': datetime.datetime(2022, 7, 15, 0, 20, 50, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 921915348, 'comment_body': ""Initializing values on zero was created, due to it is possible to move with `m_readPos` to left over the left delay buffer bound. For the current code version, it is allowed in the beginning too. Depending on that, the read position can read values, which weren't written by `m_writePos`. If I'm thinking about it, not a good practice. It is possible to allow skipping to the left only if the items were written by `m_writePos` with `VERIFY_OR_DEBUG_ASSERT`."", 'comment_created': datetime.datetime(2022, 7, 15, 7, 59, 57, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 922120709, 'comment_body': 'I think this post is a little bit of coherence with the [post ](https://github.com/mixxxdj/mixxx/pull/4852#discussion_r920779550)by @daschuer. Both of them work with the beginning situation, that the delay is set (the previous delay is zero). New data are written classically from the start of the (ring) buffer. Anyway, for the delay value, it may happen, that the reader will read uninitialized (zero values), probably from the end of (ring buffer), because the read pointer circle to the end through the left buffer border. This situation was allowed because it was possible in the previous delay handling version and in [EngineFilterDelay](https://github.com/mixxxdj/mixxx/blob/main/src/engine/filters/enginefilterdelay.h) too.', 'comment_created': datetime.datetime(2022, 7, 15, 12, 31, 59, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 922122150, 'comment_body': 'To your advice that the modulo operation can be used instead of the bitwise operation. If we do not allow the reading of uninitialized values, it may be used.', 'comment_created': datetime.datetime(2022, 7, 15, 12, 33, 55, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 922243479, 'comment_body': ""Thank you so much for this idea. Sounds cool and I think it cleans up the code a lot. I have just one thing on my mind for two cases. Based on the proposed new version, the ring delay buffer will behave a little bit differently.\r\n\r\n1. If, for example, 8 samples will be written into the ring delay buffer, and then the different amount of samples will be read with zero delays, just propose 4 samples, so, for the previous version, the ring buffer will read the first half of the written samples by index 0, however, the new version will read the second half of the written samples (8 - 0 - 4).\r\n\r\n2. If the write method will be called two times in a row without calling the read method, the situation will be quite similar to the first one.\r\n\r\nFor our future use case for `EngineEffectsDelay`, this cannot happen. Anyway, if I will think only about `RingDelayBuffer`, it may be possible. What do you think about that? I don't want to throw down somehow this idea, I really like it and I would like to use it. I'm only thinking about possible cases, which can happen."", 'comment_created': datetime.datetime(2022, 7, 15, 14, 51, 41, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 933589780, 'comment_body': 'Thank you both for your recommendations. Anyway, after code refactorization which removes the binary operations, the ""power of two"" condition is no longer required.', 'comment_created': datetime.datetime(2022, 7, 29, 20, 17, 26, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 939568546, 'comment_body': 'I would like to re-open a discussion about this idea. I would like to discuss just one thing which I noticed. If the new version will be used, then a lot of checks of delay value have to be run for every `read()` call, probably all code in `moveReadPositionBy()`. Can I ask what is your view on this situation?', 'comment_created': datetime.datetime(2022, 8, 6, 19, 40, 36, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 940230191, 'comment_body': ""It doesn't really make sense to pass value types like SINT as const, especially if you need to copy again afterwards. \r\n```suggestion\r\nSINT RingDelayBuffer::read(CSAMPLE* pBuffer, SINT itemsToRead) {\r\n    const SINT available = getReadAvailable();\r\n```"", 'comment_created': datetime.datetime(2022, 8, 8, 13, 20, 34, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 940236530, 'comment_body': '```suggestion\r\n// The RingDelayBuffer is designed to be single-threaded\r\n// and based on that IS NOT THREAD-SAFE.\r\n```', 'comment_created': datetime.datetime(2022, 8, 8, 13, 26, 33, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 944168198, 'comment_body': 'I do not understand the comment. ', 'comment_created': datetime.datetime(2022, 8, 12, 6, 58, 40, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 944179656, 'comment_body': 'This function is hard to use, because the using code need to keep track of the old and the new delay. \r\nDid you consider to wrap it into a \r\n`SINT read(CSAMPLE* pBuffer, const SINT numItems, const SINT delayItems)` \r\nor such?', 'comment_created': datetime.datetime(2022, 8, 12, 7, 17, 20, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 944205910, 'comment_body': 'I am in doubt that this is correct. m_fullFlag is only relevant when m_readPos = m_writePos;\r\nThe same below. \r\n', 'comment_created': datetime.datetime(2022, 8, 12, 7, 54, 14, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 944210834, 'comment_body': 'The buffer is full if itemsToWrite >= available, not due to crossing the boundaries. ', 'comment_created': datetime.datetime(2022, 8, 12, 8, 0, 39, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 944226807, 'comment_body': 'I think you should zero out the remaining buffer. It does not really make sense to put that work to the using code. \r\nWe may also consider to just return without touching the buffer, or zero out the whole buffer. ', 'comment_created': datetime.datetime(2022, 8, 12, 8, 20, 51, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 945330093, 'comment_body': 'I disagree with this proposal. I see where you are coming from, but IMO designing the read position in a way that you need the delay value to use it is exactly what this ring buffer abstraction is supposed to avoid. ', 'comment_created': datetime.datetime(2022, 8, 14, 19, 1, 15, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 945330643, 'comment_body': 'I think the non-contiguous read and write deserve to be deduplicated by using a helper function.', 'comment_created': datetime.datetime(2022, 8, 14, 19, 6, 30, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 945330918, 'comment_body': 'IMO both read and write methods could be simplified if we used `moveReadPositionBy` internally as well. ', 'comment_created': datetime.datetime(2022, 8, 14, 19, 9, 31, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 945337332, 'comment_body': ""I don't understand the arithmetic here. \r\nlogically it seems to me `readAvailableLeft = getWriteAvailable` would hold."", 'comment_created': datetime.datetime(2022, 8, 14, 20, 14, 47, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 945343008, 'comment_body': 'I came up with this optimization to minimize branch misspredictions. Idk if it actually improves things. I guess just try locally and test if you see a difference in the benchmarks.\r\n```suggestion\r\n    SINT getReadAvailable() const {\r\n        const SINT delta = m_writePos - m_readPos;\r\n        if (delta == 0) [[unlikely]] {\r\n          return m_fullFlag ? m_buffer.size() : 0;\r\n        }\r\n        const SINT range = std::abs(delta);\r\n        return range == delta ? range : m_buffer.size() - range;\r\n    }\r\n```', 'comment_created': datetime.datetime(2022, 8, 14, 21, 11, 11, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 945343156, 'comment_body': '```suggestion\r\n        m_fullFlag = m_readPos==m_writePos;\r\n```', 'comment_created': datetime.datetime(2022, 8, 14, 21, 13, 23, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 945347707, 'comment_body': ""I don't understand why we should require the user code to do book keeping about the read position. The read position is IMHO an implementation detail that should be hidden. The user code has the desired delay already. \r\n "", 'comment_created': datetime.datetime(2022, 8, 14, 22, 1, 38, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 945350579, 'comment_body': 'I think I see what you are saying. In the specific context, this does make sense, but we have an important tradeoff to make here then. If we shift the delay book-keeping into the ringbuffer, the ringbuffer will loose its generality. The only advantage gained by this is possibly nicer code in the consumer, while sacrificing simplicity of the ringbuffer API. IMO there is a good chance the consumer will have to keep track of the latency anyways. And in that case, the only extra code required by the consumer is to call `moveReadPositionBy(oldDelay - newDelay)`.', 'comment_created': datetime.datetime(2022, 8, 14, 22, 30, 8, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 945442595, 'comment_body': 'I would like to join this discussion. As @daschuer mentioned I agree that this code version is a little bit harder to use and the inner implementation is not so hidden. On the other side, as @Swiftb0y mentioned, my first goal was to make the API as general as possible. Anyway, if I\'m thinking about it again, I can\'t think of any other specific use at the moment. If you can think of one, please share. IMO the RingDelayBuffer should be optimized for the purpose it was created first. It can be used as a normal ring buffer too, but I think, that for this purpose it should be better to use the [CircularBuffer](https://github.com/mixxxdj/mixxx/blob/070a475cdddf67b2423c564e3f7cc29ee8d8d455/src/util/circularbuffer.h). The `CircularBuffer` can be extended and improved as well of course for the ""classic"" purpose and I can take this task. But to my main thought which I would like to mention, the previous delay value for the purposed new version has to be stored in the `RingDelayBuffer` to avoid running a complicated structure of reading position checks for every read run (as was mentioned in the discussion the check has to be in user code for the current version or in RingDelayBuffer code for the purposed version, so this check is the same). However, the `EngineEffectsDelay`, for which is RingDelayBuffer actually implemented, stores the previous delay value, so for the current use case the previous delay value information will be duplicated.', 'comment_created': datetime.datetime(2022, 8, 15, 5, 57, 59, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 945487755, 'comment_body': 'Calling `moveReadPositionBy(oldDelay - newDelay)` is probably not what you want, because you need to read a buffer with the old delay first and than with the new delay for crossfading. So we require a `moveReadPositionBy(oldDelay - newDelay - numItems)`. The order of calls is also important. This is IMHO not understandable, without looking into the implementation. You need to understand what the read position is, and where it is initial. Otherwise the boundary checks may hit. \r\n\r\nThe class is `RingDelayBuffer` and the API has nothing with delay in it, I am sure the first time user will expect a function with a delay parameter. Please keep also in mind that we need two consecutive reads, in case the delay has changed. \r\n\r\nThinking about the proposed function again, It turns out that it will even release the implementation from keeping read position and a delay value as member. It allows to freely call API functions without order restrictions: \r\n\r\n```\r\nSINT read(CSAMPLE* pBuffer, const SINT numItems, const SINT delayItems) {\r\n    SINT readPos = m_writePos - numItems - delayItems;\r\n    if (readPos < 0) {\r\n       readPos + m_buffer.size(); \r\n    }\r\n    ....\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n', 'comment_created': datetime.datetime(2022, 8, 15, 7, 34, 18, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 945652633, 'comment_body': 'Sure lets give the delay optimized version a try.', 'comment_created': datetime.datetime(2022, 8, 15, 11, 50, 53, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 945688982, 'comment_body': ""Right, thank you for this point, it really didn't make much sense and was hard to understand the flag handling. The new version should fix this based on the proposed change."", 'comment_created': datetime.datetime(2022, 8, 15, 12, 48, 37, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 945691247, 'comment_body': 'Yeah, it was over-complicated. The comment is removed for the new version.', 'comment_created': datetime.datetime(2022, 8, 15, 12, 50, 56, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 945693332, 'comment_body': 'Based on the new version proposed by @daschuer, this line of code was removed.', 'comment_created': datetime.datetime(2022, 8, 15, 12, 53, 10, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 946045447, 'comment_body': 'If you are interested in it, I have the results on my system:\r\n\r\n**Previous version**\r\n```\r\n----------------------------------------------------------------------------------------------\r\nBenchmark                                                    Time             CPU   Iterations\r\n----------------------------------------------------------------------------------------------\r\nBM_WriteReadWholeBufferNoSkip/64_mean                      528 ns          531 ns           20\r\nBM_WriteReadWholeBufferNoSkip/64_median                    528 ns          531 ns           20\r\nBM_WriteReadWholeBufferNoSkip/64_stddev                  0.513 ns        0.478 ns           20\r\nBM_WriteReadWholeBufferNoSkip/64_cv                       0.10 %          0.09 %            20\r\nBM_WriteReadWholeBufferNoSkip/512_mean                     612 ns          616 ns           20\r\nBM_WriteReadWholeBufferNoSkip/512_median                   613 ns          616 ns           20\r\nBM_WriteReadWholeBufferNoSkip/512_stddev                 0.880 ns        0.988 ns           20\r\nBM_WriteReadWholeBufferNoSkip/512_cv                      0.14 %          0.16 %            20\r\nBM_WriteReadWholeBufferNoSkip/4096_mean                   1339 ns         1370 ns           20\r\nBM_WriteReadWholeBufferNoSkip/4096_median                 1341 ns         1373 ns           20\r\nBM_WriteReadWholeBufferNoSkip/4096_stddev                 6.57 ns         8.56 ns           20\r\nBM_WriteReadWholeBufferNoSkip/4096_cv                     0.49 %          0.62 %            20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/64_mean            535 ns          539 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/64_median          534 ns          538 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/64_stddev         1.03 ns        0.994 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/64_cv             0.19 %          0.18 %            20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/512_mean           617 ns          621 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/512_median         616 ns          621 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/512_stddev        2.98 ns         2.97 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/512_cv            0.48 %          0.48 %            20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/4096_mean         1371 ns         1397 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/4096_median       1375 ns         1405 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/4096_stddev       9.64 ns         12.8 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/4096_cv           0.70 %          0.91 %            20\r\nBM_WriteReadWholeBufferSkipLeftCircle/64_mean              538 ns          542 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/64_median            538 ns          541 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/64_stddev           1.37 ns         1.20 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/64_cv               0.25 %          0.22 %            20\r\nBM_WriteReadWholeBufferSkipLeftCircle/512_mean             621 ns          626 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/512_median           621 ns          626 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/512_stddev         0.396 ns        0.412 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/512_cv              0.06 %          0.07 %            20\r\nBM_WriteReadWholeBufferSkipLeftCircle/4096_mean           1427 ns         1467 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/4096_median         1456 ns         1497 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/4096_stddev         40.4 ns         40.9 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/4096_cv             2.83 %          2.78 %            20\r\n```\r\n**Optimized version**\r\n```\r\n----------------------------------------------------------------------------------------------\r\nBenchmark                                                    Time             CPU   Iterations\r\n----------------------------------------------------------------------------------------------\r\nBM_WriteReadWholeBufferNoSkip/64_mean                      528 ns          532 ns           20\r\nBM_WriteReadWholeBufferNoSkip/64_median                    528 ns          531 ns           20\r\nBM_WriteReadWholeBufferNoSkip/64_stddev                   2.03 ns         1.91 ns           20\r\nBM_WriteReadWholeBufferNoSkip/64_cv                       0.38 %          0.36 %            20\r\nBM_WriteReadWholeBufferNoSkip/512_mean                     619 ns          623 ns           20\r\nBM_WriteReadWholeBufferNoSkip/512_median                   618 ns          622 ns           20\r\nBM_WriteReadWholeBufferNoSkip/512_stddev                  3.65 ns         3.61 ns           20\r\nBM_WriteReadWholeBufferNoSkip/512_cv                      0.59 %          0.58 %            20\r\nBM_WriteReadWholeBufferNoSkip/4096_mean                   1345 ns         1375 ns           20\r\nBM_WriteReadWholeBufferNoSkip/4096_median                 1342 ns         1372 ns           20\r\nBM_WriteReadWholeBufferNoSkip/4096_stddev                 7.18 ns         7.49 ns           20\r\nBM_WriteReadWholeBufferNoSkip/4096_cv                     0.53 %          0.54 %            20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/64_mean            532 ns          537 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/64_median          531 ns          536 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/64_stddev         2.00 ns         1.55 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/64_cv             0.38 %          0.29 %            20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/512_mean           617 ns          621 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/512_median         616 ns          620 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/512_stddev        1.08 ns         1.07 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/512_cv            0.18 %          0.17 %            20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/4096_mean         1366 ns         1395 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/4096_median       1363 ns         1395 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/4096_stddev       5.43 ns         3.70 ns           20\r\nBM_WriteReadWholeBufferSkipLeftNoCircle/4096_cv           0.40 %          0.27 %            20\r\nBM_WriteReadWholeBufferSkipLeftCircle/64_mean              537 ns          542 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/64_median            535 ns          539 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/64_stddev           5.06 ns         5.09 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/64_cv               0.94 %          0.94 %            20\r\nBM_WriteReadWholeBufferSkipLeftCircle/512_mean             625 ns          631 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/512_median           624 ns          630 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/512_stddev          2.83 ns         2.74 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/512_cv              0.45 %          0.43 %            20\r\nBM_WriteReadWholeBufferSkipLeftCircle/4096_mean           1387 ns         1425 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/4096_median         1388 ns         1424 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/4096_stddev         2.15 ns         2.00 ns           20\r\nBM_WriteReadWholeBufferSkipLeftCircle/4096_cv             0.15 %          0.14 %            20\r\n```', 'comment_created': datetime.datetime(2022, 8, 15, 19, 10, 18, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 946049197, 'comment_body': 'I agree, sounds reasonable and good. It will be a lot cleaner approach. Thank you @daschuer.', 'comment_created': datetime.datetime(2022, 8, 15, 19, 15, 15, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 946055858, 'comment_body': 'Could be. To me, the version that it will be just returned from the function without touching the buffer looks more intuitively. The zero value will be returned and the user code can handle this situation on its own. IMO clearing the buffer looks like a little bit of unexpected behaviour to me, but that is just my view about it.', 'comment_created': datetime.datetime(2022, 8, 15, 19, 24, 53, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 946087871, 'comment_body': 'Interesting. So at least its not a pessimization. What are your thoughts @daschuer?', 'comment_created': datetime.datetime(2022, 8, 15, 20, 12, 15, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 946169918, 'comment_body': 'Sorry, but according the benchmarks, it is a pessimization. \r\nI think it is because we have now three branches, instead of one. The if, inside std::abs() and the conditional assignment.\r\nEvery branch is likely flushing the pipeline. The [[unlikely]] may help here though. \r\n\r\nThe best optimization is to dispose the whole function. Because we actually have always size() readable. This is true even after initialization where we have zeros available. \r\n', 'comment_created': datetime.datetime(2022, 8, 15, 22, 13, 5, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 946206606, 'comment_body': ""> Sorry, but according the benchmarks, it is a pessimization.\r\n\r\nWell, IMO the difference is not clear enough to make a clear decision.\r\n\r\n> I think it is because we have now three branches, instead of one. The if, inside std::abs() and the conditional assignment.\r\n\r\nOptimistically speaking, the resulting code could only have a single branch.\r\n```cpp\r\nif (delta == 0) [[unlikely]] {\r\n  return m_fullFlag ? m_buffer.size() : 0;\r\n}\r\n```\r\nThis results in a single branch which is very unlikely (the `[[unlikely]]` attribute probably doesn't change that, the branch predictor could pick that up by itself). The ternary statement afterwards is just a `cmove` (assuming `m_buffer.size()` is inlined). This branch is still cheap though because we can assume its taken so seldomly, so we only pay the cost of the compare. \r\n```\r\nconst SINT range = std::abs(delta);\r\n```\r\n\r\nTheoretically, std::abs can be implemented branchless for integers. Not sure how the standard does it.  My guess is that std::abs is probably the bottleneck if it can't get inlined (which is the case for some c apis).\r\n\r\n```cpp\r\nreturn range == delta ? range : m_buffer.size() - range;\r\n```\r\nthis results in a branch because I was careless. If we pull out the `m_buffer.size() - range` and compute that unconditionally, this ternary could be a `cmove` as well. \r\n\r\n\r\nIn the end, the branchless version probably has less mispredictions, though it probably suffers from data-dependency problems which also lead to bubbles in the pipeline. \r\n\r\nIn the end, it doesn't seem to matter what method we use. If for some reason the alternative implementation wouldve been >2x faster, than I'd advocate for using that, but since it doesn't make a difference, the previous version is probably better because its code is much more readable."", 'comment_created': datetime.datetime(2022, 8, 15, 23, 3, 30, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 946341102, 'comment_body': ""> If for some reason the alternative implementation wouldve been >2x faster, than I'd advocate for using that, but since it doesn't make a difference, the previous version is probably better because its code is much more readable.\r\n\r\nI am on the same. It is not a problem to use the optimised version. Anyway, I expected better results for that, so, I agree to keep the first more readable version. \r\n"", 'comment_created': datetime.datetime(2022, 8, 16, 5, 8, 16, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 946376062, 'comment_body': 'Ok', 'comment_created': datetime.datetime(2022, 8, 16, 6, 19, 42, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 948253711, 'comment_body': 'Due to optimizing the `RingDelayBuffer::read` this line of code was removed.', 'comment_created': datetime.datetime(2022, 8, 17, 17, 48, 57, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 948254817, 'comment_body': 'Due to optimizing the `RingDelayBuffer::read` the `moveReadPositionBy` function was removed.', 'comment_created': datetime.datetime(2022, 8, 17, 17, 50, 10, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 948300539, 'comment_body': 'Could be. I would like to propose, that another option is to move the whole data read/write handling into the helper function (contiguous and non-contiguous). This code part is in fact same for the read and write but just with swapped destination and source buffer (input/output buffer and inner ring buffer). What do you think about it?', 'comment_created': datetime.datetime(2022, 8, 17, 18, 46, 14, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 949552975, 'comment_body': 'Right that was exactly why I proposed to deduplicate it.', 'comment_created': datetime.datetime(2022, 8, 18, 20, 10, 37, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 950881003, 'comment_body': ' Since this is a free function now, we this can go to an an anonymous namespace or if we think we can use it elsewhere, it can be moved sample.cpp. \r\nThis is not a plain copy it is a `copyRing()` or such. \r\n\r\nDoes it work if the source sourcePos AND destPos are not 0? I think not. We may either assert that or add the case with three copy calls. ', 'comment_created': datetime.datetime(2022, 8, 21, 18, 3, 51, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 950882090, 'comment_body': '```suggestion\r\n    VERIFY_OR_DEBUG_ASSERT(shift <= m_buffer.size()) {\r\n```', 'comment_created': datetime.datetime(2022, 8, 21, 18, 14, 20, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 950882164, 'comment_body': '```suggestion\r\n    VERIFY_OR_DEBUG_ASSERT(itemsToWrite <= m_buffer.size()) {\r\n```', 'comment_created': datetime.datetime(2022, 8, 21, 18, 15, 3, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 950882965, 'comment_body': 'This makes assumption of the behavior of copy() and is not correct in the case of an early return.\r\nOne option is to pass m_writePos by pointer. The same goes for itemsToRead above. ', 'comment_created': datetime.datetime(2022, 8, 21, 18, 22, 37, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 951574842, 'comment_body': 'The mentioned problems should be fixed, to summarise:\r\n- `copy() `renamed to `copyRing()`\r\n- `copyRing()` is moved into an anonymous namespace and serves as a helper function only\r\n\r\n> Does it work if the source sourcePos AND destPos are not 0? I think not. We may either assert that or add the case with three copy calls.\r\n\r\nI think I understand, what you mean. IMO for the case that such a huge `numItems` value will be provided, which will be many times greater than the size of the source and destination buffer too, it would be needed much more copies than just three. It cannot occur for the actual usage but may be possible. Based on that multiple copies would not be used now, I would prefer the assert-way solution.', 'comment_created': datetime.datetime(2022, 8, 22, 15, 21, 59, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 951606126, 'comment_body': 'Right, thank you for this hint. Based on the latest changes for the `copyRing()` the fix for this bug should be included.', 'comment_created': datetime.datetime(2022, 8, 22, 15, 51, 36, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 951643505, 'comment_body': ""I have an other (unused) case in mind for three copies: Copy from a ring to a ring.\r\n\r\nSource:\r\n123456789\r\n\r\nDestination\r\n123456789\r\n\r\nCopy 8 samples \r\nRead pointer at 5 write pointer at 7\r\nCopy\r\n5...7 to 7...9 (3)\r\n7...9 to 1..3 (3)\r\n1..2 to 4..5\r\n\r\nThis can't happen if one of the pointers points to the start. \r\n\r\n"", 'comment_created': datetime.datetime(2022, 8, 22, 16, 28, 12, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 951644386, 'comment_body': 'Asserting that this not happens works for me.', 'comment_created': datetime.datetime(2022, 8, 22, 16, 29, 10, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 951649055, 'comment_body': 'Oh I missed that you did it already.\r\nThank you. ', 'comment_created': datetime.datetime(2022, 8, 22, 16, 34, 15, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 952803016, 'comment_body': ""shouldn't this just do the contiguous copy instead of returning early?"", 'comment_created': datetime.datetime(2022, 8, 23, 15, 48, 33, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 952807765, 'comment_body': ""I'm planning to deprecate `mixxx::SampleBuffer::*Slice`. Why not use `std::span` instead?"", 'comment_created': datetime.datetime(2022, 8, 23, 15, 52, 12, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 952822843, 'comment_body': 'I think this breaks if both buffers would requires non-contigous reads. \r\n```\r\ncopying 6 items of a buffer of length 8:\r\ninput:\r\n0000|00 00xxxx\r\n1111 11|11xxxx\r\nafter first copy:\r\n 000000|00xxxx\r\n|111111 00xxxx\r\nafter second copy:\r\n0000 0000xx|xx\r\n00xx|1100\r\n``` \r\nxx is out-of-bounds data/memory', 'comment_created': datetime.datetime(2022, 8, 23, 16, 3, 26, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 952824174, 'comment_body': 'same here, this should just be a non-contiguous read imo', 'comment_created': datetime.datetime(2022, 8, 23, 16, 4, 31, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 952825095, 'comment_body': '```suggestion\r\n    SINT copiedItems = 0;\r\n```\r\navoid potentially uninitialized memory (in case on of the below branches change).', 'comment_created': datetime.datetime(2022, 8, 23, 16, 5, 17, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 952838033, 'comment_body': 'Than we have half the destied result which may worse. Since this is a not used case in this anonymous namespace function, asset and return 0 is a good choice. IMHO \r\n', 'comment_created': datetime.datetime(2022, 8, 23, 16, 15, 32, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 952839318, 'comment_body': 'That is why we asset that is does not happen above. ', 'comment_created': datetime.datetime(2022, 8, 23, 16, 16, 33, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 952840153, 'comment_body': 'For what? ', 'comment_created': datetime.datetime(2022, 8, 23, 16, 17, 13, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 952845772, 'comment_body': 'Ah yes, I misinterpreted the code above. That makes sense now. ', 'comment_created': datetime.datetime(2022, 8, 23, 16, 21, 18, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 952848628, 'comment_body': 'My mistake. I got the behavior of `VERIFY_OR_DEBUG_ASSERT` mixed up.', 'comment_created': datetime.datetime(2022, 8, 23, 16, 23, 33, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 952934875, 'comment_body': 'Of course, `std::span` can be used. I thought, that I should rather work with span through `SampleBuffer` and forgot, that I can call the `mixxx::spanutil::spanFromPtrLen()` directly.', 'comment_created': datetime.datetime(2022, 8, 23, 17, 35, 8, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 952951627, 'comment_body': ""Okay, I'm not just sure how the checks will react on it due to my IDE shows me, that _the value is never used_. I will try it."", 'comment_created': datetime.datetime(2022, 8, 23, 17, 54, 35, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 952954315, 'comment_body': 'Such preventive initialization will hide real errors (variable not set in one branch) from the static code analysis done by the compiler.', 'comment_created': datetime.datetime(2022, 8, 23, 17, 57, 36, tzinfo=datetime.timezone.utc), 'commenter': 'JoergAtGithub', 'type': 'User'}, {'comment_id': 952983747, 'comment_body': ""To be honest, I wouldn't bet on the fact that static analysis will catch this. Technically it can, in practice it might (assuming we even set the right compiler flags). IMO its better to analyze a variable early than possibly not all. If we really want to avoid this entirely, we can do a instead use an IILE and return the value instead, then I'd be confident for the compiler to catch the issue."", 'comment_created': datetime.datetime(2022, 8, 23, 18, 32, 27, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 952985621, 'comment_body': ""> Okay, I'm not just sure how the checks will react on it due to my IDE shows me, that _the value is never used_. I will try it.\r\n\r\nMhmm interesting. \r\nThen here is the lambda solution I mentioned:\r\n```cpp\r\nconst int numItems = [&]() {\r\nif (m_firstInputBuffer) {\r\n        // If the first input buffer is written, the first sample is on the index 0.\r\n        // Based on the checking of an available number of samples, the situation,\r\n        // that the writing will be non-contiguous cannot occur.\r\n        // The itemsToWrite value is multiply by 2 to\r\n        SampleUtil::copyWithRampingGain(m_buffer.data(), pBuffer, 0.0f, 1.0f, itemsToWrite);\r\n        m_firstInputBuffer = false;\r\n        return itemsToWrite;\r\n    } else {\r\n        return copyRing(ReadableSlice(pBuffer, itemsToWrite),\r\n                0,\r\n                WritableSlice(m_buffer.data(), m_buffer.size()),\r\n                m_writePos,\r\n                itemsToWrite);\r\n    }\r\n\r\n}();\r\n```"", 'comment_created': datetime.datetime(2022, 8, 23, 18, 34, 51, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 953020669, 'comment_body': 'However, all CI tests passed, but based on the previous discussion, I would prefer the lambda solution. I thought about it too and it looked like it can look overcomplicated, but when I see your solution now, IMO it is quite clean.', 'comment_created': datetime.datetime(2022, 8, 23, 19, 19, 9, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 953040319, 'comment_body': 'Just one thing, I changed the `int` to `SINT` due to it is returned from the lambda expression and the same type returns the `RingDelayBuffer::write` function. Just please a little clear up for me, what do you mean by this phrase: _""The itemsToWrite value is multiply by 2 to""_?', 'comment_created': datetime.datetime(2022, 8, 23, 19, 34, 28, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 953048731, 'comment_body': 'I ask myself the same. I just copy pasted the comment from the source. ', 'comment_created': datetime.datetime(2022, 8, 23, 19, 46, 9, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 955104073, 'comment_body': 'Right, you just use `spanFromPtrLen` as an adapter so to speak and then try to use std::span as much as possible in any APIs that take the usual `(pointer, size)` pair. ', 'comment_created': datetime.datetime(2022, 8, 25, 15, 20, 6, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 957384499, 'comment_body': '```suggestion\r\n    SINT read(std::span<CSAMPLE> destinationBuffer, const SINT delayItems);\r\n\r\n    /// The method writes items from the pBuffer into the ring buffer.\r\n    /// The number of items that will be written is passed through\r\n    /// the itemsToWrite parameter. This value has to be smaller or equal\r\n    /// to the ring buffer size. Otherwise, the items are not written\r\n    /// and the method returns the zero value. The first chunk of items\r\n    /// after creating of ring delay buffer or after clean-up is ramped\r\n    /// by using fading-in.\r\n    SINT write(std::span<const CSAMPLE> sourceBuffer);\r\n```\r\nsmall nitpick to use spans in the API as well... ', 'comment_created': datetime.datetime(2022, 8, 29, 14, 8, 1, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 957574929, 'comment_body': ""Didn't we already merge the PR containing `SampleBuffer::span`?\r\nIt would cut down on boilerplate code considerably in all tests. \r\n```suggestion\r\n        m_ringDelayBuffer.write(input.span());\r\n        m_ringDelayBuffer.read(output.span(), 0);\r\n        m_ringDelayBuffer.write(input.span());\r\n        m_ringDelayBuffer.read(output.span(), 0);\r\n```"", 'comment_created': datetime.datetime(2022, 8, 29, 16, 53, 53, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}]","[{'commit_sha': '88a160b74e128148ca8b49debfb8c69f885c9c3f', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ccb96508c38dbbd4b34eb136928c51743c5ab451', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '207d26f608a966dff636901caeecd69a3d734c4d', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '785f636ead9679a85445741bf9fe6c6779141760', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'a1551578794b2adc3ed1bc10d7d0182bc2beac8d', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'eeb6e6d11b3a89057589ec00d08a899b3bbd8caa', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'cb2d57bf0c1ce9d54e7f277769655ba629b0ace7', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '1dd8830499153b3c809a569da427f4cca26d1ff4', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '8f264388b25bf598d835c1975f6ac41fb58803ef', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '36d92d268e044876ad05bbd9739c6c45a66f798b', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '248f38e95885000e2f658be01c590bcf711e3619', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '4e6a1ef02303346ab68e8fc721b2ed68a3cc79f9', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'd6565e7868c2379276af5e8b69ebeea27679e780', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '0bfd1683ead56e69413d417a3833070923990353', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '9ef5752878b95ef59c5831a0bbeb3ebfcb17fbab', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '5772334d8446365c84394b269544355d95eb5705', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'de60af2f9227226eec9611df728f84391e4fdc2d', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '77181a8036a04981b1021c3ef517a0ac19ed703e', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '1df0fbbc10878624923e87f8ad6e7afcf900bc0b', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '7c2610e2efde5cc6d01d1bd98e8bb5142851fa5d', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '95182eab054f9014abd4498832fcf691150d2f1e', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '90f9772d7a1573fb4fe3236fe8513df82121b6e5', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'dd4980a0a9cb7be0ec4f306a899009f3ea88a387', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'adf2454662208b572bd55d55a054538df6afdb97', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '0a61a7ba1638f3b17da41a8cd437cb22a7ac9820', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'c6a6c3a86fd10f107e9612fed4152a6848c7038d', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'e3638b4ec5e369c65ead2724c65c39a760caa2a8', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'b95d6be89a0b332bb42576cadc240ad2956555dd', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'b73a2b58d79db0d6a1cc6a8166dd2d67e6ff901c', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '2b2a7a3f3a4dbea0a6e9c5de898b4a086a10e09b', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '0f4729f0b6d674a1439681dba668a78750ca6c34', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'c683b41e6382b89122970aeb603378383f468c3e', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '08285352d095186c7dfa558886d86f6148f0f347', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '6e212af7a4299d7c2a0ed91c26fa08aa1a5a604d', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ac546948dbd3dfea9f09e8fb6b8e21255d9363bf', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '6ee66034e668c3d3ed59b37be4516e658b46dbfc', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'bc6240a51099b4da8090d2e081d192be46880510', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '74b52eac92d2d1b36855ad6c8d649b9f277c6590', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '9addec279ae6ce23745fd0bdb2d60231b09fcd15', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '8076e29572e06acacd624c132d1646dc32791327', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'd886d09bc4ec48c88a9dd5abb36ef96939a86a07', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '6c22c409e027bec8883295788c7928251126f601', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'b686546eaf55a71024c88badba5c053c2a2424c2', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}]",David Chocholatý,84876095,,User,,44,,15,14
1001216000,[rubberband] add overlayed rubberband v3,"This PR is based on the vcpkg implementation for microsoft/vcpkg by @daschuer for RubberBand v2.0.2 ([see #24549](https://github.com/microsoft/vcpkg/pull/24549)). The code was used on 19 Jul. 2022 with the current PR version. It was moved into overlayed ports and replaces with the previous code. At the same time, the RubberBand version was changed to v3.0.0.",True,48,https://api.github.com/repos/mixxxdj/vcpkg/pulls/48,https://github.com/mixxxdj/vcpkg/pull/48,closed,77,41,4,6,3,0,0,0,[],2022-07-19 20:28:56+00:00,2022-08-06 22:01:45+00:00,1560769.0,"18 days, 1:32:49",[],"[{'commit_sha': '48cacddf2aa429302c862618d85773a292758367', 'committer_username': 'dreuter', 'committer_name': 'Daniel Reuter', 'committer_email': 'daniel.robin.reuter@googlemail.com', 'commit_date': datetime.datetime(2010, 5, 6, 15, 35, 14, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'b0e82df169b6e9ee9f983a343acbcbbb7ebc8552', 'committer_username': 'daschuer', 'committer_name': 'Daniel Schürmann', 'committer_email': None, 'commit_date': datetime.datetime(2012, 5, 25, 9, 53, 25, tzinfo=datetime.timezone.utc)}, {'commit_sha': '440cd531d7048b58ed1e939d9299f3cb221a08ac', 'committer_username': 'daschuer', 'committer_name': 'Daniel Schürmann', 'committer_email': None, 'commit_date': datetime.datetime(2012, 5, 25, 9, 53, 25, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'c4fdb6827d09c09baa94601758a3b737bee85dc0', 'committer_username': 'daschuer', 'committer_name': 'Daniel Schürmann', 'committer_email': None, 'commit_date': datetime.datetime(2012, 5, 25, 9, 53, 25, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ae7a9b3a594fc659a23e4638073e6f5db92536e7', 'committer_username': 'daschuer', 'committer_name': 'Daniel Schürmann', 'committer_email': None, 'commit_date': datetime.datetime(2012, 5, 25, 9, 53, 25, tzinfo=datetime.timezone.utc)}, {'commit_sha': '9cd401ea7f557189b7756c287cf708c3c8069905', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}]",David Chocholatý,84876095,,User,,44,,15,14
1008073809,EngineFilterDelay: clamp wrong delay values,"This PR moves the delay value checking into a setter in `EngineFilterDelay`. The reason, why the delay value checking should be updated is, that the previous version allows working with a huge not acceptable delay, but which is after inner calculation allowed due to it is a k-multiple (on the left side of the modulo operator) of the delay buffer size (on the right side of the modulo operator). Three examples for which is in previous version delay allowed, and should not be:

Let's work with the used size of the delay buffer as `SIZE = 3300`.

1. The first example works with delay size as 4*3300 = 13200
`
int delaySourcePos = (m_delayPos + SIZE - m_delaySamples) % SIZE = (0 + 3300 - 13200) % 3300 = -9900 % 3300 = 0
`

2. The second example works with a huge delay, but which is the same as `m_delayPos + SIZE`.
`
int delaySourcePos = (m_delayPos + SIZE - m_delaySamples) % SIZE = (2426 + 3300 - 5726) % 3300 = 0 % 3300 = 0
`

3. The third example works with the situation similar to 1, anyway, it shows that the position has not to be zero.
`
int delaySourcePos = (m_delayPos + SIZE - m_delaySamples) % SIZE = (1024 + 3300 - 7624) % 3300 = -3300 % 3300 = 0
`

Based on the delay value checking in the setter, the situation, that the previous used `VERIFY_OR_DEBUG_ASSERT` will be violated should not occur.",True,4869,https://api.github.com/repos/mixxxdj/mixxx/pulls/4869,https://github.com/mixxxdj/mixxx/pull/4869,closed,14,26,1,2,2,9,0,0,[],2022-07-26 05:40:09+00:00,2022-07-26 13:31:25+00:00,28276.0,7:51:16,"[{'comment_id': 929545947, 'comment_body': 'You may put a static_assert for this condition as well. That will fail the build in that case.', 'comment_created': datetime.datetime(2022, 7, 26, 5, 45, 6, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 929548138, 'comment_body': 'Can you also assert here that the delay is devide-able by the channel count? \r\nThis way we can below just use `< SIZE` which is easier to understand.', 'comment_created': datetime.datetime(2022, 7, 26, 5, 49, 2, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 929550956, 'comment_body': 'The original code just performs a. copy.\r\n(Delay = 0) in that case. Since we are anyway In an anti crash backup path, I find mind, I just want to pint it out.', 'comment_created': datetime.datetime(2022, 7, 26, 5, 54, 4, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 929552456, 'comment_body': 'Is this condition correct, or do we need to substract the engine  buffer size? \r\n', 'comment_created': datetime.datetime(2022, 7, 26, 5, 56, 51, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 929576522, 'comment_body': ""I agree, that's right. This PR just offers another point of view for the problem, that the wrong delay values can be clamped in the setter. This version should be anti-crash too. Of course, I will be okay, if the PR won't be merged. It is just proposed to use a more similar approach as in [EngineDelay](https://github.com/mixxxdj/mixxx/blob/f2d670edeb483efb066bf7f00255d01df2f0017c/src/engine/enginedelay.cpp) or the future used `EngineEffectsDelay`."", 'comment_created': datetime.datetime(2022, 7, 26, 6, 36, 33, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 929580376, 'comment_body': 'Agree, that is really more clear way.', 'comment_created': datetime.datetime(2022, 7, 26, 6, 41, 48, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 929646159, 'comment_body': 'Can you please explain more about why you think of substracting the engine buffer size instead and which ""engine buffer size"" you think of? The size of the input buffer? The reason, why the number of channels is subtracted is, that the delay size can\'t be equal to the size of the delay buffer (`m_buf`). It can be smaller and subtracting the number of channels ensures, that the channels won\'t be swapped between. IMO the assertion shouldn\'t go wrong as original, because it doesn\'t allow the delay values greater than possible (greater or equal to buffer size), so the `m_delaySamples` values from the examples wouldn\'t be allowed.', 'comment_created': datetime.datetime(2022, 7, 26, 7, 58, 37, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 929966372, 'comment_body': 'Ah sorry, I have misread the code. In case of 0 delay, you but one frame into the buffer and read it back immediately. \r\nThat is why `- mixxx::kEngineChannelCount` is sufficient. ', 'comment_created': datetime.datetime(2022, 7, 26, 13, 29, 24, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 930029450, 'comment_body': 'No problem. Perfect.', 'comment_created': datetime.datetime(2022, 7, 26, 14, 22, 3, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}]","[{'commit_sha': '855be7275b5b9b26da9610b28afa46e0a0506e23', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '33c6e0da5108b0b321d285fd195977669dff54a7', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}]",David Chocholatý,84876095,,User,,44,,15,14
971290657,EngineEffectsDelay: effects chain delay handling,"Solves the delay issue for the effects chain. The solution
is useful for the dry/wet or dry+wet mode. If the effects chain
has a specific delay based on the effects processing latency,
the dry signal is delayed to ensure dry and wet signals overlap.
To delay the dry signal, the sum of all chain effects group delay
is calculated. In the current version, the solution is especially used
for the Pitch shift effect. The known issue is, that the Pitch shift
effect doesn't provide the right amount of latency and the delay
is pretty huge. This problem has to be solved for the Pitch shift
effect implementation first. The effect group delay propagation
was implemented through the use of the EffectProcessorImpl,
EffectProcessor and EngineEffect. The special class wasn't created
for the purpose to preserve the hierarchy of effects implementation
as much as possible.",True,4810,https://api.github.com/repos/mixxxdj/mixxx/pulls/4810,https://github.com/mixxxdj/mixxx/pull/4810,closed,686,2,12,40,70,154,2,1,"[{'name': 'build'}, {'name': 'code quality'}]",2022-06-18 14:20:49+00:00,2022-08-14 22:32:56+00:00,4954327.0,"57 days, 8:12:07","[{'comment_id': 901002888, 'comment_body': ""It would make more sense to enforce the fact that this can't be the case in the caller. Use the `M_RESTRICT` macro from `util/platform.h`\r\nhttps://en.wikipedia.org/wiki/Restrict"", 'comment_created': datetime.datetime(2022, 6, 18, 18, 17, 17, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 901003047, 'comment_body': ""I don't see much use in a private setter to be honest. "", 'comment_created': datetime.datetime(2022, 6, 18, 18, 19, 18, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 901003107, 'comment_body': 'Use SINT for indexing or quantities of samples.\r\n```suggestion\r\nSINT PitchShiftEffect::getGroupDelay() {\r\n    return m_groupDelay;\r\n}\r\n```', 'comment_created': datetime.datetime(2022, 6, 18, 18, 20, 3, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 901003192, 'comment_body': 'Can you explain this a bit better? why the method exists and what its return value means and how its supposed to be used?', 'comment_created': datetime.datetime(2022, 6, 18, 18, 21, 15, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 901003221, 'comment_body': 'implement in the header instead?', 'comment_created': datetime.datetime(2022, 6, 18, 18, 21, 44, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 901003489, 'comment_body': 'make class final and implement the simple setter here to allow for inlining.', 'comment_created': datetime.datetime(2022, 6, 18, 18, 25, 4, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 901003571, 'comment_body': 'is this class supposed to be inherited from? If not make it final and its protected member private.', 'comment_created': datetime.datetime(2022, 6, 18, 18, 25, 55, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 901061037, 'comment_body': 'I think it would be better to format this in frames.\r\nCan this ever be a float? Can we put the unit into the function name? ', 'comment_created': datetime.datetime(2022, 6, 19, 7, 27, 36, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 901061326, 'comment_body': 'We need to be careful not to swap stereo channels.\r\nI think if we make the group delay by frames it is solved automatically.', 'comment_created': datetime.datetime(2022, 6, 19, 7, 30, 8, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 901061988, 'comment_body': 'New is locking and must not be called from the engine.\r\nJust allocated a reasonable maximum during the constructor.', 'comment_created': datetime.datetime(2022, 6, 19, 7, 35, 43, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 901130872, 'comment_body': ""> I think it would be better to format this in frames.\r\n\r\nI think it could be maybe possible. Anyway, I would like to mention a few reasons, why the samples option was used.\r\n\r\nFirst is, that the EngineEffectsDelay is based on the [EngineFilterDelay,](https://github.com/mixxxdj/mixxx/blob/935ba94f7e498eebd7c3710b2f0df35d989d9a7d/src/engine/filters/enginefilterdelay.h#L34) which uses samples and the thought was to keep the structure as similar as possible.\r\n\r\nThe second reason was, that for now the stereo signal is kept as default. If I would like to keep the other possible options in mind for maybe some extensions in the future, in the EngineEffectChain it isn't possible to get the number of channels, at least not straight. The information on the number of channels is possible to get via EngineParameters ([created later](https://github.com/mixxxdj/mixxx/blob/935ba94f7e498eebd7c3710b2f0df35d989d9a7d/src/engine/effects/engineeffect.cpp#L181) through process() method call in EngineEffectChain).\r\n\r\nAnd at least the last third and the main reason based on the second one, in the EngineEffectsDelay process() method, it is necessary to work with samples in the work with audio buffers, not with the frames. It can be used frames if it would be possible in EngineEffectsDelay to get information about the number of channels of input audio signal.\r\n\r\nSo, I would like to summarize the main idea. It is possible if I can get information about the number of channels in the EngineEffectChain process() method, or at least in the EngineEffectsDelay process() method.\r\n\r\n> Can this ever be a float?\r\n\r\nIf I assume, that it will be worked with the samples or frames, it isn't possible. It can be possible if we thought of to option to work with the delay in milliseconds, but IMO it doesn't make much sense. If I'm wrong, please correct me.\r\n\r\n> Can we put the unit into the function name?\r\n\r\nYeah, of course. \r\n"", 'comment_created': datetime.datetime(2022, 6, 19, 16, 35, 4, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 901131479, 'comment_body': ""That's a good point. If the effectChainGroupDelay isn't right to the number of channels, the channels could be swapped (for stereo signal an odd number of samples). This situation isn't handled internally for now. As I mentioned for the PitchShiftEffect setGroupDelay() method, it is necessary to have the information about the number of channels, if I wouldn't assume, that it will be worked only with the stereo audio signal."", 'comment_created': datetime.datetime(2022, 6, 19, 16, 41, 29, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 901131842, 'comment_body': ""Okay, thank you. It will be a better option. I will fix it. The buffer size wasn't allocated in the constructor due to the huge amount of delay of the Pitch shift effect, but it will be solved."", 'comment_created': datetime.datetime(2022, 6, 19, 16, 45, 23, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 901134269, 'comment_body': 'Ok, that sounds reasonable. \r\nIf we put an assertion that the stereo signal is it swapped it works for me as well.', 'comment_created': datetime.datetime(2022, 6, 19, 17, 7, 30, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 901301007, 'comment_body': ""Okay, thank you. Good idea. Still, I see now on my solution and proposal of using samples rather than frames maybe a little problem, that if it will be worked in the future with other numbers of channels than the stereo signal, it would be harder to assert the invalid number of samples. To check the invalid value the number of samples has to be divisible by the number of channels. And because of that, the information about the number of channels has to be accessible in the EngineEffectChannel or EngineEffectsDelay, so this situation isn't still solved."", 'comment_created': datetime.datetime(2022, 6, 20, 6, 36, 56, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 906721702, 'comment_body': ""It would be interesting to see whats faster.\r\n1. Copying and making use of vectorization\r\n2. Doing the mutation in place and possibly don't get vectorization\r\n\r\nMy guess would be that it depends on buffer size. "", 'comment_created': datetime.datetime(2022, 6, 25, 20, 34, 1, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 906721959, 'comment_body': 'what if we take two `gsl::span`s instead? Do we suffer a significant performance penalty because of the runtime bounds checking? ', 'comment_created': datetime.datetime(2022, 6, 25, 20, 37, 8, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 906722379, 'comment_body': 'Also a documentation header would be nice', 'comment_created': datetime.datetime(2022, 6, 25, 20, 42, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 906799892, 'comment_body': 'since the group delay is an offset in sample, using `SINT` makes more sense.\r\n```suggestion\r\n    virtual SINT getGroupDelay() override {\r\n```', 'comment_created': datetime.datetime(2022, 6, 26, 11, 33, 1, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 906802503, 'comment_body': 'Agree, reporting the latency in Frames is better than samples because samples depend on the number of channels. ', 'comment_created': datetime.datetime(2022, 6, 26, 11, 53, 45, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 906803708, 'comment_body': ""I don't understand this case. Is it when the delay hasn't changed and the buffer is large enough? Why do we need this exception?"", 'comment_created': datetime.datetime(2022, 6, 26, 12, 1, 44, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 906837576, 'comment_body': ""Okay, I agree. If it is ok, the setter will recalculate the number of the frames into samples by using [mixxx::kEngineChannelCount](https://github.com/mixxxdj/mixxx/blob/1cd826af252c51f96db17f8a27cd3599828aa946/src/engine/engine.h#L8), I'm fine with that. The reason why the number of frames has to be recalculated in the setter is, that the inner process() method structure works with samples and it doesn't make sense to recalculate samples for every delay value usage."", 'comment_created': datetime.datetime(2022, 6, 26, 15, 46, 32, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 906838317, 'comment_body': ""Sure, if I think about it again, it really doesn't make much sense."", 'comment_created': datetime.datetime(2022, 6, 26, 15, 52, 56, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 906842856, 'comment_body': 'Yes, of course.', 'comment_created': datetime.datetime(2022, 6, 26, 16, 29, 42, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 906863005, 'comment_body': '> is this class supposed to be inherited from?\r\n\r\nIf I think about it again, probably not.\r\n\r\n', 'comment_created': datetime.datetime(2022, 6, 26, 19, 45, 3, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 907102979, 'comment_body': ""It's alright, the second condition part (`m_delayBufferSize == iBufferSize + m_delaySamples`) was added, because it looked to me not so clean to rely on that the `iBufferSize`, which is the input parameter, is always the same. If it wouldn't the same, the `m_delayBufferSize` would contain a bad value. Anyway, the buffer size is set now in the new version in the constructor and is known in compile time, so the condition for this part will be that just the delay hasn't changed (`m_oldDelaySamples == m_delaySamples`)."", 'comment_created': datetime.datetime(2022, 6, 27, 8, 16, 16, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 907336919, 'comment_body': 'In fact, I see the `gsl::span` for the first time. I studied some information about that. It looks like it could be cool. However, the `process()` method overrides the method from [EngineObjectConstIn,](https://github.com/mixxxdj/mixxx/blob/d209239967f2f4709d03c05261f8fef07ba47f75/src/engine/engineobject.h#L23) so for now, it doesn\'t fit well into the current structure. To still preserve hierarchy, I think that the new class should be created in `engineobject.h,` which will use `gsl::span` instead of `CSAMPLE*`, from which will the `EngineEffectsDelay` inherit. Another thing to the implementation, the use of span is great when using iterator. If I\'m right, for optimal use of gsl::span in `EngineEffectsDelay`, there have to be two iterators for one for cycle for input and output buffer, if we will use the ""two buffers"" version.', 'comment_created': datetime.datetime(2022, 6, 27, 12, 34, 38, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 907414744, 'comment_body': 'Since #4803 just got merged, you can also use `std::span` (which should be exactly equivalent to the pointer-based implementation because it doesn\'t perform bounds checking unlike `gsl::span`). Since this is somewhat performance-critical code, it would make sense to use implementation without bounds checking.\r\n\r\ntransforming `void process(const CSAMPLE* pIn, CSAMPLE* pOutput, const int iBufferSize)` to `void process(std::span<CSAMPLE> in, std::span<CSAMPLE> out);` and vice versa is trivial. We can provide a virtual method in the baseclass that has a default implementation and implements one in term of the other. Then mark the pointer-based method deprecated and then we can gradually change all implementations.\r\n\r\n> If I\'m right, for optimal use of gsl::span in EngineEffectsDelay, there have to be two iterators for one for cycle for input and output buffer, if we will use the ""two buffers"" version.\r\n\r\nWhy do you think so? The elements within spans are mutable, you can just change them in-place. So you can just create a span over the single mutable buffer. ', 'comment_created': datetime.datetime(2022, 6, 27, 13, 51, 7, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 907426193, 'comment_body': 'No need for heap allocation here imo. And if there is prefer unique_ptr. https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es60-avoid-new-and-delete-outside-resource-management-functions', 'comment_created': datetime.datetime(2022, 6, 27, 14, 1, 30, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 907703415, 'comment_body': ""> Since this is somewhat performance-critical code, it would make sense to use implementation without bounds checking.\r\n\r\nI agree, sounds good to me of using std::span.\r\n\r\n> Why do you think so? The elements within spans are mutable, you can just change them in-place. So you can just create a span over the single mutable buffer.\r\n\r\nOh, right right. I just didn't realize that while reading the documentation.\r\n"", 'comment_created': datetime.datetime(2022, 6, 27, 18, 57, 27, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 909674298, 'comment_body': 'basic getter still belongs in the header.', 'comment_created': datetime.datetime(2022, 6, 29, 14, 0, 53, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 909676537, 'comment_body': 'Can you explain why the heap allocation is needed?', 'comment_created': datetime.datetime(2022, 6, 29, 14, 2, 44, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 909678290, 'comment_body': '```suggestion\r\nconstexpr int kiMaxDelay = static_cast<int>(0.508 *\r\n        mixxx::audio::SampleRate::kValueMax * mixxx::kEngineChannelCount);\r\n```', 'comment_created': datetime.datetime(2022, 6, 29, 14, 4, 13, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 909679517, 'comment_body': 'Have you considered inheriting from `EngineObject` instead?', 'comment_created': datetime.datetime(2022, 6, 29, 14, 5, 14, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 909686120, 'comment_body': 'These pre-conditions must hold no matter which branch is actually taken. Can you deduplicate them outside the `if`?', 'comment_created': datetime.datetime(2022, 6, 29, 14, 10, 32, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 909706798, 'comment_body': 'why the ramping in the first place?', 'comment_created': datetime.datetime(2022, 6, 29, 14, 19, 47, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 910297407, 'comment_body': '```suggestion\r\n    /// The method returns the number of frames by which the dry signal\r\n```', 'comment_created': datetime.datetime(2022, 6, 29, 18, 52, 56, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 910299203, 'comment_body': '```suggestion\r\n    /// needs to be delayed so that buffers for the dry and wet signal (output\r\n    /// of the effect) overlap. The return value represents the current effect\r\n```', 'comment_created': datetime.datetime(2022, 6, 29, 18, 55, 4, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 910302493, 'comment_body': 'Can we give the buffer a better name? ', 'comment_created': datetime.datetime(2022, 6, 29, 18, 59, 6, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 910310417, 'comment_body': 'It feels scary that pIn is not const. I think It should be, because messing around with the input buffer feels wrong. \r\n\r\nThere is also no need for this copy. We can use m_tmpBuffer below. \r\n\r\n\r\n', 'comment_created': datetime.datetime(2022, 6, 29, 19, 8, 38, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 910313208, 'comment_body': 'We have also no definition for a i prefix. 0.508 is a magic number can we name it? What is the unit of kMaxDelay?', 'comment_created': datetime.datetime(2022, 6, 29, 19, 12, 3, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 910324383, 'comment_body': 'it looks like clang-format needs your help here:\r\n```suggestion\r\n        int delaySourcePos = \r\n                (m_delayPos + kiMaxDelay - m_delaySamples + iBufferSize / 2) %\r\n                kiMaxDelay;\r\n```\r\nDoes this work? ', 'comment_created': datetime.datetime(2022, 6, 29, 19, 27, 6, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 910328141, 'comment_body': 'Does this need to be with double precision? I can Imagine that a float calculation is sufficient, but faster on a 32 bit CPU.   ', 'comment_created': datetime.datetime(2022, 6, 29, 19, 31, 58, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 910334627, 'comment_body': 'if you feel lucky you may fiddle around to either use factorized functions or make this loop vetcorized. \r\nThis can be checked like described here: https://github.com/mixxxdj/mixxx/blob/0ad01b6ccc744045fb727eb4e775aa0e52bf4998/src/util/sample.cpp#L14\r\n\r\nThis requires that you chop the loop in chunks to get around the % kiMaxDelay on every sample. \r\n\r\n\r\n\r\n', 'comment_created': datetime.datetime(2022, 6, 29, 19, 40, 43, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 910804485, 'comment_body': 'The ramping is required, to remove click sounds form the stream. This happens due to the steep slope when concatenate two unrelated steams after changing the delay. A peace is cut out or doubled.   \r\nNot ramping in the first half is not relevant here. That was required in the bessel EQ, because it contains an unwanted settling sound of the filter after changing the cut of frequencies. \r\nHere the dry signal is all the way good. ', 'comment_created': datetime.datetime(2022, 6, 30, 9, 21, 15, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 910918145, 'comment_body': 'Mhmm ok, yeah makes sense. But yes, the ramping should be done over the entire buffer (not branching on the index helps with autovectorization) and it should be accomplished using `RampingValue`.', 'comment_created': datetime.datetime(2022, 6, 30, 11, 36, 41, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 910919758, 'comment_body': 'We should refine this anyways. Also rounding up to the next power of 2 helps the optimizer because the expensive modulo operation can be transformed into a binary AND.', 'comment_created': datetime.datetime(2022, 6, 30, 11, 38, 51, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 910973987, 'comment_body': 'Maybe I am a little bit confused. What I think is to construct an object by which I use the class methods. Can you please describe your proposal or what solution you propose?', 'comment_created': datetime.datetime(2022, 6, 30, 12, 35, 49, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 910986284, 'comment_body': ""Yes, I mentioned it few messages [earlier](https://github.com/mixxxdj/mixxx/pull/4810#issuecomment-1167068213). The difference is that the `process()` method works in place and doesn't need a temporary buffer and IMO fits better for the usage in the `EngineEffectChain`."", 'comment_created': datetime.datetime(2022, 6, 30, 12, 48, 48, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 910990916, 'comment_body': 'The reason, why are they duplicated is because of the difference in the `delaySourcePos` value calculation. See [R27](https://github.com/mixxxdj/mixxx/pull/4810/files/f40e7967a7f4b4988342e0930bbd2c8959db07e2#diff-8a31dfcb8638a3ad83fe1f01bcc3403c5918447ac9c8bd62f067c7d8debd1972R27) and [R55](https://github.com/mixxxdj/mixxx/pull/4810/files/f40e7967a7f4b4988342e0930bbd2c8959db07e2#diff-8a31dfcb8638a3ad83fe1f01bcc3403c5918447ac9c8bd62f067c7d8debd1972R55).', 'comment_created': datetime.datetime(2022, 6, 30, 12, 53, 26, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 910999120, 'comment_body': 'Thank you @daschuer for your answer. I agree that the ramping can be done through the whole buffer and `RampingValue` can be used.', 'comment_created': datetime.datetime(2022, 6, 30, 13, 1, 23, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 911133624, 'comment_body': 'You could add a reminder in this commit by adding a `static_assert(mixxx::kEngineChannelCount == 2);` somewhere. Then the compilation would fail if the stereo assumption is violated.', 'comment_created': datetime.datetime(2022, 6, 30, 14, 58, 34, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 911287312, 'comment_body': ""I'm really struggling to read the algorithm in the process function because these membernames don't really explain their purpose. Can you try to name them better?"", 'comment_created': datetime.datetime(2022, 6, 30, 17, 30, 56, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 911467278, 'comment_body': 'Trivial functions like that benefit greatly from inlining which is usually achieved by being implemented in the header.', 'comment_created': datetime.datetime(2022, 6, 30, 21, 44, 49, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 911474242, 'comment_body': 'Not in this case, because it is a virtual function that cannot be inline. ', 'comment_created': datetime.datetime(2022, 6, 30, 21, 57, 55, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 911477421, 'comment_body': ""Right. but what you are doing right now is that you are allocating an instance of `EngineEffectsDelay` on the heap and then storing the point in the `EngineEffectChain`. But you don't have to allocate on the heap. You can just construct the object as part of the owning object. \r\nSince `EngineEffectChain` lives in the audio engine thread, using heap-allocation is a nogo.\r\nNow:\r\n```\r\n ┌─────────────────┐       ┌─────────────────┐\r\n │EngineEffectChain│   ┌──►│EngineEffectDelay│\r\n │                 │   │   │                 │\r\n │m_pEffectDelay ──┼───┘   │...              │\r\n │                 │       └─────────────────┘\r\n │...              │\r\n └─────────────────┘\r\n``` \r\nWhat I propose:\r\n```\r\n\r\n ┌─────────────────────┐\r\n │EngineEffectChain    │\r\n │ ┌─────────────────┐ │\r\n │ │EngineEffectDelay│ │\r\n │ │                 │ │\r\n │ │...              │ │\r\n │ └─────────────────┘ │\r\n │...                  │\r\n └─────────────────────┘\r\n\r\n```\r\nI don't even think that the member would have to be constructed explicitly as it can be default constructed. So I'm basically just proposing to remove the line in question and change the class definition from `std::unique_ptr<EngineEffectsDelay> m_pEffectsDelay;` to `EngineEffectsDelay m_effectsDelay;`."", 'comment_created': datetime.datetime(2022, 6, 30, 22, 4, 14, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 911479677, 'comment_body': 'Yes. I actually thought about it too and IMO it makes more sense from not only a usage but also a performance perspective. Just append the input to `m_pDelayBuffer` in one pass, then copy from the older offset position. That would be vectorizer friendly. The only caveat is that `m_pDelayBuffer` would have to be big enough but that should be trivial to assert.', 'comment_created': datetime.datetime(2022, 6, 30, 22, 9, 16, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 911480068, 'comment_body': 'Mhmm ok, I have not looked much into that because I struggle to understand the arithmetic (as pointed out in the latest review below)', 'comment_created': datetime.datetime(2022, 6, 30, 22, 10, 8, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 911625924, 'comment_body': 'Yes, I can. I used the same names as in the `EngineFilterDelay`, but I agree that names are not quite telling of their purpose.', 'comment_created': datetime.datetime(2022, 7, 1, 5, 29, 42, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 911657029, 'comment_body': 'What do you think about this proposal:\r\n\r\n- _m_delaySamples -> m_newDelaySamples_\r\n\r\n  The purpose of the variable is to keep the actual setting of the number of samples saved. When the delay has changed (via `EngineEffectsDelay::setDelayFrames`), this variable is changed too and the value before the change is kept saved in the m_oldDelaySamples.\r\n\r\n  For the `EngineEffectsDelay` usage in the `EngineEffectChain` it makes sense to use the word ""new"" because before every `EngineEffectsDelay::process` call the delay value is set via `EngineEffectsDelay::setDelayFrames`.\r\n\r\n- _m_oldDelaySamples -> m_prevDelaySamples_\r\n\r\n  The purpose of the variable is to hold the number of delay samples before the last change (""previous delay value""). This value is kept saved for use in ramping when the delay has changed. If the delay hasn\'t changed between two `EngineEffectsDelay::process` calls, the `m_oldDelaySamples` and `m_delaySamples` hold the same value.\r\n\r\n- _m_delayPos -> m_delayBufferWritePos_\r\n\r\n  The purpose of the variable is to hold the position where should be new samples written into the delay buffer (like ""write pointer"" for a ring buffer).\r\n\r\n- _m_pDelayBuffer -> keep the same name_\r\n\r\nWe can discuss the clearness later while the new names will be used in the code, however, I would like to avoid multiple commits that rename variable names only.', 'comment_created': datetime.datetime(2022, 7, 1, 6, 36, 53, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 911680466, 'comment_body': 'Thank you for the tip. Sounds good.', 'comment_created': datetime.datetime(2022, 7, 1, 7, 14, 11, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 911685971, 'comment_body': 'If I am thinking about it again, the calculations will be the same, while the ramping will be changed for the whole buffer version (not only for the second half), which we agreed on before. The code will be much cleaner and we will avoid these statements duplication too.', 'comment_created': datetime.datetime(2022, 7, 1, 7, 22, 9, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 911760194, 'comment_body': '> We have also no definition for a i prefix. 0.508 is a magic number can we name it? What is the unit of kMaxDelay?\r\n\r\nI agree that is a magic number. The value was used from the [EngineDelay](https://github.com/mixxxdj/mixxx/blob/bf98de330910c38bd9b3cf51fb50dbe0188f4690/src/engine/enginedelay.cpp#L11) using maximum delay pot. The value can be changed.', 'comment_created': datetime.datetime(2022, 7, 1, 8, 52, 35, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 911761095, 'comment_body': ""> We should refine this anyways. Also rounding up to the next power of 2 helps the optimizer because the expensive modulo operation can be transformed into a binary AND.\r\n\r\nI agree. That's a good point, thank you."", 'comment_created': datetime.datetime(2022, 7, 1, 8, 53, 35, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 911768012, 'comment_body': ""I agree, it doesn't have to be double and float is a better option."", 'comment_created': datetime.datetime(2022, 7, 1, 9, 1, 30, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 911792910, 'comment_body': ""> The value can be changed.\r\n\r\nYes we should probably change it, which is why I didn't complain about it being a magic constant yet."", 'comment_created': datetime.datetime(2022, 7, 1, 9, 30, 19, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 911830850, 'comment_body': 'Yes, it works.', 'comment_created': datetime.datetime(2022, 7, 1, 10, 17, 58, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 911865870, 'comment_body': 'Oh, clear. Thank you very much for this perfect explanation. It makes much more sense to me now.', 'comment_created': datetime.datetime(2022, 7, 1, 11, 7, 27, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 913253412, 'comment_body': '> m_delaySamples -> m_newDelaySamples\r\n\r\nI would name that `m_currentDelaySamples`. I agree with the rest.', 'comment_created': datetime.datetime(2022, 7, 4, 20, 17, 17, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 913256453, 'comment_body': 'IMO ideal usecase for `std::span` here. \r\n```suggestion\r\n    void AssertIdenticalBufferEquals(const std::span<CSAMPLE> buffer, \r\n            const std::span<CSAMPLE> referenceBuffer) {\r\n```', 'comment_created': datetime.datetime(2022, 7, 4, 20, 28, 42, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 913258100, 'comment_body': 'I\'m not sure if its a good idea to test debug behavior like this. I agree that it makes sense to test whether a type correctly fails when its preconditions are violated, but I don\'t know if its a good idea to test this conditionally. Especially if the ""handling"" of violated pre-conditions is a controlled crash. What are your thoughts @daschuer?', 'comment_created': datetime.datetime(2022, 7, 4, 20, 34, 43, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 913830560, 'comment_body': 'Okay, thank you for this tip.', 'comment_created': datetime.datetime(2022, 7, 5, 13, 56, 56, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 913864188, 'comment_body': 'At least it would be a new pattern in out test code.\r\n\r\nI think it is a kind of paranoia to test test code, on the other hand it is a fixture that guarantees that a certain assertion is not removed and the code is already written. \r\nI have no strong opinion here. Maybe keep the code but not invest time to introduce similar test elsewhere. \r\n\r\n\r\n\r\n ', 'comment_created': datetime.datetime(2022, 7, 5, 14, 27, 15, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 913991841, 'comment_body': ""Well, if this was Rust code with explicit error types, or even C++ with proper exception use, I'd be in favor of testing failure modes. But in mixxx, our error handling is almost non-existent. We just have our `DEBUG_ASSERT`s so we're not flying completely blind in debug builds and in release builds we're just praying nothing will happen. I don't know if it makes sense to test `DEBUG_ASSERT`s which are already a hack in the first place.\r\n\r\nSince the code is already written, lets just keep it as long as the test don't turn out to be flaky. "", 'comment_created': datetime.datetime(2022, 7, 5, 16, 35, 28, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 914057660, 'comment_body': ""I would like to ask you whether you thought `gsl::span` instead of `std::span` from the standard library. I ask this question because Mixxx works with the C++17 standard, but if I'm right, the [span](https://en.cppreference.com/w/cpp/container/span) is in the standard library by C++20."", 'comment_created': datetime.datetime(2022, 7, 5, 18, 0, 57, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 914064758, 'comment_body': ""Okay, I understand your reason for the question if it is a good idea. So, as you wrote, for now, I will keep this code as-is. On the other hand, it isn't a problem to change it."", 'comment_created': datetime.datetime(2022, 7, 5, 18, 10, 6, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 914068776, 'comment_body': 'Well it depends. the main branch now does target C++20 (see #4803) (you might need to rebase on the newest commit). For performance-sensitive code, std::span is preferred because it does not do bounds-checking while the safety-focused gsl::span does. \r\nSee https://github.com/microsoft/GSL/wiki/gsl::span-and-std::span\r\n\r\nI think if you are still on ubuntu 20.04 you might be stuck with an old gcc version that still lacks adequate c++20 support. ', 'comment_created': datetime.datetime(2022, 7, 5, 18, 13, 57, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 914126320, 'comment_body': 'Oh, thank you for the explanation. I am using Ubuntu 22.04.', 'comment_created': datetime.datetime(2022, 7, 5, 19, 11, 10, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 915090833, 'comment_body': ""The code duplication is resolved. Just one thing to the `VERIFY_OR_DEBUG_ASSERT`. IMO after a code change from `unsigned int` to the new variable `kiMaxDelay`, which is a `const int` data type (`constexpr int` after fix), the `static_cast` is not necessary. Anyway, I'm not sure how the checks will react to it."", 'comment_created': datetime.datetime(2022, 7, 6, 17, 27, 7, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 915659655, 'comment_body': 'So, just for summarizing an easy calculation. Following the current calculation, with magic constant 0.508 from `enginedelay.cpp` and using `mixxx::audio::SampleRate::kValueMax`(which is 192 000) and `mixxx::kEngineChannelCount` (which is stereo), the following power of two is 2^18 (262 144) or next 2^19 (524 288). I am thinking about whether it makes sense to think about a greater buffer because the following power of two (2^20) is over 1 million.', 'comment_created': datetime.datetime(2022, 7, 7, 9, 24, 39, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 915925900, 'comment_body': 'Mhmmm. The fact that we need to account for the (unlikely) worstcase (192Khz samplingrate) makes this tradeoff somewhat difficult to evaluate. I wish we could allocate the buffer based on the actual buffer size currently being used instead of the worst case.\r\nWhat do we think is an acceptable maximum delay factor? 2x the current buffer size?', 'comment_created': datetime.datetime(2022, 7, 7, 14, 14, 11, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 915931186, 'comment_body': 'Just make it compile IMO. though try to avoid unnecessary casts.', 'comment_created': datetime.datetime(2022, 7, 7, 14, 18, 51, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 915933194, 'comment_body': ""I'm not sure how much vectorizing potential there actually is. I think the `n % kiMaxDelay` always breaks the autovectorizer because you can't use vectorizing instructions when `n` is at the wrap-around boundary."", 'comment_created': datetime.datetime(2022, 7, 7, 14, 20, 37, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 916177482, 'comment_body': ""Yeah, I agree that it is a little bit tricky, that so big buffer size is possible, but not so common. For the current pitch shift effect version, the delay is about 4 buffer sizes, or more, which is unacceptable. For now, I don't have a specific amount of maximum delay. I think, that about 2 buffer sizes are a good tradeoff. Anyway, I will test the different delay settings, what is maximum delay by ear and feeling (with only using dry signal and cross-fading). I will inform you about the results."", 'comment_created': datetime.datetime(2022, 7, 7, 18, 38, 23, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 916197633, 'comment_body': 'This loop does double the work compared to the non-crossfading benchmarks which I find confusing.', 'comment_created': datetime.datetime(2022, 7, 7, 19, 5, 4, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 916201130, 'comment_body': 'not needed anymore\r\n```suggestion\r\nvoid EngineEffectsDelay::process(CSAMPLE* pInOut,\r\n```', 'comment_created': datetime.datetime(2022, 7, 7, 19, 10, 8, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 916212572, 'comment_body': '```suggestion\r\n    const int delaySourcePos = (m_delayBufferWritePos - m_currentDelaySamples) % kiMaxDelay;\r\n```\r\n$$(b + c - d) \\bmod c \\iff \\\\  (b \\bmod c + c \\bmod c - d \\bmod c) \\bmod c \\iff  (b \\bmod c + 0 - d \\bmod c) \\bmod c \\iff (b - d) \\bmod c$$', 'comment_created': datetime.datetime(2022, 7, 7, 19, 26, 13, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 916221047, 'comment_body': ""> This requires that you chop the loop in chunks to get around the % kiMaxDelay on every sample.\r\n\r\nI missed that in my last note in this thread (which is why that note essentially repeated what you just said). The problem I see is that we simply can't do that. At least the current interface and implementation allows the delay to be any frame frame number. I don't think we can make the interface more granular so we'd have to find a workaround in the implementation."", 'comment_created': datetime.datetime(2022, 7, 7, 19, 38, 19, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 916603864, 'comment_body': 'I agree, that from a mathematical point of view you\'re right. Anyway, from the C++ point of view, the modulo operator for negative values (for example, x % y, where x is a negative value) produces negative values (but in math result value is positive). The addition of delay buffer size is used to ensure positive values, otherwise, the calculation fails on the `""delaySourcePos >= 0""` debug assert.', 'comment_created': datetime.datetime(2022, 7, 8, 8, 49, 11, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 916756331, 'comment_body': 'Do you plan to get rid of this % ? I would prefer a memcpy() based solution:\r\nhttps://github.com/mixxxdj/mixxx/blob/b58dd5bc990a1f6afe7a400e9b9451882c78112a/src/util/sample.h#L53\r\n', 'comment_created': datetime.datetime(2022, 7, 8, 12, 10, 59, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 916829855, 'comment_body': ""Right, good point. I really don't like that we make sure its not negative like this though. I'm sure in the future someone would come along and make the same buggy optimization as I just proposed. Can you at least document that the `+ kiMaxDelay` is necessary?"", 'comment_created': datetime.datetime(2022, 7, 8, 13, 42, 52, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 916835898, 'comment_body': 'use the RAII type `SampleBuffer` instead please. Manual (de-)allocation is error-prone.', 'comment_created': datetime.datetime(2022, 7, 8, 13, 49, 16, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 916837970, 'comment_body': 'IMO this requires some more complicated code to be safe, but it would be a worthwhile optimization too look into. ', 'comment_created': datetime.datetime(2022, 7, 8, 13, 51, 29, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 916871886, 'comment_body': ""Of course, I would like to avoid using these modulo operations. However, as the next step, I will implement the mentioned ring buffer, and then I can try to solve this optimization problem, so for now I still don't have a complete idea of the solution. Thank you for the tip with memcpy(). "", 'comment_created': datetime.datetime(2022, 7, 8, 14, 27, 2, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 916958547, 'comment_body': ""Yes, of course. I think I will create a new PR and document the same tricky part for `EngineDelay` and `EngineFilterDelay` because all these calculations are the same. As you wrote, it could be cool to solve this problem differently, but for now, I can't think of the more optimal solution."", 'comment_created': datetime.datetime(2022, 7, 8, 16, 8, 3, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 917012982, 'comment_body': 'This may serve as a model: \r\nhttps://github.com/mixxxdj/mixxx/blob/b58dd5bc990a1f6afe7a400e9b9451882c78112a/lib/portaudio/pa_ringbuffer.c#L198\r\ncopy in two steps form the current position to the ring wrap around and then the remaining samples.  ', 'comment_created': datetime.datetime(2022, 7, 8, 17, 27, 18, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 917069437, 'comment_body': 'Thank you very much for this tip. It seems like it could be really helpful.', 'comment_created': datetime.datetime(2022, 7, 8, 18, 57, 20, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 917966515, 'comment_body': ""I'm not familiar enough with virtual inheritance but this seems unnecessary to me.\r\n```suggestion\r\n```"", 'comment_created': datetime.datetime(2022, 7, 11, 13, 58, 35, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 917968145, 'comment_body': ""most methods on this class could be const but aren't right now. \r\n```suggestion\r\n    bool isFull() const {\r\n        return getWriteAvailable() == 0;\r\n    }\r\n```\r\n"", 'comment_created': datetime.datetime(2022, 7, 11, 14, 0, 5, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 917972903, 'comment_body': 'Ideally this would be generic, but that would essentially make this about as complex as `std::vector` with all the required SFINAE (or C++20 concepts work)...', 'comment_created': datetime.datetime(2022, 7, 11, 14, 4, 17, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 917974866, 'comment_body': ""You don't need to store that IMO. its already part of the `SampleBuffer` object."", 'comment_created': datetime.datetime(2022, 7, 11, 14, 6, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 917988404, 'comment_body': ""I'm not sure this is correct. I think `sizeof(m_buffer)` only yields the size of the control block (so 16 bytes on x64 because the control block is just a pointer and size)."", 'comment_created': datetime.datetime(2022, 7, 11, 14, 14, 57, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 917995240, 'comment_body': 'Please avoid invasive manipulation like this. Manual handling of sizes and memsetting is prone to cause buffer overflow problems. \r\n```suggestion\r\n    m_buffer.fill(0);\r\n```', 'comment_created': datetime.datetime(2022, 7, 11, 14, 21, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 920172776, 'comment_body': 'please separate this into its own `src/util/span.h` header', 'comment_created': datetime.datetime(2022, 7, 13, 14, 47, 50, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 921023143, 'comment_body': '```suggestion\r\n        return mixxx::span<CSAMPLE>{m_data, static_cast<mixxx::span<CSAMPLE>::index_type>>(m_size)};\r\n```', 'comment_created': datetime.datetime(2022, 7, 14, 10, 52, 52, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 921023354, 'comment_body': '```suggestion\r\n        return mixxx::span<CSAMPLE>{m_data, static_cast<mixxx::span<CSAMPLE>::index_type>>(m_size)};\r\n```', 'comment_created': datetime.datetime(2022, 7, 14, 10, 53, 11, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 922081396, 'comment_body': 'Thank you. Anyway, I think it depends on the version of the system too. On GitHub CI the `index_type` is required, anyway, for example, on my system the `std::size_t` is required. IMO it may depend on the [GSL issue](https://github.com/microsoft/GSL/issues/782).', 'comment_created': datetime.datetime(2022, 7, 15, 11, 32, 33, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 922109704, 'comment_body': 'Yeah... the resulting code is quite verbose but what daniel proposed should work in all cases, we just need to hide that complexity with a couple helper methods.', 'comment_created': datetime.datetime(2022, 7, 15, 12, 16, 8, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 922220871, 'comment_body': 'Oh, okay. Thank you.', 'comment_created': datetime.datetime(2022, 7, 15, 14, 27, 8, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 923543868, 'comment_body': ""since std::transform always does a map. I don't think this is appropriate here... I think you'll just have to iterate over the two spans manually."", 'comment_created': datetime.datetime(2022, 7, 18, 15, 59, 58, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 923652712, 'comment_body': 'more concise IMO\r\n```suggestion\r\n      auto pBufferIterator = std::cbegin(buffer);\r\n      auto pReferenceBufferIterator = std::cbegin(referenceBuffer);\r\n```', 'comment_created': datetime.datetime(2022, 7, 18, 17, 45, 23, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 923653952, 'comment_body': ""Simple by-index for loop would've been okay too."", 'comment_created': datetime.datetime(2022, 7, 18, 17, 46, 4, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 923676951, 'comment_body': 'Okay, so can I use it instead and avoid using iterators in this special case? IMO more readable solution.', 'comment_created': datetime.datetime(2022, 7, 18, 18, 8, 5, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 923682250, 'comment_body': 'Yes, but only because we asserted that the sizes were the same. Alternatively you can use the bounds-checked accessor `span.at(i)` in the loop.', 'comment_created': datetime.datetime(2022, 7, 18, 18, 14, 58, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 923684289, 'comment_body': ""Maybe not so clear, as I expected. The data type has to be explicitly written (can't use auto), to avoid casting, so the solution looks like this:\r\n\r\n```\r\nfor (std::span<CSAMPLE>::size_type i = 0; i < buffer.size(); i++) {\r\n    EXPECT_FLOAT_EQ(buffer[i], referenceBuffer[i]);\r\n}\r\n```\r\n\r\nWhat would you prefer?"", 'comment_created': datetime.datetime(2022, 7, 18, 18, 17, 31, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 923700795, 'comment_body': 'Are you sure, it works for me...\r\nhttps://compiler-explorer.com/z/q77Eaa8jq', 'comment_created': datetime.datetime(2022, 7, 18, 18, 38, 31, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 923701674, 'comment_body': 'Even works on gcc 10', 'comment_created': datetime.datetime(2022, 7, 18, 18, 39, 41, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 923781718, 'comment_body': ""Yeah, it works, that's right. The compiler shows this warning only:\r\n```\r\n/home/david/Documents/CodingFiles/GitWorkspace/Mixxx/mixxx/src/test/engineeffectsdelay_test.cpp: In member function ‘void {anonymous}::EngineEffectsDelayTest::AssertIdenticalBufferEquals(std::span<float>, std::span<const float>)’:\r\n/home/david/Documents/CodingFiles/GitWorkspace/Mixxx/mixxx/src/test/engineeffectsdelay_test.cpp:33:28: warning: comparison of integer expressions of different signedness: ‘int’ and ‘std::span<float>::size_type’ {aka ‘long unsigned int’} [-Wsign-compare]\r\n   33 |         for (auto i = 0; i < buffer.size(); i++) {\r\n      |                          ~~^~~~~~~~~~~~~~~\r\n```\r\n\r\nbut I suppose that the clazy test on CI will fail after updating on Ubuntu 22 still."", 'comment_created': datetime.datetime(2022, 7, 18, 19, 31, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 925605285, 'comment_body': 'Mhmm, its odd that auto defaults to `int` instead of `unsigned int`. Then use the `std::span<CSAMPLE>::size_type` I guess. If you need it more than once, you can hide it behind a `using` alias.', 'comment_created': datetime.datetime(2022, 7, 20, 13, 26, 12, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 925651912, 'comment_body': 'easy optimization / warning workaround (cuz the compiler will warn if you check `size >= 0` on an unsigned type). \r\n`#include <type_traits>`\r\n```suggestion\r\n        if constexpr (std::is_signed_v<S>) {\r\n          VERIFY_OR_DEBUG_ASSERT(size >= 0) {\r\n              size = 0;\r\n          }\r\n        }\r\n```', 'comment_created': datetime.datetime(2022, 7, 20, 14, 6, 10, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 925652994, 'comment_body': 'IMO prefer a namespace over a class with static member functions. ', 'comment_created': datetime.datetime(2022, 7, 20, 14, 7, 5, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 926025327, 'comment_body': 'Oh, thank you. Looks good.', 'comment_created': datetime.datetime(2022, 7, 20, 20, 25, 57, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 926759490, 'comment_body': '```suggestion\r\n```', 'comment_created': datetime.datetime(2022, 7, 21, 14, 38, 19, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 926763112, 'comment_body': '```suggestion\r\n        ASSERT_EQ(buffer.size(), referenceBuffer.size());\r\n```\r\nOtherwise the loop below would overrun. ', 'comment_created': datetime.datetime(2022, 7, 21, 14, 40, 52, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 926965624, 'comment_body': 'Lets just remove this constant for now.\r\n```suggestion\r\nconstexpr int kMaxDelay = mixxx::audio::SampleRate::kValueMax * mixxx::kEngineChannelCount;\r\n```', 'comment_created': datetime.datetime(2022, 7, 21, 18, 1, 15, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 927080542, 'comment_body': ""Oh, thank you. I'm sorry, I overlooked it."", 'comment_created': datetime.datetime(2022, 7, 21, 20, 35, 3, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 927098841, 'comment_body': 'No problem. Thats what code review is for.', 'comment_created': datetime.datetime(2022, 7, 21, 20, 59, 50, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 928140206, 'comment_body': 'great that you were able to figure out the reason the tests failed. I think if you fix this test, we can merge (theoretically, we still need to wait for 22.04).', 'comment_created': datetime.datetime(2022, 7, 23, 16, 19, 44, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 928142827, 'comment_body': 'Okay, I just would like to fix the mentioned delay value issue in this PR too (clamping the delay to [0;kMaxDelay]).', 'comment_created': datetime.datetime(2022, 7, 23, 16, 48, 55, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 928296964, 'comment_body': ""You're subtracting here, isn't that a bug? Also I'd just add another constexpr variable `kMaxDelayFrames` instead. "", 'comment_created': datetime.datetime(2022, 7, 24, 18, 36, 48, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 928297052, 'comment_body': 'please add a comment that this actually tests the clamping of the delay value. ', 'comment_created': datetime.datetime(2022, 7, 24, 18, 37, 45, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 928307394, 'comment_body': ""****\r\n\r\n> You're subtracting here, isn't that a bug? Also I'd just add another constexpr variable kMaxDelayFrames instead.\r\n\r\nThe inspiration was by [EngineDelay](https://github.com/mixxxdj/mixxx/blob/0d1dc9fa448181db8714425b424a754227bc0e1b/src/engine/enginedelay.cpp#L41). The reason of subtraction is, that last valid delay value is `kMaxDelay - 1`. However, clamping delay to this value will cause a switch between channels (for example stereo channels will be swapped). However, with your proposal of `kMaxDelayFrames`, the subtraction wouldn't be needed and only frames value will be compared."", 'comment_created': datetime.datetime(2022, 7, 24, 20, 17, 12, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 939638952, 'comment_body': 'I am unsure about this. Why does this work? I assume it also did not work above with data().\r\nFor my view ""const std::span<CSAMPLE>"" is a ""smart pointer to the non-const CAMPLE.  \r\nIsn\'t a Span() allways const. I think all sub-span functions are const anyway. \r\nIn C++ returning an value type as const does not really make sense. \r\n\r\nConclusion:  I think we can delete replace both functions and replace it with:\r\n `std::span<CSAMPLE> span() const {`\r\n', 'comment_created': datetime.datetime(2022, 8, 7, 9, 45, 49, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 939639254, 'comment_body': 'Can this whole one become a constexpr', 'comment_created': datetime.datetime(2022, 8, 7, 9, 47, 49, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 939639309, 'comment_body': 'and this also constexpr?', 'comment_created': datetime.datetime(2022, 8, 7, 9, 48, 27, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 939639501, 'comment_body': 'By the way, this function is unused. ', 'comment_created': datetime.datetime(2022, 8, 7, 9, 49, 55, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 939670021, 'comment_body': ""> Isn't a Span() allways const.\r\n\r\nNo its not. its a view into contiguous chunk of memory. Whether the memory should be seen as const or non const is defined by the template parameter. \r\n\r\n>  In C++ returning an value type as const does not really make sense.\r\n\r\nYes, sorry that slipped through it should be this instead:\r\n\r\n```suggestion\r\n    std::span<const CSAMPLE> span() const {\r\n```\r\n\r\n> Conclusion: I think we can delete replace both functions and replace it with:\r\n`std::span<CSAMPLE> span() const {`\r\n\r\nNo, that won't work. `std::span<T>` and `std::span<const T>` are different types. In the const member function, all class members are const, so you'd essentially try to construct mutable span into a type that is `const`. Here's a godbolt to demonstrate it: https://compiler-explorer.com/z/KaEcWxGYh\r\n\r\nIts unfortunately a flaw of the language that you can't be generic over the constness. So we have to duplicate the function here with two different signatures in regards to constness. (Rust has the same problem [but is trying to fix that](https://blog.rust-lang.org/inside-rust/2022/07/27/keyword-generics.html))\r\n\r\n> By the way, this function is unused.\r\n\r\nYes, but that doesn't matter because its intended as a library function to be used in the future. Its essentially supposed to replace `Samplebuffer::ReadableSlice`\r\n"", 'comment_created': datetime.datetime(2022, 8, 7, 13, 40, 50, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 939674111, 'comment_body': ""You demonstration is not valid for our case, because the T[100] in your test is also const, because it is part of the constant object memory. In the case of SampleBuffer only the pointer is part of the (const) object. See: \r\nhttps://compiler-explorer.com/z/9To5fvK7P  \r\n\r\nThis means 'std::span<CSAMPLE> span() const {' is valid in the same way like subspan returns a non const template type with a const function: https://en.cppreference.com/w/cpp/container/span/subspan "", 'comment_created': datetime.datetime(2022, 8, 7, 14, 9, 18, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 939675048, 'comment_body': 'I do not relay see the use case for `std::span<const CSAMPLE> span() const {` because SampleBuffer is more used as a factory. \r\nI think we will convert `std::span<CSAMPLE>` to `std::span<const CSAMPLE>` implicit on the fly via function parameters. \r\n', 'comment_created': datetime.datetime(2022, 8, 7, 14, 15, 43, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 939676146, 'comment_body': ""Can you show me the code that achieves that? If we have a const samplebuffer, and we want a view into it. We need an implementation of `std::span<const CSAMPLE> span() const`. If you want example where we'd use that in the mixxx codebase, grep for `SampleBuffer::ReadableSlice`. "", 'comment_created': datetime.datetime(2022, 8, 7, 14, 23, 35, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 939677181, 'comment_body': ""> You demonstration is not valid for our case, because the T[100] in your test is also const, because it is part of the constant object memory. In the case of SampleBuffer only the pointer is part of the (const) object. See:\r\n\r\nOh wow, thats even worse then IMO. that means we have a const object that allows mutable access to the resource it manages. In Rust that's called the interior mutability pattern and its used to provide safe mutable access when otherwise prohibited. In C++ we can not enforce the safety guarantees. SampleBuffer seems to be intentionally written with the RAII guideline in mind that if you have a const Samplebuffer, you can not alter the contents of the buffer within. Your proposal explicitly breaks that if I understand correctly."", 'comment_created': datetime.datetime(2022, 8, 7, 14, 31, 6, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 939677811, 'comment_body': ""> This means 'std::span span() const {' is valid in the same way like subspan returns a non const template type with a const function: https://en.cppreference.com/w/cpp/container/span/subspan\r\n\r\nThats not entirely true. while `std::span::subspan` is a const member func (which makes sense), the span it returns is templated on the `element_type`. So the `decltype(std::span<const T>:subspan())` is still `const T`. With samplebuffer its not the case, we have no way to specify that the underlying buffer is const, so we can only specify it for the SampleBuffer itself. Again, most of the samplebuffer code already explicitly makes that assumption, if the SampleBuffer is const, then the access to the underyling buffer is only const as well. So to follow that convention, we need to provide a `std::span<const CSAMPLE> span() const`. "", 'comment_created': datetime.datetime(2022, 8, 7, 14, 35, 44, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 939678495, 'comment_body': '> SampleBuffer is more used as a factory.\r\n\r\nCan you elaborate? IMO `SampleBuffer` is explicitly not intended as a glorified alligned_malloc. Its supposed to allocate once and then own its content. All access should either be directly through `operator[]` or the Readable-/WriteableSlice classes. `SampleBuffer::data` is an escape hatch and thus should be avoided unless absolutely necessary. ', 'comment_created': datetime.datetime(2022, 8, 7, 14, 40, 41, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 939679086, 'comment_body': '> If we have a const samplebuffer\r\n\r\nWe never have a const samplebuffer, because it always points to non-const samples.   \r\nhttps://github.com/mixxxdj/mixxx/blob/828a189b045050ca6ad5aa053e528e92ce0b8653/src/util/samplebuffer.h#L179\r\n\r\nI have found this: \r\nhttps://github.com/mixxxdj/mixxx/blob/b0a7c9e3ce9996e87146c27ca0c766c8622134a0/src/sources/soundsourcem4a.cpp#L602\r\n\r\nBut this is another class. \r\n\r\nBut anyway, I am in general in favor to only add functions that are used. If you are really sure we need it, we need to rename it because otherwise it makes zero difference due to the implicit conversion between `std::span<CSAMPLE>` to `std::span<const CSAMPLE>` \r\n\r\n\r\n\r\n', 'comment_created': datetime.datetime(2022, 8, 7, 14, 45, 12, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 939680377, 'comment_body': '> Your proposal explicitly breaks that if I understand correctly.\r\n\r\nI think you have mixed up some things. std::span not a container it is ""just"" a pointer which does not own the memory it is pointed to. \r\nWe have: \r\n```\r\nconst std::span<const CSAMPLE> constPointerToConstSampe; // it always points to the same buffer and can\'t change it \r\nstd::span<const CSAMPLE> mutablePointerToConstSampe;  // this allows to let it point to different memory but cant change it  \r\nconst std::span<CSAMPLE> mutablePointerToConstSampe;  // it alwasy points to the same memory, which can be changed.   \r\nstd::span<CSAMPLE> mutablePointerToConstSampe;  // this allows to let it point to different memory, which can be changed\r\n```\r\nIndependent of this most memory functions are also const, that prevents to alter the control structure of std::span.\r\n  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', 'comment_created': datetime.datetime(2022, 8, 7, 14, 54, 34, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 939681653, 'comment_body': ""\r\n> We never have a const samplebuffer, because it always points to non-const samples.\r\n\r\n\r\nYES. But SampleBuffer is supposed to hide that! Thats the entire point of the class! And we do have loads of SampleBuffer::ReadableSlices in our codebase. And we should have more in the future. Its intended as the de-facto way of passing immutable audio buffers. \r\n\r\n> \r\n> I have found this:\r\n> \r\n> https://github.com/mixxxdj/mixxx/blob/b0a7c9e3ce9996e87146c27ca0c766c8622134a0/src/sources/soundsourcem4a.cpp#L602\r\n> \r\n> But this is another class.\r\n> \r\n\r\n`SampleBuffer::ReadableSlice` is just a more boilerplate version of `std::span<const CSAMPLE>`. So we need a way of getting a std::span<const CSAMPLE> in our codebase. If you look at the constructor of `SampleBuffer::ReadableSlice`, it takes a `const SampleBuffer&` so its supposed to be compatible to be used with `const SampleBuffer`s. \r\n\r\n> But anyway, I am in general in favor to only add functions that are used. If you are really sure we need it, we need to rename it because otherwise it makes zero difference due to the implicit conversion between std::span<CSAMPLE> to std::span<const CSAMPLE>\r\n\r\nThis is not a matter of which functions are used and which aren't. Its a question of API and class design and if we don't provide these functions the API is incomplete and its usage will be clunky."", 'comment_created': datetime.datetime(2022, 8, 7, 15, 3, 42, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 939681856, 'comment_body': '> > Your proposal explicitly breaks that if I understand correctly.\r\n> \r\n> I think you have mixed up some things. std::span not a container it is ""just"" a pointer which does not own the memory it is pointed to. We have:\r\n> \r\n> ```\r\n> const std::span<const CSAMPLE> constPointerToConstSampe; // it always points to the same buffer and can\'t change it \r\n> std::span<const CSAMPLE> mutablePointerToConstSampe;  // this allows to let it point to different memory but cant change it  \r\n> const std::span<CSAMPLE> mutablePointerToConstSampe;  // it alwasy points to the same memory, which can be changed.   \r\n> std::span<CSAMPLE> mutablePointerToConstSampe;  // this allows to let it point to different memory, which can be changed\r\n> ```\r\n> \r\n> Independent of this most memory functions are also const, that prevents to alter the control structure of std::span.\r\n\r\nI simply don\'t understand what you are trying to say here. \r\n\r\nI understand what you are saying from a technical perspective, but I don\'t know how that relates to the discussion of providing a `std::span<const CSAMPLE> span() const` overload. ', 'comment_created': datetime.datetime(2022, 8, 7, 15, 5, 15, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 939683708, 'comment_body': 'Ok I think I kinda wrapped my head around this. But I that still leaves major issues:\r\n1. if we implement a `std:span<CSAMPLE> span() const` we allow mutable access to an object which has been crated by const object. While not leading to correctness issues, it goes explicitly against the entire rest of the SampleBuffer API. It breaks consistency severely. \r\n2. The proposed api correctness relies on the coercion with explicit type annotations. Take this code:\r\n```cpp\r\nconst SampleBuffer a{};\r\nconst auto b = a.span();\r\n// const everywhere, still we get mutable access just\r\n// because of the `auto` above. Combine that with\r\n// the former point and we have a severly confusing API\r\nb[0] = 1;\r\n```', 'comment_created': datetime.datetime(2022, 8, 7, 15, 19, 17, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 939692096, 'comment_body': ""Here's another example on how the API would get confusing with your proposal: \r\n\r\n```cpp\r\nconst SampleBuffer a{};\r\n// a[0] = 1; // compile error\r\na.span()[0] = 1; // legal\r\n```"", 'comment_created': datetime.datetime(2022, 8, 7, 16, 26, 48, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 939902113, 'comment_body': '> if we implement a std:span<CSAMPLE> span() const we allow mutable access to an object which has been crated by const object. \r\n\r\nAh OK, that is your point. I was not aware that you are planning to use a ""const SampleBuffer"". For my understanding the std::span should be used to pass the samples around and the SampleBuffer serves only the purpose as a Factory and owner of the memory. So in that case I agree that the pair: \r\n```\r\nstd::span<CSAMPLE> span() {...}\r\nstd::span<const CSAMPLE> span() const {...}\r\n```\r\nIs sensible ', 'comment_created': datetime.datetime(2022, 8, 8, 7, 22, 9, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 940157675, 'comment_body': ""Well, I know that we currently don't really pass `const SampleBuffer`s around, but SampleBuffer is still a container and its written as if it were. So for simplicity's sake I'd follow that API. I agree that views into SampleBuffers should be passed around as `std::span<CSAMPLE>`, I overall still think that the two method API results in a simpler and more predictable API (which we should value IMO). "", 'comment_created': datetime.datetime(2022, 8, 8, 12, 1, 47, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 940159096, 'comment_body': ""Seems like we've found consensus. Thank you very much. "", 'comment_created': datetime.datetime(2022, 8, 8, 12, 3, 29, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 944603237, 'comment_body': 'small oversight from my side\r\n```suggestion\r\n    if constexpr (std::is_signed_v<S> && std::is_unsigned_v<T2>) {\r\n        VERIFY_OR_DEBUG_ASSERT(size >= 0) {\r\n            size = 0;\r\n        }\r\n```', 'comment_created': datetime.datetime(2022, 8, 12, 15, 55, 46, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}]","[{'commit_sha': '461f6f78f181ac82532ba9c57b34f4683ba25ce0', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ad76619f3c5708aa9aa44a467c6ef650b9a1b41b', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'f40e7967a7f4b4988342e0930bbd2c8959db07e2', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '93d2d1923a0f56216dd058a336d60b577f2b88b9', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '97fdb392c1d303a160a6f5daaae94bed167156da', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'a1456a62a196f0004452bf6d8de20630affc4926', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'cc5abdd308af916c0cb77c8e47c092b4d0c91465', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'e958a081d15d784e6a8c2a671f16c345cdd8811b', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '5d2d560a3c98f07fccd4a96d237ea4c37120c5a4', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '4f7515ba26fd352e0bebcee8dd62b2e7c58eab15', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '755c714eb6327783319c91d138290f46f558e35e', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '164e2005dfcca2c0ac25fa73d784057ad0827c57', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'bc7834487758a1b3c4c04aa81566db0b3d98e7e8', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '5f1ea3676f9d815f33ea5a657e07a6521269c63c', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '1b88485b04c6a2d6a725904a9702ce238c0f5e89', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'af331857351c4fe6fa944973ba13fae691223ffb', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '5892a7e9f55038589546a311bc6455cd84e04437', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ea7d77c3ba327c59723758f45c07b676ff054ec3', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '047c3e2cb91f41f7be86554308099a37c62383f5', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '1db08fd1acf465bed95e7c9efb5624d96fb4092f', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'e84b0967cfa795fe6f243ee15d829d73b38d7c90', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '3da53da0d0c96127044385ab1f7bf5cd1848fc55', 'committer_username': 'Swiftb0y', 'committer_name': None, 'committer_email': None, 'commit_date': datetime.datetime(2015, 5, 10, 11, 0, 12, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'b0ed62c573787794aea782b1387db43162f5e785', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ff2fefe09ab3525fd5a68ff9d17bba67c3b60496', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '7107c873fc2f348a6a0e4ec34e290a799561b81f', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ef31bfb06de75e7e349997934fa63bbb3b634712', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '11a83a81215066d80d8e4025b5426214fa9a53fd', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'f40707c89960f7b4d9c4cc5788b57d8d2c0b0936', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '42487b27f4599b9bd13a7c6311f93941001e7ca1', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '79e6681bcc098269f0494a90b2f0d091319daa00', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '1e2d0f2ced42f9b66c143cb5c575bb85c77dbb7c', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '8e193131066bfaa27b15fb058aa17e1e586a69c9', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'f7a38c933a4b669018f2fbb62a4f51e097752e1d', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ad6569110f938699edb9472a95b4846380f9f34a', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '2e14db163e781fcfda687fd46f852a1cf0f85fc4', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '7f00a1aa7e92dfa0a7eb63690a2f8828a2b7ec28', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '8945f3df9e5ec484a8be4f25dba340024c31408e', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '9ffdb1122a242c2300c94015603cb54f2a9f72ea', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '80b92095da3b0c2d9919ddcdba2e4b22e4521412', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '5342307e2d64ffdd7a95e061e2dbb033485eabe2', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}]",David Chocholatý,84876095,,User,,44,,15,14
1027761138,PitchShiftEffect: decrease and report latency,"This PR improves the current implementation of the Pitch shift effect. The implementation approach is still the ""push"" model as known. The new version decreases the amount of latency that the effect produces. The implementation is based on the public ladspa-lv2 example implementation by RubberBand. The main difference is, that the maximum number of samples, that will be provided into RubberBand is not set, but instead of it, the minimum required number of samples is provided and processed. Based on the processing of smaller chunks of the input buffer the latency is recognizably decreased.

To avoid the dropouts which are possible in the previous implementation, the specific amount of zero samples is prefilled into the RubberBand. Based on that, the sample dropouts may occur only for the extreme settings changes. The implementation is possible without prefilling the zero samples and the latency decreased even more, anyway, a greater amount of sample dropouts occur.

The known issue is, that the sound quality for the new implementation, primarily for the +12 semitones settings looks a little bit worse to me, but IMO it could be probably solved by the RubberBand option settings.

In this PR the latency is propagated into the delay handling of the effect chain too. For now, the initial delay based on the prefilled samples is provided. Based on that, the latency reporting works properly for the initial setting, however, after dynamic pitch changes, the propagated amount of delay is not valid. This issue should be fixed in this PR too.

Please share your thoughts, comments and proposed changes to the new implementation. Thank you.",False,4898,https://api.github.com/repos/mixxxdj/mixxx/pulls/4898,https://github.com/mixxxdj/mixxx/pull/4898,open,230,61,3,9,37,13,1,0,[{'name': 'effects'}],2022-08-16 15:14:59+00:00,,0.0,,"[{'comment_id': 952211957, 'comment_body': 'A comment would be nice explaining why this helps us. ', 'comment_created': datetime.datetime(2022, 8, 23, 6, 46, 5, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 952216851, 'comment_body': 'Do we use this in our main pitch shifter as well? Can this be a solution for:\r\nhttps://github.com/mixxxdj/mixxx/pull/4030\r\n\r\n', 'comment_created': datetime.datetime(2022, 8, 23, 6, 52, 34, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 952223381, 'comment_body': 'Rubberband does it for us:\r\nhttps://github.com/breakfastquay/rubberband/blob/3efb5625d1fb3031a64d5454f77e9a806940b07e/src/faster/R2Stretcher.cpp#L266', 'comment_created': datetime.datetime(2022, 8, 23, 7, 0, 34, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 952264457, 'comment_body': 'After a bit reading I think I understand the approach. We use not setMaxProcessSize() to keep the internal buffering at a minimum. \r\n\r\nThis should be explained here, else everyone will read the Rubberband documentation and consider our approach an unnecessarily complicated\r\n\r\nhttps://breakfastquay.com/rubberband/code-doc/classRubberBand_1_1RubberBandStretcher.html#ad653e0e0498a9355cf59c2e8c8900c52\r\n\r\n> If your application has no particular constraint on processing block size ... \r\n\r\nfor my understanding we have a constrain and the proposed code here works around this.\r\n\r\n', 'comment_created': datetime.datetime(2022, 8, 23, 7, 46, 36, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 952278990, 'comment_body': ""Can't we remove this inner loop and feed Rubberband directly with a max size from framesPerBuffer?  "", 'comment_created': datetime.datetime(2022, 8, 23, 7, 58, 22, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 952281475, 'comment_body': 'What happens if requiredFrames > framesPerBuffer? ', 'comment_created': datetime.datetime(2022, 8, 23, 8, 0, 26, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 952284060, 'comment_body': 'We must not qDebug() in the engine thread, because locking buffer allocation is involved. ', 'comment_created': datetime.datetime(2022, 8, 23, 8, 2, 44, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 952286495, 'comment_body': 'I think it is more effective to do the interleaving outside the loop. ', 'comment_created': datetime.datetime(2022, 8, 23, 8, 5, 10, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 952288646, 'comment_body': 'Can we assert against this? I thing if this happens we need to pre-fill Rubberband more. ', 'comment_created': datetime.datetime(2022, 8, 23, 8, 7, 28, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 952563675, 'comment_body': ""What is the difference between 0 and X inside Rubberband? Isn't 0 just a special X? Probably the visual is just misleading.\r\nIs each bar a callback? I think than you may visualize this: \r\n\r\n```\r\nwithout zero initalization \r\nin:    |XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX| ...\r\nout:   |        |        |        |    XXXX|    XXXX|  XXXXXX|XXXXXXXX|XXXXXXXX| ...\r\n\r\n6 x out broken, if we skip 5 cycles we have enough samples in the 6th,   \r\n\r\nwith two cycles zero initialization \r\nin:    |00000000|00000000|XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX| ...\r\nout:   |        |        |        |        |        |00000000|00000000|XXXXXXXX|XXXXXXXX| ...\r\n \r\n\r\nwith zero initalization during init \r\ninit:  |00000000|00000000|00000000|00000000|00000000|\r\nin:    |XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX| ...\r\nout:   |00000000|00000000|00000000|00000000|00000000|XXXXXXXX| ...\r\n\r\n```\r\n\r\n\r\n"", 'comment_created': datetime.datetime(2022, 8, 23, 12, 37, 16, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 952580296, 'comment_body': 'My idea is that we can do the same wit a start delay and real samples: \r\n\r\n```\r\nwithout zero initalization \r\nin:    |XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX| ...\r\nout:   |        |        |        |    XXXX|    XXXX|  XXXXXX|XXXXXXXX|XXXXXXXX| ...\r\n\r\n6 x out broken, if we skip 5 cycles we have enough samples in the 6th,  \r\nFill output with 0 during the first 5 cycles  \r\n\r\nin:    |XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX| ...\r\nout:   |00000000|00000000|00000000|00000000|00000000|XXXXXXXX|XXXXXXXX|XXXXXXXX| ...\r\n\r\nsince de group delay is not const put some X into a ring and comsume it whenever Rubberband request it via getSamplesRequired() \r\n \r\nin:    |XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX|XXXXXXXX| ...\r\nout:   |00000000|00000000|00000000|00000000|00000000|00000000|XXXXXXXX|XXXXXXXX| ...\r\n\r\n```\r\n\r\n\r\n', 'comment_created': datetime.datetime(2022, 8, 23, 12, 49, 26, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 952594792, 'comment_body': 'Can RubberBand even use the rest, or is something bad happening. \r\n\r\nI expect the Rubberband users windowing functions. With 50 % overlap or such. If you now pass only a few samples the window is not full. What will happen? Rubberband fills is with old samples, CPU is increase / Rubberband does nothing, than there is no pint to even provide the samples / Rubberband pads the window with zeros which may create an audible glitch. (I have not checked so I might be wrong).\r\n\r\nFrom this point of view a traditional pull model with an input buffer creating a fixed group delay seems to be more robust. This way we can always provide the expected samples for the desired output with no exceptions. \r\n \r\n\r\n\r\n\r\n ', 'comment_created': datetime.datetime(2022, 8, 23, 13, 0, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 952633486, 'comment_body': 'Rubberband actually skips the process call if we have provided not enough data: \r\nhttps://github.com/breakfastquay/rubberband/blob/10661f40c60038cef55c1a2d8e417dbca4a17616/src/faster/StretcherProcess.cpp#L335', 'comment_created': datetime.datetime(2022, 8, 23, 13, 32, 6, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}]","[{'commit_sha': '89eecd04b8b8ce86e3f0e77b9f389f2df2d70e28', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '713e79227b1dfe7ee10853bb84ca8b019794784b', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'f804dea1bcd0aff6373cc1026d091d9f40113a83', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'f0eaccce5c900dea2fd141ff0d2aec54841f0223', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '7df030983278aa02c38392ac4124a0af56ca88b7', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '527b8b326f45478da6b926665d12036de7f1bbb0', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'd7431ed76d881e806998de43eb3e5a242567db12', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'cb2ae41f0491047b0826d22f8ff51080d993c776', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '146f104e0e3d544178428f12f2f0c295b4545966', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}]",David Chocholatý,84876095,,User,,44,,15,14
1031520817,PitchShiftEffect: extend effect options,"This PR extends the settings options of the Pitch shift effect. The implemented options are Range Mode, Semitones Mode and Wide Range option.

The Range Mode changes the range of the Pitch knob. The neutral mode (knob in the default position) keeps the range from the lowest pitch to the highest pitch. The positive mode (knob in the maximum position) keeps the range from the default pitch to the highest pitch. The negative mode (knob in the minimum position) keeps the range from the default pitch to the lowest pitch. Every mode works correctly with set the Wide Range option too.

The Wide Range option doubles the default Pitch knob scale. So, when the default scale of the pitch knob is from -1 octave to +1 octave, with set the option on the range is from -2 octaves to +2 octaves.

Lastly, the semitones mode changes the Pitch knob scale from the continuous mode to the semitones mode which works in the chromatic scale. By default, this option is on.

Another option, that will be implemented, will be the Formant option which works with the same-named option of the RubberBand library.

---

**TODO**:
- [x] Implementation of the Formant option. ",True,4901,https://api.github.com/repos/mixxxdj/mixxx/pulls/4901,https://github.com/mixxxdj/mixxx/pull/4901,closed,89,12,3,20,13,34,0,0,[],2022-08-19 19:53:53+00:00,2022-08-29 12:29:47+00:00,837354.0,"9 days, 16:35:54","[{'comment_id': 950863578, 'comment_body': 'A few suggestions. To explain them: templated functions are always inline, so we can omit it. Use c++20 concepts instead of the static_assert since the result looks nicer and probably results in a nicer error message. When T is unsigned, `a < T(0)` will always be false, so compilers will warn you about it, so I put a `if constexpr` there. I also added some static casts since the implicit casts might break and/or cause compiler warnings and errors. Also made `constexpr` because why not.\r\n```suggestion\r\n/// https://en.wikipedia.org/wiki/Sign_function\r\ntemplate<typename T>\r\nrequires std::is_arithmetic_v<T>\r\nconstexpr T sgn(const T a) {\r\n    // silence -Wtype-limits\r\n    if constexpr (std::is_unsigned_v<T>) {\r\n        return static_cast<T>(a > T(0))\r\n    } else {\r\n        return static_cast<T>(a > T(0)) - static_cast<T>(a < T(0));\r\n    }\r\n}\r\n```', 'comment_created': datetime.datetime(2022, 8, 21, 15, 33, 7, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 950864987, 'comment_body': 'IMO this is knob is unnecessary. What was your motivation for introducing it?', 'comment_created': datetime.datetime(2022, 8, 21, 15, 44, 28, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 950865330, 'comment_body': 'I don\'t think these explanations are very intuitive. I have some proposals which seem more user friendly. wdyt?\r\n```suggestion\r\n            ""Change pitch in semitone-steps instead of smoothly));\r\n```', 'comment_created': datetime.datetime(2022, 8, 21, 15, 47, 26, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 950865455, 'comment_body': '```suggestion\r\n            ""Preserve formants""));\r\n```', 'comment_created': datetime.datetime(2022, 8, 21, 15, 48, 27, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 950876273, 'comment_body': 'Okay, thank you very much for the detailed explanation. Your version looks good to me. It is really a cleaner solution.', 'comment_created': datetime.datetime(2022, 8, 21, 17, 19, 5, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 950878348, 'comment_body': 'The idea is based on the demo of the Pioneer DJM-900NX2 build-in effects including the Pitch Shift effect. As is shown in the [demo video](https://youtu.be/9BTKCT7NHIM?t=964), with turning the ""TIME"" knob, using the effect ""LEVEL/DEPTH"" knob, the Pitch goes only up or down based on the mentioned ""TIME"" knob setting (IMO it is not to best understandable solution, but don\'t care). Based on that idea, I think that it can be useful to work with the pitch in only one way (up or down) and that working with the knob in his limit bounds (minimum bound and maximum bound) is much easier. You don\'t have to take care to go from the middle knob position to maximum and back (and not go under the middle position). With that, the Pitch knob is much more sensitive, because the range, which was previously only the half of range (from the middle position to maximum for pitching up) is now recalculated to the whole knob range. In summary, it looks cool to me to allow working with the effect as same as on the Pioneer mixer (and maybe some other brand\'s mixers too), but that is just my point of view.\r\n\r\nI agree, that using the knob for only 3 possible settings is not the clearest solution, but it cannot be allowed more modes simultaneously.', 'comment_created': datetime.datetime(2022, 8, 21, 17, 39, 23, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 950883235, 'comment_body': 'Agree, looks good. Thank you.', 'comment_created': datetime.datetime(2022, 8, 21, 18, 25, 20, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 950902229, 'comment_body': 'The DJM-900NX2 TIME knob behaves differently. It is our original Pitch knob with unity at center. It sets the range of the effect when using the (additional) ""LEVEL/DEPTH"" knob.\r\nSo instead of introducing ""Mode"" and ""wideRange"" you may just introduce a ""Range"" knob, that set the min/max of the Pitch knob. \r\n\r\nThis maps to the Pioneer knobs like this: \r\n* TIME = Pitch \r\n* ""LEVEL/DEPTH"" = Range \r\n\r\n \r\n\r\n\r\n \r\n', 'comment_created': datetime.datetime(2022, 8, 21, 21, 26, 3, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 951258430, 'comment_body': 'Okay, thank you for the explanation. Just please a little clear up for me, because it is a little bit different than I understood it before. So, to actually copy the Pioneer knob\'s behaviour, you proposed something like this:\r\n```\r\n- Range: minimum position  | Pitch: using the Pitch knob nothing\'s gonna happen because the range is set as zero\r\n- Range: middle position   | Pitch: works from -12 semitones to 12 semitones\r\n- Range: maximum position  | Pitch: works from -24 semitones to 24 semitones\r\n```\r\n\r\nIs it right? If I understood it correctly, using your ""mapping"" for the Pioneer knobs should work the same.\r\n\r\nOf course, the positions of the Range knob that wasn\'t mentioned will recalculate the range too.', 'comment_created': datetime.datetime(2022, 8, 22, 10, 12, 10, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 951362281, 'comment_body': ""Yes, but the range knob has no regions, it is continuously. That's why Phil Harris eagerly turns it to be sure to hit the max range. The manual says it has a Rage from -50 ... +100%  whatever that means. Translated into speed it would be -12 ... +12 semitones. https://docs.pioneerdj.com/Manuals/DJM_900NXS2_DRI1300A_manual/?_ga=2.239935050.831276606.1638182063-764262911.1599494699&page=16\r\nDoes that make sense? I think it is much more when listening to the video. \r\nThe proposed -24 to + 24 sound reasonable.\r\n\r\n"", 'comment_created': datetime.datetime(2022, 8, 22, 12, 11, 49, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 951387222, 'comment_body': '```suggestion\r\n            ""Change pitch in semitone-steps instead of continuously.""));\r\n```\r\nSounds more natural for me, not sure though ... \r\nYou could have even a smooth change to full semitone steps, which is a different feature. ', 'comment_created': datetime.datetime(2022, 8, 22, 12, 37, 29, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 951397098, 'comment_body': 'Perfect, thank you so much. I think I understand it completely now.', 'comment_created': datetime.datetime(2022, 8, 22, 12, 47, 27, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 951423095, 'comment_body': '```suggestion\r\n            ""Preserve formants, the resonance frequencies of human vocal tract and other instruments.""));\r\n```\r\n\r\nI must admit I was not clear what exactly formats are when starting play with pitch shifting. \r\nMaybe this one liner is enough to give at least a hint, for others like me. \r\n\r\nOr we may pick a sentence that is more catchy but less exact. \r\n\r\n""Preserve formants to compensate chipmunk or growling voices.""\r\n\r\n', 'comment_created': datetime.datetime(2022, 8, 22, 13, 12, 16, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 951429331, 'comment_body': 'It looks like RB ""engine fine"" actually supports to shift the formants. If we consider this, the name ""Formant"" is better used for the formant rotary knob. This one is ""Formant Preserving"" in case we use the LV2 variant. Is the length still OK?  ', 'comment_created': datetime.datetime(2022, 8, 22, 13, 17, 49, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 951605677, 'comment_body': 'I purposefully suggested ""smooth"" instead of ""continuous"" because these texts should be as easy to understand as possible. IMO knowing the word ""continuous"" requires a higher level of english skills than ""smooth"". Even though ""continuous"" would probably be the better antonym to ""semitone-steps"". ', 'comment_created': datetime.datetime(2022, 8, 22, 15, 51, 10, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 951607962, 'comment_body': '```suggestion\r\n            ""Preserve the resonant frequencies of human vocal tract and other instruments (formants)""));\r\n```\r\nThats better imo. Easy explanation upfront and then the technical term afterwards for those that are familiar with it.', 'comment_created': datetime.datetime(2022, 8, 22, 15, 53, 14, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 951614082, 'comment_body': '> Sounds more natural for me, not sure though ...\r\nYou could have even a smooth change to full semitone steps, which is a different feature.\r\n\r\nI agree, based on some grammar upgrades, the `""Change the pitch in semitone steps instead of continuously.""` version looks good to me.', 'comment_created': datetime.datetime(2022, 8, 22, 15, 59, 1, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 951625639, 'comment_body': '> Or we may pick a sentence that is more catchy but less exact.\r\n""Preserve formants to compensate chipmunk or growling voices.""\r\n\r\nLooks cool :+1:, anyway, I would prefer the proposed version due to it mentions the best usage (vocal tracks and instruments) too. Or, the easier way to understand can be added in brackets:\r\n\r\n`""Preserve formants, the resonance frequencies of the human vocal tract and other instruments (hint: ""compensates chipmunk or growling voices"").""`\r\n\r\nWhat do you think about that? I agree, that the phrase ""resonance frequencies"" does not have to be quite helpful still.', 'comment_created': datetime.datetime(2022, 8, 22, 16, 11, 1, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 951641963, 'comment_body': '@Swiftb0y sorry, based my browser did not update your answer, I see it until now. IMHO the ""continuously"" looks more accurately in some way to me. To go a little bit deeper in the English point of view, both words belong to the B2 level, but it\'s true that the ""continuously"" word is rather for more technical English users. Of course, I am open-minded to both versions.', 'comment_created': datetime.datetime(2022, 8, 22, 16, 26, 36, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 951661480, 'comment_body': 'Pick what works for you, or an entire different string. As long we explain the user a bit more what this is about it should be fine. ', 'comment_created': datetime.datetime(2022, 8, 22, 16, 46, 13, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 951739688, 'comment_body': 'Yeah, in the R3 version the formant can be shifted using a knob. With introducing the R3 version in the Pitch shift effect, this option of course could be added and if it would be, the identical toggle name will be the problem too. On the other hand, the ""Formant Preserving"" name is too wide, see the print screen:\r\n\r\n![image](https://user-images.githubusercontent.com/84876095/185974426-f9350bde-0a6c-4242-84ee-adc313cc24d3.png)\r\n\r\nIt looks like the maximum number of characters is about 10.', 'comment_created': datetime.datetime(2022, 8, 22, 17, 57, 9, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 951750012, 'comment_body': 'Then just name it formant and put the detailed explanation in the tooltip imo.', 'comment_created': datetime.datetime(2022, 8, 22, 18, 7, 23, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 951941382, 'comment_body': 'Ok, but at least the Id should not be ""formant"". Since the name can be changed at any time, but not the ID.', 'comment_created': datetime.datetime(2022, 8, 22, 21, 47, 8, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 952185667, 'comment_body': 'Since this is a translated text, there is no much need to be understandable for non English speaker. As long it is correct English it works for me. \r\n\r\nIt just jumps to my eyes initially because It look unusual to me. But I can*t really judge. Maybe a native speaker can jump in, @ywwg? This is not a blocking issue, though. \r\n  ', 'comment_created': datetime.datetime(2022, 8, 23, 6, 6, 23, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 952213629, 'comment_body': 'Okay, that looks good to me.', 'comment_created': datetime.datetime(2022, 8, 23, 6, 48, 18, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 952703914, 'comment_body': 'IMO this is cleaner since the value now actually depends on the parameter instead of just flipflopping based on itself (even though the solution are both probably equivalent) \r\n```suggestion\r\n    if (const bool formantPreserving = m_pFormantPreservingParameter->toBool(); m_currentFormant != formantPreserving) {\r\n        m_currentFormant = formantPreserving;\r\n```', 'comment_created': datetime.datetime(2022, 8, 23, 14, 29, 26, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 952705668, 'comment_body': '```suggestion\r\nstatic constexpr SINT kSemitonesPerOctave = 12;\r\n```', 'comment_created': datetime.datetime(2022, 8, 23, 14, 30, 49, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 954564858, 'comment_body': ""Yeah, good idea. Anyway, didn't you mean this solution instead?\r\n\r\n```\r\nconst bool formantPreserving = m_pFormantPreservingParameter->toBool();\r\n\r\nif (m_currentFormant != formantPreserving) {\r\n        m_currentFormant = formantPreserving;\r\n```"", 'comment_created': datetime.datetime(2022, 8, 25, 6, 49, 56, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 955053386, 'comment_body': 'Both works. C++17 added support for `init-statement`s before the `condition`. \r\nhttps://en.cppreference.com/w/cpp/language/if\r\nhttps://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0305r0.html\r\nThis will bind the variable scope to the if statement instead of the outer scope. I like to reduce the scope variables are bound to to be as narrow as possible.\r\nIf you find your solution easier to read/understand then go ahead and use that instead. As I said, both is legal C++', 'comment_created': datetime.datetime(2022, 8, 25, 14, 38, 53, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 955347636, 'comment_body': ""> Both works. C++17 added support for `init-statement`s before the `condition`. https://en.cppreference.com/w/cpp/language/if https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0305r0.html \r\n\r\nOh perfect, sounds cool. The new thing for me. Thank you for the links.\r\n\r\n> This will bind the variable scope to the if statement instead of the outer scope. I like to reduce the scope variables are bound to to be as narrow as possible.\r\n\r\nThat's reasonable.\r\n\r\n> If you find your solution easier to read/understand then go ahead and use that instead. As I said, both is legal C++\r\n\r\nReducing the variable scope makes sense to me.\r\n\r\n"", 'comment_created': datetime.datetime(2022, 8, 25, 19, 30, 16, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 955442977, 'comment_body': '```suggestion\r\n    m_pFormantPreservingParameter = parameters.value(""formantPreserving"");\r\n```\r\nThis fixes the segfault.', 'comment_created': datetime.datetime(2022, 8, 25, 21, 36, 53, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 955455979, 'comment_body': 'I think we should put these as `QStringLiteral`s into the anonymous namespace above. ', 'comment_created': datetime.datetime(2022, 8, 25, 21, 59, 17, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 955648125, 'comment_body': ""Oh, thank you. I'm sorry, I overlooked it."", 'comment_created': datetime.datetime(2022, 8, 26, 4, 53, 30, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 955683638, 'comment_body': 'Great idea, good approach to avoid the grammar mistakes which causes the segmentation fault as was found.', 'comment_created': datetime.datetime(2022, 8, 26, 5, 59, 38, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}]","[{'commit_sha': '651325020ffa213b33a6ac7b006d4d598b23dc8e', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ab124c31027d0c730322c8f56a3c6fda38fcac78', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'b913b7ec3bfba6aef22eccea2dcc5d532166fd2f', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'cd431e69705d278b7e31a6785d358feed1979ec5', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'bc09b723c8f927fbad4226bab3f9bfb71e291854', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '2c579975e3b973316d797e9155ef3236f352c802', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '150f647d4212d3e7e25bec2317e569b613016068', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '9ea8322fdb64f8f6ee5911ef600421206e5a2100', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'c49712ab0e4ccab3db27b1d7d4b8cde53915e529', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ba5e5d4d00d2cb9a7d792f3207e94142c450874a', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'd44fc12084b30e9918770e7a74aaf67b71bcb3d3', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'c60407c90707b6d586259a5f6487e6a5c8b436d4', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '0d9bc0c8b555529c7df5c937a06c7005d03170e5', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '5901cfdc6bcdb76f9339c35c42eba8f336a51ceb', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '9c42ae2aa3e87abb8628e3ba216d4b59b7e4bd9d', 'committer_username': 'Swiftb0y', 'committer_name': None, 'committer_email': None, 'commit_date': datetime.datetime(2015, 5, 10, 11, 0, 12, tzinfo=datetime.timezone.utc)}, {'commit_sha': '7eef60861c90325d51f8005e2970dc6c3f6314dc', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'cd26497cbcc063bd1fe6976d3d28e53ff36c23a6', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '7d40f6dfcc110c0af0560307a2a97d12eeb05aea', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '5d98c7f6041789b6e0e6624ce1fc6d4f455ba1c0', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'fe7fe7d3a2e7680e0b3ecfb349f3ad45d3a52a6d', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}]",David Chocholatý,84876095,,User,,44,,15,14
1038679721,Improve buffers size function const-correctness,"This PR improves the const-correctness of the function which returns the size of the buffer for a specific buffer implementation. Due to the returned value can be evaluated in the compile time, the value can be marked as a constant expression. 

The idea of this improvement is inspired by the size function from std::span.

What do you think about it?",True,10827,https://api.github.com/repos/mixxxdj/mixxx/pulls/10827,https://github.com/mixxxdj/mixxx/pull/10827,closed,4,4,3,3,3,0,0,0,[],2022-08-27 17:53:00+00:00,2022-08-29 06:48:47+00:00,132947.0,"1 day, 12:55:47",[],"[{'commit_sha': '8255e1776564220dce3dd84957fea47ffacd2963', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '6777080250d8b3a7c44e2f1c633dfd263453a71f', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'bdf92343f2f8f998dc6e4d0b10cd6cdd3a31972f', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}]",David Chocholatý,84876095,,User,,44,,15,14
1039721404,EngineBufferScaleRubberBand: remove unused include,"This PR removes the unused include for ""track/keyutils.h"".",True,10835,https://api.github.com/repos/mixxxdj/mixxx/pulls/10835,https://github.com/mixxxdj/mixxx/pull/10835,closed,0,1,1,1,0,0,0,0,[],2022-08-29 13:43:45+00:00,2022-09-01 19:19:18+00:00,279333.0,"3 days, 5:35:33",[],"[{'commit_sha': '38d8462f206eae84bb282f380988f74d138ec9f1', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}]",David Chocholatý,84876095,,User,,44,,15,14
1040589279,EngineEffectsDelay: introduce ring delay buffer,"This PR introduces the `RingDelayBuffer` and replaces the previous processing approach. Based on that, the implemented crossfade is replaced with `SampleUtil::linearCrossfadeBuffersOut`. Dependent tests are upgraded because `RingDelayBuffer` uses the fading-in, for the first written chunk of data, and the crossfading is used in stereo mode.",False,10840,https://api.github.com/repos/mixxxdj/mixxx/pulls/10840,https://github.com/mixxxdj/mixxx/pull/10840,open,223,180,3,8,8,14,1,0,[{'name': 'code quality'}],2022-08-30 07:45:08+00:00,,0.0,,"[{'comment_id': 958352521, 'comment_body': 'There is no reason for these to exist imo. \r\n\r\nIf you need a subspan, you can just call `subspan` on the span you just got from `SampleBuffer::span`. Performance should be similar because the subspan method is so trivial that its likely inlined anyways. ', 'comment_created': datetime.datetime(2022, 8, 30, 11, 22, 41, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 958414766, 'comment_body': ""I don't see any reason for allocating here. RingDelayBuffer already does internally. \r\n```suggestion\r\n    RingDelayBuffer m_pDelayBuffer;\r\n```"", 'comment_created': datetime.datetime(2022, 8, 30, 12, 27, 23, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 958440635, 'comment_body': 'A shame that we need to copy here... iterators could solve that problem. \r\n\r\nThe suggestion below is identical in functionality but is a little better self-documenting in my opinion.\r\n\r\n```suggestion\r\n        // Read the samples using the current group delay samples.\r\n        auto tmpBufferView = m_currentDelayBuffer.span().first(inOutSpan.size());\r\n        m_pDelayBuffer->read(tmpBufferView, m_currentDelaySamples);\r\n        \r\n        SampleUtil::linearCrossfadeBuffersOut(\r\n                pInOut,\r\n                tmpBufferView.data(),\r\n                tmpBufferView.size());\r\n```', 'comment_created': datetime.datetime(2022, 8, 30, 12, 52, 9, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 958947680, 'comment_body': ""Yeah, I thought about creating another span (subspan), from the span which we didn't need, so we have actually two spans with one unused. But as you describe the situation with inlining, it does not make much sense then."", 'comment_created': datetime.datetime(2022, 8, 30, 21, 31, 24, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 958993517, 'comment_body': '```suggestion\r\n                m_currentDelayBuffer.span().first(iBufferSize),\r\n```', 'comment_created': datetime.datetime(2022, 8, 30, 22, 41, 57, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 959002977, 'comment_body': 'Should be done with a fix for your previous proposal for the same part of the code. I mean the version using the `tmpBufferView `variable and primarily `inOutSpan.size()` for the size. IMO a more solid solution preventing errors in case of future possible code changes.', 'comment_created': datetime.datetime(2022, 8, 30, 23, 3, 11, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 959003779, 'comment_body': 'I just noticed another flaw in these tests (sorry for widening the scope of the PR). \r\nthe `p` prefix of variables is only used for variables holding a pointer. But samplebuffer is not a pointer, so we should fix the name accordingly.', 'comment_created': datetime.datetime(2022, 8, 30, 23, 5, 7, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 959005689, 'comment_body': 'Having to change the data in tests to fix them is usually a sign that some observable behavior has changed. Can you explain why the change of the values is still correct?', 'comment_created': datetime.datetime(2022, 8, 30, 23, 9, 36, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 959012952, 'comment_body': 'Yeah of course. I will start with the change in the `EngineEffectsDelay`.\r\n\r\n1. In the version before, the ramping was used for samples chunk independent of the channel count, so the previous version sequence was [-100.0, 75.0, -49.5, 24.75]. Based on the change of use `SampleUtil::linearCrossfadeBuffersOut` the crossfade (in this case more ramping due to crossfade with zero ""silence"" samples) works in the I would call ""stereo mode"". So the new expected result is [-100.0, 100.0, -49.5, 49.5].\r\n\r\n2. Due to the feature in the `RingDelayBuffer`, that the first chunk of written samples is faded-in due to avoid a ""crackling"" sound when crossing the border from zero ""silence"" samples to real data, the expected result should change based on this feature. So, the final result is [-50.0, 50.0, -49.5, 49.5].\r\n\r\n', 'comment_created': datetime.datetime(2022, 8, 30, 23, 26, 49, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 959013813, 'comment_body': ""No problem. You're right, it does not make sense."", 'comment_created': datetime.datetime(2022, 8, 30, 23, 28, 53, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 959679180, 'comment_body': 'Ah yes, that makes total sense. Thank you for the explanation.', 'comment_created': datetime.datetime(2022, 8, 31, 14, 45, 24, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 960829702, 'comment_body': '```suggestion\r\n    const CSAMPLE expectedResult[] = {0, 0, 0, 0};\r\n```\r\n\r\nThis might fix the failing test, even though I have no idea why that causes the failure in the first place...', 'comment_created': datetime.datetime(2022, 9, 1, 15, 56, 9, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 961024772, 'comment_body': 'Oh, thank you for the proposal. I will try it.', 'comment_created': datetime.datetime(2022, 9, 1, 19, 24, 48, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 973767020, 'comment_body': ""Can you simplify this somehow? Tests need to be simple enough to confirm their correctness by simply looking at them. In this case, I not only can't confirm its correctness, I even struggle to understand what this does in the first place. "", 'comment_created': datetime.datetime(2022, 9, 18, 19, 46, 6, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}]","[{'commit_sha': '999db3bdb99e683d014ac03bab0e097e80ecfcda', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '65955edff508197c5de7d8e3b61f0b4851dc2cb7', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '0f1dca4192ddd7b36df3792069ba8b2a379a12f6', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'fd4b475c00310f34c551dc9acf5715789e5182dc', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '6c90dcaa5433ad0be5f9a862f8282b59f771ca58', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '0c01e340f43386155896f56333e608695d407677', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '338f3397c0c9c52d55bab3647df97eff534731c5', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '8f6dbbb791b5d310591a9b4801bb04cdcbb47f33', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}]",David Chocholatý,84876095,,User,,44,,15,14
1040900888,RingDelayBufferTest: refactor includes and span creation,The PR just improves a little bit the `RingDelayBufferTest`. The unused include is removed and the multiple span creation from one `SampleBuffer` is avoided.,True,10843,https://api.github.com/repos/mixxxdj/mixxx/pulls/10843,https://github.com/mixxxdj/mixxx/pull/10843,closed,36,25,1,3,3,2,1,0,[{'name': 'code quality'}],2022-08-30 12:10:20+00:00,2022-09-01 19:18:52+00:00,198512.0,"2 days, 7:08:32","[{'comment_id': 958949194, 'comment_body': 'Build fails because `spanFromPtrLen` can only create a `std::span<const CSAMPLE>` since the buffer it observes is also `const`. Either of the below suggestions would work. I prefer the `auto` version since the type is clear and the line is already somewhat long. \r\n\r\n```suggestion\r\n    std::span<const CSAMPLE> inputBufferSpan = mixxx::spanutil::spanFromPtrLen(inputBuffer, numSamples);\r\n```\r\n\r\n```suggestion\r\n    auto inputBufferSpan = mixxx::spanutil::spanFromPtrLen(inputBuffer, numSamples);\r\n```', 'comment_created': datetime.datetime(2022, 8, 30, 21, 33, 42, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 959009506, 'comment_body': 'Auto looks better in this situation to me too. Thank you.', 'comment_created': datetime.datetime(2022, 8, 30, 23, 18, 28, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}]","[{'commit_sha': '4579d2e85cc965cc48b89663cfcfc2229d15c517', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'e1c6e8a2c61a5edbb0d42786e22b8516e094857a', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '9044dd8312cff70c156d2f9ce3fca93559858838', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}]",David Chocholatý,84876095,,User,,44,,15,14
1044569444,PitchShiftEffect: add description comments,"This PR adds the comments, primarily for the usage
of the RubberBand API, for the Pitch shift effect processing.",True,10858,https://api.github.com/repos/mixxxdj/mixxx/pulls/10858,https://github.com/mixxxdj/mixxx/pull/10858,closed,68,0,1,6,2,3,0,0,[],2022-09-02 07:08:57+00:00,2022-09-04 11:23:18+00:00,188061.0,"2 days, 4:14:21","[{'comment_id': 961589219, 'comment_body': 'This comment just repeats the code. ', 'comment_created': datetime.datetime(2022, 9, 2, 11, 45, 8, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 961590751, 'comment_body': 'This comment does also not add any value. \r\nYou may explain that one of from 0...X and the other from -x to +y ... and describe the implications. ', 'comment_created': datetime.datetime(2022, 9, 2, 11, 47, 19, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 961591555, 'comment_body': 'Here also no value. You may tell us why std::pow(2.0 is required. ', 'comment_created': datetime.datetime(2022, 9, 2, 11, 48, 28, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}]","[{'commit_sha': 'c3f24bf2e6f378c7263f1f5b5b52c56ab1602136', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'a8bc3c11f58c178b96c10cc928d81dabacc8fb8d', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'cdea4bfbc96b5f220d7cf22a7be95878b66ad046', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '8a29d5457d53e942efbc66bb3f447c12f8679f72', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'e030e1ee778833406b7c399c7a3ea8ed219477d0', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '1cb332100ed8bf680ea1cbf269fd8113ee59dc70', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}]",David Chocholatý,84876095,,User,,44,,15,14
1045550192,content/news: add GSoC 2022 Work Product,This PR adds the final blog with the work product for the Google Summer of Code 2022. The blog is written for the Pitch Shift effect and Group delay handling project which was implemented by davidchocholaty contributor.,True,279,https://api.github.com/repos/mixxxdj/website/pulls/279,https://github.com/mixxxdj/website/pull/279,closed,771,0,9,53,15,68,0,0,[],2022-09-03 20:01:56+00:00,2022-09-08 21:45:53+00:00,438237.0,"5 days, 1:43:57","[{'comment_id': 962350057, 'comment_body': '```suggestion\r\ntitle: GSoC 2022 Work Product - Pitch Shift effect and Group delay handling\r\n```', 'comment_created': datetime.datetime(2022, 9, 4, 18, 9, 46, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 962350756, 'comment_body': 'markdown is simpler and should work just as well.\r\n```suggestion\r\n * Scale\r\n   * In music theory, a scale is any set of musical notes ordered\r\n    by fundamental frequency or pitch. The scale ordered\r\n    by increasing pitch is an ascending scale, and a scale ordered\r\n    by decreasing pitch is a descending scale.\r\n```', 'comment_created': datetime.datetime(2022, 9, 4, 18, 16, 16, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 962350823, 'comment_body': '```suggestion\r\n---\r\n```', 'comment_created': datetime.datetime(2022, 9, 4, 18, 17, 14, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 962351183, 'comment_body': 'I think we should add a disclaimer that this blogpost primarily serves as documentation to google and thus goes into a lot more detail our other blogposts.', 'comment_created': datetime.datetime(2022, 9, 4, 18, 19, 58, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 963054918, 'comment_body': '```suggestion\r\nBefore the effect is implemented, the pitch of a track could be changed using the decks\r\nrate slider separately only. This imposes significant restrictions in the ways other effects can interact with the sound. In this project, the new Pitch Shift\r\n```\r\n\r\nBoth of these statements is not really true, there are a lot of creative things DJs have done with the rate adjustment of a turntable. Also it can shift by quite a lot if configured so in the settings. ', 'comment_created': datetime.datetime(2022, 9, 5, 16, 56, 27, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 963055730, 'comment_body': 'prefer the simpler Markdown constructs if possible.\r\n```suggestion\r\n* Scale\r\n  * In music theory, a scale is any set of musical notes ordered\r\n    by fundamental frequency or pitch. The scale ordered\r\n    by increasing pitch is an ascending scale, and a scale ordered\r\n    by decreasing pitch is a descending scale.\r\n```', 'comment_created': datetime.datetime(2022, 9, 5, 16, 58, 37, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 963056273, 'comment_body': '""distance in pitch"" doesn\'t make sense to me. What unit is that supposed to be?', 'comment_created': datetime.datetime(2022, 9, 5, 16, 59, 54, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 963057075, 'comment_body': '```suggestion\r\n            <li>A semitone is a distance in pitch between a note\r\n            and the very next note, higher or lower. It is the smallest interval\r\n            in most western scales.</li>\r\n```', 'comment_created': datetime.datetime(2022, 9, 5, 17, 1, 56, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 963058033, 'comment_body': 'I think we should leave citations for snippets ripped from other sources. ', 'comment_created': datetime.datetime(2022, 9, 5, 17, 4, 26, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 963058622, 'comment_body': '```suggestion\r\n            <li>An audio buffer holds a fixed size amount of sampled audio data.\r\n            The audio buffer size determines the time allowed for the computer\r\n            to process the audio data. Thus it also determines Latency.</li>\r\n```', 'comment_created': datetime.datetime(2022, 9, 5, 17, 6, 1, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 963059114, 'comment_body': 'IMO too general of an explanation. We should either replace it by an audio specific explanation or at least add a concrete example.', 'comment_created': datetime.datetime(2022, 9, 5, 17, 7, 10, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 963059555, 'comment_body': 'not important for understanding the article IMO. We should just link to the github wiki page when the term is mentioned in the document body.', 'comment_created': datetime.datetime(2022, 9, 5, 17, 8, 23, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 963066626, 'comment_body': 'we should probably use the permalink instead:\r\n```suggestion\r\n- [pitchshifteffect.cpp](https://github.com/mixxxdj/mixxx/blob/d232119d8fd82e9bdaaf2958e847593156b261f0/src/effects/backends/builtin/pitchshifteffect.cpp)\r\n```', 'comment_created': datetime.datetime(2022, 9, 5, 17, 28, 45, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 963067691, 'comment_body': ':stuck_out_tongue_winking_eye: :joy: \r\n```suggestion\r\n@Video(https://www.youtube.com/watch?v=dQw4w9WgXcQ)\r\n```', 'comment_created': datetime.datetime(2022, 9, 5, 17, 31, 38, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 963068669, 'comment_body': ""since these PRs don't belong to the same repo all the time, I'd prepend the repo name.\r\n```suggestion\r\n[mixxx#4852](https://github.com/mixxxdj/mixxx/pull/4852)\r\n- RingDelayBuffer: ring buffer for delay handling\r\n```"", 'comment_created': datetime.datetime(2022, 9, 5, 17, 34, 27, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 963069318, 'comment_body': ""I'd also add a mention of the PR to this blog post here since its technically also work done for mixxx imo."", 'comment_created': datetime.datetime(2022, 9, 5, 17, 36, 36, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 963069528, 'comment_body': '```suggestion\r\n(`EngineEffectChain`), the group delay latency handling was implemented\r\n```\r\nput class names in backquotes so their appear in monospace.', 'comment_created': datetime.datetime(2022, 9, 5, 17, 37, 23, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 963071019, 'comment_body': 'would it be possible to remake these with a color scheme that matches the mixxx website better?\r\nAlso it would be nice if these were SVGs if possible.\r\nIMO it would also be better if the y-axis would start at 0 instead of the lowest latency value. That would illustrate why either model is imperfect.', 'comment_created': datetime.datetime(2022, 9, 5, 17, 41, 58, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 963075355, 'comment_body': ""this is where I'd link to the github wiki page. Also a slight correction: ubuntu/canonical does not really have any minimum requirements policy as far as I'm aware of. They just include whats stable in their repositories. It's our own policy that we want mixxx to be compatible with the latest ubuntu LTS and thus ensure we stay compatible with the dependencies available in ubuntu."", 'comment_created': datetime.datetime(2022, 9, 5, 17, 56, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 963076104, 'comment_body': ""Just to be clear, you're not forced to do anything mixxx related after gsoc. :sweat_smile:   \r\nI was just suggesting that this is probably a very anticipated feature for mixxx and thus worth spending time on. "", 'comment_created': datetime.datetime(2022, 9, 5, 17, 58, 28, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 963077152, 'comment_body': 'Can you redo these screenshots with a dark theme to fit the website better? I think you can find that on github > settings > appearance.', 'comment_created': datetime.datetime(2022, 9, 5, 18, 2, 20, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 963078808, 'comment_body': ""Thank you. I'd also like to thank you for spending your valuable time with me on mixxx. While certainly stressful, it has still been fun with you.\r\n\r\nYou can link my author page if you want.\r\n```suggestion\r\nFirst, I would like to many thank my mentor [@Swiftb0y]({author}nikolaus-einhauser) for his guidance, help,\r\nreviews, and a lot of new information and lessons he gave me during the summer.\r\n```"", 'comment_created': datetime.datetime(2022, 9, 5, 18, 8, 19, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 963087779, 'comment_body': ':joy::joy::joy:', 'comment_created': datetime.datetime(2022, 9, 5, 18, 39, 32, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 964477032, 'comment_body': 'This indentation is lost in the rendered html ', 'comment_created': datetime.datetime(2022, 9, 7, 7, 23, 10, tzinfo=datetime.timezone.utc), 'commenter': 'daschuer', 'type': 'User'}, {'comment_id': 964479532, 'comment_body': 'Yeah, I know. :smile:  I would like to continue contributing after GSoC and I took it as an agreement, that I can work on this task due to it being from a similar field as the project.', 'comment_created': datetime.datetime(2022, 9, 7, 7, 25, 25, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 964486093, 'comment_body': ""Thank you very much. Yeah, it was fun for me too. :+1: \r\n\r\nPerfect, I will add it. Is okay that I used your nickname? Or would you like to replace it with your full name as on the developer link? I used the names you and Daniel used on the GSoC page as Mentor's names, so I followed them.\r\n"", 'comment_created': datetime.datetime(2022, 9, 7, 7, 32, 17, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 964520048, 'comment_body': 'Thank you for the hint. Now, it should be fixed.', 'comment_created': datetime.datetime(2022, 9, 7, 8, 5, 44, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 964550356, 'comment_body': 'Replaced with a new version: In music theory, an interval is a difference in pitch between two sounds. In western scales, intervals are most commonly differences between whole tones and semitones.', 'comment_created': datetime.datetime(2022, 9, 7, 8, 34, 33, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 964598800, 'comment_body': 'Replaced with a new version:\r\n\r\nIn the audio world, “latency” is another word for “delay”.\r\n     The latency (time) of an audio system refers to the time difference\r\n     from the moment a signal is fed into the system, to the moment it appears\r\n     at the output. For example, audio latency is when there’s a noticeable\r\n     delay between the sound being played and the moment it reaches\r\n     the speakers. Depending on the application, such a delay can have various\r\n     effects. Usually, the aim is to achieve the lowest possible latency.', 'comment_created': datetime.datetime(2022, 9, 7, 9, 19, 34, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 964681569, 'comment_body': ""I'm afraid, that I do not fully understand what you mean. Do you mean to remove the description from here and rather use the link in the text on the citation source?"", 'comment_created': datetime.datetime(2022, 9, 7, 10, 43, 46, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 964766650, 'comment_body': ""Well, It's common practice when you cite something (just as you cited wikipedia here) you usually provide a reference to the source right where you cited it (or provide at least a footnote). At least thats how I learned it in school in germany, there are probably regional differences though.\r\n\r\nHere's an example on how footnotes work in pelican (which we use for building the website): https://github.com/getpelican/pelican/blob/master/pelican/tests/content/article_with_markdown_and_footnote.md"", 'comment_created': datetime.datetime(2022, 9, 7, 12, 13, 56, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 964769982, 'comment_body': 'So Im just requesting that you add the annotations that link the quote to the source. \r\n```quote\r\nIn computer science, a circular buffer or ring buffer\r\nis a data structure that uses a single, fixed-size buffer\r\nas if it were connected end-to-end. This structure lends itself\r\neasily to buffering data streams.[^1]\r\n```\r\nAt the page bottom:\r\n```\r\n[^1]: https://en.wikipedia.org/wiki/Circular_buffer\r\n```', 'comment_created': datetime.datetime(2022, 9, 7, 12, 17, 28, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 964772885, 'comment_body': ""I don't really care, my nickname and my real name have become synonymous. Use whatever you like."", 'comment_created': datetime.datetime(2022, 9, 7, 12, 20, 41, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 964779015, 'comment_body': '```suggestion\r\ntags: gsoc, gsoc-2022\r\n```\r\nAny other tags that would fit?', 'comment_created': datetime.datetime(2022, 9, 7, 12, 26, 59, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 964785221, 'comment_body': '```suggestion\r\nIn this PR, the `std::span` was newly introduced into the Mixxx app code\r\n```', 'comment_created': datetime.datetime(2022, 9, 7, 12, 33, 23, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 964788882, 'comment_body': '```suggestion\r\nWhile working on [mixxx#4810](https://github.com/mixxxdj/mixxx/pull/4810) I encountered a bug in the `EngineFilterDelay` structure: The structure\r\n```', 'comment_created': datetime.datetime(2022, 9, 7, 12, 37, 17, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 964791286, 'comment_body': '```suggestion\r\nring buffer size depending on the range that was set. As the last thing,\r\n```', 'comment_created': datetime.datetime(2022, 9, 7, 12, 39, 40, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 964795605, 'comment_body': '```suggestion\r\nis off, the Pitch knob works in the continuous mode, which is also the default\r\nin the RubberBand library. At last, the Formant preserving option was added\r\n```', 'comment_created': datetime.datetime(2022, 9, 7, 12, 44, 9, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 964802372, 'comment_body': '```suggestion\r\nto work in the range of ± 2 octaves (± 24 semitones). \r\nThe pitch shift effect has the following options:\r\n```', 'comment_created': datetime.datetime(2022, 9, 7, 12, 50, 30, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 964803476, 'comment_body': 'If I am thinking about it, just the latency offers, but not sure.', 'comment_created': datetime.datetime(2022, 9, 7, 12, 51, 33, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 964806360, 'comment_body': ""Perfect, I just didn't understand, that you have this approach in mind. :+1: Yeah, I know it a lot from technical papers."", 'comment_created': datetime.datetime(2022, 9, 7, 12, 54, 58, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 964809330, 'comment_body': '```suggestion\r\nit should be preferred over the “push model” implementation.\r\n```', 'comment_created': datetime.datetime(2022, 9, 7, 12, 58, 43, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 964813853, 'comment_body': '```suggestion\r\nfor Pitch Shifting was tested too but produced results with worse\r\n```', 'comment_created': datetime.datetime(2022, 9, 7, 13, 3, 1, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 964820282, 'comment_body': '```suggestion\r\nIt will allow users to use their favorite effects enabled via audio plugin\r\nstandards such as  LADSPA, DSSI, LV2, VST2, VST3 and so on,\r\n```', 'comment_created': datetime.datetime(2022, 9, 7, 13, 9, 3, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 964820519, 'comment_body': ""> At least thats how I learned it in school in germany, there are probably regional differences though.\r\n\r\nJust for interest, we use it in the Czech Republic's universities as well."", 'comment_created': datetime.datetime(2022, 9, 7, 13, 9, 15, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 964829076, 'comment_body': '```suggestion\r\nIn the GSoC Coding period, work was started to minimize the effects latency as\r\nwell as to polish the effect even more. Unfortunately that work could \r\nnot be finished before the GSoC deadline. \r\n```', 'comment_created': datetime.datetime(2022, 9, 7, 13, 16, 58, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 964833730, 'comment_body': ""```suggestion\r\nI'm just motivated and learned a lot. I would like to thank the Mixxx organization\r\n```"", 'comment_created': datetime.datetime(2022, 9, 7, 13, 20, 36, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 964886298, 'comment_body': 'Lets hide this for now until we have the correct video uploaded.\r\n```suggestion\r\n\r\n<!---\r\n#### Demo video\r\nTODO(davidchocholaty) add demo video\r\n\r\n@Video(https://www.youtube.com/watch?v=rt5Ed5GZ1U8)\r\n-->\r\n```', 'comment_created': datetime.datetime(2022, 9, 7, 14, 1, 45, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 965183124, 'comment_body': 'Sounds cool, really well-formed. :+1: ', 'comment_created': datetime.datetime(2022, 9, 7, 19, 6, 28, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 965212756, 'comment_body': '```suggestion\r\nRun on the same system as above.\r\n```', 'comment_created': datetime.datetime(2022, 9, 7, 19, 47, 44, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 965213090, 'comment_body': 'What does this signify? Load on what? What are those numbers?', 'comment_created': datetime.datetime(2022, 9, 7, 19, 48, 11, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 965239447, 'comment_body': 'This footnote seems wrong.', 'comment_created': datetime.datetime(2022, 9, 7, 20, 24, 38, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 965240411, 'comment_body': '`10` and `11` are here twice, is that on purpose?', 'comment_created': datetime.datetime(2022, 9, 7, 20, 26, 1, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 965358802, 'comment_body': '@Be-ing uploaded the video to our YouTube channel: https://www.youtube.com/watch?v=NTjV7s5Jb_o', 'comment_created': datetime.datetime(2022, 9, 7, 22, 47, 4, tzinfo=datetime.timezone.utc), 'commenter': 'Holzhaus', 'type': 'User'}, {'comment_id': 965527256, 'comment_body': 'Awesome. :+1:  Thank you very much for the information and @Be-ing for so fast uploading.', 'comment_created': datetime.datetime(2022, 9, 8, 5, 53, 12, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 965529451, 'comment_body': 'Yeah, right. Thank you! I forgot to remove it.', 'comment_created': datetime.datetime(2022, 9, 8, 5, 57, 10, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 965543479, 'comment_body': 'Yes, it was meant to be. The reason for that is, that the description is a combination of citations from two sources and the whole paragraph made more sense to me if the sentences have combined these ways, so the two citation sources alternate.', 'comment_created': datetime.datetime(2022, 9, 8, 6, 13, 22, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 965562484, 'comment_body': ""To be honest, I had to do some research about the meaning :smile:. In a nutshell, it describes the computational work of the CPU. More information in the following sources:\r\n\r\nhttps://en.wikipedia.org/wiki/Load_(computing)\r\nhttps://www.guyrutenberg.com/2008/07/25/understanding-load-average-a-practitioner-guide/\r\n\r\nIMO because the pattern is written exactly the same on the Linux system (the `uptime` command), I propose to just keep it as it is for the user who is consecration in it (others will just probably skip this part) or remove it if we agree that it doesn't make sense to publish. Because it is exactly the copy-paste from the Google Benchmark output, I would prefer to keep it as is. IMHO I don't see much value in explaining the reason for the resulting output.\r\n\r\nWhat's your opinion?\r\n"", 'comment_created': datetime.datetime(2022, 9, 8, 6, 41, 46, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 965564987, 'comment_body': 'Thank you, great idea. :+1: ', 'comment_created': datetime.datetime(2022, 9, 8, 6, 45, 26, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 965926592, 'comment_body': '```suggestion\r\nThe Pitch knob changes the pitch of a track up or down. For the default\r\n```', 'comment_created': datetime.datetime(2022, 9, 8, 12, 47, 44, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 965926929, 'comment_body': '```suggestion\r\nthe range of the Pitch knob. The Pitch knob based on the range setting can work\r\n```', 'comment_created': datetime.datetime(2022, 9, 8, 12, 47, 57, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 965931186, 'comment_body': '```suggestion\r\nto [@Be.]({author}be) for taking care of publishing\r\n```', 'comment_created': datetime.datetime(2022, 9, 8, 12, 51, 38, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 965938820, 'comment_body': ""You made the video. Uploading it was trivial. You don't need to credit me for that."", 'comment_created': datetime.datetime(2022, 9, 8, 12, 58, 33, tzinfo=datetime.timezone.utc), 'commenter': 'Be-ing', 'type': 'User'}, {'comment_id': 965939164, 'comment_body': ""Interesting, I didn't know google benchmark outputted this info. To be honest, I'd remove them because they just signify load averages over the last 1, 5, 15 minutes. For a benchmark that only runs for 30s, I don't see much value in the info retrieved with the mentioned window sizes. "", 'comment_created': datetime.datetime(2022, 9, 8, 12, 58, 54, tzinfo=datetime.timezone.utc), 'commenter': 'Swiftb0y', 'type': 'User'}, {'comment_id': 966010305, 'comment_body': 'Sorry for the possible misunderstanding. The previous deleted (""Right :smile:"") answer was for a proposal for change by @Swiftb0y. My web browser just did not update the page. @Be-ing I\'m grateful to you that you publish the video so early and made adding it to this PR possible. Of course, I understand if you don\'t want to be listed, it\'s your choice. Please for your feedback.', 'comment_created': datetime.datetime(2022, 9, 8, 14, 0, 57, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 966015016, 'comment_body': 'Sounds reasonable, I agree.', 'comment_created': datetime.datetime(2022, 9, 8, 14, 5, 1, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}, {'comment_id': 966064347, 'comment_body': ""I'd prefer to not be credited here."", 'comment_created': datetime.datetime(2022, 9, 8, 14, 46, 1, tzinfo=datetime.timezone.utc), 'commenter': 'Be-ing', 'type': 'User'}, {'comment_id': 966078271, 'comment_body': 'Okay, no problem. I will fix it.', 'comment_created': datetime.datetime(2022, 9, 8, 14, 57, 20, tzinfo=datetime.timezone.utc), 'commenter': 'davidchocholaty', 'type': 'User'}]","[{'commit_sha': '3361cffa48d2cbfe4d80ab699580b152594b89f2', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '8caa5998d5ea37e0705c36182f090877f1ea30c2', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '5faa633deb9b27460dbb8f73f624677fd8e87317', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '881e6b71d478741e21dd155f3e0d705ee3a84fa0', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'f22238e328f3ce395c5e55f6543265a7fdcb76cd', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ff3c45959b3573ba9251602b4c27a3364ed25545', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '044eb2dc815cae7dba223a337c3ec570cf1b2f41', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '10bbc93f492857492e3db933409b1c9e60e7494d', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '3c9e10c8b4ff47c3486aaa381fe5d0abac8b55d5', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'f2bfafad0e0bf35c69869c77a3429f585a90aa9e', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '8a280eeddb79a66d5df19cba7cf3c06df42fc38f', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '3e9561dc6a1d18a63da1cada4f7ba3d0c9421ef5', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'a6fd7015c62bfc2b978c246c36502f73f6da84fc', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '94b676d5ceed480e1eedf62a2cfaf895fd5806a9', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'f1aed898af2858231f2f202d46b87ec8705baad7', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '1c830f960c1dff3206c48717296550a4fe16f2e0', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '015f8773bb31a50a25994a34697cf5020398d1eb', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'abbd151444e88b931b39554013bc236052bfa8ad', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'e54d3e760f2729726bcb934a3cf7b693ee5996e3', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'e9694aa4212356ea9f1f1ccb006f74b91c834310', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ebbde3331fe45eb301bb66c2b376430ae7afc377', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '0d5b2df16ff9852c2c2569a95fef965ec767b91e', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'e65b59537c227c88e02846ed4686c3675d347876', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'a00da3987c812bf9a5f56b2e3dfa04e1dab1522a', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '889ae62e83aaf3bcde4391d4c3cbe194b14c8003', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '56c5a5826898b7c5d027f8a6e871c0d86c178507', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '30df5d9337371928af563c02e2b50b810a8b43c1', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'a1268c5d389584043461bd4c63492cde5356aa61', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'e94e38018bd19c4c58448b8867a957efb28cec61', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '23809c0f00c086a8b9c6cf1ea47d8516f1b9522f', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ad35b95d31ef139fdfa184b09d3ed45889301898', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'c8f3b64fe2649bbd0c603bd8b1177beaa4ed3d40', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '295f6f8e62196fc8f776be466f029144c7db9232', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '286c21e63d4141459ddd7e262fb354ee63f9c01d', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'f5194b38bce4aa01c5c47d72811928572bae6007', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'a68b30d5e02273768e638aa15f281af1a9608813', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'a0dc777982f44db9bcc3e58a1349f642642766a8', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '8dceacbcf646064e44c20d37f5c0bd4b6db16e67', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '28292d6bfee4b2bc47f9afa76c6582b4a28f46d1', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '056e7fdfc882918c75f9a4001eacdaa6a13caa9d', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'fac31a789fc79d9e801cdf61fedb0c5c9dbf4f31', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '14d77bccd5a1323ae60e2fa72e017a7abfa3bf32', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'aa9ba749ee5aa10546ea6aebe02d6590184ad990', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ce1bea5c75dfb7e7385c43928aac3f087b201b27', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '8e6b594a72e3c527699f8f103d5f108bca1db5f0', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'dd743d0ec8d6c3f08aa8335a80624f67f4b335c2', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '41409199d8242667fd9bbe0bd1d89bc6f3bec9ea', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'da1b43e44dd3e84f9324a6c31771e09927dc7d34', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'e87f61cb312b2181ba1e476404848d85724dbb5f', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '62607e8ba1097583aedc92138e4678b34c914dec', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '83aece7b13098db96cc73a246fa71731a68f7c96', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '96959e65790e7043dcf9da48a93d8ab8edc89e2c', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}, {'commit_sha': '0209e3620f6e4a9ddd80f3d2b963fd8c9354d7e5', 'committer_username': 'davidchocholaty', 'committer_name': 'David Chocholatý', 'committer_email': None, 'commit_date': datetime.datetime(2021, 5, 26, 20, 12, 33, tzinfo=datetime.timezone.utc)}]",David Chocholatý,84876095,,User,,44,,15,14

Project_ID,Name,Full_name,Language,Forks,Stars,Watchers,contributors,commits,issues,branches,PRs_count,contributor pullrequests
10126031,mixxx,mixxxdj/mixxx,C++,1251,4331,136,357,48321,2131,16,248,"[{'id': 1044569444, 'number': 10858, 'closed': datetime.datetime(2022, 9, 4, 11, 23, 18, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2022, 9, 2, 7, 8, 57, tzinfo=datetime.timezone.utc), 'time_taken': 188061.0, 'time_delta': '2 days, 4:14:21', 'additions': 68, 'deletions': 0, 'state': 'closed'}, {'id': 1043286301, 'number': 10853, 'closed': datetime.datetime(2022, 9, 1, 19, 49, 13, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2022, 9, 1, 6, 50, 41, tzinfo=datetime.timezone.utc), 'time_taken': 46712.0, 'time_delta': '12:58:32', 'additions': 3, 'deletions': 3, 'state': 'closed'}, {'id': 1040900888, 'number': 10843, 'closed': datetime.datetime(2022, 9, 1, 19, 18, 52, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2022, 8, 30, 12, 10, 20, tzinfo=datetime.timezone.utc), 'time_taken': 198512.0, 'time_delta': '2 days, 7:08:32', 'additions': 36, 'deletions': 25, 'state': 'closed'}, {'id': 1040589279, 'number': 10840, 'closed': None, 'created': datetime.datetime(2022, 8, 30, 7, 45, 8, tzinfo=datetime.timezone.utc), 'time_taken': 0.0, 'time_delta': '', 'additions': 223, 'deletions': 180, 'state': 'open'}, {'id': 1039721404, 'number': 10835, 'closed': datetime.datetime(2022, 9, 1, 19, 19, 18, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2022, 8, 29, 13, 43, 45, tzinfo=datetime.timezone.utc), 'time_taken': 279333.0, 'time_delta': '3 days, 5:35:33', 'additions': 0, 'deletions': 1, 'state': 'closed'}, {'id': 1038679721, 'number': 10827, 'closed': datetime.datetime(2022, 8, 29, 6, 48, 47, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2022, 8, 27, 17, 53, tzinfo=datetime.timezone.utc), 'time_taken': 132947.0, 'time_delta': '1 day, 12:55:47', 'additions': 4, 'deletions': 4, 'state': 'closed'}, {'id': 1031520817, 'number': 4901, 'closed': datetime.datetime(2022, 8, 29, 12, 29, 47, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2022, 8, 19, 19, 53, 53, tzinfo=datetime.timezone.utc), 'time_taken': 837354.0, 'time_delta': '9 days, 16:35:54', 'additions': 89, 'deletions': 12, 'state': 'closed'}, {'id': 1027761138, 'number': 4898, 'closed': None, 'created': datetime.datetime(2022, 8, 16, 15, 14, 59, tzinfo=datetime.timezone.utc), 'time_taken': 0.0, 'time_delta': '', 'additions': 230, 'deletions': 61, 'state': 'open'}, {'id': 1008073809, 'number': 4869, 'closed': datetime.datetime(2022, 7, 26, 13, 31, 25, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2022, 7, 26, 5, 40, 9, tzinfo=datetime.timezone.utc), 'time_taken': 28276.0, 'time_delta': '7:51:16', 'additions': 14, 'deletions': 26, 'state': 'closed'}, {'id': 994329335, 'number': 4852, 'closed': datetime.datetime(2022, 8, 29, 19, 53, 10, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2022, 7, 12, 13, 57, 57, tzinfo=datetime.timezone.utc), 'time_taken': 4168513.0, 'time_delta': '48 days, 5:55:13', 'additions': 408, 'deletions': 0, 'state': 'closed'}, {'id': 992170912, 'number': 4848, 'closed': datetime.datetime(2022, 7, 9, 13, 31, 40, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2022, 7, 9, 7, 53, 39, tzinfo=datetime.timezone.utc), 'time_taken': 20281.0, 'time_delta': '5:38:01', 'additions': 15, 'deletions': 0, 'state': 'closed'}, {'id': 971290657, 'number': 4810, 'closed': datetime.datetime(2022, 8, 14, 22, 32, 56, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2022, 6, 18, 14, 20, 49, tzinfo=datetime.timezone.utc), 'time_taken': 4954327.0, 'time_delta': '57 days, 8:12:07', 'additions': 686, 'deletions': 2, 'state': 'closed'}, {'id': 951145635, 'number': 4775, 'closed': datetime.datetime(2022, 6, 10, 8, 27, 47, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2022, 5, 30, 15, 56, 21, tzinfo=datetime.timezone.utc), 'time_taken': 923486.0, 'time_delta': '10 days, 16:31:26', 'additions': 177, 'deletions': 0, 'state': 'closed'}, {'id': 921772772, 'number': 4735, 'closed': None, 'created': datetime.datetime(2022, 4, 28, 12, 14, 46, tzinfo=datetime.timezone.utc), 'time_taken': 0.0, 'time_delta': '', 'additions': 121, 'deletions': 18, 'state': 'open'}]"
329737103,vcpkg,mixxxdj/vcpkg,CMake,5,5,4,2116,20898,3,7,3,"[{'id': 1001216000, 'number': 48, 'closed': datetime.datetime(2022, 8, 6, 22, 1, 45, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2022, 7, 19, 20, 28, 56, tzinfo=datetime.timezone.utc), 'time_taken': 1560769.0, 'time_delta': '18 days, 1:32:49', 'additions': 77, 'deletions': 41, 'state': 'closed'}]"
12713190,website,mixxxdj/website,HTML,40,15,13,38,1631,23,3,7,"[{'id': 1053168954, 'number': 281, 'closed': datetime.datetime(2022, 9, 12, 12, 26, 2, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2022, 9, 12, 11, 21, 15, tzinfo=datetime.timezone.utc), 'time_taken': 3887.0, 'time_delta': '1:04:47', 'additions': 1, 'deletions': 0, 'state': 'closed'}, {'id': 1045550192, 'number': 279, 'closed': datetime.datetime(2022, 9, 8, 21, 45, 53, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2022, 9, 3, 20, 1, 56, tzinfo=datetime.timezone.utc), 'time_taken': 438237.0, 'time_delta': '5 days, 1:43:57', 'additions': 771, 'deletions': 0, 'state': 'closed'}]"
