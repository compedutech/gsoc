pr_id,pr_title,pr_body,is_merged,pr_number,pr_url,pr_html_url,pr_state,additions,deletions,pr_changed_files,pr_commits_count,pr_comments_count,pr_review_comments_count,pr_labels_count,pr_assignees_count,pr_labels,pr_created_at,pr_closed_at,time_taken,time_delta,pr_review_comments,pr_commits,contributor,contributor_id,contributor_email,contributor_type,contributions,contributor_public_repos,contributor_private_repos,contributor_followings,contributor_followers
456804433,[GSoC] Improvements to ref-filter,"This is the first patch series that introduces some improvements and features to file ref-filter.{c,h}. These changes are useful to `ref-filter`, but in near future also will allow us to use ref-filter's logic in pretty.c

I plan to add more to format-support.{c,h} in the upcoming patch series. That will lead to more improved and feature-rich ref-filter.c
",False,684,https://api.github.com/repos/gitgitgadget/git/pulls/684,https://github.com/gitgitgadget/git/pull/684,closed,161,65,5,8,41,13,3,0,"[{'name': 'master'}, {'name': 'next'}, {'name': 'seen'}]",2020-07-26 20:55:47+00:00,2020-09-09 22:37:26+00:00,3894099.0,"45 days, 1:41:39","[{'comment_id': 461216006, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/xmqqeeowfu75.fsf@gitster.c.googlers.com), Junio C Hamano wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\n""Hariom Verma via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n\n> From: Hariom Verma <hariom18599@gmail.com>\n>\n> Currently, ref-filter only supports printing email with arrow brackets.\n\nThis is the first time I heard the term ""arrow bracket"".  Aren\'t\nthey more commonly called angle brackets?\n\n> Let\'s add support for two more email options.\n> - trim : print email without arrow brackets.\n\nWhy would this be useful?\n\n> - localpart : prints the part before the @ sign\n\nMeaning I\'d get ""<gitster"" for me?\n\nBuilding small pieces of new feature in each patch is good, and\nadding tests to each step is also good.  Why not do the same for\ndocs?\n\n> +static struct email_option{\n\nMissing SP.\n\n> +\tenum { EO_INVALID, EO_RAW, EO_TRIM, EO_LOCALPART } option;\n> +} email_option;\n> +\n> @@ -1040,10 +1044,26 @@ static const char *copy_email(const char *buf)\n>  \tconst char *eoemail;\n>  \tif (!email)\n>  \t\treturn xstrdup("""");\n> -\teoemail = strchr(email, \'>\');\n\nThe original code prepares to see NULL from this strchr(); that is\nwhy it checks eoemail for NULL and returns an empty string---the\ndata is broken (i.e. not an address in angle brackets), which this\ncode cannot do anything about---in the later part of the code.\n\n> +\tswitch (email_option.option) {\n> +\tcase EO_RAW:\n> +\t\teoemail = strchr(email, \'>\') + 1;\n\nAnd this breaks the carefully laid out error handling by the\noriginal code.  Adding 1 to NULL is quite undefined.\n\n> +\t\tbreak;\n> +\tcase EO_TRIM:\n> +\t\temail++;\n> +\t\teoemail = strchr(email, \'>\');\n> +\t\tbreak;\n> +\tcase EO_LOCALPART:\n> +\t\temail++;\n> +\t\teoemail = strchr(email, \'@\');\n\nThe undocumented design here is that you want to return ""hariom"" for\n""<hariom@gmail.com>"", i.e. out of the ""trimmed"" e-mail, the part\nbefore the at-sign is returned.\n\nIf the data were ""<hariom>"", you\'d still want to return ""hariom"" no?\nBut because you do not check for NULL, you end up returning an empty\nstring.\n\nI think you want to cut at the first \'@\' or \'>\', whichever comes\nfirst.\n\n\n> +\t\tbreak;\n> +\tcase EO_INVALID:\n> +\tdefault:\n\nInvalid and unhandled ones are silently ignored and not treated as\nan error?  I would have thought that at least the ""default"" one\nwould be a BUG(), as you covered all the possible values for the\nenum with case arms.  I wouldn\'t be surprised if seeing EO_INVALID\nis also a BUG(), i.e. the control flow that led to the caller to\ncall this function with EO_INVALID in email_option.option is likely\nto be broken.  It\'s not like you return """" to protect yourself when\nfed a bad data from objects---a bad value in .option can only come\nhere if the parser you wrote for ""--format=<string>"" produced a\nwrong result.\n\n> +\t\treturn xstrdup("""");\n> +\t}\n> +\n>  \tif (!eoemail)\n>  \t\treturn xstrdup("""");\n> -\treturn xmemdupz(email, eoemail + 1 - email);\n> +\treturn xmemdupz(email, eoemail - email);\n>  }\n>  \n>  static char *copy_subject(const char *buf, unsigned long len)\n> @@ -1113,7 +1133,7 @@ static void grab_person(const char *who, struct atom_value *val, int deref, void\n>  \t\t\tcontinue;\n>  \t\tif (name[wholen] != 0 &&\n>  \t\t    strcmp(name + wholen, ""name"") &&\n> -\t\t    strcmp(name + wholen, ""email"") &&\n> +\t\t    !starts_with(name + wholen, ""email"") &&\n>  \t\t    !starts_with(name + wholen, ""date""))\n>  \t\t\tcontinue;\n>  \t\tif (!wholine)\n> @@ -1124,8 +1144,16 @@ static void grab_person(const char *who, struct atom_value *val, int deref, void\n>  \t\t\tv->s = copy_line(wholine);\n>  \t\telse if (!strcmp(name + wholen, ""name""))\n>  \t\t\tv->s = copy_name(wholine);\n> -\t\telse if (!strcmp(name + wholen, ""email""))\n> +\t\telse if (starts_with(name + wholen, ""email"")) {\n> +\t\t\temail_option.option = EO_INVALID;\n> +\t\t\tif (!strcmp(name + wholen, ""email""))\n> +\t\t\t\temail_option.option = EO_RAW;\n> +\t\t\tif (!strcmp(name + wholen, ""email:trim""))\n> +\t\t\t\temail_option.option = EO_TRIM;\n> +\t\t\tif (!strcmp(name + wholen, ""email:localpart""))\n> +\t\t\t\temail_option.option = EO_LOCALPART;\n\nThe ref-filter formatting language already knows many ""colon plus\nmodifier"" suffix like ""refname:short"" and ""contents:body"", but I do\nnot think we have ugly repetition like the above code to parse them.\nPerhaps the addition for ""email:<whatever>"" can benefit from\nstudying and mimicking existing practices a bit more?\n\n``````````\n', 'comment_created': datetime.datetime(2020, 7, 27, 22, 54, 20, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 461225927, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/xmqq1rkwfss2.fsf@gitster.c.googlers.com), Junio C Hamano wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\n""Hariom Verma via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n\n> -\t\tif (!strcmp(name, ""tree"")) {\n> +\t\tif (!strcmp(name, ""tree""))\n>  \t\t\tv->s = xstrdup(oid_to_hex(get_commit_tree_oid(commit)));\n> -\t\t}\n> +\t\telse if (!strcmp(name, ""tree:short""))\n> +\t\t\tv->s = xstrdup(find_unique_abbrev(get_commit_tree_oid(commit), DEFAULT_ABBREV));\n\nAgain, isn\'t this going in totally unacceptable direction?  \n\nBy the time grab_foo() helper functions are reached, the requested\nformat should have been parsed to atom->u.foo.option and the only\nthing grab_foo() helper functions should look at are the option.\n\nPerhaps studying how ""objectname"" and its "":""-modified forms are\nhandled before writing this series would be beneficial.\n\n - objectname_atom_parser() is called when the parser for --format\n   notices ""objectname:modifier""; it is responsible for setting up\n   atom->u.objectname.option.  Note that this is done only once at\n   the very begining of processing\n\n - grab_objectname() is called for each and every object ref-filter\n   iterates over and ""objectname"" and/or its modified form\n   (e.g. ""objectname:short"") is requested.  Since the modifier is\n   already parsed, it can do a simple switch on the value in\n   .option.\n\nI do not know if patches [3-5/5] follow the pattern used in [1-2/5],\nbut if they do, then they all need to be fixed, I think.\n\nThanks.\n\n\n``````````\n', 'comment_created': datetime.datetime(2020, 7, 27, 23, 23, 7, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 461603331, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/20200728135803.GD24134@danh.dev), Đoàn Trần Công Danh wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\n[this is a resent, my previous mail couldn\'t reach the archive]\n\nOn 2020-07-27 20:43:04+0000, Hariom Verma via GitGitGadget <gitgitgadget@gmail.com> wrote:\n> From: Hariom Verma <hariom18599@gmail.com>\n> \n> Currently, ref-filter only supports printing email with arrow brackets.\n> \n> Let\'s add support for two more email options.\n> - trim : print email without arrow brackets.\n> - localpart : prints the part before the @ sign\n> \n> Mentored-by: Christian Couder <chriscool@tuxfamily.org>\n> Mentored-by: Heba Waly <heba.waly@gmail.com>\n> Signed-off-by: Hariom Verma <hariom18599@gmail.com>\n> ---\n>  ref-filter.c            | 36 ++++++++++++++++++++++++++++++++----\n>  t/t6300-for-each-ref.sh | 16 ++++++++++++++++\n>  2 files changed, 48 insertions(+), 4 deletions(-)\n> \n> diff --git a/ref-filter.c b/ref-filter.c\n> index 8447cb09be..8563088eb1 100644\n> --- a/ref-filter.c\n> +++ b/ref-filter.c\n> @@ -102,6 +102,10 @@ static struct ref_to_worktree_map {\n>  \tstruct worktree **worktrees;\n>  } ref_to_worktree_map;\n>  \n> +static struct email_option{\n> +\tenum { EO_INVALID, EO_RAW, EO_TRIM, EO_LOCALPART } option;\n> +} email_option;\n> +\n>  /*\n>   * An atom is a valid field atom listed below, possibly prefixed with\n>   * a ""*"" to denote deref_tag().\n> @@ -1040,10 +1044,26 @@ static const char *copy_email(const char *buf)\n>  \tconst char *eoemail;\n>  \tif (!email)\n>  \t\treturn xstrdup("""");\n> -\teoemail = strchr(email, \'>\');\n> +\tswitch (email_option.option) {\n> +\tcase EO_RAW:\n> +\t\teoemail = strchr(email, \'>\') + 1;\n> +\t\tbreak;\n> +\tcase EO_TRIM:\n> +\t\temail++;\n> +\t\teoemail = strchr(email, \'>\');\n> +\t\tbreak;\n> +\tcase EO_LOCALPART:\n> +\t\temail++;\n> +\t\teoemail = strchr(email, \'@\');\n> +\t\tbreak;\n\n\nThis is not correct.\nRFC-822 allows @ in local part,\nalbeit, that localpart must be quoted:\n\n        addr-spec       =       local-part ""@"" domain\n        local-part      =       dot-atom / quoted-string / obs-local-part\n        quoted-string   =       [CFWS]\n                                DQUOTE *([FWS] qcontent) [FWS] DQUOTE\n                                [CFWS]\n        qcontent        =       qtext / quoted-pair\n        qtext           =       NO-WS-CTL /     ; Non white space\n        qtext           =       NO-WS-CTL /     ; Non white space controls\n                                %d33 /          ; The rest of the US-ASCII\n                                %d35-91 /       ;  characters not including ""\\""\n                                %d93-126        ;  or the quote character\n        quoted-pair     =       (""\\"" text) / obs-qp\n\nIOW, those below email addresses are valid email address,\nand the local part is `quoted@local\'\n\n        ""quoted@local""@example.com\n        quoted\\@local@example.com\n\nAnyway, it seems like current Git strips first `""\'\nfrom `""quoted@local""@example.com\'\n\n\n-- \nDanh\n``````````\n', 'comment_created': datetime.datetime(2020, 7, 28, 14, 1, 9, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 461724946, 'comment_body': ""[On the Git mailing list](https://lore.kernel.org/git/xmqqime7eggb.fsf@gitster.c.googlers.com), Junio C Hamano wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nĐoàn Trần Công Danh  <congdanhqx@gmail.com> writes:\n\n> This is not correct.\n> RFC-822 allows @ in local part,\n> albeit, that localpart must be quoted:\n\nWe do care about truly local e-mail addresses, without '@' anywhere\ninside <braket>, simply because they are common in the result of SCM\nconversion from CVS/SVN.\n\nBut I do not think we are pedantic/academic enough to have cared\nabout any local part that is unusual enough to require quoting; we\ninstead relied on the fact that we live in real world with practical\npeople who would avoid such an address ;-).\n``````````\n"", 'comment_created': datetime.datetime(2020, 7, 28, 16, 46, 26, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 461865046, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/CA+CkUQ9nqW8=GuvNapsySf=EXm8c02qKV2xMrwvRY-Kd9Yy9mA@mail.gmail.com), Hariom verma wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nHi,\n\nOn Tue, Jul 28, 2020 at 4:21 AM Junio C Hamano <gitster@pobox.com> wrote:\n>\n> ""Hariom Verma via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n>\n> > From: Hariom Verma <hariom18599@gmail.com>\n> >\n> > Currently, ref-filter only supports printing email with arrow brackets.\n>\n> This is the first time I heard the term ""arrow bracket"".  Aren\'t\n> they more commonly called angle brackets?\n\nYeah. Sorry about that.\n\n> > Let\'s add support for two more email options.\n> > - trim : print email without arrow brackets.\n>\n> Why would this be useful?\n\nIt might be useful for using the ref-filter\'s logic in pretty.c\n(especially for `--pretty` formats like `%an` and `%cn`)\n\n> > - localpart : prints the part before the @ sign\n>\n> Meaning I\'d get ""<gitster"" for me?\n\nNo, you\'ll get ""gitster"".\n\n> Building small pieces of new feature in each patch is good, and\n> adding tests to each step is also good.  Why not do the same for\n> docs?\n\nYeah, I agree with you. I should have focused on documentation too.\n\n> > +static struct email_option{\n>\n> Missing SP.\n\nI\'ll fix it.\n\n> > +     enum { EO_INVALID, EO_RAW, EO_TRIM, EO_LOCALPART } option;\n> > +} email_option;\n> > +\n> > @@ -1040,10 +1044,26 @@ static const char *copy_email(const char *buf)\n> >       const char *eoemail;\n> >       if (!email)\n> >               return xstrdup("""");\n> > -     eoemail = strchr(email, \'>\');\n>\n> The original code prepares to see NULL from this strchr(); that is\n> why it checks eoemail for NULL and returns an empty string---the\n> data is broken (i.e. not an address in angle brackets), which this\n> code cannot do anything about---in the later part of the code.\n\nI think this commit still takes care of NULL.\nAfter the switch-case statements, code consists of:\n```\nif (!eoemail)\n    return xstrdup("""");\n```\nWhich checks eoemail for NULL. And will return empty string if address\nis not in angle brackets.\nSame applies for local-part too. If \'@\' is not present in email\naddress, it will still return empty string.\n\n> > +     switch (email_option.option) {\n> > +     case EO_RAW:\n> > +             eoemail = strchr(email, \'>\') + 1;\n>\n> And this breaks the carefully laid out error handling by the\n> original code.  Adding 1 to NULL is quite undefined.\n\nYeah. I\'ll take care of it in the next version.\n\n> > +             break;\n> > +     case EO_TRIM:\n> > +             email++;\n> > +             eoemail = strchr(email, \'>\');\n> > +             break;\n> > +     case EO_LOCALPART:\n> > +             email++;\n> > +             eoemail = strchr(email, \'@\');\n>\n> The undocumented design here is that you want to return ""hariom"" for\n> ""<hariom@gmail.com>"", i.e. out of the ""trimmed"" e-mail, the part\n> before the at-sign is returned.\n>\n> If the data were ""<hariom>"", you\'d still want to return ""hariom"" no?\n> But because you do not check for NULL, you end up returning an empty\n> string.\n\nI never heard of email address without \'@\' symbol. Thats why I\nreturned empty string.\n\nWill fix that too.\n\n> I think you want to cut at the first \'@\' or \'>\', whichever comes\n> first.\n\nIf email data can be without \'@\' symbol, then I guess ""yes"".\n\n> > +             break;\n> > +     case EO_INVALID:\n> > +     default:\n>\n> Invalid and unhandled ones are silently ignored and not treated as\n> an error?  I would have thought that at least the ""default"" one\n> would be a BUG(), as you covered all the possible values for the\n> enum with case arms.  I wouldn\'t be surprised if seeing EO_INVALID\n> is also a BUG(), i.e. the control flow that led to the caller to\n> call this function with EO_INVALID in email_option.option is likely\n> to be broken.  It\'s not like you return """" to protect yourself when\n> fed a bad data from objects---a bad value in .option can only come\n> here if the parser you wrote for ""--format=<string>"" produced a\n> wrong result.\n\nChristian <chriscool@tuxfamily.org> also suggested me the same. Will\nfix this too.\n\nBTW, on master ""{author,committer,tagger}email:<xyz>"" does not print any error.\n\n> > +             return xstrdup("""");\n> > +     }\n> > +\n> >       if (!eoemail)\n> >               return xstrdup("""");\n> > -     return xmemdupz(email, eoemail + 1 - email);\n> > +     return xmemdupz(email, eoemail - email);\n> >  }\n> >\n> >  static char *copy_subject(const char *buf, unsigned long len)\n> > @@ -1113,7 +1133,7 @@ static void grab_person(const char *who, struct atom_value *val, int deref, void\n> >                       continue;\n> >               if (name[wholen] != 0 &&\n> >                   strcmp(name + wholen, ""name"") &&\n> > -                 strcmp(name + wholen, ""email"") &&\n> > +                 !starts_with(name + wholen, ""email"") &&\n> >                   !starts_with(name + wholen, ""date""))\n> >                       continue;\n> >               if (!wholine)\n> > @@ -1124,8 +1144,16 @@ static void grab_person(const char *who, struct atom_value *val, int deref, void\n> >                       v->s = copy_line(wholine);\n> >               else if (!strcmp(name + wholen, ""name""))\n> >                       v->s = copy_name(wholine);\n> > -             else if (!strcmp(name + wholen, ""email""))\n> > +             else if (starts_with(name + wholen, ""email"")) {\n> > +                     email_option.option = EO_INVALID;\n> > +                     if (!strcmp(name + wholen, ""email""))\n> > +                             email_option.option = EO_RAW;\n> > +                     if (!strcmp(name + wholen, ""email:trim""))\n> > +                             email_option.option = EO_TRIM;\n> > +                     if (!strcmp(name + wholen, ""email:localpart""))\n> > +                             email_option.option = EO_LOCALPART;\n>\n> The ref-filter formatting language already knows many ""colon plus\n> modifier"" suffix like ""refname:short"" and ""contents:body"", but I do\n> not think we have ugly repetition like the above code to parse them.\n> Perhaps the addition for ""email:<whatever>"" can benefit from\n> studying and mimicking existing practices a bit more?\n>\n\nFor ""email:<whatever>"",\neven If I parse that <whatever>. I still make comparison something like:\n```\nif (!modifier)\n    email_option.option = EO_RAW;\nelse if (!strcmp(modifier, ""trim""))\n    email_option.option = EO_TRIM;\nelse if (!strcmp(arg, ""localpart""))\n    email_option.option = EO_LOCALPART;\n```\n\nThanks,\nHariom\n``````````\n', 'comment_created': datetime.datetime(2020, 7, 28, 20, 40, 54, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 461868520, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/xmqqzh7jcqv7.fsf@gitster.c.googlers.com), Junio C Hamano wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nHariom verma <hariom18599@gmail.com> writes:\n\n>> The ref-filter formatting language already knows many ""colon plus\n>> modifier"" suffix like ""refname:short"" and ""contents:body"", but I do\n>> not think we have ugly repetition like the above code to parse them.\n>> Perhaps the addition for ""email:<whatever>"" can benefit from\n>> studying and mimicking existing practices a bit more?\n>>\n>\n> For ""email:<whatever>"",\n> even If I parse that <whatever>. I still make comparison something like:\n> ```\n> if (!modifier)\n>     email_option.option = EO_RAW;\n> else if (!strcmp(modifier, ""trim""))\n>     email_option.option = EO_TRIM;\n> else if (!strcmp(arg, ""localpart""))\n>     email_option.option = EO_LOCALPART;\n> ```\n\nSomebody needs to do a comparison, but it should be done at parsing\nphase when the --format is grokked, not in grab phase that is run\nfor each and every ref to be shown.\n\nThese patches should only be done after looking at existing\n""<basicatom>:<modifiers>"" like ""objectname:short"" etc are handled,\nnot before, I think.\n``````````\n', 'comment_created': datetime.datetime(2020, 7, 28, 20, 46, 56, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 471728994, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/xmqqpn7p1373.fsf@gitster.c.googlers.com), Junio C Hamano wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\n""Hariom Verma via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n\n> -static void format_sanitized_subject(struct strbuf *sb, const char *msg)\n> +static void format_sanitized_subject(struct strbuf *sb, const char *msg, size_t len)\n>  {\n> +\tchar *r = xmemdupz(msg, len);\n>  \tsize_t trimlen;\n>  \tsize_t start_len = sb->len;\n>  \tint space = 2;\n> +\tint i;\n>  \n> -\tfor (; *msg && *msg != \'\\n\'; msg++) {\n> -\t\tif (istitlechar(*msg)) {\n> +\tfor (i = 0; i < len; i++) {\n> +\t\tif (r[i] == \'\\n\')\n> +\t\t\tr[i] = \' \';\n\nCopying the whole string only for this one looks very wasteful.\nCan\'t you do\n\n\tfor (i = 0; i < len; i++) {\n\t\tchar r = msg[i];\n\t\tif (isspace(r))\n\t\t\tr = \' \';\n\t\tif (istitlechar(r)) {\n\t\t\t...\n\t}\n\nor something like that instead?  \n\n> +\t\tif (istitlechar(r[i])) {\n>  \t\t\tif (space == 1)\n>  \t\t\t\tstrbuf_addch(sb, \'-\');\n>  \t\t\tspace = 0;\n> -\t\t\tstrbuf_addch(sb, *msg);\n> -\t\t\tif (*msg == \'.\')\n> -\t\t\t\twhile (*(msg+1) == \'.\')\n> -\t\t\t\t\tmsg++;\n> +\t\t\tstrbuf_addch(sb, r[i]);\n> +\t\t\tif (r[i] == \'.\')\n> +\t\t\t\twhile (r[i+1] == \'.\')\n> +\t\t\t\t\ti++;\n>  \t\t} else\n>  \t\t\tspace |= 1;\n>  \t}\n> +\tfree(r);\n\nAlso, because neither LF or SP is a titlechar(), wouldn\'t the ""if\nr[i] is LF, replace it with SP"" a no-op wrt what will be in sb at\nthe end?\n\n\n>  \tcase \'f\':\t/* sanitized subject */\n> -\t\tformat_sanitized_subject(sb, msg + c->subject_off);\n> +\t\teol = strchrnul(msg + c->subject_off, \'\\n\');\n> +\t\tformat_sanitized_subject(sb, msg + c->subject_off, eol - (msg + c->subject_off));\n\nThis original caller expected the helper to stop reading at the end\nof the first line, but the updated helper needs to be told where to\nstop, so we do so with some extra computation.  Makes sense.\n\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 17, 19, 30, 43, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 471731725, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/xmqqlfid1305.fsf@gitster.c.googlers.com), Junio C Hamano wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\n""Hariom Verma via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n\n> From: Hariom Verma <hariom18599@gmail.com>\n>\n> In hope of some new features in `subject` atom, move funtion\n> `format_sanitized_subject()` and all the function it uses\n> to new file format-support.{c,h}.\n>\n> Consider this new file as a common interface between functions that\n> pretty.c and ref-filter.c shares.\n\nSorry, I do not see a point.  Let\'s not do this and keep or add them\nin pretty.[ch] if you are making some of the static ones public.\n\nThanks.\n\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 17, 19, 36, 42, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 473036586, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/CA+CkUQ9tkwXmrHq_ZV+RCgwoFHZ0M4dEhBkjUd97Xi+3shB-WQ@mail.gmail.com), Hariom verma wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nHi Junio,\n\nOn Tue, Aug 18, 2020 at 12:59 AM Junio C Hamano <gitster@pobox.com> wrote:\n>\n> ""Hariom Verma via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n>\n> > -static void format_sanitized_subject(struct strbuf *sb, const char *msg)\n> > +static void format_sanitized_subject(struct strbuf *sb, const char *msg, size_t len)\n> >  {\n> > +     char *r = xmemdupz(msg, len);\n> >       size_t trimlen;\n> >       size_t start_len = sb->len;\n> >       int space = 2;\n> > +     int i;\n> >\n> > -     for (; *msg && *msg != \'\\n\'; msg++) {\n> > -             if (istitlechar(*msg)) {\n> > +     for (i = 0; i < len; i++) {\n> > +             if (r[i] == \'\\n\')\n> > +                     r[i] = \' \';\n>\n> Copying the whole string only for this one looks very wasteful.\n> Can\'t you do\n>\n>         for (i = 0; i < len; i++) {\n>                 char r = msg[i];\n>                 if (isspace(r))\n>                         r = \' \';\n>                 if (istitlechar(r)) {\n>                         ...\n>         }\n>\n> or something like that instead?\n\nOk, that sounds better. Noted for the next version.\n\n> > +             if (istitlechar(r[i])) {\n> >                       if (space == 1)\n> >                               strbuf_addch(sb, \'-\');\n> >                       space = 0;\n> > -                     strbuf_addch(sb, *msg);\n> > -                     if (*msg == \'.\')\n> > -                             while (*(msg+1) == \'.\')\n> > -                                     msg++;\n> > +                     strbuf_addch(sb, r[i]);\n> > +                     if (r[i] == \'.\')\n> > +                             while (r[i+1] == \'.\')\n> > +                                     i++;\n> >               } else\n> >                       space |= 1;\n> >       }\n> > +     free(r);\n>\n> Also, because neither LF or SP is a titlechar(), wouldn\'t the ""if\n> r[i] is LF, replace it with SP"" a no-op wrt what will be in sb at\n> the end?\n\nMaybe its better to directly replace LF with hyphen? [Instead of first\nreplacing LF with SP and then replacing SP with \'-\'.]\n\n> >       case \'f\':       /* sanitized subject */\n> > -             format_sanitized_subject(sb, msg + c->subject_off);\n> > +             eol = strchrnul(msg + c->subject_off, \'\\n\');\n> > +             format_sanitized_subject(sb, msg + c->subject_off, eol - (msg + c->subject_off));\n>\n> This original caller expected the helper to stop reading at the end\n> of the first line, but the updated helper needs to be told where to\n> stop, so we do so with some extra computation.  Makes sense.\n\nYeah.\n\nThanks,\nHariom\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 19, 13, 39, 11, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 473141179, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/xmqqimdevd4l.fsf@gitster.c.googlers.com), Junio C Hamano wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nHariom verma <hariom18599@gmail.com> writes:\n\n>> Also, because neither LF or SP is a titlechar(), wouldn\'t the ""if\n>> r[i] is LF, replace it with SP"" a no-op wrt what will be in sb at\n>> the end?\n>\n> Maybe its better to directly replace LF with hyphen? [Instead of first\n> replacing LF with SP and then replacing SP with \'-\'.]\n\nWhy do you think LF is so special?\n\nEverything other than titlechar() including HT, \'#\', \'*\', SP is\ntreated in the same way as the body of that loop.  It does not\ndirectly contribute to the final contents of sb, but just leaves\nthe marker in the variable ""space"" the fact that when adding the\nnext titlechar() to the resulting sb, we need a SP to wordbreak.\n\nLF now happens to be in the set due to the way you extended the\nfunction (it wasn\'t fed to this function by its sole caller), but\nother than that, it is no more special than HT, SP or \'*\'.  And they\nare not replaced with SP or replaced with \'-\'.\n\nSo it would be the most sensible to just drop \'if LF, replace it\nwith SP before doing anything else\' you added.  The existing \'if\ntitlechar, add it to sb but if we saw non-title, add a SP before\ndoing so to wordbreak, and if not titlechar, just remember the fact\nthat we saw one\' should work fine as-is without special casing LF at\nall.\n\nOr am I missing something subtle?\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 19, 16, 3, 29, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 473144904, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/xmqqeeo2vcsl.fsf@gitster.c.googlers.com), Junio C Hamano wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nJunio C Hamano <gitster@pobox.com> writes:\n\n> Hariom verma <hariom18599@gmail.com> writes:\n>\n>>> Also, because neither LF or SP is a titlechar(), wouldn\'t the ""if\n>>> r[i] is LF, replace it with SP"" a no-op wrt what will be in sb at\n>>> the end?\n>>\n>> Maybe its better to directly replace LF with hyphen? [Instead of first\n>> replacing LF with SP and then replacing SP with \'-\'.]\n>\n> Why do you think LF is so special?\n>\n> Everything other than titlechar() including HT, \'#\', \'*\', SP is\n> treated in the same way as the body of that loop.  It does not\n> directly contribute to the final contents of sb, but just leaves\n> the marker in the variable ""space"" the fact that when adding the\n> next titlechar() to the resulting sb, we need a SP to wordbreak.\n\nI was undecided between mentioning and not mentioning the variable\nname ""space"" here.  On one hand, one _could_ argue that ""space"" is\nused to remember we saw ""space and the like"" and if it were named\n""seen_non_title_char"", then such a confusion to treat LF so\nspecially might not have occurred.  But on the other hand, ""space""\nis what the variable exactly keeps track of; it is just the need for\nspace on the output side, i.e. we remember that ""space needed before\nthe next output"" with that variable.\n\nI am inclined not to suggest renaming ""space"" at all, but it won\'t\nbe the end of the world if it were renamed to ""need_space"" (before\nthe next output), or ""seen_nontitle"".  If we were to actually\nrename, I have moderately strong preference to the ""need_space"" over\n""seen_nontitle"", as it won\'t have to be renamed again when the logic\nto require a space before the next output has to be updated to\ninclude cases other than just ""we saw a nontitle character"".\n\nThanks.\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 19, 16, 9, 27, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 474155248, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/CA+CkUQ8=ej=NuG=FjsE6oqT+n8YUpGeVVNyhhs3FZ7UwZ5pG_g@mail.gmail.com), Hariom verma wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nHi,\n\nOn Wed, Aug 19, 2020 at 9:31 PM Junio C Hamano <gitster@pobox.com> wrote:\n>\n> Hariom verma <hariom18599@gmail.com> writes:\n>\n> >> Also, because neither LF or SP is a titlechar(), wouldn\'t the ""if\n> >> r[i] is LF, replace it with SP"" a no-op wrt what will be in sb at\n> >> the end?\n> >\n> > Maybe its better to directly replace LF with hyphen? [Instead of first\n> > replacing LF with SP and then replacing SP with \'-\'.]\n>\n> Why do you think LF is so special?\n>\n> Everything other than titlechar() including HT, \'#\', \'*\', SP is\n> treated in the same way as the body of that loop.  It does not\n> directly contribute to the final contents of sb, but just leaves\n> the marker in the variable ""space"" the fact that when adding the\n> next titlechar() to the resulting sb, we need a SP to wordbreak.\n>\n> LF now happens to be in the set due to the way you extended the\n> function (it wasn\'t fed to this function by its sole caller), but\n> other than that, it is no more special than HT, SP or \'*\'.  And they\n> are not replaced with SP or replaced with \'-\'.\n>\n> So it would be the most sensible to just drop \'if LF, replace it\n> with SP before doing anything else\' you added.  The existing \'if\n> titlechar, add it to sb but if we saw non-title, add a SP before\n> doing so to wordbreak, and if not titlechar, just remember the fact\n> that we saw one\' should work fine as-is without special casing LF at\n> all.\n>\n> Or am I missing something subtle?\n\nYou actually got it all right. Thanks for the insight.\n\nNow, I got it. There is no need to give special attention to LF. I\nmissed to see that `titlechar()` is already taking care of everything.\n\nThanks,\nHariom\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 20, 17, 29, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 474158602, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/CA+CkUQ8tkKM6SKrpJJ9-+9Nj+4Ly3FWHKUp1BQgJEG0-XyWENw@mail.gmail.com), Hariom verma wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nHi,\n\nOn Wed, Aug 19, 2020 at 9:38 PM Junio C Hamano <gitster@pobox.com> wrote:\n>\n> Junio C Hamano <gitster@pobox.com> writes:\n>\n> > Hariom verma <hariom18599@gmail.com> writes:\n> >\n> >>> Also, because neither LF or SP is a titlechar(), wouldn\'t the ""if\n> >>> r[i] is LF, replace it with SP"" a no-op wrt what will be in sb at\n> >>> the end?\n> >>\n> >> Maybe its better to directly replace LF with hyphen? [Instead of first\n> >> replacing LF with SP and then replacing SP with \'-\'.]\n> >\n> > Why do you think LF is so special?\n> >\n> > Everything other than titlechar() including HT, \'#\', \'*\', SP is\n> > treated in the same way as the body of that loop.  It does not\n> > directly contribute to the final contents of sb, but just leaves\n> > the marker in the variable ""space"" the fact that when adding the\n> > next titlechar() to the resulting sb, we need a SP to wordbreak.\n>\n> I was undecided between mentioning and not mentioning the variable\n> name ""space"" here.  On one hand, one _could_ argue that ""space"" is\n> used to remember we saw ""space and the like"" and if it were named\n> ""seen_non_title_char"", then such a confusion to treat LF so\n> specially might not have occurred.  But on the other hand, ""space""\n> is what the variable exactly keeps track of; it is just the need for\n> space on the output side, i.e. we remember that ""space needed before\n> the next output"" with that variable.\n>\n> I am inclined not to suggest renaming ""space"" at all, but it won\'t\n> be the end of the world if it were renamed to ""need_space"" (before\n> the next output), or ""seen_nontitle"".  If we were to actually\n> rename, I have moderately strong preference to the ""need_space"" over\n> ""seen_nontitle"", as it won\'t have to be renamed again when the logic\n> to require a space before the next output has to be updated to\n> include cases other than just ""we saw a nontitle character"".\n\nYeah, if it was named ""seen_non_title_char"", I might not get confused.\nBut now as you have already explained its working pretty well, ""space""\nmakes more sense to me.\nWell, I\'m okay with both ""space"" and ""need_space"".\n\nI wonder what others have to say on this? ""space"" or ""need_space""?\n\nThanks,\nHariom\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 20, 17, 35, 3, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}]","[{'commit_sha': '55618fe4c1ea96fb0c2734121f8a54a921fb0aff', 'committer_username': 'harry-hov', 'committer_name': 'Hariom Verma', 'committer_email': None, 'commit_date': datetime.datetime(2018, 3, 20, 9, 19, 52, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'c508c96eb88f7e11b0ac6303c30fa78dd7585ec0', 'committer_username': 'harry-hov', 'committer_name': 'Hariom Verma', 'committer_email': None, 'commit_date': datetime.datetime(2018, 3, 20, 9, 19, 52, tzinfo=datetime.timezone.utc)}, {'commit_sha': '582f00ace6b3173cfebb3f6e5d859f471ea01ab7', 'committer_username': 'harry-hov', 'committer_name': 'Hariom Verma', 'committer_email': None, 'commit_date': datetime.datetime(2018, 3, 20, 9, 19, 52, tzinfo=datetime.timezone.utc)}, {'commit_sha': '503a1874ce48192eba27d7fe3d61ffb6d44e4ee0', 'committer_username': 'harry-hov', 'committer_name': 'Hariom Verma', 'committer_email': None, 'commit_date': datetime.datetime(2018, 3, 20, 9, 19, 52, tzinfo=datetime.timezone.utc)}, {'commit_sha': '6b971667960549fb5fbd293e1880ec34169e5aea', 'committer_username': 'harry-hov', 'committer_name': 'Hariom Verma', 'committer_email': None, 'commit_date': datetime.datetime(2018, 3, 20, 9, 19, 52, tzinfo=datetime.timezone.utc)}, {'commit_sha': '5ed5ac259d59b855fc5c956bc8af80fecfc7c971', 'committer_username': 'harry-hov', 'committer_name': 'Hariom Verma', 'committer_email': None, 'commit_date': datetime.datetime(2018, 3, 20, 9, 19, 52, tzinfo=datetime.timezone.utc)}, {'commit_sha': '6105046d96223bda40ab0f0177e4f0281376ba53', 'committer_username': 'harry-hov', 'committer_name': 'Hariom Verma', 'committer_email': None, 'commit_date': datetime.datetime(2018, 3, 20, 9, 19, 52, tzinfo=datetime.timezone.utc)}, {'commit_sha': '7cba8d7a2881055e89976ca420392da2eaa596b8', 'committer_username': 'harry-hov', 'committer_name': 'Hariom Verma', 'committer_email': None, 'commit_date': datetime.datetime(2018, 3, 20, 9, 19, 52, tzinfo=datetime.timezone.utc)}]",Hariom Verma,37576387,,User,,27,,51,46
470141940,[GSoC] Fix trailers atom bug and improved tests,"Currently, there exists a bug in 'contents' atom. It does not show any error if used with modifier 'trailers' and semicolon is missing before trailers arguments.
This small patch series is focused on fixing that bug and also unified 'trailers' and 'contents:trailers' tests. Thus, removed duplicate code from `t6300` and made tests more compact.

Change log since v2:
- Used simplified logic as per suggested by Eric (here https://public-inbox.org/git/CAPig+cRxCvHG70Nd00zBxYFuecu6+Z6uDP8ooN3rx9vPagoYBA@mail.gmail.com/)
- Unified trailer formatting logic for pretty.c and ref-filter.c


cc: Hariom verma <hariom18599@gmail.com>",False,707,https://api.github.com/repos/gitgitgadget/git/pulls/707,https://github.com/gitgitgadget/git/pull/707,closed,219,87,6,4,10,18,0,0,[],2020-08-19 12:48:07+00:00,2020-09-05 19:17:07+00:00,1492140.0,"17 days, 6:29:00","[{'comment_id': 473206915, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/xmqq1rk2v8y5.fsf@gitster.c.googlers.com), Junio C Hamano wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\n""Hariom Verma via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n\n> diff --git a/t/t6300-for-each-ref.sh b/t/t6300-for-each-ref.sh\n> index a83579fbdf..495848c881 100755\n> --- a/t/t6300-for-each-ref.sh\n> +++ b/t/t6300-for-each-ref.sh\n> @@ -776,60 +776,39 @@ test_expect_success \'set up trailers for next test\' \'\n>  \'\n>  \n>  test_expect_success \'%(trailers:unfold) unfolds trailers\' \'\n> -\tgit for-each-ref --format=""%(trailers:unfold)"" refs/heads/master >actual &&\n>  \t{\n>  \t\tunfold <trailers\n>  \t\techo\n>  \t} >expect &&\n> +\tgit for-each-ref --format=""%(trailers:unfold)"" refs/heads/master >actual &&\n> +\ttest_cmp expect actual &&\n> +\tgit for-each-ref --format=""%(contents:trailers:unfold)"" refs/heads/master >actual &&\n>  \ttest_cmp expect actual\n>  \'\n\nHmph, what is this one doing?  Ah, OK, trailers:unfold is tested as\nbefore (just the steps to prepare \'expect\' and \'actual\' got swapped),\nand because the same expectation holds for contents:trailers:unfold,\nwe can test it at the same.   Makes sense.\n\n>  test_expect_success \'%(trailers:only) and %(trailers:unfold) work together\' \'\n> -\tgit for-each-ref --format=""%(trailers:only,unfold)"" refs/heads/master >actual &&\n> -\tgit for-each-ref --format=""%(trailers:unfold,only)"" refs/heads/master >reverse &&\n> -\ttest_cmp actual reverse &&\n>  \t{\n>  \t\tgrep -v patch.description <trailers | unfold &&\n>  \t\techo\n>  \t} >expect &&\n> +\tgit for-each-ref --format=""%(trailers:only,unfold)"" refs/heads/master >actual &&\n> +\tgit for-each-ref --format=""%(trailers:unfold,only)"" refs/heads/master >reverse &&\n> +\ttest_cmp actual reverse &&\n> +\ttest_cmp expect actual &&\n\nThis uses different pattern.  It may be cleaner to test one side at\na time, as we have prepared the \'expect\' that should be the same for\nboth, and compare with the expected pattern one at a time; that would\neliminate the need for \'reverse\', too.  I.e.\n\n\t{\n\t\tgrep -v patch.description trailers | unfold && echo\n\t} >expect &&\n\tgit for-each-ref ... only,unfold ... >actual &&\n\ttest_cmp expect actual &&\n\tgit for-each-ref ... unfold,only ... >actual &&\n\ttest_cmp expect actual &&\n\n> @@ -839,14 +818,7 @@ test_expect_success \'%(trailers) rejects unknown trailers arguments\' \'\n>  \tfatal: unknown %(trailers) argument: unsupported\n>  \tEOF\n>  \ttest_must_fail git for-each-ref --format=""%(trailers:unsupported)"" 2>actual &&\n> -\ttest_i18ncmp expect actual\n> -\'\n> -\n> -test_expect_success \'%(contents:trailers) rejects unknown trailers arguments\' \'\n> -\t# error message cannot be checked under i18n\n> -\tcat >expect <<-EOF &&\n> -\tfatal: unknown %(trailers) argument: unsupported\n> -\tEOF\n> +\ttest_i18ncmp expect actual &&\n>  \ttest_must_fail git for-each-ref --format=""%(contents:trailers:unsupported)"" 2>actual &&\n>  \ttest_i18ncmp expect actual\n>  \'\n\nDoesn\'t this highlight a small bug, where an end-user request for an\nunknown %(contents:trailers:unsupported) is flagged as an error\nabout %(trailers)?  Is it OK because we expect that users who use\nthe longer %(contents:trailers) to know that it is a synonym for\n%(trailers) and the latter is the official way to write it?\n\nThanks.\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 19, 17, 33, 41, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 473220688, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/xmqqv9hettag.fsf@gitster.c.googlers.com), Junio C Hamano wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\n""Hariom Verma via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n\n> From: Hariom Verma <hariom18599@gmail.com>\n>\n> The \'contents\' atom does not show any error if used with \'trailers\'\n> atom and semicolon is missing before trailers arguments.\n>\n> e.g %(contents:trailersonly) works, while it shouldn\'t.\n>\n> It is definitely not an expected behavior.\n>\n> Let\'s fix this bug.\n>\n> Mentored-by: Christian Couder <chriscool@tuxfamily.org>\n> Mentored-by: Heba Waly <heba.waly@gmail.com>\n> Signed-off-by: Hariom Verma <hariom18599@gmail.com>\n> ---\n\nNice spotting.  7a5edbdb (ref-filter.c: parse trailers arguments\nwith %(contents) atom, 2017-10-01) talks about being deliberate\nabout the case where skip_prefix("":"") does not find a colon after\nthe ""trailers"" token, but from the message it is clear that it\nexpected that the case happens only when ""trailers"" is at the end of\nthe string.\n\nThe new helper that is overly verbose and may be overkill.\n\nShouldn\'t this be clear enough, equivalent and sufficient?\n\n\telse if (skip_prefix(arg, ""trailers"", &arg) &&\n\t\t (!*arg || *arg == \':\'))) {\n\t\tif (trailers_atom_parser(...);\n\nThat is, we not just make sure the string begins with ""trailers"",\nbut also make sure it either (1) ends the string (i.e. the token is\njust ""trailers""), or (2) is followed by a colon \':\', before entering\nthe block to handle ""trailers[:anything]"".  If we later add a new\natom ""trailersonly"", that will not be handled here, but elsewhere in\nthe ""else if"" cascade.\n\n>  ref-filter.c            | 21 ++++++++++++++++++---\n>  t/t6300-for-each-ref.sh |  9 +++++++++\n>  2 files changed, 27 insertions(+), 3 deletions(-)\n>\n> diff --git a/ref-filter.c b/ref-filter.c\n> index ba85869755..dc31fbbe51 100644\n> --- a/ref-filter.c\n> +++ b/ref-filter.c\n> @@ -332,6 +332,22 @@ static int trailers_atom_parser(const struct ref_format *format, struct used_ato\n>  \treturn 0;\n>  }\n>  \n> +static int check_format_field(const char *arg, const char *field, const char **option)\n> +{\n> +\tconst char *opt;\n> +\tif (skip_prefix(arg, field, &opt)) {\n> +\t\tif (*opt == \'\\0\') {\n> +\t\t\t*option = NULL;\n> +\t\t\treturn 1;\n> +\t\t}\n> +\t\telse if (*opt == \':\') {\n> +\t\t\t*option = ++opt;\n> +\t\t\treturn 1;\n> +\t\t}\n> +\t}\n> +\treturn 0;\n> +}\n> +\n>  static int contents_atom_parser(const struct ref_format *format, struct used_atom *atom,\n>  \t\t\t\tconst char *arg, struct strbuf *err)\n>  {\n> @@ -345,9 +361,8 @@ static int contents_atom_parser(const struct ref_format *format, struct used_ato\n>  \t\tatom->u.contents.option = C_SIG;\n>  \telse if (!strcmp(arg, ""subject""))\n>  \t\tatom->u.contents.option = C_SUB;\n> -\telse if (skip_prefix(arg, ""trailers"", &arg)) {\n> -\t\tskip_prefix(arg, "":"", &arg);\n> -\t\tif (trailers_atom_parser(format, atom, *arg ? arg : NULL, err))\n> +\telse if (check_format_field(arg, ""trailers"", &arg)) {\n> +\t\tif (trailers_atom_parser(format, atom, arg, err))\n>  \t\t\treturn -1;\n>  \t} else if (skip_prefix(arg, ""lines="", &arg)) {\n>  \t\tatom->u.contents.option = C_LINES;\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 19, 17, 57, 48, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 473259015, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/xmqqmu2qtpxp.fsf@gitster.c.googlers.com), Junio C Hamano wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nJunio C Hamano <gitster@pobox.com> writes:\n\n> ""Hariom Verma via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n>\n>> From: Hariom Verma <hariom18599@gmail.com>\n>>\n>> The \'contents\' atom does not show any error if used with \'trailers\'\n>> atom and semicolon is missing before trailers arguments.\n>>\n>> e.g %(contents:trailersonly) works, while it shouldn\'t.\n>>\n>> It is definitely not an expected behavior.\n>>\n>> Let\'s fix this bug.\n>>\n>> Mentored-by: Christian Couder <chriscool@tuxfamily.org>\n>> Mentored-by: Heba Waly <heba.waly@gmail.com>\n>> Signed-off-by: Hariom Verma <hariom18599@gmail.com>\n>> ---\n>\n> Nice spotting.  7a5edbdb (ref-filter.c: parse trailers arguments\n> with %(contents) atom, 2017-10-01) talks about being deliberate\n> about the case where skip_prefix("":"") does not find a colon after\n> the ""trailers"" token, but from the message it is clear that it\n> expected that the case happens only when ""trailers"" is at the end of\n> the string.\n>\n> The new helper that is overly verbose and may be overkill.\n>\n> Shouldn\'t this be clear enough, equivalent and sufficient?\n>\n> \telse if (skip_prefix(arg, ""trailers"", &arg) &&\n> \t\t (!*arg || *arg == \':\'))) {\n> \t\tif (trailers_atom_parser(...);\n\nAh, no, even with ""*arg++ == \':\'.  This moves arg past ""trailers"" if\ngiven ""trailersandsomegarbage"" and the next one in ""else if"" cascade\nwould look at ""andsomegarbage""---which is not what we want.\n\n>> +static int check_format_field(const char *arg, const char *field, const char **option)\n>> +{\n>> +\tconst char *opt;\n>> +\tif (skip_prefix(arg, field, &opt)) {\n>> +\t\tif (*opt == \'\\0\') {\n>> +\t\t\t*option = NULL;\n>> +\t\t\treturn 1;\n>> +\t\t}\n>> +\t\telse if (*opt == \':\') {\n>> +\t\t\t*option = ++opt;\n>> +\t\t\treturn 1;\n>> +\t\t}\n>> +\t}\n>> +\treturn 0;\n>> +}\n\nAnd the helper does not have such a breakage.  It looks good.\n\nThanks.\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 19, 19, 9, 58, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 473276101, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/CAPig+cS398dm4W5Q2DnK+bGvw0mOG3916dHPbZ=y1JNrqz1G-w@mail.gmail.com), Eric Sunshine wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Wed, Aug 19, 2020 at 3:07 PM Junio C Hamano <gitster@pobox.com> wrote:\n> Junio C Hamano <gitster@pobox.com> writes:\n> > ""Hariom Verma via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n> >> +static int check_format_field(const char *arg, const char *field, const char **option)\n> >> +{\n> >> +            else if (*opt == \':\') {\n> >> +                    *option = ++opt;\n> >> +                    return 1;\n> >> +            }\n>\n> And the helper does not have such a breakage.  It looks good.\n\nOne minor comment (not worth a re-roll): I personally found:\n\n    *option = ++opt;\n\nmore confusing than:\n\n    *option = opt + 1;\n\nThe `++opt` places a higher cognitive load on the reader. As a\nreviewer, I had to go back and carefully reread the function to see if\nthe side-effect of `++opt` had some impact which I didn\'t notice on\nthe first readthrough. The simpler `opt + 1` does not have a\nside-effect, thus is easier to reason about (and doesn\'t require me to\nre-study the function when I encounter it).\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 19, 19, 43, 7, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 473374737, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/xmqqsgcis2zc.fsf@gitster.c.googlers.com), Junio C Hamano wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nEric Sunshine <sunshine@sunshineco.com> writes:\n\n> On Wed, Aug 19, 2020 at 3:07 PM Junio C Hamano <gitster@pobox.com> wrote:\n>> Junio C Hamano <gitster@pobox.com> writes:\n>> > ""Hariom Verma via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n>> >> +static int check_format_field(const char *arg, const char *field, const char **option)\n>> >> +{\n>> >> +            else if (*opt == \':\') {\n>> >> +                    *option = ++opt;\n>> >> +                    return 1;\n>> >> +            }\n>>\n>> And the helper does not have such a breakage.  It looks good.\n>\n> One minor comment (not worth a re-roll): I personally found:\n>\n>     *option = ++opt;\n>\n> more confusing than:\n>\n>     *option = opt + 1;\n>\n> The `++opt` places a higher cognitive load on the reader. As a\n> reviewer, I had to go back and carefully reread the function to see if\n> the side-effect of `++opt` had some impact which I didn\'t notice on\n> the first readthrough. The simpler `opt + 1` does not have a\n> side-effect, thus is easier to reason about (and doesn\'t require me to\n> re-study the function when I encounter it).\n\nThat makes the two of us ... thanks.\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 19, 22, 11, 13, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 474152078, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/CA+CkUQ9qz1=xvpdtTy49W5Uru3ONJ5R1zUCSdi7OXJCnZxTdzA@mail.gmail.com), Hariom verma wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nHi,\n\nOn Thu, Aug 20, 2020 at 3:38 AM Junio C Hamano <gitster@pobox.com> wrote:\n>\n> Eric Sunshine <sunshine@sunshineco.com> writes:\n>\n> > On Wed, Aug 19, 2020 at 3:07 PM Junio C Hamano <gitster@pobox.com> wrote:\n> >> Junio C Hamano <gitster@pobox.com> writes:\n> >> > ""Hariom Verma via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n> >> >> +static int check_format_field(const char *arg, const char *field, const char **option)\n> >> >> +{\n> >> >> +            else if (*opt == \':\') {\n> >> >> +                    *option = ++opt;\n> >> >> +                    return 1;\n> >> >> +            }\n> >>\n> >> And the helper does not have such a breakage.  It looks good.\n> >\n> > One minor comment (not worth a re-roll): I personally found:\n> >\n> >     *option = ++opt;\n> >\n> > more confusing than:\n> >\n> >     *option = opt + 1;\n> >\n> > The `++opt` places a higher cognitive load on the reader. As a\n> > reviewer, I had to go back and carefully reread the function to see if\n> > the side-effect of `++opt` had some impact which I didn\'t notice on\n> > the first readthrough. The simpler `opt + 1` does not have a\n> > side-effect, thus is easier to reason about (and doesn\'t require me to\n> > re-study the function when I encounter it).\n>\n> That makes the two of us ... thanks.\n\nIt seems like the score is 2-0.\nI guess I\'m going with winning side.\n\nWill be improved in next version.\n\nThanks,\nHariom\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 20, 17, 23, 32, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 474603023, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/CA+CkUQ_z8RL=g32aWm5bx6+-W8SHBUxaOd8tWfxa7wfEWiNQJA@mail.gmail.com), Hariom verma wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nHi,\n\nOn Wed, Aug 19, 2020 at 11:01 PM Junio C Hamano <gitster@pobox.com> wrote:\n>\n> ""Hariom Verma via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n>\n> > @@ -839,14 +818,7 @@ test_expect_success \'%(trailers) rejects unknown trailers arguments\' \'\n> >       fatal: unknown %(trailers) argument: unsupported\n> >       EOF\n> >       test_must_fail git for-each-ref --format=""%(trailers:unsupported)"" 2>actual &&\n> > -     test_i18ncmp expect actual\n> > -\'\n> > -\n> > -test_expect_success \'%(contents:trailers) rejects unknown trailers arguments\' \'\n> > -     # error message cannot be checked under i18n\n> > -     cat >expect <<-EOF &&\n> > -     fatal: unknown %(trailers) argument: unsupported\n> > -     EOF\n> > +     test_i18ncmp expect actual &&\n> >       test_must_fail git for-each-ref --format=""%(contents:trailers:unsupported)"" 2>actual &&\n> >       test_i18ncmp expect actual\n> >  \'\n>\n> Doesn\'t this highlight a small bug, where an end-user request for an\n> unknown %(contents:trailers:unsupported) is flagged as an error\n> about %(trailers)?  Is it OK because we expect that users who use\n> the longer %(contents:trailers) to know that it is a synonym for\n> %(trailers) and the latter is the official way to write it?\n\nMaybe.\n\nAnother way of thinking is...\n\'trailers\' is an argument to \'contents\', likewise here \'unsupported\'\nis an argument to trailers.\nTechnically, the error message is correct.\n\nAgain, I think views on this are highly subjective.\n\nThanks,\nHariom\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 21, 10, 5, 41, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 474818156, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/CAPig+cRxCvHG70Nd00zBxYFuecu6+Z6uDP8ooN3rx9vPagoYBA@mail.gmail.com), Eric Sunshine wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Fri, Aug 21, 2020 at 6:11 AM Hariom Verma via GitGitGadget\n<gitgitgadget@gmail.com> wrote:\n> The \'contents\' atom does not show any error if used with \'trailers\'\n> atom and semicolon is missing before trailers arguments.\n\nDo you mean s/semicolon/colon/ ?\n\n> e.g %(contents:trailersonly) works, while it shouldn\'t.\n>\n> It is definitely not an expected behavior.\n>\n> Let\'s fix this bug.\n>\n> Signed-off-by: Hariom Verma <hariom18599@gmail.com>\n> ---\n> diff --git a/ref-filter.c b/ref-filter.c\n> @@ -332,6 +332,22 @@ static int trailers_atom_parser(const struct ref_format *format, struct used_ato\n> +static int check_format_field(const char *arg, const char *field, const char **option)\n> +{\n> +       const char *opt;\n> +       if (skip_prefix(arg, field, &opt)) {\n> +               if (*opt == \'\\0\') {\n> +                       *option = NULL;\n> +                       return 1;\n> +               }\n> +               else if (*opt == \':\') {\n> +                       *option = opt + 1;\n> +                       return 1;\n> +               }\n> +       }\n> +       return 0;\n> +}\n\nNot necessarily worth a re-roll, but rather than introducing all the\nabove new code...\n\n> @@ -345,9 +361,8 @@ static int contents_atom_parser(const struct ref_format *format, struct used_ato\n> -       else if (skip_prefix(arg, ""trailers"", &arg)) {\n> -               skip_prefix(arg, "":"", &arg);\n> -               if (trailers_atom_parser(format, atom, *arg ? arg : NULL, err))\n> +       else if (check_format_field(arg, ""trailers"", &arg)) {\n> +               if (trailers_atom_parser(format, atom, arg, err))\n>                         return -1;\n\n...an alternative would have been something like:\n\n    else if (!strcmp(arg, ""trailers"")) {\n        if (trailers_atom_parser(format, atom, NULL, err))\n            return -1;\n    } else if (skip_prefix(arg, ""trailers:"", &arg)) {\n        if (trailers_atom_parser(format, atom, arg, err))\n            return -1;\n    }\n\nwhich is quite simple to reason about (though has the cost of a tiny\nbit of duplication).\n\n> diff --git a/t/t6300-for-each-ref.sh b/t/t6300-for-each-ref.sh\n> @@ -823,6 +823,15 @@ test_expect_success \'%(trailers) rejects unknown trailers arguments\' \'\n> +test_expect_success \'if arguments, %(contents:trailers) shows error if semicolon is missing\' \'\n\ns/semicolon/colon/\n\n> +       # error message cannot be checked under i18n\n\nWhat is this comment about? I realize that you copied it from other\nnearby tests, but I find that it muddies rather than clarifies.\n\n> +       cat >expect <<-EOF &&\n> +       fatal: unrecognized %(contents) argument: trailersonly\n> +       EOF\n> +       test_must_fail git for-each-ref --format=""%(contents:trailersonly)"" 2>actual &&\n> +       test_i18ncmp expect actual\n> +\'\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 21, 17, 0, 28, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 474884998, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/xmqqeenz95bj.fsf@gitster.c.googlers.com), Junio C Hamano wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nEric Sunshine <sunshine@sunshineco.com> writes:\n\n> ...an alternative would have been something like:\n>\n>     else if (!strcmp(arg, ""trailers"")) {\n>         if (trailers_atom_parser(format, atom, NULL, err))\n>             return -1;\n>     } else if (skip_prefix(arg, ""trailers:"", &arg)) {\n>         if (trailers_atom_parser(format, atom, arg, err))\n>             return -1;\n>     }\n>\n> which is quite simple to reason about (though has the cost of a tiny\n> bit of duplication).\n\nYeah, that looks quite simple and straight-forward.\n\n>> diff --git a/t/t6300-for-each-ref.sh b/t/t6300-for-each-ref.sh\n>> @@ -823,6 +823,15 @@ test_expect_success \'%(trailers) rejects unknown trailers arguments\' \'\n>> +test_expect_success \'if arguments, %(contents:trailers) shows error if semicolon is missing\' \'\n>\n> s/semicolon/colon/\n\nDefinitely.\n\n>\n>> +       # error message cannot be checked under i18n\n>\n> What is this comment about? I realize that you copied it from other\n> nearby tests, but I find that it muddies rather than clarifies.\n\nYup.  If a patch changes test_cmp with test_i18ncmp, the above\nmessage belongs to its commit log message, but it is overkill to\nhave it as an in-line comment in every place where test_i18ncmp gets\nused.\n\nThanks for a review.\n\n>> +       cat >expect <<-EOF &&\n>> +       fatal: unrecognized %(contents) argument: trailersonly\n>> +       EOF\n>> +       test_must_fail git for-each-ref --format=""%(contents:trailersonly)"" 2>actual &&\n>> +       test_i18ncmp expect actual\n>> +\'\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 21, 19, 19, 6, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 474973814, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/CAPig+cSxjRoBE9FNqBW_xSkct6F23HmVSPhta_b4YD+MJERcTA@mail.gmail.com), Eric Sunshine wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Fri, Aug 21, 2020 at 5:06 PM Hariom Verma via GitGitGadget\n<gitgitgadget@gmail.com> wrote:\n> The \'contents\' atom does not show any error if used with \'trailers\'\n> atom and colon is missing before trailers arguments.\n>\n> e.g %(contents:trailersonly) works, while it shouldn\'t.\n>\n> It is definitely not an expected behavior.\n>\n> Let\'s fix this bug.\n>\n> Acked-by: Eric Sunshine <sunshine@sunshineco.com>\n\nI didn\'t ""ack"" this patch. If you think some sort of attribution with\nmy name is warranted, then a ""Helped-by:"" would be more appropriate.\n\n> Signed-off-by: Hariom Verma <hariom18599@gmail.com>\n> ---\n> diff --git a/ref-filter.c b/ref-filter.c\n> @@ -345,9 +345,11 @@ static int contents_atom_parser(const struct ref_format *format, struct used_ato\n> -       else if (skip_prefix(arg, ""trailers"", &arg)) {\n> -               skip_prefix(arg, "":"", &arg);\n> -               if (trailers_atom_parser(format, atom, *arg ? arg : NULL, err))\n> +       else if (!strcmp(arg, ""trailers"")) {\n> +               if (trailers_atom_parser(format, atom, NULL, err))\n> +                       return -1;\n> +       } else if (skip_prefix(arg, ""trailers:"", &arg)) {\n> +               if (trailers_atom_parser(format, atom, arg, err))\n>                         return -1;\n\nThis looks better and easier to reason about (but I may be biased in\nthinking so).\n\n> diff --git a/t/t6300-for-each-ref.sh b/t/t6300-for-each-ref.sh\n> @@ -823,6 +823,14 @@ test_expect_success \'%(trailers) rejects unknown trailers arguments\' \'\n> +test_expect_success \'if arguments, %(contents:trailers) shows error if semicolon is missing\' \'\n\nThis still needs a s/semicolon/colon/ (mentioned in my previous review).\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 21, 21, 16, 46, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 474984810, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/CA+CkUQ-2sCguVx2SVJhEZj0WJefxFDt28HD=R5WD_wk25sZV0A@mail.gmail.com), Hariom verma wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nHi Eric,\n\nOn Sat, Aug 22, 2020 at 2:43 AM Eric Sunshine <sunshine@sunshineco.com> wrote:\n>\n> On Fri, Aug 21, 2020 at 5:06 PM Hariom Verma via GitGitGadget\n> <gitgitgadget@gmail.com> wrote:\n> > The \'contents\' atom does not show any error if used with \'trailers\'\n> > atom and colon is missing before trailers arguments.\n> >\n> > e.g %(contents:trailersonly) works, while it shouldn\'t.\n> >\n> > It is definitely not an expected behavior.\n> >\n> > Let\'s fix this bug.\n> >\n> > Acked-by: Eric Sunshine <sunshine@sunshineco.com>\n>\n> I didn\'t ""ack"" this patch. If you think some sort of attribution with\n> my name is warranted, then a ""Helped-by:"" would be more appropriate.\n\nSorry about that. Fixing in the next version.\n\n> > Signed-off-by: Hariom Verma <hariom18599@gmail.com>\n> > ---\n> > diff --git a/ref-filter.c b/ref-filter.c\n> > @@ -345,9 +345,11 @@ static int contents_atom_parser(const struct ref_format *format, struct used_ato\n> > -       else if (skip_prefix(arg, ""trailers"", &arg)) {\n> > -               skip_prefix(arg, "":"", &arg);\n> > -               if (trailers_atom_parser(format, atom, *arg ? arg : NULL, err))\n> > +       else if (!strcmp(arg, ""trailers"")) {\n> > +               if (trailers_atom_parser(format, atom, NULL, err))\n> > +                       return -1;\n> > +       } else if (skip_prefix(arg, ""trailers:"", &arg)) {\n> > +               if (trailers_atom_parser(format, atom, arg, err))\n> >                         return -1;\n>\n> This looks better and easier to reason about (but I may be biased in\n> thinking so).\n\nThanks for the review.\n\n> > diff --git a/t/t6300-for-each-ref.sh b/t/t6300-for-each-ref.sh\n> > @@ -823,6 +823,14 @@ test_expect_success \'%(trailers) rejects unknown trailers arguments\' \'\n> > +test_expect_success \'if arguments, %(contents:trailers) shows error if semicolon is missing\' \'\n>\n> This still needs a s/semicolon/colon/ (mentioned in my previous review).\n\nSorry, I missed that too.\n\nThanks,\nHariom\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 21, 21, 49, 56, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 474986722, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/xmqqk0xr7jht.fsf@gitster.c.googlers.com), Junio C Hamano wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nEric Sunshine <sunshine@sunshineco.com> writes:\n\n> On Fri, Aug 21, 2020 at 5:06 PM Hariom Verma via GitGitGadget\n> <gitgitgadget@gmail.com> wrote:\n>> The \'contents\' atom does not show any error if used with \'trailers\'\n>> atom and colon is missing before trailers arguments.\n>>\n>> e.g %(contents:trailersonly) works, while it shouldn\'t.\n>>\n>> It is definitely not an expected behavior.\n>>\n>> Let\'s fix this bug.\n>>\n>> Acked-by: Eric Sunshine <sunshine@sunshineco.com>\n>\n> I didn\'t ""ack"" this patch. If you think some sort of attribution with\n> my name is warranted, then a ""Helped-by:"" would be more appropriate.\n\nYes, I did exactly that after moving it just above Hariom\'s sign-off.\n\n>> Signed-off-by: Hariom Verma <hariom18599@gmail.com>\n>> ---\n>> diff --git a/ref-filter.c b/ref-filter.c\n>> @@ -345,9 +345,11 @@ static int contents_atom_parser(const struct ref_format *format, struct used_ato\n>> -       else if (skip_prefix(arg, ""trailers"", &arg)) {\n>> -               skip_prefix(arg, "":"", &arg);\n>> -               if (trailers_atom_parser(format, atom, *arg ? arg : NULL, err))\n>> +       else if (!strcmp(arg, ""trailers"")) {\n>> +               if (trailers_atom_parser(format, atom, NULL, err))\n>> +                       return -1;\n>> +       } else if (skip_prefix(arg, ""trailers:"", &arg)) {\n>> +               if (trailers_atom_parser(format, atom, arg, err))\n>>                         return -1;\n>\n> This looks better and easier to reason about (but I may be biased in\n> thinking so).\n>\n>> diff --git a/t/t6300-for-each-ref.sh b/t/t6300-for-each-ref.sh\n>> @@ -823,6 +823,14 @@ test_expect_success \'%(trailers) rejects unknown trailers arguments\' \'\n>> +test_expect_success \'if arguments, %(contents:trailers) shows error if semicolon is missing\' \'\n>\n> This still needs a s/semicolon/colon/ (mentioned in my previous review).\n\nYup.  Tweaked while queueing.\n\nThanks always for sharp eyes.\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 21, 21, 55, 58, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 475292556, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/CA+CkUQ8Gst2RTaXY6t+ytWu_9Pu7eqnRYRrnawRwYd_NN=u0Lg@mail.gmail.com), Hariom verma wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nHi,\n\nOn Sat, Aug 22, 2020 at 12:47 AM Junio C Hamano <gitster@pobox.com> wrote:\n>\n> Eric Sunshine <sunshine@sunshineco.com> writes:\n>\n> > ...an alternative would have been something like:\n> >\n> >     else if (!strcmp(arg, ""trailers"")) {\n> >         if (trailers_atom_parser(format, atom, NULL, err))\n> >             return -1;\n> >     } else if (skip_prefix(arg, ""trailers:"", &arg)) {\n> >         if (trailers_atom_parser(format, atom, arg, err))\n> >             return -1;\n> >     }\n> >\n> > which is quite simple to reason about (though has the cost of a tiny\n> > bit of duplication).\n>\n> Yeah, that looks quite simple and straight-forward.\n\nNo doubt, it looks good for ""contents:trailers"".\n\nWhat if In future we would like to expand functionalities of other\n\'contents\' options?\n\nRecently, I sent a patch series ""Improvements to ref-filter""[1]. A\npatch in this patch series introduced ""sanitize"" modifier to ""subject""\natom. i.e ""%(subject:sanitize)"".\n\nWhat if in the future we also want ""%(contents:subject:sanitize)"" to work?\nWe can duplicate code again. Something like:\n```\n} else if (!strcmp(arg, ""trailers"")) {\n        if (trailers_atom_parser(format, atom, NULL, err))\n            return -1;\n} else if (skip_prefix(arg, ""trailers:"", &arg)) {\n        if (trailers_atom_parser(format, atom, arg, err))\n            return -1;\n} else if (!strcmp(arg, ""subject"")) {\n        if (subject_atom_parser(format, atom, NULL, err))\n            return -1;\n} else if (skip_prefix(arg, ""subject:"", &arg)) {\n        if (subject_atom_parser(format, atom, arg, err))\n            return -1;\n}\n```\n\nOR\n\nWe can just simply use helper. Something like:\n```\nelse if (check_format_field(arg, ""subject"", &arg)) {\n    if (subject_atom_parser(format, atom, arg, err))\n        return -1;\n} else if (check_format_field(arg, ""trailers"", &arg)) {\n    if (trailers_atom_parser(format, atom, arg, err))\n        return -1;\n```\nWe can use this helper any number of times, whenever there is a need.\n\nSorry, I missed saying this earlier. But I don\'t prefer duplicating\nthe code here.\n\nThanks,\nHariom\n\n[1]: https://public-inbox.org/git/pull.684.v4.git.1598046110.gitgitgadget@gmail.com/#t\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 24, 0, 57, 25, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 475327806, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/CAPig+cScdV1ORSbqDuUiOEvCd6TYgkR=3GK8OCUu4yuoKVy5Pg@mail.gmail.com), Eric Sunshine wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Sun, Aug 23, 2020 at 8:56 PM Hariom verma <hariom18599@gmail.com> wrote:\n> On Sat, Aug 22, 2020 at 12:47 AM Junio C Hamano <gitster@pobox.com> wrote:\n> > Eric Sunshine <sunshine@sunshineco.com> writes:\n> > > ...an alternative would have been something like:\n> > >\n> > >   else if (!strcmp(arg, ""trailers"")) {\n> > >     if (trailers_atom_parser(format, atom, NULL, err))\n> > >       return -1;\n> > >   } else if (skip_prefix(arg, ""trailers:"", &arg)) {\n> > >     if (trailers_atom_parser(format, atom, arg, err))\n> > >       return -1;\n> > >   }\n> > >\n> > > which is quite simple to reason about (though has the cost of a tiny\n> > > bit of duplication).\n> >\n> > Yeah, that looks quite simple and straight-forward.\n>\n> Recently, I sent a patch series ""Improvements to ref-filter""[1]. A\n> patch in this patch series introduced ""sanitize"" modifier to ""subject""\n> atom. i.e ""%(subject:sanitize)"".\n>\n> What if in the future we also want ""%(contents:subject:sanitize)"" to work?\n> We can use this helper any number of times, whenever there is a need.\n>\n> Sorry, I missed saying this earlier. But I don\'t prefer duplicating\n> the code here.\n\nPushing back on a reviewer suggestion is fine. Explaining the reason\nfor your position -- as you do here -- helps reviewers understand why\nyou feel the way you do. My review suggestion about making it easier\nto reason about the code while avoiding a brand new function, at the\ncost of a minor amount of duplication, was made in the context of this\none-off case in which the function increased cognitive load and was\nused just once (not knowing that you envisioned future callers). If\nyou expect the new function to be re-used by upcoming changes, then\nthat may be a good reason to keep it. Stating so in the commit message\nwill help reviewers see beyond the immediate patch or patch series.\n\nAside from a couple minor style violations[1,2], I don\'t particularly\noppose the helper function, though I have a quibble with the name\ncheck_format_field(), which I don\'t find helpful, and which (at least\nfor me) increases the cognitive load. The increased cognitive load, I\nthink, comes not only from the function name not spelling out what the\nfunction actually does, but also because the function is dual-purpose:\nit\'s both checking that the argument matches a particular token\n(""trailers"", in this case) and extracting the sub-argument. Perhaps\nnaming it match_and_extract_subarg() or something similar would help,\nthough that\'s a mouthful.\n\nBut the observation about the function being dual-purpose (thus\npotentially confusing) brings up other questions. For instance, is it\ntoo special-purpose? If you foresee more callers in the future with\nmultiple-token arguments such as `%(content:subject:sanitize)`, should\nthe function provide more assistance by splitting out each of the\nsub-arguments rather than stopping at the first? Taking that even\nfurther, a generalized helper for ""splitting"" arguments like that\nmight be useful at the top-level of contents_atom_parser() too, rather\nthan only for specific arguments, such as ""trailers"". Of course, this\nmay all be way too ambitious for this little bug fix series or even\nfor whatever upcoming changes you\'re planning, thus not worth\npursuing.\n\nAs for the helper\'s implementation, I might have written it like this:\n\n    static int check_format_field(...)\n    {\n        const char *opt\n        if (!strcmp(arg, field))\n            *option = NULL;\n        else if (skip_prefix(arg, field, opt) && *opt == \':\')\n            *option = opt + 1;\n        else\n            return 0;\n        return 1;\n    }\n\nwhich is more compact and closer to what I suggested earlier for\navoiding the helper function in the first place. But, of course,\nprogramming is quite subjective, and you may find your implementation\neasier to reason about. Plus, your version has the benefit of being\nslightly more optimal since it avoids an extra string scan, although\nthat probably is mostly immaterial considering that\ncontents_atom_parser() itself contains a long chain of potentially\nsub-optimal strcmp() and skip_prefix() calls.\n\n\nFootnotes\n\n[1]: use `if (!*opt)` rather than `if (*opt == \'\\0\')`\n[2]: cuddle the closing brace and `else` on the same line like this:\n     `} else if (...) {`\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 24, 3, 51, 27, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 475962548, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/CA+CkUQ_eRqOB8Ushg-BcEmjRxEZSs7tmPnZcb8GUTwz3R55Xhg@mail.gmail.com), Hariom verma wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nHi,\n\nOn Mon, Aug 24, 2020 at 9:19 AM Eric Sunshine <sunshine@sunshineco.com> wrote:\n>\n> On Sun, Aug 23, 2020 at 8:56 PM Hariom verma <hariom18599@gmail.com> wrote:\n> > On Sat, Aug 22, 2020 at 12:47 AM Junio C Hamano <gitster@pobox.com> wrote:\n> > > Eric Sunshine <sunshine@sunshineco.com> writes:\n> > > > ...an alternative would have been something like:\n> > > >\n> > > >   else if (!strcmp(arg, ""trailers"")) {\n> > > >     if (trailers_atom_parser(format, atom, NULL, err))\n> > > >       return -1;\n> > > >   } else if (skip_prefix(arg, ""trailers:"", &arg)) {\n> > > >     if (trailers_atom_parser(format, atom, arg, err))\n> > > >       return -1;\n> > > >   }\n> > > >\n> > > > which is quite simple to reason about (though has the cost of a tiny\n> > > > bit of duplication).\n> > >\n> > > Yeah, that looks quite simple and straight-forward.\n> >\n> > Recently, I sent a patch series ""Improvements to ref-filter""[1]. A\n> > patch in this patch series introduced ""sanitize"" modifier to ""subject""\n> > atom. i.e ""%(subject:sanitize)"".\n> >\n> > What if in the future we also want ""%(contents:subject:sanitize)"" to work?\n> > We can use this helper any number of times, whenever there is a need.\n> >\n> > Sorry, I missed saying this earlier. But I don\'t prefer duplicating\n> > the code here.\n>\n> Pushing back on a reviewer suggestion is fine. Explaining the reason\n> for your position -- as you do here -- helps reviewers understand why\n> you feel the way you do. My review suggestion about making it easier\n> to reason about the code while avoiding a brand new function, at the\n> cost of a minor amount of duplication, was made in the context of this\n> one-off case in which the function increased cognitive load and was\n> used just once (not knowing that you envisioned future callers). If\n> you expect the new function to be re-used by upcoming changes, then\n> that may be a good reason to keep it. Stating so in the commit message\n> will help reviewers see beyond the immediate patch or patch series.\n\nYeah. I should have mentioned this in the commit message.\n\n> Aside from a couple minor style violations[1,2], I don\'t particularly\n> oppose the helper function, though I have a quibble with the name\n> check_format_field(), which I don\'t find helpful, and which (at least\n> for me) increases the cognitive load. The increased cognitive load, I\n> think, comes not only from the function name not spelling out what the\n> function actually does, but also because the function is dual-purpose:\n> it\'s both checking that the argument matches a particular token\n> (""trailers"", in this case) and extracting the sub-argument. Perhaps\n> naming it match_and_extract_subarg() or something similar would help,\n> though that\'s a mouthful.\n\nI will fix those violations.\nAlso, ""match_and_extract_subarg()"" looks good to me.\n\n> But the observation about the function being dual-purpose (thus\n> potentially confusing) brings up other questions. For instance, is it\n> too special-purpose? If you foresee more callers in the future with\n> multiple-token arguments such as `%(content:subject:sanitize)`, should\n> the function provide more assistance by splitting out each of the\n> sub-arguments rather than stopping at the first? Taking that even\n> further, a generalized helper for ""splitting"" arguments like that\n> might be useful at the top-level of contents_atom_parser() too, rather\n> than only for specific arguments, such as ""trailers"". Of course, this\n> may all be way too ambitious for this little bug fix series or even\n> for whatever upcoming changes you\'re planning, thus not worth\n> pursuing.\n\nSplitting sub-arguments is done at ""<atomname>_atom_parser()"".\nIf you mean pre-splitting every argument...\nsomething like: [\'contents\', \'subject\', \'sanitize\'] for\n`%(content:subject:sanitize)` in `contents_atom_parser()` ? I\'m not\nable to see how it can be useful.\n\nSorry, If I got your concerned wrong.\n\n> As for the helper\'s implementation, I might have written it like this:\n>\n>     static int check_format_field(...)\n>     {\n>         const char *opt\n>         if (!strcmp(arg, field))\n>             *option = NULL;\n>         else if (skip_prefix(arg, field, opt) && *opt == \':\')\n>             *option = opt + 1;\n>         else\n>             return 0;\n>         return 1;\n>     }\n>\n> which is more compact and closer to what I suggested earlier for\n> avoiding the helper function in the first place. But, of course,\n> programming is quite subjective, and you may find your implementation\n> easier to reason about. Plus, your version has the benefit of being\n> slightly more optimal since it avoids an extra string scan, although\n> that probably is mostly immaterial considering that\n> contents_atom_parser() itself contains a long chain of potentially\n> sub-optimal strcmp() and skip_prefix() calls.\n\n""programming is quite subjective""\nYeah, I couldn\'t agree more.\n\nThe change you suggested looks good too. But I\'m little inclined to my\nkeeping my changes. I\'m curious, what others have to say on this.\n\nThanks,\nHariom\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 24, 23, 34, 48, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 477060877, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/CAP8UFD03Am94_84FvRPxEdt_AG74864eQ4TimggKtUYWjJYqCg@mail.gmail.com), Christian Couder wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nHi,\n\nOn Tue, Aug 25, 2020 at 1:32 AM Hariom verma <hariom18599@gmail.com> wrote:\n\n> On Mon, Aug 24, 2020 at 9:19 AM Eric Sunshine <sunshine@sunshineco.com> wrote:\n> >\n> > On Sun, Aug 23, 2020 at 8:56 PM Hariom verma <hariom18599@gmail.com> wrote:\n\n> > > Recently, I sent a patch series ""Improvements to ref-filter""[1]. A\n> > > patch in this patch series introduced ""sanitize"" modifier to ""subject""\n> > > atom. i.e ""%(subject:sanitize)"".\n> > >\n> > > What if in the future we also want ""%(contents:subject:sanitize)"" to work?\n> > > We can use this helper any number of times, whenever there is a need.\n> > >\n> > > Sorry, I missed saying this earlier. But I don\'t prefer duplicating\n> > > the code here.\n> >\n> > Pushing back on a reviewer suggestion is fine. Explaining the reason\n> > for your position -- as you do here -- helps reviewers understand why\n> > you feel the way you do. My review suggestion about making it easier\n> > to reason about the code while avoiding a brand new function, at the\n> > cost of a minor amount of duplication, was made in the context of this\n> > one-off case in which the function increased cognitive load and was\n> > used just once (not knowing that you envisioned future callers). If\n> > you expect the new function to be re-used by upcoming changes, then\n> > that may be a good reason to keep it. Stating so in the commit message\n> > will help reviewers see beyond the immediate patch or patch series.\n>\n> Yeah. I should have mentioned this in the commit message.\n\nI agree.\n\n> > Aside from a couple minor style violations[1,2], I don\'t particularly\n> > oppose the helper function, though I have a quibble with the name\n> > check_format_field(), which I don\'t find helpful, and which (at least\n> > for me) increases the cognitive load. The increased cognitive load, I\n> > think, comes not only from the function name not spelling out what the\n> > function actually does, but also because the function is dual-purpose:\n> > it\'s both checking that the argument matches a particular token\n> > (""trailers"", in this case) and extracting the sub-argument. Perhaps\n> > naming it match_and_extract_subarg() or something similar would help,\n> > though that\'s a mouthful.\n>\n> I will fix those violations.\n> Also, ""match_and_extract_subarg()"" looks good to me.\n\nI am not sure about the ""subarg"" part of the name. In the for-each-ref\ndoc, names inside %(...) are called ""field names"", and parts after "":""\nare called ""options"". So it might be better to have ""field_option""\ninstead of ""subarg"" in the name.\n\nI think we could also get rid of the ""match_and_"" part of the\nsuggestion, in the same way as skip_prefix() is not called\nmatch_and_skip_prefix(). Readers can just expect that if there is no\nmatch the function will return 0.\n\nSo maybe ""extract_field_option()"".\n\n> > But the observation about the function being dual-purpose (thus\n> > potentially confusing) brings up other questions. For instance, is it\n> > too special-purpose? If you foresee more callers in the future with\n> > multiple-token arguments such as `%(content:subject:sanitize)`, should\n> > the function provide more assistance by splitting out each of the\n> > sub-arguments rather than stopping at the first? Taking that even\n> > further, a generalized helper for ""splitting"" arguments like that\n> > might be useful at the top-level of contents_atom_parser() too, rather\n> > than only for specific arguments, such as ""trailers"". Of course, this\n> > may all be way too ambitious for this little bug fix series or even\n> > for whatever upcoming changes you\'re planning, thus not worth\n> > pursuing.\n>\n> Splitting sub-arguments is done at ""<atomname>_atom_parser()"".\n> If you mean pre-splitting every argument...\n> something like: [\'contents\', \'subject\', \'sanitize\'] for\n> `%(content:subject:sanitize)` in `contents_atom_parser()` ? I\'m not\n> able to see how it can be useful.\n\nYeah, it seems to me that such a splitting would require a complete\nrewrite of the current code, so I am not sure it\'s an interesting way\nforward for now. And anyway adding extract_field_option() goes in the\nright direction of abstracting the parsing and making the code\nsimpler, more efficient and likely more correct.\n\n> Sorry, If I got your concerned wrong.\n>\n> > As for the helper\'s implementation, I might have written it like this:\n> >\n> >     static int check_format_field(...)\n> >     {\n> >         const char *opt\n> >         if (!strcmp(arg, field))\n> >             *option = NULL;\n> >         else if (skip_prefix(arg, field, opt) && *opt == \':\')\n> >             *option = opt + 1;\n> >         else\n> >             return 0;\n> >         return 1;\n> >     }\n> >\n> > which is more compact and closer to what I suggested earlier for\n> > avoiding the helper function in the first place. But, of course,\n> > programming is quite subjective, and you may find your implementation\n> > easier to reason about. Plus, your version has the benefit of being\n> > slightly more optimal since it avoids an extra string scan, although\n> > that probably is mostly immaterial considering that\n> > contents_atom_parser() itself contains a long chain of potentially\n> > sub-optimal strcmp() and skip_prefix() calls.\n>\n> ""programming is quite subjective""\n> Yeah, I couldn\'t agree more.\n>\n> The change you suggested looks good too. But I\'m little inclined to my\n> keeping my changes. I\'m curious, what others have to say on this.\n\nI also prefer a slightly more optimal one even if it\'s a bit less compact.\n\nThanks,\nChristian.\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 26, 6, 23, 12, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 477060881, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/CAP8UFD0Ds816PfQFwX+1wQhpjaCHZFOF3dK76SRUzt23uS9jPg@mail.gmail.com), Christian Couder wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Wed, Aug 26, 2020 at 8:18 AM Christian Couder\n<christian.couder@gmail.com> wrote:\n\n> I think we could also get rid of the ""match_and_"" part of the\n> suggestion, in the same way as skip_prefix() is not called\n> match_and_skip_prefix(). Readers can just expect that if there is no\n> match the function will return 0.\n>\n> So maybe ""extract_field_option()"".\n\nIf we want to hint more that it works in the way as skip_prefix(), we\ncould call it ""skip_field()"".\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 26, 6, 23, 14, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 477580988, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/CA+CkUQ_M=q9bkxjM9b+5DRkRBoFRnzhnsCUB-gX9GEeW6H5SVw@mail.gmail.com), Hariom verma wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nHi,\n\nOn Wed, Aug 26, 2020 at 11:48 AM Christian Couder\n<christian.couder@gmail.com> wrote:\n>\n> Hi,\n>\n> On Tue, Aug 25, 2020 at 1:32 AM Hariom verma <hariom18599@gmail.com> wrote:\n>\n> > On Mon, Aug 24, 2020 at 9:19 AM Eric Sunshine <sunshine@sunshineco.com> wrote:\n>\n> > > Aside from a couple minor style violations[1,2], I don\'t particularly\n> > > oppose the helper function, though I have a quibble with the name\n> > > check_format_field(), which I don\'t find helpful, and which (at least\n> > > for me) increases the cognitive load. The increased cognitive load, I\n> > > think, comes not only from the function name not spelling out what the\n> > > function actually does, but also because the function is dual-purpose:\n> > > it\'s both checking that the argument matches a particular token\n> > > (""trailers"", in this case) and extracting the sub-argument. Perhaps\n> > > naming it match_and_extract_subarg() or something similar would help,\n> > > though that\'s a mouthful.\n> >\n> > I will fix those violations.\n> > Also, ""match_and_extract_subarg()"" looks good to me.\n>\n> I am not sure about the ""subarg"" part of the name. In the for-each-ref\n> doc, names inside %(...) are called ""field names"", and parts after "":""\n> are called ""options"". So it might be better to have ""field_option""\n> instead of ""subarg"" in the name.\n>\n> I think we could also get rid of the ""match_and_"" part of the\n> suggestion, in the same way as skip_prefix() is not called\n> match_and_skip_prefix(). Readers can just expect that if there is no\n> match the function will return 0.\n>\n> So maybe ""extract_field_option()"".\n\nMakes sense to me.\n\n> > > But the observation about the function being dual-purpose (thus\n> > > potentially confusing) brings up other questions. For instance, is it\n> > > too special-purpose? If you foresee more callers in the future with\n> > > multiple-token arguments such as `%(content:subject:sanitize)`, should\n> > > the function provide more assistance by splitting out each of the\n> > > sub-arguments rather than stopping at the first? Taking that even\n> > > further, a generalized helper for ""splitting"" arguments like that\n> > > might be useful at the top-level of contents_atom_parser() too, rather\n> > > than only for specific arguments, such as ""trailers"". Of course, this\n> > > may all be way too ambitious for this little bug fix series or even\n> > > for whatever upcoming changes you\'re planning, thus not worth\n> > > pursuing.\n> >\n> > Splitting sub-arguments is done at ""<atomname>_atom_parser()"".\n> > If you mean pre-splitting every argument...\n> > something like: [\'contents\', \'subject\', \'sanitize\'] for\n> > `%(content:subject:sanitize)` in `contents_atom_parser()` ? I\'m not\n> > able to see how it can be useful.\n>\n> Yeah, it seems to me that such a splitting would require a complete\n> rewrite of the current code, so I am not sure it\'s an interesting way\n> forward for now. And anyway adding extract_field_option() goes in the\n> right direction of abstracting the parsing and making the code\n> simpler, more efficient and likely more correct.\n>\n> > Sorry, If I got your concerned wrong.\n> >\n> > > As for the helper\'s implementation, I might have written it like this:\n> > >\n> > >     static int check_format_field(...)\n> > >     {\n> > >         const char *opt\n> > >         if (!strcmp(arg, field))\n> > >             *option = NULL;\n> > >         else if (skip_prefix(arg, field, opt) && *opt == \':\')\n> > >             *option = opt + 1;\n> > >         else\n> > >             return 0;\n> > >         return 1;\n> > >     }\n> > >\n> > > which is more compact and closer to what I suggested earlier for\n> > > avoiding the helper function in the first place. But, of course,\n> > > programming is quite subjective, and you may find your implementation\n> > > easier to reason about. Plus, your version has the benefit of being\n> > > slightly more optimal since it avoids an extra string scan, although\n> > > that probably is mostly immaterial considering that\n> > > contents_atom_parser() itself contains a long chain of potentially\n> > > sub-optimal strcmp() and skip_prefix() calls.\n> >\n> > ""programming is quite subjective""\n> > Yeah, I couldn\'t agree more.\n> >\n> > The change you suggested looks good too. But I\'m little inclined to my\n> > keeping my changes. I\'m curious, what others have to say on this.\n>\n> I also prefer a slightly more optimal one even if it\'s a bit less compact.\n\n+1\n\nThanks,\nHariom\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 26, 20, 50, 5, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}]","[{'commit_sha': '383476b1778eb0d62c6cf013008388f72065beb0', 'committer_username': 'harry-hov', 'committer_name': 'Hariom Verma', 'committer_email': None, 'commit_date': datetime.datetime(2018, 3, 20, 9, 19, 52, tzinfo=datetime.timezone.utc)}, {'commit_sha': '659b9835dcd0b38ac3972eb19c08c3bf26dccc80', 'committer_username': 'harry-hov', 'committer_name': 'Hariom Verma', 'committer_email': None, 'commit_date': datetime.datetime(2018, 3, 20, 9, 19, 52, tzinfo=datetime.timezone.utc)}, {'commit_sha': '712ab9aacf240a02d808af6b6837e682b929493c', 'committer_username': 'harry-hov', 'committer_name': 'Hariom Verma', 'committer_email': None, 'commit_date': datetime.datetime(2018, 3, 20, 9, 19, 52, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'd491be5d10991189f7ec6ead739c1d1500e437a1', 'committer_username': 'harry-hov', 'committer_name': 'Hariom Verma', 'committer_email': None, 'commit_date': datetime.datetime(2018, 3, 20, 9, 19, 52, tzinfo=datetime.timezone.utc)}]",Hariom Verma,37576387,,User,,27,,51,46

Project_ID,Name,Full_name,Language,Forks,Stars,Watchers,contributors,commits,issues,branches,PRs_count,contributor pullrequests
135437869,git,gitgitgadget/git,C,132,205,28,2235,74374,264,536,188,"[{'id': 480572395, 'number': 726, 'closed': datetime.datetime(2021, 3, 1, 22, 50, 34, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2020, 9, 5, 19, 31, 44, tzinfo=datetime.timezone.utc), 'time_taken': 15304730.0, 'time_delta': '177 days, 3:18:50', 'additions': 236, 'deletions': 103, 'state': 'closed'}, {'id': 470141940, 'number': 707, 'closed': datetime.datetime(2020, 9, 5, 19, 17, 7, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2020, 8, 19, 12, 48, 7, tzinfo=datetime.timezone.utc), 'time_taken': 1492140.0, 'time_delta': '17 days, 6:29:00', 'additions': 219, 'deletions': 87, 'state': 'closed'}, {'id': 456804433, 'number': 684, 'closed': datetime.datetime(2020, 9, 9, 22, 37, 26, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2020, 7, 26, 20, 55, 47, tzinfo=datetime.timezone.utc), 'time_taken': 3894099.0, 'time_delta': '45 days, 1:41:39', 'additions': 161, 'deletions': 65, 'state': 'closed'}, {'id': 434115642, 'number': 658, 'closed': None, 'created': datetime.datetime(2020, 6, 14, 8, 59, 39, tzinfo=datetime.timezone.utc), 'time_taken': 0.0, 'time_delta': '', 'additions': 139, 'deletions': 4, 'state': 'open'}, {'id': 401046299, 'number': 606, 'closed': None, 'created': datetime.datetime(2020, 4, 8, 19, 50, 30, tzinfo=datetime.timezone.utc), 'time_taken': 0.0, 'time_delta': '', 'additions': 3, 'deletions': 12, 'state': 'open'}, {'id': 382525481, 'number': 570, 'closed': datetime.datetime(2020, 3, 5, 22, 4, 19, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2020, 3, 2, 17, 58, 28, tzinfo=datetime.timezone.utc), 'time_taken': 273951.0, 'time_delta': '3 days, 4:05:51', 'additions': 6, 'deletions': 0, 'state': 'closed'}, {'id': 365527761, 'number': 535, 'closed': datetime.datetime(2020, 3, 5, 22, 3, 44, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2020, 1, 21, 21, 40, 34, tzinfo=datetime.timezone.utc), 'time_taken': 3802990.0, 'time_delta': '44 days, 0:23:10', 'additions': 44, 'deletions': 18, 'state': 'closed'}, {'id': 344792485, 'number': 473, 'closed': datetime.datetime(2019, 12, 9, 17, 18, 48, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2019, 11, 23, 9, 23, 26, tzinfo=datetime.timezone.utc), 'time_taken': 1410922.0, 'time_delta': '16 days, 7:55:22', 'additions': 0, 'deletions': 4, 'state': 'closed'}, {'id': 326404794, 'number': 382, 'closed': datetime.datetime(2019, 11, 11, 4, 50, 48, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2019, 10, 9, 19, 12, 39, tzinfo=datetime.timezone.utc), 'time_taken': 2799489.0, 'time_delta': '32 days, 9:38:09', 'additions': 12, 'deletions': 12, 'state': 'closed'}]"
