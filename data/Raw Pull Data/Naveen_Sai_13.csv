pr_id,pr_title,pr_body,is_merged,pr_number,pr_url,pr_html_url,pr_state,additions,deletions,pr_changed_files,pr_commits_count,pr_comments_count,pr_review_comments_count,pr_labels_count,pr_assignees_count,pr_labels,pr_created_at,pr_closed_at,time_taken,time_delta,pr_review_comments,pr_commits,contributor,contributor_id,contributor_email,contributor_type,contributions,contributor_public_repos,contributor_private_repos,contributor_followings,contributor_followers
641085952,[WIP] Rational Riccati solver,"This PR introduces a Rational Riccati ODE solver. This code can also be used to solve a subclass of 2nd order ODEs solvable by [Kovacic's Algorithm](https://cs.uwaterloo.ca/research/tr/1984/CS-84-35.pdf)

#### References to other Issues or PRs
Partial Fix #19183, #21503

#### Brief description of what is fixed or changed
The algorithm present [here](https://www3.risc.jku.at/publications/download/risc_5387/PhDThesisThieu.pdf) is implemented. The examples used to test are [here](https://www3.risc.jku.at/publications/download/risc_5197/RISCReport15-19.pdf).

#### Other comments
I will soon add the Kovacic solver.

#### Release Notes
<!-- BEGIN RELEASE NOTES -->
* solvers
  * ode:  Added a new solver for Riccati equation
<!-- END RELEASE NOTES -->",True,21459,https://api.github.com/repos/sympy/sympy/pulls/21459,https://github.com/sympy/sympy/pull/21459,closed,1974,8,6,41,119,144,1,0,[{'name': 'solvers.dsolve'}],2021-05-11 16:56:48+00:00,2021-07-21 18:43:35+00:00,6140807.0,"71 days, 1:46:47","[{'comment_id': 635613747, 'comment_body': ""I don't think this should use SinglePatternODESolver.\r\n\r\nRather the code here should just be a bunch of functions for doing the different parts of the algorithm. Then we can make a Solve class in single.py that wraps this for the current dsolve framework."", 'comment_created': datetime.datetime(2021, 5, 19, 22, 2, 12, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 635717623, 'comment_body': ""So we don't need the `RationalRiccati` class? What would the `Solve` class constitute?"", 'comment_created': datetime.datetime(2021, 5, 20, 3, 15, 12, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 635936048, 'comment_body': ""The solver class would basically be this one except that it wouldn't have all of these methods. Instead it would just call the functions from the ricatti module.\r\n\r\nThese classes exist just for the current pattern-matching structure of dsolve but we might want to move beyond that to a different structure later so an algorithm like this should not be tied to that structure."", 'comment_created': datetime.datetime(2021, 5, 20, 9, 32, 57, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 637573653, 'comment_body': 'Is the current structure okay?', 'comment_created': datetime.datetime(2021, 5, 23, 16, 53, 44, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 637591659, 'comment_body': 'For testing while this is being worked on I would put this hint at or near the top of the list. Then it will be used more often and we can see if it causes test failures.\r\n\r\nAlso if you see the notes at the top of `test_single.py` there is a way to run the hint with all the test examples.', 'comment_created': datetime.datetime(2021, 5, 23, 19, 36, 53, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 641791531, 'comment_body': 'You could create these above as `one = Poly(1, x)` and `xpoly = Poly(x, x)`.', 'comment_created': datetime.datetime(2021, 5, 28, 20, 6, 59, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 641793900, 'comment_body': ""We don't need to compute the whole series just for one coefficient:\r\n```\r\nIn [9]: f = (x**2 - 1)/(x**2 + 1)/(x - 2)**2\r\n\r\nIn [10]: f\r\nOut[10]: \r\n       2         \r\n      x  - 1     \r\n─────────────────\r\n       2 ⎛ 2    ⎞\r\n(x - 2) ⋅⎝x  + 1⎠\r\n\r\nIn [11]: f.series(x, 2)\r\nOut[11]: \r\n                                          2             3             4              5                            \r\n    3            8        206   82⋅(x - 2)    88⋅(x - 2)    58⋅(x - 2)    672⋅(x - 2)    48⋅x    ⎛       6       ⎞\r\n────────── + ────────── - ─── - ─────────── + ─────────── + ─────────── - ──────────── + ──── + O⎝(x - 2) ; x → 2⎠\r\n         2   25⋅(x - 2)   625       3125         15625         78125         390625      625                      \r\n5⋅(x - 2)                                                                                                         \r\n\r\nIn [12]: cancel(f*(x - 2)**2).subs(x, 2)\r\nOut[12]: 3/5\r\n```"", 'comment_created': datetime.datetime(2021, 5, 28, 20, 12, 48, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 641882583, 'comment_body': ""Got it, didn't realize that"", 'comment_created': datetime.datetime(2021, 5, 29, 3, 25, 24, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 642391774, 'comment_body': 'What is the advantage of using `solve_undetermined_coeffs` rather than `linsolve?', 'comment_created': datetime.datetime(2021, 5, 31, 10, 35, 33, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 642393455, 'comment_body': 'It would be good to put these conditions in a function with a docstring that clearly explains what they mean', 'comment_created': datetime.datetime(2021, 5, 31, 10, 38, 47, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 642396243, 'comment_body': 'A list comprehension is generally easier to read than a `list(map(lambda:` so I would write this as:\r\n```python\r\nsol = [Eq(fx, -y/b2 - b2.diff(x)/(2*b2**2) - b1/(2*b2)) for y in presol]\r\n```\r\nThen again you are recomputing the saem value at each iteration of the loop so:\r\n```python\r\nbp = b2.diff(x)/(2*b2**2) - b1/(2*b2)\r\nsol = [Eq(fx, -y/b2 - bp) for y in presol]\r\n```\r\nI would probably have made a function for these transformations anyway. As a separate function it can be tested separately. You can also test for a large range of (random) inputs that the transformation and inverse transformation do actually invert each other.', 'comment_created': datetime.datetime(2021, 5, 31, 10, 44, 8, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 642453670, 'comment_body': 'I thought using `solve_undetermined_coeffs` is better since it is more specific, i.e. `linsolve` has other types of equations it can solve. Also, I was using `solve` here before', 'comment_created': datetime.datetime(2021, 5, 31, 12, 31, 39, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 642461592, 'comment_body': 'You should compare them to see which gives a more usable output and which is faster.', 'comment_created': datetime.datetime(2021, 5, 31, 12, 44, 36, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 643343884, 'comment_body': ""Is `x**2*a` a rational function here?\r\n\r\nIf so then we can compute the limit much more efficiently. If the numerator and the denominator have the same degree then it's just the ratio of their leading coefficients:\r\n```python\r\nIn [6]: num = Poly(3*x**2 + x + 1)\r\n\r\nIn [7]: den = Poly(2*x**2 - x - 4)\r\n\r\nIn [8]: limit(num / den, x, oo)\r\nOut[8]: 3/2\r\n\r\nIn [9]: num.LC() / den.LC()\r\nOut[9]: 3/2\r\n```\r\nIf the denominator has greater degree then it's zero. If the numerator has greater degree then it's just `oo*sign(num.LC() / den.LC())`.\r\n\r\nAgain a function could be made for this calculation."", 'comment_created': datetime.datetime(2021, 6, 1, 17, 30, 39, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 643654491, 'comment_body': 'Changed to `linsolve` since `solve_undetermined_coeffs` is calling `solve` internally.', 'comment_created': datetime.datetime(2021, 6, 2, 5, 4, 55, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 643664056, 'comment_body': ""I've moved it up"", 'comment_created': datetime.datetime(2021, 6, 2, 5, 32, 51, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 645450999, 'comment_body': ""In some cases `coeffs` here is a large dict. In those cases it is more efficient to use `xreplace` rather than `subs`. In general the reason for preferring subs is because it handles bound vs free symbols but I don't think that is an issue here. Some slow examples can be made much faster by using `xreplace` here."", 'comment_created': datetime.datetime(2021, 6, 4, 10, 2, 4, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 645456053, 'comment_body': 'In some cases `m` here can be an algebraic expression that could be simplified to zero or perhaps another integer e.g.:\r\n```python\r\nIn [6]: m\r\nOut[6]: \r\n             _________________________________           _________________________________\r\n            ╱     7348059520   716670080⋅√105           ╱     716670080⋅√105   7348059520 \r\n           ╱      ────────── - ──────────────          ╱      ────────────── + ────────── \r\n          ╱           9              9                ╱             9              9      \r\n         ╱    1 + ───────────────────────────        ╱    1 + ─────────────────────────── \r\n        ╱          265995800   25937800⋅√105        ╱          25937800⋅√105   265995800  \r\n       ╱           ───────── - ─────────────       ╱           ───────────── + ─────────  \r\n     ╲╱                3             3           ╲╱                  3             3      \r\n-3 + ───────────────────────────────────────── + ─────────────────────────────────────────\r\n                         2                                           2                    \r\n\r\nIn [7]: m.is_integer\r\nOut[7]: True\r\n\r\nIn [8]: m.is_zero\r\nOut[8]: True\r\n\r\nIn [9]: m.n()\r\nOut[9]: 0.e-125\r\n\r\nIn [10]: minpoly(m)\r\nOut[10]: x\r\n```\r\nThe `is_integer` check gives true here because `is_zero` gives True and that is because `is_zero` checks `minpoly`. Subsequent code fails due to:\r\n```python\r\n  File ""/Users/enojb/current/sympy/sympy/my/ricattic.py"", line 137, in main\r\n    sol = solve_riccati(yf, x, q0, q1, q2)\r\n  File ""/Users/enojb/current/sympy/sympy/sympy/solvers/ode/riccati.py"", line 476, in solve_riccati\r\n    psol, coeffs, exists = solve_aux_eq(num, den, numy, deny, x, m)\r\n  File ""/Users/enojb/current/sympy/sympy/sympy/solvers/ode/riccati.py"", line 404, in solve_aux_eq\r\n    psyms = symbols(f\'C0:{m}\', cls=Dummy)\r\n  File ""/Users/enojb/current/sympy/sympy/sympy/core/symbol.py"", line 728, in symbols\r\n    a = 0 if not a else int(a)\r\n```\r\nThis only works for `m` because it is equal to zero. An algebraic expression equal to another integer would not work:\r\n```python\r\nIn [11]: m2 = 2 + m\r\n\r\nIn [12]: m2\r\nOut[12]: \r\n             _________________________________           _________________________________\r\n            ╱     7348059520   716670080⋅√105           ╱     716670080⋅√105   7348059520 \r\n           ╱      ────────── - ──────────────          ╱      ────────────── + ────────── \r\n          ╱           9              9                ╱             9              9      \r\n         ╱    1 + ───────────────────────────        ╱    1 + ─────────────────────────── \r\n        ╱          265995800   25937800⋅√105        ╱          25937800⋅√105   265995800  \r\n       ╱           ───────── - ─────────────       ╱           ───────────── + ─────────  \r\n     ╲╱                3             3           ╲╱                  3             3      \r\n-1 + ───────────────────────────────────────── + ─────────────────────────────────────────\r\n                         2                                           2                    \r\n\r\nIn [13]: m2.is_integer\r\n\r\nIn [14]: m2.n()\r\nOut[14]: 2.00000000000000\r\n\r\nIn [15]: minpoly(m2)\r\nOut[15]: x - 2\r\n```', 'comment_created': datetime.datetime(2021, 6, 4, 10, 10, 51, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 645983940, 'comment_body': 'So what should I use? `.n()` with a threshold?', 'comment_created': datetime.datetime(2021, 6, 5, 12, 15, 41, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 646118838, 'comment_body': ""Poly with extension=True will automatically simplify any algebraic expression:\r\n```python\r\nIn [6]: (1 + sqrt(2))**2 + (1 - sqrt(2))**2\r\nOut[6]: \r\n        2           2\r\n(1 - √2)  + (1 + √2) \r\n\r\nIn [7]: Poly(_, x, extension=True)\r\nOut[7]: Poly(6, x, domain='ZZ')\r\n```\r\nIf `m` had been computed using `Poly` then it would already be simplified to a rational if possible."", 'comment_created': datetime.datetime(2021, 6, 6, 11, 31, 15, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 656194108, 'comment_body': ""When I looked at this to try and compare it with the thesis I found it quite confusing because of the variable names and the way that the indexing is done.\r\n\r\nFirstly `temp` and `temp1` are not good variable names. I would call these `d1` and `d2` or `dplus` and `dminus` or something.\r\n\r\nSecondly the indexing is confusing because of the `-mul-1` etc. I understand why you've done that because you have lists that have additional items in them but it would be better to use dicts instead of lists so that you can use whatever indices you want. Then the indices and variables should be made to match the equations in the thesis as closely as possible e.g. like:\r\n```python\r\nS[0] = sum(d[j]*d[N-1-j] for j in range(0, N-1+1))\r\nd[-1] = (1 / (2*d[N])) * (a[N-1] - N*d[N] - S[0])\r\n```\r\n"", 'comment_created': datetime.datetime(2021, 6, 22, 12, 57, 27, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 656198262, 'comment_body': 'The scope needs to be explained clearly. What are `b0`, `b1` and `b2` required to be? Rational functions with rational coefficients? Are floats allowed? Are symbols allowed? What about coefficients like `exp(t)`? If we can have a symbol `t` then we should be able to have an expression like `exp(t)`. If the scope is currently restricted to pure Rational coefficients then that is fine but should be explicitly stated here.\r\n\r\nWe also need to clearly explain what a rational solution is. The most significant point of the algorithm is not mentioned here which is not just that the it finds rational solutions but that it finds *all* possible rational solutions. The reason that is significant is because it means that the algorithm is also a decision procedure: it can prove that no rational solutions exist.\r\n\r\nWe also need some tests for this. The fact that the algorithm proves the *non-existence* of solutions should be tested.', 'comment_created': datetime.datetime(2021, 6, 22, 13, 2, 14, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 656199108, 'comment_body': 'The name of the thesis should be given. Write this like an explicit reference. Including the link is nice but if the link goes stale then we need a proper reference to be able to identify the document.', 'comment_created': datetime.datetime(2021, 6, 22, 13, 3, 17, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 656200404, 'comment_body': 'It would be good to show equation 5.12 here and to explain that the basis of the algorithm is in considering all possibilities for which `m` poles are movable and the possible values of the coefficients `cij` and `di`', 'comment_created': datetime.datetime(2021, 6, 22, 13, 4, 55, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 656201372, 'comment_body': 'If `syms` is a list then `linsolve` will ignore the `var` argument. Why is that passed?', 'comment_created': datetime.datetime(2021, 6, 22, 13, 6, 2, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 656207741, 'comment_body': ""I don't think it's necessary to call `roots` here. Basically if we have `p(x) / q(x)` then there is a pole at `oo` if `deg(p) > deg(q)`."", 'comment_created': datetime.datetime(2021, 6, 22, 13, 13, 32, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 656208298, 'comment_body': 'This line is too long. This function needs a docstring with an explanation.', 'comment_created': datetime.datetime(2021, 6, 22, 13, 14, 9, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 656213372, 'comment_body': 'I think this should be changed to just be a function that makes `c` for a single pole. At least it should call a function that works for a single pole. Then we can have functions for each step like:\r\n```python\r\ndef get_c(...):\r\n    if ...:\r\n       return get_c_case1(...)\r\n    ...\r\n\r\ndef get_c_case1(...):\r\n    ...\r\n\r\ndef get_c_case2(...):\r\n    ...\r\n```\r\nEach of these functions can have a docstring that explains the relevant concepts from the algorithm and the thesis.\r\n\r\nIt would be good to construct explicit simple examples of each case by hand and carefully write manual tests that verify each step of the algorithm that the correct values are returned for `c` and that any statements from the thesis about the form of the solution are correct.', 'comment_created': datetime.datetime(2021, 6, 22, 13, 19, 50, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 656214608, 'comment_body': 'If this calculates `m` and `ybar` then I think that the name should be something like `compute_m_ybar`.', 'comment_created': datetime.datetime(2021, 6, 22, 13, 21, 16, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 656216160, 'comment_body': 'This can probably be written more clearly using something like `itertools.product`.', 'comment_created': datetime.datetime(2021, 6, 22, 13, 22, 56, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 656218791, 'comment_body': 'Why put the `oo` pole in `poles` only to remove it? I think it might be clearer to avoid treating `oo` as a pole in any part of the algorithm since it only confuses things. The explanation of the algorithm could avoid describing `oo` as a pole as well.', 'comment_created': datetime.datetime(2021, 6, 22, 13, 25, 45, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 656220295, 'comment_body': ""Maybe there should also be a function like `riccati_reduced` that puts the equation in the form `y' + y^2 = a(x)`."", 'comment_created': datetime.datetime(2021, 6, 22, 13, 27, 23, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 656221318, 'comment_body': 'Why is this checking `free_symbols`?', 'comment_created': datetime.datetime(2021, 6, 22, 13, 28, 24, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 657634755, 'comment_body': 'I actually need the multiplicity of `oo` when it is a pole since that is used in the `rational_laurent_series` function. Maybe can I just find the multiplicity inside that function.', 'comment_created': datetime.datetime(2021, 6, 24, 5, 24, 18, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 657636222, 'comment_body': 'If `a(x)` is a non-zero constant, then `sqrt(a)` and `-sqrt(a)` are solutions for the equation.', 'comment_created': datetime.datetime(2021, 6, 24, 5, 28, 14, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 657638251, 'comment_body': 'Right now, `single.py` contains the code to match the equation and get `b0, b1, b2`. Should I move this code to `riccati.py`?', 'comment_created': datetime.datetime(2021, 6, 24, 5, 33, 51, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 657638861, 'comment_body': '`syms` is a list of undetermined coefficient symbols, while `var` is `x`.', 'comment_created': datetime.datetime(2021, 6, 24, 5, 35, 27, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 657639480, 'comment_body': ""I've removed `oo` as pole."", 'comment_created': datetime.datetime(2021, 6, 24, 5, 37, 13, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 657826686, 'comment_body': ""Yes, let's make the code in `riccati.py` self-contained so that it can be used separately from `dsolve`."", 'comment_created': datetime.datetime(2021, 6, 24, 10, 29, 53, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 657827257, 'comment_body': ""I think that the var argument is just being ignored so it shouldn't be passed to `linsolve`."", 'comment_created': datetime.datetime(2021, 6, 24, 10, 30, 49, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 658117251, 'comment_body': 'Yes, it is being ignored. Removed it.', 'comment_created': datetime.datetime(2021, 6, 24, 16, 44, 55, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 658125480, 'comment_body': 'This problem has been solved now using `Poly`.', 'comment_created': datetime.datetime(2021, 6, 24, 16, 56, 51, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 659258745, 'comment_body': 'I think we can mention that floats are not allowed. Symbols will be allowed, but I have to test my theory of `x**m` being always valid. I have written about the fact that the algorithm will find all possible rational solutions. I will add some tests for ODEs for which there are no rational solutions.', 'comment_created': datetime.datetime(2021, 6, 27, 4, 10, 44, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 659302297, 'comment_body': 'If floats are disallowed then the code should disallow them and there should be tests for that. There should be some code that explicitly checks what is acceptable.', 'comment_created': datetime.datetime(2021, 6, 27, 10, 53, 57, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 659357879, 'comment_body': '> but I have to test my theory of x**m being always valid\r\n\r\nThis is not valid (as expected!). This means that symbolic coefficients are also not allowed.\r\n\r\n> If floats are disallowed then the code should disallow them and there should be tests for that. There should be some code that explicitly checks what is acceptable.\r\n\r\nI will add checks for this', 'comment_created': datetime.datetime(2021, 6, 27, 18, 16, 31, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 660676571, 'comment_body': 'It looks like `dsolve` converts floats to fractions. Maybe we can do the same here to keep things consistent and raise a warning saying that floats are being converted to fractions.\r\n``` python\r\nIn [1]: eq = f(x).diff(x) - 2/3 + x/3\r\n\r\nIn [2]: eq\r\nOut[2]: \r\nx   d\r\n─ + ──(f(x)) - 0.666666666666667\r\n3   dx\r\n\r\nIn [3]: dsolve(eq)\r\nOut[3]: \r\n             2\r\n            x    2⋅x\r\nf(x) = C₁ - ── + ───\r\n            6     3\r\n```', 'comment_created': datetime.datetime(2021, 6, 29, 14, 30, 3, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 660683519, 'comment_body': 'Well we can let `dsolve` do that. The routine here should just validate its inputs. No need to attempt conversion but we can make a nice error message for the user if necessary.', 'comment_created': datetime.datetime(2021, 6, 29, 14, 37, 3, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 664845651, 'comment_body': 'Please give full references (author names and document titles). A URL is also nice but we need a reference that can be used if the URL stops working.', 'comment_created': datetime.datetime(2021, 7, 6, 20, 8, 11, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 664845851, 'comment_body': 'Also since the algorithm is called ""Algorithm 11"" it would be good to state that.', 'comment_created': datetime.datetime(2021, 7, 6, 20, 8, 32, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 664846954, 'comment_body': 'A wikipedia reference for Ricatti ODE would also be nice:\r\nhttps://en.wikipedia.org/wiki/Riccati_equation', 'comment_created': datetime.datetime(2021, 7, 6, 20, 10, 34, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 664848090, 'comment_body': ""I don't think that we need 4 examples in the docstring. This example is good so just use this one. The others are all separable or Bernoulli so not good examples."", 'comment_created': datetime.datetime(2021, 7, 6, 20, 12, 40, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 664848628, 'comment_body': ""If `b_0 = 0` it's Bernoulli."", 'comment_created': datetime.datetime(2021, 7, 6, 20, 13, 37, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 664849858, 'comment_body': ""Other forms that reduce to this like `f'(x) - (f(x) + 1)**2`.\r\n\r\nWould those be matched?"", 'comment_created': datetime.datetime(2021, 7, 6, 20, 15, 48, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 664859628, 'comment_body': ""It would be better if the tests were not randomly generated functions like this. Randomised testing is very useful but there are two ways it should be used:\r\n\r\n1. The test suite can be random so every time you run the tests random inputs are generated.\r\n2. Use randomised testing during development/debugging in order to identify problem cases.\r\n\r\nThe advantage of type 1 is that each time the test suite different examples are being tested so if the test suite runs often then it might eventually pick up on very rare cases. This can be useful but it needs careful tuning with seeds etc so that any failures can be debugged after.\r\n\r\nI would say that what you are doing is case 2. here. In that case the basic way to write tests is like this:\r\n\r\n1. (before writing any code!) Think up some careful examples of simple base cases and corner cases and add those to the tests.\r\n2. Manually work through some reasonably simple examples of generic cases that cover all the possible outcomes of the algorithm/routine and add those.\r\n3. Write the actual code\r\n4. Run tests and measure coverage - if any lines are not covered then think carefully about test cases that should hit them and what the answer should be. Add those tests.\r\n5. If you think that the code is correct and it seems to have full test coverage use randomised testing to identify potential bugs. Once you have identified a bug *manually* come up with a simple test case for it and add that to the tests.\r\n\r\nNote that we don't use the randomised testing until the last step. Sometimes it could be used in step 4 if you are unable to come up with an example to get complete coverage. The same principle applies though that you are trying to identify the case so that you can use that to make a simple example.\r\n\r\nImportantly as much as possible the tests that are written down should be hand-written. When the test suite is made up of randomly generated tests then it becomes very hard for a *human* to understand what is being tested.\r\n\r\nIn this particular test function the underlying functions being tested are very simple so they really don't need to be tested with many generic examples. I would probably test this with one fairly generic case and then any extra tests that are needed for corner cases like one of the functions being zero or anything that should raise an error.\r\n\r\nIf you look carefully at the way this function tests `ricatti_normal` you can see that although many examples are being tested not one of them tests the output of `ricatti_normal` directly."", 'comment_created': datetime.datetime(2021, 7, 6, 20, 33, 1, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 665477796, 'comment_body': ""I think its a little ambiguous because Bernoulli can refer to equations of the form `y' + P*y = Q` or the more general form `y' + P*y = Q*y^n`. Maybe its just better to avoid mentioning this here."", 'comment_created': datetime.datetime(2021, 7, 7, 15, 24, 15, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 665478713, 'comment_body': 'Yes, since I am always expanding the equation first and collecting the coefficients based on `f(x)`.', 'comment_created': datetime.datetime(2021, 7, 7, 15, 25, 20, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 665480949, 'comment_body': 'Okay, I will add some manually verified examples which are not complex like the ones present here.', 'comment_created': datetime.datetime(2021, 7, 7, 15, 27, 39, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 665595700, 'comment_body': ""I think it's worth saying something here. There are two relevant points:\r\n\r\n1. If either `b_0` or `b_2` is zero then the equation comes under a simpler class (Bernoulli or linear respectively) that can be solved more directly.\r\n2. The algorithm here can find any rational solution for any equation of this form provided `b_2 != 0`."", 'comment_created': datetime.datetime(2021, 7, 7, 18, 1, 45, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 665618903, 'comment_body': ""It's better to explain it here rather than link to a comment on github"", 'comment_created': datetime.datetime(2021, 7, 7, 18, 38, 9, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 665623812, 'comment_body': ""I don't really understand why IndexedBase is being used here. It seems like a complicated way to get from the denominator to the recursion relation. Is the recursion relation not just a linear equation having the same coefficients as the denominator polynomial?"", 'comment_created': datetime.datetime(2021, 7, 7, 18, 45, 48, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 666427025, 'comment_body': ""Yes, but I am using `IndexedBase` because it is easy to represent the recurrence relation and it allows symbolic indexing. In one of the commits above, I tried removing it and adding an approach without IndexedBase, but it is hard to construct the coefficients since I have to store them in a list and it doesn't have symbolic indexing."", 'comment_created': datetime.datetime(2021, 7, 8, 18, 27, 21, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 666427550, 'comment_body': ""Sure. I thought it might be too long, but I'll add it in a docstring."", 'comment_created': datetime.datetime(2021, 7, 8, 18, 28, 8, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 667045000, 'comment_body': 'I don\'t see why symbolic indexing is needed:\r\n```python\r\nfrom sympy.polys.polytools import parallel_poly_from_expr\r\n\r\n\r\ndef ratfunc_series_at_pole(f, x, r, m, n):\r\n    """"""Series of f(x) around pole r of order m up to nth term""""""\r\n\r\n    # Shift so we can compute series around x=0\r\n    fr = f.subs(x, r + x) * x**m\r\n    num, den = fr.as_numer_denom()\r\n    (num, den), opt = parallel_poly_from_expr((num, den), x)\r\n\r\n    # Equate coefficients for the first terms:\r\n    maxdegree = 1 + max(num.degree(), den.degree())\r\n    syms = symbols(f\'a:{maxdegree}\', cls=Dummy)\r\n    diff = num - den * Poly(syms[::-1], x)\r\n    coeff_diffs = diff.all_coeffs()[::-1][:maxdegree]\r\n    (coeffs,) = linsolve(coeff_diffs, syms)\r\n\r\n    # Use the recursion relation for the rest:\r\n    recursion = den.all_coeffs()[::-1]\r\n    div, rec_rhs = recursion[0], recursion[1:]\r\n    series = list(coeffs)\r\n    while len(series) < n:\r\n        next_coeff = sum(c*series[-1-n] for n, c in enumerate(rec_rhs)) / div\r\n        series.append(-next_coeff)\r\n\r\n    return series[:n]\r\n\r\n\r\ndef series_at_pole(f, x, r, m, n):\r\n    fr = f.subs(x, r + x) * x**m\r\n    return Poly(fr.series(x, n=n).removeO(), x).all_coeffs()[::-1]\r\n\r\n\r\nf = (1 + 2*x + 3*x**2) / ((x - 1)*(x - 2)*(x - 3)**2)\r\nn = 13\r\nfor r, m in roots(denom(f)).items():\r\n    series1 = ratfunc_series_at_pole(f, x, r, m, n)\r\n    series2 = series_at_pole(f, x, r, m, n)\r\n    assert series1 == series2\r\n```', 'comment_created': datetime.datetime(2021, 7, 9, 15, 43, 14, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667498014, 'comment_body': ""This doesn't just find rational solutions since e.g. `rational_riccati_15` has exponential functions."", 'comment_created': datetime.datetime(2021, 7, 11, 15, 29, 53, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667498067, 'comment_body': 'This reference seems out of place here. Maybe it belongs somewhere else.', 'comment_created': datetime.datetime(2021, 7, 11, 15, 30, 29, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667498198, 'comment_body': 'Is the `Ricatti_special_minus` solver still needed?', 'comment_created': datetime.datetime(2021, 7, 11, 15, 31, 27, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667498293, 'comment_body': 'Is this module included in the rst docs anywhere?', 'comment_created': datetime.datetime(2021, 7, 11, 15, 32, 19, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667498997, 'comment_body': ""You subsequently found that this was incorrect didn't you?"", 'comment_created': datetime.datetime(2021, 7, 11, 15, 37, 53, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667499074, 'comment_body': 'Combine steps 8 and 9. It would be good to explain what `m` and `ybar` are e.g. `m` is the bound on the degree of ...', 'comment_created': datetime.datetime(2021, 7, 11, 15, 38, 37, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667499281, 'comment_body': 'I think maybe referring to ""sol"" and ""presol"" is just confusing. Maybe just say transform the solutions for the normal form ODE to find solutions for the original Riccati ODE.', 'comment_created': datetime.datetime(2021, 7, 11, 15, 40, 34, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667499473, 'comment_body': 'There should generally be two blank lines between top-level functions/classes etc.', 'comment_created': datetime.datetime(2021, 7, 11, 15, 41, 54, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667499641, 'comment_body': 'This should at least have a one-line docstring explaining what the function does and making it clear what each argument represents and what is returned.', 'comment_created': datetime.datetime(2021, 7, 11, 15, 43, 18, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667499663, 'comment_body': 'Same for other functions', 'comment_created': datetime.datetime(2021, 7, 11, 15, 43, 29, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667499983, 'comment_body': ""Why does this test for `Add`? That seems potentially fragile.\r\n\r\nIf it's just so you can use `eq.args` below then maybe use `Add.make_args` instead."", 'comment_created': datetime.datetime(2021, 7, 11, 15, 46, 7, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667500102, 'comment_body': 'The map/lambda combination is generally easier to read as a comprehension e.g.:\r\n```python\r\nAdd(*(cancel(x/cf) for x in eq.args))\r\n```', 'comment_created': datetime.datetime(2021, 7, 11, 15, 47, 9, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667500126, 'comment_body': 'Yes. Maybe I can say that it finds general solutions for all Riccati equations that have atleast 1 particular rational solution?', 'comment_created': datetime.datetime(2021, 7, 11, 15, 47, 28, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 667500239, 'comment_body': 'Should I put it in `test_riccati.py`?', 'comment_created': datetime.datetime(2021, 7, 11, 15, 47, 54, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 667500325, 'comment_body': 'Do we need to cancel for each term? Can we not just do `cancel(eq/cf).expand().collect(f(x))`', 'comment_created': datetime.datetime(2021, 7, 11, 15, 48, 31, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667500341, 'comment_body': ""Yes, the `1st_rational_riccati` solver doesn't work for symbolic coefficients"", 'comment_created': datetime.datetime(2021, 7, 11, 15, 48, 41, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 667500457, 'comment_body': ""No. Could you please tell me where I need to add it? I'm not familiar with rst docs that much."", 'comment_created': datetime.datetime(2021, 7, 11, 15, 49, 17, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 667500477, 'comment_body': 'Maybe it would be better to use `Wild` and `match` here.', 'comment_created': datetime.datetime(2021, 7, 11, 15, 49, 28, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667500480, 'comment_body': ""Oh yes, I'll remove this."", 'comment_created': datetime.datetime(2021, 7, 11, 15, 49, 29, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 667500586, 'comment_body': ""Maybe this function isn't necessary"", 'comment_created': datetime.datetime(2021, 7, 11, 15, 50, 17, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667500927, 'comment_body': 'This is really about transforming a rational function although it is represented as a numerator denominator pair. Somewhere in this module either in the docstring or comments it should be explained that the algorithm here is primarily implemented using Poly and that rational functions are represented as a numerator denominator pair.', 'comment_created': datetime.datetime(2021, 7, 11, 15, 52, 44, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667501296, 'comment_body': 'I followed the step numbers from the thesis. Should I keep them the same or merge these steps?', 'comment_created': datetime.datetime(2021, 7, 11, 15, 55, 16, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 667501552, 'comment_body': ""I don't think that this much explanation is needed."", 'comment_created': datetime.datetime(2021, 7, 11, 15, 57, 25, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667502122, 'comment_body': ""I don't think that the first cancel call is needed given that cancel will be called again after."", 'comment_created': datetime.datetime(2021, 7, 11, 16, 1, 57, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667502307, 'comment_body': '`eq` must be `Add` since it would have atleast 2 terms (`f(x).diff(x)` and `b2*y**2`).', 'comment_created': datetime.datetime(2021, 7, 11, 16, 3, 48, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 667502521, 'comment_body': 'I thought it might be better to avoid `Wild` since matching can be done without it.', 'comment_created': datetime.datetime(2021, 7, 11, 16, 6, 12, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 667502613, 'comment_body': 'If `px` is a much larger polynomial than the others then it will be more efficient to compute this as\r\n```python\r\nauxeq += px*(2*numy*deny*dena)\r\n```\r\nIn other words do most multiplication with small polynomials and only one multiplication with the large polynomial.', 'comment_created': datetime.datetime(2021, 7, 11, 16, 6, 53, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667502699, 'comment_body': 'Yes, I will mention it on the top where I explain the algorithm.', 'comment_created': datetime.datetime(2021, 7, 11, 16, 7, 15, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 667502737, 'comment_body': 'Okay, should I remove the example?', 'comment_created': datetime.datetime(2021, 7, 11, 16, 7, 38, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 667503420, 'comment_body': ""A `Poly` can be constructed directly from a list of coefficients:\r\n```python\r\nIn [9]: syms = symbols('x:3')\r\n\r\nIn [10]: Poly(syms, z, domain=ZZ[syms])\r\nOut[10]: Poly(x0*z**2 + x1*z + x2, z, domain='ZZ[x0,x1,x2]')\r\n\r\nIn [11]: Poly(syms[::-1], z, domain=ZZ[syms])\r\nOut[11]: Poly(x2*z**2 + x1*z + x0, z, domain='ZZ[x0,x1,x2]')\r\n```"", 'comment_created': datetime.datetime(2021, 7, 11, 16, 12, 21, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667503474, 'comment_body': 'Depending on the value of `m`, `px` may be large enough. I will change it.', 'comment_created': datetime.datetime(2021, 7, 11, 16, 13, 2, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 667503604, 'comment_body': ""If you're going to call `doit` it would be better to compute the integral once first. Does this call integrate twice?"", 'comment_created': datetime.datetime(2021, 7, 11, 16, 14, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667503726, 'comment_body': 'Maybe explain that the substitution `y = y1 + 1/z` leads to a Bernoulli ODE for z.', 'comment_created': datetime.datetime(2021, 7, 11, 16, 15, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667503814, 'comment_body': 'Perhaps mention that this seems to be the most common case in practice.', 'comment_created': datetime.datetime(2021, 7, 11, 16, 15, 39, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667504059, 'comment_body': ""I will compute the `exp(Integral(2*y1, x))` only once and use it again. I'm sorry, I didn't get what you are trying to ask about integrate."", 'comment_created': datetime.datetime(2021, 7, 11, 16, 17, 49, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 667504116, 'comment_body': ""I don't see how the sorting helps here if there is no early exit from this loop."", 'comment_created': datetime.datetime(2021, 7, 11, 16, 18, 25, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667504455, 'comment_body': 'There should be some kind of comment here explaining what this is', 'comment_created': datetime.datetime(2021, 7, 11, 16, 21, 4, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667504879, 'comment_body': ""Do we need so many examples for testing these functions? What exactly do the different examples represent?\r\n\r\nThese functions seem to be relatively straight-forward so I don't see why 8 test cases are needed. A more relevant test would be one that involved the bp parameter for example which doesn't seem to be tested here."", 'comment_created': datetime.datetime(2021, 7, 11, 16, 24, 34, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667505284, 'comment_body': ""Again why so many examples? What are they testing?\r\n\r\nAre there any examples testing the `return False` line of the function?\r\n\r\nWhen testing it's more important to cover corner cases and all particular lexical or logical branches of a function than it is to have lots of repetitive examples testing common usage."", 'comment_created': datetime.datetime(2021, 7, 11, 16, 27, 53, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667505481, 'comment_body': 'As far as I remember, using `cancel` and expanding was failing for one ODE.', 'comment_created': datetime.datetime(2021, 7, 11, 16, 29, 43, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 667505590, 'comment_body': ""Again I don't see why so many examples are needed. This function is basically trivial. It would be more useful to test base cases like what happens if the numerator is zero or do we even care about that case?"", 'comment_created': datetime.datetime(2021, 7, 11, 16, 30, 28, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667506007, 'comment_body': ""Do these examples need to be so long? Why not an example that is short enough that you can easily see that it is correct?\r\n\r\nThere is nothing wrong with using randomised testing but we don't want to explicitly include large, complicated randomly generated examples in the tests unless they represent some particular corner case that can not be reproduced with a simpler example."", 'comment_created': datetime.datetime(2021, 7, 11, 16, 33, 29, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667506727, 'comment_body': 'Are the examples from that reference actually used anywhere in this PR?', 'comment_created': datetime.datetime(2021, 7, 11, 16, 40, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667506823, 'comment_body': 'That needs to be explained in comments/docstrings etc. If the coefficients need to be rational then that needs to be checked for.', 'comment_created': datetime.datetime(2021, 7, 11, 16, 40, 45, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667506978, 'comment_body': ""Take a look in `docs/src/modules/solvers/ode.rst`. That's the source code for this page:\r\nhttps://docs.sympy.org/latest/modules/solvers/ode.html"", 'comment_created': datetime.datetime(2021, 7, 11, 16, 41, 53, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667507134, 'comment_body': 'Okay keep them separate. There should be an explanation here of what these are though.', 'comment_created': datetime.datetime(2021, 7, 11, 16, 43, 8, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667507652, 'comment_body': ""I'll remove this test case and make others simpler."", 'comment_created': datetime.datetime(2021, 7, 11, 16, 48, 4, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 667508099, 'comment_body': ""I'll remove some examples. The numerator being zero would mean `a(x)` is 0, and the solution is trivial for this case. So, that wouldn't be of interest here."", 'comment_created': datetime.datetime(2021, 7, 11, 16, 51, 40, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 667508656, 'comment_body': 'The `bp` parameter is used when multiple solutions for the same equation are transformed back in the last step of the algorithm. It is useful only when 2 or more test cases have the same `b1` and `b2`.', 'comment_created': datetime.datetime(2021, 7, 11, 16, 56, 18, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 667508994, 'comment_body': 'Yes, but there should be a test that the bp parameter works correctly. If the function has two possible modes of operation then there needs to be a test for each rather than 10 tests for one and none for the other.', 'comment_created': datetime.datetime(2021, 7, 11, 17, 0, 16, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 667509394, 'comment_body': ""I've removed some examples, and instead added some that test the `return False` line."", 'comment_created': datetime.datetime(2021, 7, 11, 17, 3, 37, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 667513425, 'comment_body': ""I want to construct a polynomial of the form `C_0 + C_1*x + C_2*x**2 + ... + C_{m-1}*x**(m - 1) + x**m`, but the below code gives a generator error. It works if I don't specify the domain, but is there a way to specify the domain and make it work, since it takes time to construct the domain of `Poly`?\r\n``` python\r\npsyms = symbols(f'C0:{m}', cls=Dummy) + ('1', )\r\npsol = Poly(psyms[::-1], x, ZZ[psyms])\r\n```"", 'comment_created': datetime.datetime(2021, 7, 11, 17, 38, 57, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 667514567, 'comment_body': 'Why are you appending the string `1` to the symbols tuple?\r\n\r\nAlso domain needs to be given as a keyword argument.', 'comment_created': datetime.datetime(2021, 7, 11, 17, 49, 27, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 668054519, 'comment_body': 'Mentioning the kwarg removed the error. The error was saying something about a generator having only string, symbol, etc, so I made it a string. Infact, 1 is not even required to be mentioned since it would already be part of `ZZ`.', 'comment_created': datetime.datetime(2021, 7, 12, 15, 54, 33, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 668062303, 'comment_body': 'Yes, in the tests for general solutions.', 'comment_created': datetime.datetime(2021, 7, 12, 16, 3, 57, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 668063150, 'comment_body': 'I will mention it in the docstring. We are already checking if the functions are rational, so I think that would cover it.', 'comment_created': datetime.datetime(2021, 7, 12, 16, 4, 59, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 668070778, 'comment_body': 'I was just thinking of adding an early exit, but it might happen that we exit if there are 3 solutions in `presol`, but it might happen that 2 of them are redundant, so instead of spending some more time in computing the particular solutions, the code will end up computing the general solution from a single particular solution which might be a lot slower. What do you think should be done? ', 'comment_created': datetime.datetime(2021, 7, 12, 16, 14, 50, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 668073485, 'comment_body': ""I don't see anything that checks the coefficients of the rational functions. Note that `is_rational_function` does not do that:\r\n```python\r\nIn [4]: a = z*x**2 + pi*exp(1) - 3.1\r\n\r\nIn [5]: a\r\nOut[5]: \r\n 2              \r\nx ⋅z - 3.1 + ℯ⋅π\r\n\r\nIn [6]: a.is_rational_function(x)\r\nOut[6]: True\r\n```"", 'comment_created': datetime.datetime(2021, 7, 12, 16, 18, 20, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 668262808, 'comment_body': ""This docstring doesn't say what the function actually returns or specify what the parameters are.\r\n\r\nIt could be something like:\r\n```\r\nReduce a Riccati ODE given by b1 and b2 to normal form given by a.\r\n\r\nA general Riccati ODE has the form\r\n\r\n.. math:: w'(x) = ...\r\n\r\nThe substitution $w(x) = ...$ leads to a normal form Riccati ODE\r\n\r\n.. math: y'(x) + y(x)^2 = a(x)\r\n\r\nGiven b1 and b2 this function returns a for the normal form ODE. A solution `y1`\r\ncan be transformed to a solution of the original ODE with\r\n\r\n.. math: y1(x) = w1(x)...\r\n```"", 'comment_created': datetime.datetime(2021, 7, 12, 21, 17, 3, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 668868079, 'comment_body': 'Actually, this function does not return the normal form of the Riccati ODE. It applies the transformation on the solution for the Riccati equation which gives the solution to the corresponding normal Riccati ODE.', 'comment_created': datetime.datetime(2021, 7, 13, 15, 19, 31, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 669136551, 'comment_body': 'Oh I see. Well the docstring should still explain what the parameters and return value of the function are.', 'comment_created': datetime.datetime(2021, 7, 13, 21, 55, 7, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 669137006, 'comment_body': ""I get the impression that the early exit is not usually beneficial since we don't usually get 3 rational particular solutions. If that's the case then I don't think we need to pursue this."", 'comment_created': datetime.datetime(2021, 7, 13, 21, 56, 7, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 669137257, 'comment_body': 'There should be some comments in the code explaining that an early exit is at least theoretically possible.', 'comment_created': datetime.datetime(2021, 7, 13, 21, 56, 36, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 669137689, 'comment_body': 'Yes, there just needs to be some explanation here about what this function is, what its parameters are and what it returns.', 'comment_created': datetime.datetime(2021, 7, 13, 21, 57, 22, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 669138322, 'comment_body': 'Is there an advantage in not using match?', 'comment_created': datetime.datetime(2021, 7, 13, 21, 58, 45, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 669803702, 'comment_body': ""I'll put it in `test_riccati.py`"", 'comment_created': datetime.datetime(2021, 7, 14, 17, 13, 6, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 669805899, 'comment_body': ""I remember reading somewhere that `match` doesn't work in some cases, so I didn't include it. Should I just use `match`?"", 'comment_created': datetime.datetime(2021, 7, 14, 17, 16, 27, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 669839229, 'comment_body': 'I added some functions to the rst docs. Let me know if I should remove/add any functions.', 'comment_created': datetime.datetime(2021, 7, 14, 18, 5, 22, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 671713935, 'comment_body': 'This seesm incomplete', 'comment_created': datetime.datetime(2021, 7, 17, 16, 1, 47, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 671714022, 'comment_body': ""This shouldn't compute `b0 + b1 + b2` because some terms might cancel."", 'comment_created': datetime.datetime(2021, 7, 17, 16, 2, 27, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 671714512, 'comment_body': 'Presumably both of these cases give the same results. Does the full calculation run for both or are duplicates checked later?', 'comment_created': datetime.datetime(2021, 7, 17, 16, 7, 22, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 671714648, 'comment_body': 'Spacing around operators is inconsistent. Probably for subscript indices like most of these I would just not use spaces. Consistency is the main thing though.', 'comment_created': datetime.datetime(2021, 7, 17, 16, 8, 34, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 671714960, 'comment_body': 'Is this computing with Expr rather than Poly? For Expr it is more efficient to use `Add(*terms)` rather than `sum(terms)`.', 'comment_created': datetime.datetime(2021, 7, 17, 16, 11, 26, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 671716320, 'comment_body': ""This can be quite slow for a large number of generators:\r\n```python\r\nIn [63]: psyms = symbols('C:1000')\r\n\r\nIn [64]: K = ZZ[psyms]\r\n\r\nIn [65]: %time p1 = Poly(psyms, t, domain=K)\r\nCPU times: user 530 ms, sys: 27.7 ms, total: 557 ms\r\nWall time: 562 ms\r\n\r\nIn [66]: %time p2 = Poly(K.gens, t, domain=K)\r\nCPU times: user 39.4 ms, sys: 295 µs, total: 39.7 ms\r\nWall time: 40.2 ms\r\n\r\nIn [67]: p1 == p2\r\nOut[67]: True\r\n```"", 'comment_created': datetime.datetime(2021, 7, 17, 16, 24, 39, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 671717508, 'comment_body': ""Rather than linking to a comment it is better to explain why this case is significant compared to the other test examples (the linked comment doesn't offer any further explanation).\r\n\r\nIn general in this PR I find it hard to understand what the significance of any of the test cases is. They all just look like random examples to me which makes me think:\r\n\r\n1. Do we need this many? If almost all of them are basically just testing the same thing then it would be better to have fewer tests.\r\n2. Are there reasons why you added all of these particular examples?\r\n3. If there are reasons for each of these then it would be good to have comments that explain what the examples are or to categorise them somehow."", 'comment_created': datetime.datetime(2021, 7, 17, 16, 36, 32, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 671996745, 'comment_body': 'Some of the tests are from a paper written by the same author which had examples from various sources. 2 or 3 of them are from books that Nijso suggested and the last few of them are the ones that were failing previously because of the bug. Maybe I could remove some of the previously failing examples since they are testing the same case.', 'comment_created': datetime.datetime(2021, 7, 19, 5, 29, 53, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 672022668, 'comment_body': 'The entire calculation is running as of now. I will add a check to skip it.', 'comment_created': datetime.datetime(2021, 7, 19, 6, 36, 47, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 672135607, 'comment_body': 'Maybe this could just return `[[1]]`.', 'comment_created': datetime.datetime(2021, 7, 19, 9, 23, 34, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 672136380, 'comment_body': 'The main thing is to add some comments explaining what these are testing.', 'comment_created': datetime.datetime(2021, 7, 19, 9, 24, 42, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 672193274, 'comment_body': 'I am generating a choice variable which picks either the first or the second part. Returning only one element would be inconsistent with other elements in the vector and also cause an index error, so a check has to be added anyway. I think it would be better to add a check so that if the numbers are equal anywhere else, they would also be avoided.', 'comment_created': datetime.datetime(2021, 7, 19, 10, 51, 20, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 672220240, 'comment_body': ""It's better to avoid creating duplicates at the start. You can use product like:\r\n```python\r\nIn [7]: from itertools import product\r\n\r\nIn [8]: c = [[[1, 2], [3, 4]], [[1]]]\r\n\r\nIn [9]: list(product(*c))\r\nOut[9]: [([1, 2], [1]), ([3, 4], [1])]\r\n```"", 'comment_created': datetime.datetime(2021, 7, 19, 11, 36, 54, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}]","[{'commit_sha': '498244acda583260d1db5a58c7e055fb8789eca4', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '382ea94adcef2474e7578701fb248e7a25300766', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '6c4cef622fc417434053630e08ba584765c278f5', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '99afeab4062efd8a0d5e6b5d1da644990b3b6220', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '24339d127e61ab53445c3548e3378da11d1fba10', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '6536d82f7d57278bd09f3643f8f6545a1dd3892a', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'fd640854347ad7335cb02ca02aad5666b063765a', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'e709fac1bd53f827f9ffbc4e050da2868d3bb153', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'e57b749f7578d3cc93700694025a02992f935ecf', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '297fb65616f1a782c134868a36e5faba560b0062', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'a10c95c6867162e627342b451f1a2132f0fd92cc', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '26f0fe1f5a7c7411b28e671ffd8d17bbf008fca3', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '49a54d825032fd1d7e538d7820bb2ef84ed0a62c', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '308f19db30a833f9160ac27986cb76766fb0228d', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'e51cce84428c93c035e06829ba7f01374acea61c', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'e6ad73fed675d805f8c468ce64bf8334d1d9fd2b', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '627890f379c8a0ce51a6bb0dfd701f3e919879c1', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '792eaf7dfb2eb78b2bddd3247b9ba263945b6729', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '1c136120e4e6c3df2c0fb27ea118e944701b1390', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '25b346c0b3a1a1a19c310c77a183d36495ca1980', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '02b575ac37426e5fe453555f93210db3d00402dd', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '5eb7b6c5d7a56a45e8cfd24a4a0a4ef5935ab60c', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'c5759f8a2be285d80eb6356e79940ff3f25a3340', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '3426ae85d7fca4555fa79de2fc98317d1b970302', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '3cf4dd58c75733f25db245155badb83198c48aba', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '6f81671affc1eb0b1f9d53d62ace4959b1036c89', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '0c86feeaa96bfa1f3cf91a373639ce1049e59879', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'e4e6ac61ca64e6c291c0c9b1e3af8bc7e86402dd', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '0fc750a356bf3614ef1acb797e20054b2959469a', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '8f0aed37280b6433def82e0ceba55c44ee327043', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '1bf1f7098102219540c7f8288f2cbdef9fc980db', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'caa2f4a59851e12786de869c54baa8228a5967f6', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'db0343ab8e3135af49a7205f81a700ce5d75ad4e', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '28902a08c0660ca053ee57d1935cfa843ef1b338', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'b11958fc189b0900ea5267f07a7870d5ab77eabd', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '0b826629227193a3ce3ea54d0efdecf26a1eca6b', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'eb5cff245a91c2baa0d6875b4a501985758a46aa', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'c2d3a7f82758de6ff1ef488c7bedfb17904a6828', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ff9e4dd1a37c1e9010cbe710f36a84b0fd2ff388', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '30961629d5b863cd690800a7cddf5e6164038f8c', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'b74008ab706238dede78b5cef12060aa65371820', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}]",Naveen Sai,56525288,,User,,39,,43,55
576429987,feat(core): Added dsubs function,"I have added a function `dsubs` to `Basic` which facilitates substitution of variables in ordinary differential equations.

#### References to other Issues or PRs
Fixes #17590

#### Brief description of what is fixed or changed

#### Other comments

#### Release Notes
<!-- BEGIN RELEASE NOTES -->
* core
  * Added a new function for substitutions in differential equations.
<!-- END RELEASE NOTES -->",False,20979,https://api.github.com/repos/sympy/sympy/pulls/20979,https://github.com/sympy/sympy/pull/20979,open,297,9,5,20,47,88,3,0,"[{'name': 'core'}, {'name': 'solvers.dsolve'}, {'name': 'Merge conflict'}]",2021-02-19 12:38:33+00:00,,0.0,,"[{'comment_id': 581093125, 'comment_body': ""This doesn't really make any sense to me. An ODE can only have one independent variable."", 'comment_created': datetime.datetime(2021, 2, 23, 14, 42, 15, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 581251000, 'comment_body': 'I think maybe there can be a better way to define the signature so that mapdict is not needed.', 'comment_created': datetime.datetime(2021, 2, 23, 17, 44, 20, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 581251336, 'comment_body': 'Long examples like this should be wrapped.', 'comment_created': datetime.datetime(2021, 2, 23, 17, 44, 50, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 583334014, 'comment_body': 'Its like a sum of different ODEs. The substitution must be possible in such cases as well. This works even in `dchange`.', 'comment_created': datetime.datetime(2021, 2, 26, 2, 6, 11, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 583334276, 'comment_body': ""I couldn't find a way to do it. How do you think it should be done?"", 'comment_created': datetime.datetime(2021, 2, 26, 2, 7, 2, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 583506488, 'comment_body': 'How does maple resolve this?', 'comment_created': datetime.datetime(2021, 2, 26, 9, 37, 19, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 584328529, 'comment_body': 'Maple has a parameter `params` which is a list of symbols present in the transformation rules that have to be treated as constants and not variables. Should I modify the API and include this instead of `mapdict`? Just as an example -\r\n``` python\r\n>>> ode = diff(f(x), x, x) + cos(x)\r\n>>> ode.dsubs({x: a*t}, params=[a])\r\nf(t).diff(t, 2)/a**2 + f(t)\r\n```', 'comment_created': datetime.datetime(2021, 2, 28, 17, 23, 20, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 584338117, 'comment_body': 'I think we should require the user to be explicit about what are the dependent and independent variables for the transformation. Maybe something like this:\r\n```python\r\ndsubs(eq, {f(x)}, {g(t)}, {x: a*t, f(x): g(t)})\r\n```\r\nHere we know that `t` is the new independent variable because it is listed as such in the second argument. Any function not listed could just have the independent variable change if appropriate so e.g. `h(x)` would just become `h(a*t)`.\r\n\r\nA transformation of only the dependent variable could be like:\r\n```python\r\ndsubs(eq, {x(t)}, {y(t)}, {x(t): exp(-t)*y(t)})\r\n```\r\n\r\nThen if we have a PDE it can be:\r\n```python\r\ndsubs(eq, {f(x,y)}, {g(xi,eta)}, {x: xi + eta, y: xi - eta, f(x,y): g(xi,eta)})\r\n```\r\nMaple\'s idea of a unknown function could correspond fo giving `f(x):f(t)` (use the same function `f` but change the independent variable).\r\n\r\nA system of ODEs could transform like e.g.:\r\n```python\r\ntransformation = {t: exp(tau), x(t): a(tau) + b(tau), y(t): a(tau) - b(tau)}\r\ndsubs(eqs, {x(t), y(t)}, {a(tau), b(tau)}, transformation)\r\n```\r\nSo the syntax is:\r\n```python\r\ndsubs(expressions, old_dependent_vars, new_dependent_vars, transformation_equations)\r\n```\r\n\r\nI\'m just trying to think if it would ever make sense to use `dsubs` in a situation where there are no ""dependent variables""...', 'comment_created': datetime.datetime(2021, 2, 28, 18, 29, 39, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 584339385, 'comment_body': ""I suppose it would still be useful if there was a function that sympy just didn't know how to differentiate like:\r\n```python\r\nIn [7]: Derivative(zeta(2*t), t).subs(t, z/2)\r\nOut[7]: \r\n⎛d         ⎞│   \r\n⎜──(ζ(2⋅t))⎟│  z\r\n⎝dt        ⎠│t=─\r\n               2\r\n```\r\n"", 'comment_created': datetime.datetime(2021, 2, 28, 18, 36, 22, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 584340031, 'comment_body': 'So maybe the signature could be:\r\n```python\r\ndsubs(expressions, old, new, transformation)\r\n```\r\nwhere old and new give both the dependent and independent variables.\r\n\r\nFor example:\r\n```python\r\ndsubs(eq, {f(x), x}, {g(t), t}, {x: exp(t), f(x): g(t)})\r\n```', 'comment_created': datetime.datetime(2021, 2, 28, 18, 40, 50, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 584342186, 'comment_body': ""I suppose that if we were going to make any of the arguments optional it would be `old` and `new` so we could put those last like:\r\n```python\r\ndsubs(expressions, transformation, old=None, new=None)\r\n```\r\nThen these could be equivalent:\r\n```python\r\ndsubs(eq, {x: exp(t), f(x): g(t)})\r\ndsubs(eq, {x: exp(t), f(x): g(t)}, {f(x), x}, {g(t), t})\r\n```\r\nSince there are no other symbols or functions in the transformation equations it would be unambiguous in some cases.\r\n\r\nActually perhaps `old` isn't needed if everything in `old` is always required to be on the lhs in the dict. But then I'm not sure if we would want to allow the transformation equations to be given in a non-explicit form later..."", 'comment_created': datetime.datetime(2021, 2, 28, 18, 53, 25, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 584408433, 'comment_body': ""If we have any of `old`/`new` the other set can be easily obtained, so I don't think both are required. If both of them are given, we would have to again verify that they indeed match. I feel like the Maple syntax has lesser user input and is easier. The syntax you proposed would make the user specify a lot of things which ideally can be computed."", 'comment_created': datetime.datetime(2021, 3, 1, 2, 19, 51, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 588327787, 'comment_body': ""I've changed the function signature to make it Maple like. Please review @oscarbenjamin "", 'comment_created': datetime.datetime(2021, 3, 5, 14, 18, 24, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 588502926, 'comment_body': ""I didn't realise this was a method on Basic. I don't think this should be a Basic method. It should be a function."", 'comment_created': datetime.datetime(2021, 3, 5, 17, 30, 32, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 588514143, 'comment_body': ""I think that the user should explicitly specify that they want `f(x)` to become `f(t)`. It's not really a valid transformation since the second `f` is really not the same function as the first one."", 'comment_created': datetime.datetime(2021, 3, 5, 17, 41, 51, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 588515342, 'comment_body': '> The syntax you proposed would make the user specify a lot of things which ideally can be computed.\r\n\r\nYes, but they are things that the caller of this function would already have so computing them is inefficient.\r\n\r\n> I feel like the Maple syntax has lesser user input and is easier.\r\n\r\nThe maple syntax is nice for simple cases but not very good for more complex cases. It\'s also not easy to explain or understand. The difference between ""known"" and ""unknown"" functions doesn\'t make much sense to me (perhaps there is a better name to describe it).', 'comment_created': datetime.datetime(2021, 3, 5, 17, 42, 59, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 588893593, 'comment_body': ""> I didn't realise this was a method on Basic. I don't think this should be a Basic method. It should be a function.\r\n\r\nI'll make it a function in the next commit.\r\n\r\n> I think that the user should explicitly specify that they want `f(x)` to become `f(t)`. It's not really a valid transformation since the second `f` is really not the same function as the first one.\r\n\r\nYes, this is the reason why the `known` and `unknown` options exist. By default, all `UndefinedFunction` functions are considered `unknown` which is the reason this happens. This can be changed by adding `f(x)` to the list of known functions."", 'comment_created': datetime.datetime(2021, 3, 6, 15, 17, 22, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 588894075, 'comment_body': '> The difference between ""known"" and ""unknown"" functions doesn\'t make much sense to me.\r\n\r\nThese examples will be helpful to understand `known` and `unknown` functions -\r\nhttps://github.com/sympy/sympy/blob/f74e2eb22db6a69002b1cda2040e82166ec48032/sympy/core/basic.py#L1128-L1138\r\n\r\n> Perhaps there is a better name to describe it.\r\n\r\nYes, we could rename them, but I couldn\'t think of a suitable name.', 'comment_created': datetime.datetime(2021, 3, 6, 15, 21, 3, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 588895224, 'comment_body': '> Yes, this is the reason why the `known` and `unknown` options exist. By default, all `UndefinedFunction` functions are considered `unknown` which is the reason this happens. This can be changed by adding `f(x)` to the list of known functions.\r\n\r\nI think this distinction between known and unknown functions is a bit odd and we can come up with something better.\r\n\r\nThe reason for the distinction is that sometimes the function `f` is considered to be a ""function"" and sometimes a ""variable"". In a Physics problem I might have an equation like\r\n```\r\nd T(t)/dt = k\r\n```\r\nwhere the function `T` represents a physical quantity such as temperature. Then after a transformation like `tau = k t` I would have\r\n```\r\nd T(tau)/dtau = 1\r\n```\r\nHere the function `T` in the second equation is mathematically speaking not the same function. However physically it still represents the temperature so we might want to call it the same name `T`. In this interpretation replacing `T(t)` with `T(tau)` makes sense because we treat `T` is being a variable that has many possible relationships with other variables.\r\n\r\nIf we instead view `T` as a function then the result of the transformation should be to\r\n```\r\nd T(tau/k)/dtau = 1\r\n```\r\nI think that by default we should prefer this second form of transformation that treats `T` as being strictly an unknown function. However it should also be possible for the user to provide `T(t):T(tau)` to override that.\r\n\r\nI think that what I am describing here is essentially equivalent to Maple\'s distinction between ""known"" and ""unknown"" functions.', 'comment_created': datetime.datetime(2021, 3, 6, 15, 33, 31, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 589170565, 'comment_body': ""The present code makes both of these transformations possible.\r\n``` python\r\nIn [1]: T = Function('T')\r\n\r\nIn [2]: t, k, tau = symbols('t k tau')\r\n\r\nIn [3]: eq = Eq(T(t).diff(t), k)\r\n\r\nIn [4]: eq\r\nOut[4]: \r\nd\r\n──(T(t)) = k\r\ndt\r\n\r\n\r\nIn [6]: eq.dsubs({t: tau/k}, newvars=[tau])\r\nOut[6]: \r\n  d\r\nk⋅──(T(τ)) = k\r\n  dτ\r\n\r\nIn [9]: eq.dsubs({t: tau/k}, newvars=[tau], known=[T(t)]).doit()\r\nOut[9]: \r\n⎛ d        ⎞│\r\n⎜───(T(ξ₁))⎟│   τ  =  k\r\n⎝dξ₁       ⎠│ξ₁=─\r\n                k\r\n```"", 'comment_created': datetime.datetime(2021, 3, 8, 4, 59, 14, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 589184756, 'comment_body': 'Its just that the first one is default and the second one can be achieved by adding the function to the list of known functions. If required, we can change this.', 'comment_created': datetime.datetime(2021, 3, 8, 5, 53, 15, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 589254926, 'comment_body': 'Can that not be:\r\n```python\r\nIn [7]: Derivative(T(tau/k), tau)\r\nOut[7]: \r\n∂ ⎛ ⎛τ⎞⎞\r\n──⎜T⎜─⎟⎟\r\n∂τ⎝ ⎝k⎠⎠\r\n```\r\nI think that the default should be to do this unless `T(t): T(tau)` is given. Also `known` seems like a very odd way of specifying the distinction to me.\r\n\r\nMaybe this should be discussed on the mailing list to see what people think.', 'comment_created': datetime.datetime(2021, 3, 8, 8, 47, 46, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 589270902, 'comment_body': ""> Can that not be:\r\n> \r\n> ```python\r\n> In [7]: Derivative(T(tau/k), tau)\r\n> Out[7]: \r\n> ∂ ⎛ ⎛τ⎞⎞\r\n> ──⎜T⎜─⎟⎟\r\n> ∂τ⎝ ⎝k⎠⎠\r\n> ```\r\n> \r\n\r\nThis would be mathematically wrong right? How can `k` be removed?\r\n\r\n> I think that the default should be to do this unless `T(t): T(tau)` is given. Also `known` seems like a very odd way of specifying the distinction to me.\r\n> \r\n> Maybe this should be discussed on the mailing list to see what people think.\r\n\r\nYeah sure, changing the kwarg name wouldn't be hard. Should I post on the mailing list?"", 'comment_created': datetime.datetime(2021, 3, 8, 9, 15, 21, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 589320475, 'comment_body': ""> This would be mathematically wrong right? How can `k` be removed?\r\n\r\nI guess there should be a factor of `k` in there. What I mean is can it be expressed as a Derivative wrt tau rather than a subs? The main point of `dsubs` is the fact that subs doesn't perform the substitution in the expected way.\r\n\r\n> Should I post on the mailing list?\r\n\r\nI think so. The question is really what should the signature of `dsubs` be? (You'll need to carefully explain what the differences are and how dchange works and any other examples from other CAS. Don't presume that other people reading the list will understand what you mean.)"", 'comment_created': datetime.datetime(2021, 3, 8, 10, 30, 43, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 589360215, 'comment_body': ""> I guess there should be a factor of k in there. What I mean is can it be expressed as a Derivative wrt tau rather than a subs? The main point of dsubs is the fact that subs doesn't perform the substitution in the expected way.\r\n\r\nIn this case, Maple uses the `D` operator. Maybe something of that sort will have to be added.\r\n\r\n> I think so. The question is really what should the signature of dsubs be? (You'll need to carefully explain what the differences are and how dchange works and any other examples from other CAS. Don't presume that other people reading the list will understand what you mean.\r\n\r\nI'll try to make a list of examples and then post."", 'comment_created': datetime.datetime(2021, 3, 8, 11, 40, 20, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 589381936, 'comment_body': ""> In this case, Maple uses the `D` operator. Maybe something of that sort will have to be added.\r\n\r\nWe definitely want that but adding it is not trivial. The main problem is that functions themselves are not first class objects so e.g. `cos` or `f` is a class rather than an instance. That means that `D(f)` can't be a proper Basic instance with `f` as its arg. Maybe it's possible to work around that though using `Lambda`...\r\n\r\nFor now though we can still represent the derivative as something like `y*Derivative(f(x/y), x)` rather than as `Subs(Derivative(...), ...)` which I think is nicer."", 'comment_created': datetime.datetime(2021, 3, 8, 12, 21, 57, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 589469795, 'comment_body': '> For now though we can still represent the derivative as something like `y*Derivative(f(x/y), x)` rather than as `Subs(Derivative(...), ...)` which I think is nicer.\r\n\r\nWhat about transformations like `{t: k/tau}` where `tau` is the new variable?', 'comment_created': datetime.datetime(2021, 3, 8, 14, 39, 26, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 589576833, 'comment_body': ""What about them? I don't see why that would be any different."", 'comment_created': datetime.datetime(2021, 3, 8, 16, 47, 2, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 590121580, 'comment_body': ""> What about them? I don't see why that would be any different.\r\n\r\nI'm confused about this. So we replace `Subs(Derivative(T(t), t), t, k/tau)` by `Derivative(T(k/tau), tau) / Derivative(k/tau, tau)`?"", 'comment_created': datetime.datetime(2021, 3, 9, 9, 23, 17, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 590134708, 'comment_body': ""Actually, the current code can achieve what you are asking for. But there is a small problem due to `doit`. After removing the `doit` from here\r\nhttps://github.com/sympy/sympy/blob/f74e2eb22db6a69002b1cda2040e82166ec48032/sympy/core/basic.py#L1286\r\nI get the following results -\r\n``` python\r\nIn [9]: T = Function('T')\r\n   ...: t, k, tau = symbols('t k tau')\r\n   ...: eq = Eq(T(t).diff(t), k)\r\n   ...: eq\r\nOut[9]: \r\nd\r\n──(T(t)) = k\r\ndt\r\n\r\nIn [12]: eq.dsubs({t: tau/k}, newvars=[tau])\r\nOut[12]: \r\nd\r\n──(T(τ))\r\ndτ\r\n──────── = k\r\n ∂ ⎛τ⎞\r\n ──⎜─⎟\r\n ∂τ⎝k⎠\r\n\r\nIn [13]: _.doit()\r\nOut[13]: \r\n  d\r\nk⋅──(T(τ)) = k\r\n  dτ\r\n\r\nIn [14]: eq.dsubs({t: tau/k}, newvars=[tau], known=[T(t)])\r\nOut[14]:\r\n\r\n∂ ⎛ ⎛τ⎞⎞\r\n──⎜T⎜─⎟⎟\r\n∂τ⎝ ⎝k⎠⎠\r\n──────── = k\r\n ∂ ⎛τ⎞\r\n ──⎜─⎟\r\n ∂τ⎝k⎠\r\n\r\nIn [15]: _.doit()\r\nOut[15]:\r\n\r\n⎛ d        ⎞│\r\n⎜───(T(ξ₁))⎟│   τ = k\r\n⎝dξ₁       ⎠│ξ₁=─\r\n                k\r\n```\r\nAvoiding `doit` would not simplify the equation, but using `doit` is converting the `Derivative` of `known` functions to `Subs(Derivative(...), ...)`. So, we must find a way to avoid using `doit` but somehow simplify the equation."", 'comment_created': datetime.datetime(2021, 3, 9, 9, 35, 29, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 590277920, 'comment_body': ""I think this should be the default behaviour without needing to specify `known=[T(t)]`. The user should have to provide `T(t): T(tau)` if they want the other kind of substitution.\r\n\r\nMaybe the best way to fix the `doit` problem would be to add a `AppliedFunctionDerivative` class that can represent e.g. `f'(x)`.\r\n"", 'comment_created': datetime.datetime(2021, 3, 9, 11, 48, 23, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 590458841, 'comment_body': 'What are the things required in the `AppliedFunctionDerivative` class?', 'comment_created': datetime.datetime(2021, 3, 9, 15, 15, 15, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 590465999, 'comment_body': 'It would just be a Basic class like `AppliedFunctionDerivative(f(t), 0)` where the zero means ""differentiate wrt the 0th argument"". Then if the 0th argument is a simple symbol like `t` it could evaluate to an ordinary `Derivative`.', 'comment_created': datetime.datetime(2021, 3, 9, 15, 23, 12, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 616323117, 'comment_body': ""I just added the `AppliedFuncDerivative` class and tests for it. I was looking in the code for `_derivative_dispatch`, but I'm unable to figure out how to replace the `Subs(Derivative(...), ...)` part by `AppliedFuncDerivative`. Could you suggest anything? "", 'comment_created': datetime.datetime(2021, 4, 20, 3, 51, 8, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 616470433, 'comment_body': ""The derivative code is complicated. I haven't been through it myself. @Upabjojr ?"", 'comment_created': datetime.datetime(2021, 4, 20, 8, 37, 37, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 616714972, 'comment_body': '> The derivative code is complicated.\r\n\r\nThe derivative code is a mess. It would be nice to clean the code.', 'comment_created': datetime.datetime(2021, 4, 20, 14, 3, 54, tzinfo=datetime.timezone.utc), 'commenter': 'Upabjojr', 'type': 'User'}, {'comment_id': 616717214, 'comment_body': ""The problem is that we may want to decide whether it's an ordinary derivative or a matrix/array derivative. So there is some logic to switch between the two. It's really messy and it's probably going to need some cleanup for sure."", 'comment_created': datetime.datetime(2021, 4, 20, 14, 6, 20, tzinfo=datetime.timezone.utc), 'commenter': 'Upabjojr', 'type': 'User'}, {'comment_id': 616764980, 'comment_body': ""I think that it's a mistake to mix up array derivatives with ordinary derivatives. There are not really any situations where you would want to mix the two in practice so there should be a separate `ArrayDerivative` class or `array_diff` function or something like that."", 'comment_created': datetime.datetime(2021, 4, 20, 14, 56, 2, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 617329744, 'comment_body': 'Since it needs a lot of refactoring, we can use the `AppliedFuncDerivative` only in `dsubs` for now. Or another option can be to let the `Subs(Derivative(..., ...))` part remain and add `AppliedFuncDerivative` in a later PR since `dsubs` is working.', 'comment_created': datetime.datetime(2021, 4, 21, 8, 53, 51, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 617352723, 'comment_body': 'Yes, we could do that. We should at least make sure that `dsolve` can recognise an `AppliedDerivative` since that is where we really need `dsubs`.', 'comment_created': datetime.datetime(2021, 4, 21, 9, 24, 35, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 617467175, 'comment_body': 'The problem is `dsolve` can\'t solve ODEs with substitution in them. In fact, for every equation where there is a `Subs` object present, `classify_ode` somehow matches only the lie group method. So, this has to be added first, and then we can make `dsolve` recognize `AppliedFuncDerivative`.\r\n``` python\r\nIn [24]: eq = f(x).diff(x)\r\n\r\nIn [25]: eq\r\nOut[25]: \r\nd\r\n──(f(x))\r\ndx\r\n\r\nIn [26]: dsolve(eq)\r\nOut[26]: f(x) = C₁\r\n\r\nIn [27]: dsolve(eq.subs(x, y**2))\r\n---------------------------------------------------------------------------\r\nNotImplementedError                       Traceback (most recent call last)\r\n<ipython-input-27-b156955447c3> in <module>\r\n----> 1 dsolve(eq.subs(x, y**2))\r\n\r\n~\\sympy\\sympy\\solvers\\ode\\ode.py in dsolve(eq, func, hint, simplify, ics, xi, eta, x0, n, **kwargs)\r\n    662             # The key \'hint\' stores the hint needed to be solved for.\r\n    663             hint = hints[\'hint\']\r\n--> 664             return _helper_simplify(eq, hint, hints, simplify, ics=ics)\r\n    665\r\n    666 def _helper_simplify(eq, hint, match, simplify=True, ics=None, **kwargs):\r\n\r\n~\\sympy\\sympy\\solvers\\ode\\ode.py in _helper_simplify(eq, hint, match, simplify, ics, **kwargs)\r\n    693             sols = solvefunc.get_general_solution()\r\n    694         else:\r\n--> 695             sols = solvefunc(eq, func, order, match)\r\n    696         if iterable(sols):\r\n    697             rv = [odesimp(eq, s, func, hint) for s in sols]\r\n\r\n~\\sympy\\sympy\\solvers\\ode\\ode.py in ode_lie_group(eq, func, order, match)\r\n   5453     if desols == []:\r\n   5454         raise NotImplementedError(""The given ODE "" + str(eq) + "" cannot be solved by""\r\n-> 5455             + "" the lie group method"")\r\n   5456     return desols\r\n   5457\r\n\r\nNotImplementedError: The given ODE Subs(Derivative(f(x), x), x, y**2) cannot be solved by the lie group method\r\n\r\nIn [28]: dsolve(Subs(eq, x**2, y).doit())\r\n---------------------------------------------------------------------------\r\nNotImplementedError                       Traceback (most recent call last)\r\n<ipython-input-17-1e9d27472b3c> in <module>\r\n----> 1 dsolve(Subs(eq, x**2, y))\r\n\r\n~\\sympy\\sympy\\solvers\\ode\\ode.py in dsolve(eq, func, hint, simplify, ics, xi, eta, x0, n, **kwargs)\r\n    662             # The key \'hint\' stores the hint needed to be solved for.\r\n    663             hint = hints[\'hint\']\r\n--> 664             return _helper_simplify(eq, hint, hints, simplify, ics=ics)\r\n    665\r\n    666 def _helper_simplify(eq, hint, match, simplify=True, ics=None, **kwargs):\r\n\r\n~\\sympy\\sympy\\solvers\\ode\\ode.py in _helper_simplify(eq, hint, match, simplify, ics, **kwargs)\r\n    693             sols = solvefunc.get_general_solution()\r\n    694         else:\r\n--> 695             sols = solvefunc(eq, func, order, match)\r\n    696         if iterable(sols):\r\n    697             rv = [odesimp(eq, s, func, hint) for s in sols]\r\n\r\n~\\sympy\\sympy\\solvers\\ode\\ode.py in ode_lie_group(eq, func, order, match)\r\n   5453     if desols == []:\r\n   5454         raise NotImplementedError(""The given ODE "" + str(eq) + "" cannot be solved by""\r\n-> 5455             + "" the lie group method"")\r\n   5456     return desols\r\n   5457\r\n\r\nNotImplementedError: The given ODE Subs(x**2 + Derivative(f(x), x), x**2, y) cannot be solved by the lie group method\r\n```', 'comment_created': datetime.datetime(2021, 4, 21, 11, 57, 28, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 617804540, 'comment_body': ""I think it's better not to use `simplify` in tests like this. Not least because it means we're not testing the output from `dsubs` directly.\r\n\r\nWe should choose to either:\r\n\r\n1. Have `dsubs` apply some light-weight but commonly needed simplifications (with an option to disable them).\r\n2. Clearly explain in the docstring what simplification functions are likely to be useful.\r\n\r\nEither way we should test that actual output of `dsubs` rather than what happens after simplifying that output."", 'comment_created': datetime.datetime(2021, 4, 21, 19, 1, 54, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 617807407, 'comment_body': ""The idea is that `dsubs` computes the substitution without resulting in `Subs` though.\r\n\r\nI don't understand what point you are making about adding one thing before another. It isn't necessary to do everything in one PR. This PR is not ready to be merged though. The main issue with it is the fact that it adds a method to Basic but also the code can be simplified or better organised.\r\n\r\n"", 'comment_created': datetime.datetime(2021, 4, 21, 19, 6, 49, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 618273461, 'comment_body': 'Ok, maybe we can add kwargs to the function which could be passed into `simplify`. I will change the tests', 'comment_created': datetime.datetime(2021, 4, 22, 10, 19, 40, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 618282648, 'comment_body': 'With the diff\r\n``` python\r\ndiff --git a/sympy/core/basic.py b/sympy/core/basic.py\r\nindex bb9d54efa3..131edffc46 100644\r\n--- a/sympy/core/basic.py\r\n+++ b/sympy/core/basic.py\r\n@@ -1205,7 +1205,7 @@ def dsubs(self, subsdict, newvars=None, known=None, unknown=None):\r\n         2*sqrt(b)*Derivative(g(b), b) + u**3*Derivative(h(u), (u, 3)) +\r\n         3*u**2*Derivative(h(u), (u, 2)) + u*Derivative(h(u), u) + Derivative(f(x), (x, 2))\r\n         """"""\r\n-        from sympy.core.function import Function, Derivative, AppliedUndef\r\n+        from sympy.core.function import Subs, Function, Derivative, AppliedUndef\r\n         from sympy.core.symbol import Symbol\r\n\r\n         def diffx(e, sym, n):\r\n@@ -1283,7 +1283,13 @@ def diffx(e, sym, n):\r\n                         eq = eq.subs(func.subs(old_var, Function(old_var.name + \'f\')(mapdict[old_var])), func.subs(old_var, mapdict[old_var]))\r\n                 eq = eq.subs(Function(var.name + \'f\')(mapdict[var]), subsdict[var])\r\n\r\n-        return eq.doit()\r\n+        derivatives = list(eq.atoms(Derivative))\r\n+        derivatives.sort(key=lambda x: len(str(x)), reverse=True)\r\n+        for d in derivatives:\r\n+            done = d.doit()\r\n+            if not len(done.atoms(Subs)):\r\n+                eq = eq.subs(d, done)\r\n+\r\n+        return eq\r\n\r\n     def xreplace(self, rule):\r\n         """"""\r\n```\r\nI get the following output.\r\n``` python\r\nIn [1]: T = Function(\'T\')\r\n   ...: t, k, tau = symbols(\'t k tau\')\r\n   ...: eq = Eq(T(t).diff(t), k)\r\n\r\nIn [2]: eq\r\nOut[2]: \r\nd\r\n──(T(t)) = k\r\ndt\r\n\r\nIn [3]: eq.dsubs({t: tau/k}, newvars=[tau])\r\nOut[3]: \r\n  d\r\nk⋅──(T(τ)) = k\r\n  dτ\r\n\r\nIn [4]: eq.dsubs({t: tau/k}, newvars=[tau], known=[T(t)])\r\nOut[4]: \r\n\r\n  ∂ ⎛ ⎛τ⎞⎞\r\nk⋅──⎜T⎜─⎟⎟ = k\r\n  ∂τ⎝ ⎝k⎠⎠\r\n```\r\nBasically, any applied derivative will not be converted into a `Subs` object. I think this is what we were looking for initially? (https://github.com/sympy/sympy/pull/20979#discussion_r589254926) Is this okay now or should we continue with the `AppliedFuncDerivative` class?\r\n\r\nOf course, there are other things that I still have to modify. I will soon add some commits addressing your comments above.', 'comment_created': datetime.datetime(2021, 4, 22, 10, 33, 26, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 618311947, 'comment_body': ""> I didn't realise this was a method on Basic. I don't think this should be a Basic method. It should be a function.\r\n\r\nUnder which module should I make it a function - `solvers.ode` or `core`?"", 'comment_created': datetime.datetime(2021, 4, 22, 11, 21, 38, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 618312442, 'comment_body': 'Is this fine or should I remove it from the docstring?', 'comment_created': datetime.datetime(2021, 4, 22, 11, 22, 29, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 618352892, 'comment_body': 'In 2 tests, I used `expand` as the output was too long without it. Is this fine, or should the tests be changed?', 'comment_created': datetime.datetime(2021, 4, 22, 12, 25, 57, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 618358343, 'comment_body': ""That's fine if it's needed in a couple of cases. If that's a good way of simplify the output in some cases then it should be mentioned in the docstring."", 'comment_created': datetime.datetime(2021, 4, 22, 12, 33, 33, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 618370461, 'comment_body': 'Yes, in general, expanding the output helps. I will add it to the docstring.', 'comment_created': datetime.datetime(2021, 4, 22, 12, 49, 55, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 621239815, 'comment_body': 'The idea with `rerverse` was supposed to be that you would give it the same arguments as the forward substitution. If you have to pass in a different transformation dict then is there any point in having reverse?', 'comment_created': datetime.datetime(2021, 4, 27, 14, 2, 16, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 621257601, 'comment_body': 'So, we use `solve` inside?', 'comment_created': datetime.datetime(2021, 4, 27, 14, 21, 21, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 621319202, 'comment_body': ""We don't want to use `solve` because it tries to find all solutions in cases where there isn't a unique solution. Here we just want a local inverse. Rather than use `solve` I would prefer to require the user to supply the reverse transformation perhaps like:\r\n```python\r\ntrans = ({t: exp(tau), x(t):x(tau)}, {tau:log(t), x(tau):x(t)})\r\n\r\neqtrans = dsubs(eq, trans)\r\nsoltrans = dsolve(eqtrans)\r\nsol = dsubs(soltrans, trans, reverse=True)\r\n```\r\nMaybe some entries could be automatically filled like `x(tau):x(t)` if not given in the reverse part of the transformation. This approach would also mean that `newvars` is not needed because we can see which are the new variables by looking at the keys of the reverse transformation dict.\r\n\r\nIf we aren't using the same arguments though then there isn't any point in having `reverse=True` because the user should be able to use `dsubs` in both directions:\r\n```python\r\ntrans = {t: exp(tau), x(t):x(tau)}\r\ntrans_reverse = {tau:log(t), x(tau):x(t)}\r\n\r\neqtrans = dsubs(eq, trans)\r\nsoltrans = dsolve(eqtrans)\r\nsol = dsubs(soltrans, trans_reverse)\r\n```\r\nMaybe it would just be simpler to do that."", 'comment_created': datetime.datetime(2021, 4, 27, 15, 23, 2, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 621781046, 'comment_body': ""> This approach would also mean that `newvars` is not needed because we can see which are the new variables by looking at the keys of the reverse transformation dict.\r\n\r\nI think `newvars` is still required for cases like `{x: a*t, f(x): h(a)*g(t)}`.\r\n\r\n> If we aren't using the same arguments though then there isn't any point in having reverse=True because the user should be able to use dsubs in both directions:\r\n\r\nSo, I remove the `reverse=True`? The present code actually works without it, although I'd have to test a few more examples to make sure everything is happening correctly"", 'comment_created': datetime.datetime(2021, 4, 28, 3, 18, 21, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 622035334, 'comment_body': ""> I think `newvars` is still required for cases like `{x: a*t, f(x): h(a)*g(t)}`.\r\n\r\nYou could specify that as\r\n```python\r\ntrans_forward  = {x: a*t, f(x): h(a)*g(t)}\r\ntrans_backward = {t: x/a, g(t): f(x)/h(a)}\r\ntransformation = (trans_forward, trans_backward)\r\n\r\neq_subs = dsubs(eq, transformation)\r\n```\r\nThen `dsubs` knows that `t` and `g(t)` are the new variables because they are the keys in the backward transformation dict. I think that means that `newvars` is not needed.\r\n\r\nIt's also possible that the transformation could be computed differently if the backward transformation is also supplied. The docs for Maple's `dchange` imply that Maple uses a different algorithm in that case."", 'comment_created': datetime.datetime(2021, 4, 28, 10, 18, 19, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 622043514, 'comment_body': ""> Then `dsubs` knows that `t` and `g(t)` are the new variables because they are the keys in the backward transformation dict. I think that means that `newvars` is not needed.\r\n\r\nOkay, I get it now. I will change this to be the interface.\r\n\r\n> It's also possible that the transformation could be computed differently if the backward transformation is also supplied. \r\n\r\nHow can it be computed differently? Could you elaborate?"", 'comment_created': datetime.datetime(2021, 4, 28, 10, 29, 22, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 624881972, 'comment_body': ""> > I think `newvars` is still required for cases like `{x: a*t, f(x): h(a)*g(t)}`.\r\n> \r\n> You could specify that as\r\n> \r\n> ```python\r\n> trans_forward  = {x: a*t, f(x): h(a)*g(t)}\r\n> trans_backward = {t: x/a, g(t): f(x)/h(a)}\r\n> transformation = (trans_forward, trans_backward)\r\n> \r\n> eq_subs = dsubs(eq, transformation)\r\n> ```\r\n> \r\n> Then `dsubs` knows that `t` and `g(t)` are the new variables because they are the keys in the backward transformation dict. I think that means that `newvars` is not needed.\r\n> \r\n> It's also possible that the transformation could be computed differently if the backward transformation is also supplied. The docs for Maple's `dchange` imply that Maple uses a different algorithm in that case.\r\n\r\nAbout this interface, I was thinking, the user needs to specify both the directions twice. It doesn't seem nice to me. Is that okay with you? "", 'comment_created': datetime.datetime(2021, 5, 3, 5, 34, 51, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 625024039, 'comment_body': '> About this interface, I was thinking, the user needs to specify both the directions twice. It doesn\'t seem nice to me. Is that okay with you?\r\n\r\nI don\'t know what you mean by ""both the directions twice"".\r\n\r\nThe point is that we can make this work with only the forward transformation but it leaves us needing extra information such as `newvars` and that extra information is actually much less useful than the reverse transformation that can be used to compute the result with a different algorithm. If we have the user supply the reverse transformation then we can implement better algorithms later.\r\n\r\nNot providing the reverse transformation might seem nice in interactive usage but in actual practice when would you be able to do a meaningful calculation without also needing to have the reverse transformation as well?\r\n\r\nIf the caller already needs to have the reverse transformation then why shouldn\'t they give it to `dsubs` since it makes the signature of `dsubs` unambiguous? For a caller who already has the transformation in both directions asking them to supply `newvars` instead is just annoying.\r\n\r\nIf the interface is not that friendly then we can make a new function later with a nicer UI (that just calls `dsubs` internally). I think it would also be reasonable to design this now so that it could later be changed to make the reverse transformation optional. We should start from designing something that is clearly well defined and useful for library use before considering how to make it more convenient for e.g. interactive use.', 'comment_created': datetime.datetime(2021, 5, 3, 11, 28, 15, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 625210694, 'comment_body': '> I don\'t know what you mean by ""both the directions twice"".\r\n\r\nBy this I meant we are passing in both the original and reverse transformations into `dsubs` once during the forward substitution and once during the reverse substitution. But since you\'re saying we can modify the interface later, I will change the code and make the interface as you suggested above.', 'comment_created': datetime.datetime(2021, 5, 3, 16, 34, 26, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 625223427, 'comment_body': ""Yes, but actually it's nicer that way because e.g.:\r\n```python\r\ntrans_forward  = {x: a*t, f(x): h(a)*g(t)}\r\ntrans_backward = {t: x/a, g(t): f(x)/h(a)}\r\ntrans = (trans_forward, trans_backward)\r\n\r\neq_subs = dsubs(eq, trans)\r\nsol_subs  = dsolve(eq_subs)\r\nsol = dsubs(sol, trans[::-1])  # <--- reverse trans to reverse the substitution\r\n```\r\nWe get to use essentially the same object `trans` for both the forward and backward substitutions. This is much nicer if you imagine another function that receives the transformation from somewhere else like:\r\n```python\r\ndef dsolve_substitution(eq, trans):\r\n    eq_subs = dsubs(eq, trans)\r\n    sol_subs  = dsolve(eq_subs)\r\n    sol = dsubs(sol, trans[::-1])\r\n    return sol\r\n```\r\n\r\nPerhaps if the user doesn't want to provide the backwards transformation we could just allow them to provide the new variables as a set in place of the backwards transformation like:\r\n```python\r\ntrans_forward  = {x: a*t, f(x): h(a)*g(t)}\r\nnew_vars = {t, g(t)}\r\ntrans = (trans_forward, new_vars)\r\n```\r\nThen internally `dsubs` can just do:\r\n```python\r\ndef dsubs(expr, trans):\r\n    forward_trans, reverse_trans = trans\r\n    new_vars = set(reverse_trans)\r\n    if not isinstance(reverse_trans, dict):\r\n        reverse_trans = None\r\n```\r\nThen a minimal substitution would be like:\r\n```python\r\ndsubs(eq, ({x: a*t, f(x):g(t)}, {t, g(t)}))\r\n```"", 'comment_created': datetime.datetime(2021, 5, 3, 16, 55, 14, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 626481688, 'comment_body': ""I've made the requested changes"", 'comment_created': datetime.datetime(2021, 5, 5, 11, 24, 53, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 626494138, 'comment_body': ""This is quite convoluted. I think it's really just something like this:\r\n```python\r\nfor var, newexpr in trans.items():\r\n    if not isinstance(var, (Symbol, AppliedUndef)):\r\n        raise ValueError\r\n    atoms = {newexpr}\r\n```\r\nAlthough I'm not sure why you need `atoms` to be a set. Is it to handle something like `{f(a*t): g(t)}`?"", 'comment_created': datetime.datetime(2021, 5, 5, 11, 46, 47, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 626592870, 'comment_body': 'It is for the other way round - `{g(t): f(a*t)}`. Atleast one of these symbols on the right must be part of `newvars `or be a key in `reverse_trans`.', 'comment_created': datetime.datetime(2021, 5, 5, 14, 0, 26, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 626713500, 'comment_body': '```suggestion\r\n            raise ValueError(f""Expected Symbol or Function; received {var.__class__.__name__}"")\r\n```\r\nWhere this is occuring will be apparent when the error is raised.', 'comment_created': datetime.datetime(2021, 5, 5, 16, 20, 13, tzinfo=datetime.timezone.utc), 'commenter': 'smichr', 'type': 'User'}, {'comment_id': 626750500, 'comment_body': ""Sure, I'll change this in the next commit I push"", 'comment_created': datetime.datetime(2021, 5, 5, 17, 11, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 626990880, 'comment_body': 'It seems like this should be tested without wrapping expected ints in `S()`.', 'comment_created': datetime.datetime(2021, 5, 5, 23, 54, 50, tzinfo=datetime.timezone.utc), 'commenter': 'smichr', 'type': 'User'}, {'comment_id': 627036191, 'comment_body': 'Actually, this class was part of an idea which I solved through another way. Its not needed anymore and I will remove it in the next commit. ', 'comment_created': datetime.datetime(2021, 5, 6, 2, 31, 30, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 677612856, 'comment_body': 'I would split this as separate arguments to the function. ', 'comment_created': datetime.datetime(2021, 7, 27, 16, 27, 17, tzinfo=datetime.timezone.utc), 'commenter': 'asmeurer', 'type': 'User'}, {'comment_id': 677613205, 'comment_body': ""This isn't actually used in the code anywhere. I would omit it, at least for now. If it ends up being used later, we can add it back in. "", 'comment_created': datetime.datetime(2021, 7, 27, 16, 27, 44, tzinfo=datetime.timezone.utc), 'commenter': 'asmeurer', 'type': 'User'}, {'comment_id': 679448751, 'comment_body': 'Why do we need to give `reverse=True` if the dict has been reversed already?', 'comment_created': datetime.datetime(2021, 7, 29, 20, 0, 57, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 679450824, 'comment_body': ""Looks like `dsubs` is added to `__all__` here but isn't imported in this file."", 'comment_created': datetime.datetime(2021, 7, 29, 20, 4, 14, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 681126938, 'comment_body': 'Thanks, I think I accepted incoming changes in the merge conflicts and this was removed without me noticing it.', 'comment_created': datetime.datetime(2021, 8, 2, 16, 52, 53, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 681129495, 'comment_body': 'The `reverse=True` is required so that it just substitutes the transformation instead of trying to apply the substitution in the forward direction. Maybe we could omit this and set it to true internally if there are no `Derivative` terms in the equation (solution) we get?', 'comment_created': datetime.datetime(2021, 8, 2, 16, 56, 58, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 681272848, 'comment_body': ""Is there any need to distinguish those cases?\r\n\r\nI would have thought that if there are derivatives we need to transform them but there are no derivatives we don't."", 'comment_created': datetime.datetime(2021, 8, 2, 21, 9, 8, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 681418409, 'comment_body': ""Yes, I've removed the reverse kwarg now."", 'comment_created': datetime.datetime(2021, 8, 3, 4, 7, 40, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 681418896, 'comment_body': ""For now I've just made it a single arg and removed the reverse transformation. The reverse substitution can now be achieved by passing it as the same argument."", 'comment_created': datetime.datetime(2021, 8, 3, 4, 9, 5, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 681590397, 'comment_body': 'I guess the reverse argument should be removed.', 'comment_created': datetime.datetime(2021, 8, 3, 9, 23, 33, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 681590883, 'comment_body': 'Why are all these imports delayed? Can they not go at the top of the module?', 'comment_created': datetime.datetime(2021, 8, 3, 9, 24, 10, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 681653358, 'comment_body': 'We shouldn\'t refer to the additional symbols as ""variables"". The point is that here `x` and `t` are variables but `a` is intended to be a constant. The `dsubs` function has no way to know which of the symbols `a` and `t` is a variable and which is a constant so the user needs to specify that.', 'comment_created': datetime.datetime(2021, 8, 3, 10, 58, 30, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 681655111, 'comment_body': ""The `list(map(lambda` combination should not be used in code and definitely should not be used in the docs examples. A list comprehension would be better but actually here in the doc examples I think it's actually better just to do:\r\n```\r\n>>> sol1t, sol2t = dsolve(homeq)\r\n>>> sol1t\r\n...\r\n>>> sol2t\r\n...\r\n>>> sol1 = dsubs(sol1t, ...)\r\n>>> sol1\r\n...\r\n```\r\nWe don't need to demonstrate also transforming `sol2t`."", 'comment_created': datetime.datetime(2021, 8, 3, 11, 1, 17, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 681723762, 'comment_body': 'These are actually redundant. I will remove them.', 'comment_created': datetime.datetime(2021, 8, 3, 12, 47, 3, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 681725369, 'comment_body': 'Should I mention that its required when the number of new symbols is more than the number of old symbols?', 'comment_created': datetime.datetime(2021, 8, 3, 12, 48, 58, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 682146892, 'comment_body': 'I would say something like: The newvars argument specifies which symbols should be considered variables rather than constants. For example a transformation `x = a t` where `a` is a constant and `t` is the new independent variable can be specified as... For convenience the `newvars` argument can be omitted although for robust usage in code it should always be provided. If the newvars argument is not provided then `dsubs` will treat all symbols in the replacement expression as variables but will raise an exception of the number of new variables is not equal to the number of variables being replaced.\r\n\r\nThe docstring examples should mostly pass the `newvars` argument because that it is how the function should be used robustly. Not giving newvars is okay as a convenience in interactive use but is mostly a bug magnet in proper code so the docs should encourage passing the argument.', 'comment_created': datetime.datetime(2021, 8, 3, 22, 36, 26, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 685453092, 'comment_body': ""I've added the explanation, and used `newvars` wherever possible in the docstring."", 'comment_created': datetime.datetime(2021, 8, 9, 19, 11, 50, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}, {'comment_id': 685524594, 'comment_body': 'Should the substitution be described as `v = y / x` (or equivalent latex)?', 'comment_created': datetime.datetime(2021, 8, 9, 21, 12, 16, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 685525350, 'comment_body': 'I still don\'t like the way this says ""number of new variables greater than number of old variables"". The number of variables is the same: the number of *symbols* is different and that is because some symbols represent variables and others represent constants.', 'comment_created': datetime.datetime(2021, 8, 9, 21, 13, 37, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 685526078, 'comment_body': ""Why is this distinction needed? The forward and reverse substitutions should be the same it's just that the transformation dict should be inverted in the reverse case."", 'comment_created': datetime.datetime(2021, 8, 9, 21, 14, 50, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 685683064, 'comment_body': 'You are right, it is not needed. I will remove it.', 'comment_created': datetime.datetime(2021, 8, 10, 4, 35, 33, tzinfo=datetime.timezone.utc), 'commenter': 'naveensaigit', 'type': 'User'}]","[{'commit_sha': '85245670b227a7df99c6d4d85e6ffbda056466d9', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ce8f0d821fff617042ca85ec51da36c38fa0c0c0', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '1ed36dba5a3ceb49425473b1e4ee18c28c0266af', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'f912318f88c1348b2e253127f069455e7ab5785d', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'f74e2eb22db6a69002b1cda2040e82166ec48032', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'f0eeba3885437cd8928fbf4d7e157b4435ae01e2', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'be5defa499ac2237a66211061ee744ec471709cc', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '99d24885c6f3d36ab243902fbe7f31cabe11cb7d', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '3a297646caea234198eb664ea506bc1688691bb3', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '7cf9d4a96a65a711c99e4392251288f648cb2802', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '353343fe7c1faa57e6af9d8f93d1f41c2665177e', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '6dbf5e22173821ab7413524295050b18523819f7', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'f7b602b6adf12bec9dcae93e2e91af0db1692a04', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'e126a003c21123b39dcacaa02607b0805098a59c', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '32a868a6b29b77aa0b57c520f38ee0938cea031c', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '7e6ede4ab5b728be197d58293b74e33b8065b5c8', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'a3b891911931abd01ea2e557b77ff71a37ca5308', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'b73f3eab1d20ec922ccc4ebed31e9d9b6953a537', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': '531b4932ae708409f1f29b3b7abe29b556af2a36', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'f314bb4df59e9841d05d7e2e55f5372e9fad8539', 'committer_username': 'naveensaigit', 'committer_name': 'Naveen Sai', 'committer_email': None, 'commit_date': datetime.datetime(2019, 10, 14, 1, 56, 56, tzinfo=datetime.timezone.utc)}]",Naveen Sai,56525288,,User,,39,,43,55

Project_ID,Name,Full_name,Language,Forks,Stars,Watchers,contributors,commits,issues,branches,PRs_count,contributor pullrequests
640534,sympy,sympy/sympy,Python,4367,12714,293,1320,58687,5125,14,718,"[{'id': 695364144, 'number': 21770, 'closed': None, 'created': datetime.datetime(2021, 7, 22, 17, 25, 25, tzinfo=datetime.timezone.utc), 'time_taken': 0.0, 'time_delta': '', 'additions': 67, 'deletions': 0, 'state': 'open'}, {'id': 688100430, 'number': 21737, 'closed': None, 'created': datetime.datetime(2021, 7, 12, 19, 9, 35, tzinfo=datetime.timezone.utc), 'time_taken': 0.0, 'time_delta': '', 'additions': 2515, 'deletions': 1, 'state': 'open'}, {'id': 683220547, 'number': 21704, 'closed': None, 'created': datetime.datetime(2021, 7, 4, 18, 55, 3, tzinfo=datetime.timezone.utc), 'time_taken': 0.0, 'time_delta': '', 'additions': 372, 'deletions': 0, 'state': 'open'}, {'id': 641085952, 'number': 21459, 'closed': datetime.datetime(2021, 7, 21, 18, 43, 35, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2021, 5, 11, 16, 56, 48, tzinfo=datetime.timezone.utc), 'time_taken': 6140807.0, 'time_delta': '71 days, 1:46:47', 'additions': 1974, 'deletions': 8, 'state': 'closed'}, {'id': 608757065, 'number': 21241, 'closed': datetime.datetime(2021, 4, 5, 8, 34, 10, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2021, 4, 5, 7, 4, 10, tzinfo=datetime.timezone.utc), 'time_taken': 5400.0, 'time_delta': '1:30:00', 'additions': 14, 'deletions': 2, 'state': 'closed'}, {'id': 576429987, 'number': 20979, 'closed': None, 'created': datetime.datetime(2021, 2, 19, 12, 38, 33, tzinfo=datetime.timezone.utc), 'time_taken': 0.0, 'time_delta': '', 'additions': 297, 'deletions': 9, 'state': 'open'}, {'id': 575638447, 'number': 20975, 'closed': datetime.datetime(2021, 2, 18, 13, 33, 20, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2021, 2, 18, 12, 18, 32, tzinfo=datetime.timezone.utc), 'time_taken': 4488.0, 'time_delta': '1:14:48', 'additions': 5, 'deletions': 5, 'state': 'closed'}, {'id': 572691588, 'number': 20952, 'closed': datetime.datetime(2021, 2, 16, 7, 20, 7, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2021, 2, 12, 18, 4, 1, tzinfo=datetime.timezone.utc), 'time_taken': 306966.0, 'time_delta': '3 days, 13:16:06', 'additions': 3, 'deletions': 3, 'state': 'closed'}, {'id': 556290324, 'number': 20811, 'closed': datetime.datetime(2021, 1, 17, 21, 41, 25, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2021, 1, 17, 7, 31, 4, tzinfo=datetime.timezone.utc), 'time_taken': 51021.0, 'time_delta': '14:10:21', 'additions': 2, 'deletions': 2, 'state': 'closed'}, {'id': 546561380, 'number': 20696, 'closed': datetime.datetime(2021, 1, 13, 15, 6, 49, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2020, 12, 29, 16, 55, 31, tzinfo=datetime.timezone.utc), 'time_taken': 1289478.0, 'time_delta': '14 days, 22:11:18', 'additions': 205, 'deletions': 34, 'state': 'closed'}, {'id': 544293185, 'number': 20648, 'closed': None, 'created': datetime.datetime(2020, 12, 22, 18, 30, 22, tzinfo=datetime.timezone.utc), 'time_taken': 0.0, 'time_delta': '', 'additions': 1, 'deletions': 1, 'state': 'open'}, {'id': 543185660, 'number': 20638, 'closed': None, 'created': datetime.datetime(2020, 12, 21, 2, 45, 48, tzinfo=datetime.timezone.utc), 'time_taken': 0.0, 'time_delta': '', 'additions': 22, 'deletions': 2, 'state': 'open'}, {'id': 535957382, 'number': 20569, 'closed': datetime.datetime(2021, 2, 9, 10, 38, 21, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2020, 12, 10, 14, 0, 15, tzinfo=datetime.timezone.utc), 'time_taken': 5258286.0, 'time_delta': '60 days, 20:38:06', 'additions': 377, 'deletions': 23, 'state': 'closed'}, {'id': 529706199, 'number': 20514, 'closed': datetime.datetime(2020, 12, 5, 6, 42, 23, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2020, 11, 30, 17, 41, 56, tzinfo=datetime.timezone.utc), 'time_taken': 392427.0, 'time_delta': '4 days, 13:00:27', 'additions': 267, 'deletions': 9, 'state': 'closed'}, {'id': 525265033, 'number': 20473, 'closed': datetime.datetime(2021, 1, 13, 16, 50, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2020, 11, 22, 10, 55, 8, tzinfo=datetime.timezone.utc), 'time_taken': 4514092.0, 'time_delta': '52 days, 5:54:52', 'additions': 172, 'deletions': 8, 'state': 'closed'}, {'id': 522453595, 'number': 20440, 'closed': datetime.datetime(2020, 11, 24, 10, 8, 59, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2020, 11, 17, 14, 30, 18, tzinfo=datetime.timezone.utc), 'time_taken': 589121.0, 'time_delta': '6 days, 19:38:41', 'additions': 15, 'deletions': 4, 'state': 'closed'}, {'id': 518305856, 'number': 20406, 'closed': datetime.datetime(2020, 11, 28, 15, 29, 55, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2020, 11, 10, 8, 13, 5, tzinfo=datetime.timezone.utc), 'time_taken': 1581410.0, 'time_delta': '18 days, 7:16:50', 'additions': 305, 'deletions': 20, 'state': 'closed'}, {'id': 514852574, 'number': 20377, 'closed': datetime.datetime(2020, 11, 7, 1, 9, 38, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2020, 11, 3, 16, 28, 28, tzinfo=datetime.timezone.utc), 'time_taken': 290470.0, 'time_delta': '3 days, 8:41:10', 'additions': 137, 'deletions': 5, 'state': 'closed'}, {'id': 511274890, 'number': 20348, 'closed': datetime.datetime(2020, 11, 22, 15, 34, 17, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2020, 10, 28, 4, 44, 55, tzinfo=datetime.timezone.utc), 'time_taken': 2198962.0, 'time_delta': '25 days, 10:49:22', 'additions': 173, 'deletions': 11, 'state': 'closed'}, {'id': 507789534, 'number': 20311, 'closed': None, 'created': datetime.datetime(2020, 10, 21, 18, 48, 45, tzinfo=datetime.timezone.utc), 'time_taken': 0.0, 'time_delta': '', 'additions': 71, 'deletions': 5, 'state': 'open'}, {'id': 498483989, 'number': 20213, 'closed': datetime.datetime(2020, 10, 11, 19, 24, 45, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2020, 10, 6, 11, 59, 27, tzinfo=datetime.timezone.utc), 'time_taken': 458718.0, 'time_delta': '5 days, 7:25:18', 'additions': 72, 'deletions': 13, 'state': 'closed'}, {'id': 493499826, 'number': 20150, 'closed': datetime.datetime(2020, 10, 3, 5, 36, 5, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2020, 9, 26, 6, 38, 20, tzinfo=datetime.timezone.utc), 'time_taken': 601065.0, 'time_delta': '6 days, 22:57:45', 'additions': 124, 'deletions': 124, 'state': 'closed'}, {'id': 488796731, 'number': 20102, 'closed': datetime.datetime(2020, 11, 30, 17, 43, 43, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2020, 9, 17, 16, 38, 27, tzinfo=datetime.timezone.utc), 'time_taken': 6397516.0, 'time_delta': '74 days, 1:05:16', 'additions': 257, 'deletions': 9, 'state': 'closed'}]"
