pr_id,pr_title,pr_body,is_merged,pr_number,pr_url,pr_html_url,pr_state,additions,deletions,pr_changed_files,pr_commits_count,pr_comments_count,pr_review_comments_count,pr_labels_count,pr_assignees_count,pr_labels,pr_created_at,pr_closed_at,time_taken,time_delta,pr_review_comments,pr_commits,contributor,contributor_id,contributor_email,contributor_type,contributions,contributor_public_repos,contributor_private_repos,contributor_followings,contributor_followers
1445428848,[GSoC] Use a compact hash table for RubyHash instead of the buckets strategy,"This implements a ""Compact"" approach to hash tables, described at a high level 
[here](https://blog.toit.io/hash-maps-that-dont-hate-you-1a96150b492a).  TLDR : This is a representation strategy that efficiently (hopefully!) allows insertion-order preserving hash tables. It aims to replace the BucketHashStorage strategy.

Currently appears to pass all the tests. ",True,3172,https://api.github.com/repos/oracle/truffleruby/pulls/3172,https://github.com/oracle/truffleruby/pull/3172,closed,981,191,23,30,4,74,1,1,[{'name': 'OCA Verified'}],2023-07-22 21:51:14+00:00,2023-12-13 14:37:36+00:00,12415582.0,"143 days, 16:46:22","[{'comment_id': 1277399945, 'comment_body': 'Could you move that above the annotations to not be ""in the middle""?', 'comment_created': datetime.datetime(2023, 7, 28, 10, 50, 16, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1277401246, 'comment_body': '```suggestion\r\n      - The first holds the hash of a key and the second holds an offsetted index into the KV store (index + 1) where the\r\n```\r\nWould be good to explain why `+ 1`', 'comment_created': datetime.datetime(2023, 7, 28, 10, 51, 52, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1277402203, 'comment_body': 'Could you document this field?', 'comment_created': datetime.datetime(2023, 7, 28, 10, 52, 59, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1277403206, 'comment_body': ""It feels awkward to me both arrays are not next to each other in the source, since that's the main representation.\r\n\r\nI'd suggest moving `kvStoreInsertionPos` last, that's basically a detail/optimization."", 'comment_created': datetime.datetime(2023, 7, 28, 10, 54, 4, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1277403511, 'comment_body': '```suggestion\r\n    Each slot in the index array can be in one of 3 states, depending on the value of its second (offset) field\r\n```', 'comment_created': datetime.datetime(2023, 7, 28, 10, 54, 30, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1277405224, 'comment_body': 'Instead of state 1/2/3 could you rather explain this based on the index value?\r\nLike:\r\n* index >= 1:\r\n* index == 0 (EMPTY):\r\n* index == -1 (DELETED):\r\n\r\nAlso UNUSED seems clearer than EMPTY.', 'comment_created': datetime.datetime(2023, 7, 28, 10, 56, 41, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1277405687, 'comment_body': '```suggestion\r\n    // Big Picture :\r\n```\r\nAlways a space after `//`', 'comment_created': datetime.datetime(2023, 7, 28, 10, 57, 21, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1277409334, 'comment_body': ""This means if there are 8 entries all elements of the index array will be used.\r\nThat's probably too tight, i.e., it will cause a lot of collisions in the index array.\r\nSo the index array should be bigger most likely.\r\nI looked at `org.graalvm.collections.EconomicMapImpl#createHash` for instance"", 'comment_created': datetime.datetime(2023, 7, 28, 11, 1, 19, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1277409783, 'comment_body': ""Would be good to clarify with a comment that it's a number of entries."", 'comment_created': datetime.datetime(2023, 7, 28, 11, 1, 52, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1277410100, 'comment_body': 'Could you use `jt format` to format Java code like the rest of the codebase?', 'comment_created': datetime.datetime(2023, 7, 28, 11, 2, 16, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1277411445, 'comment_body': ""I think we should avoid any float/double computation on the fast, that's pretty expensive.\r\nInstead we could store an `int` to know at which number of entries we should resize."", 'comment_created': datetime.datetime(2023, 7, 28, 11, 3, 38, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1277411891, 'comment_body': 'Leave a empty line between nodes/methods/etc', 'comment_created': datetime.datetime(2023, 7, 28, 11, 4, 14, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1277412950, 'comment_body': ""I'm thinking if the `index` length is always a power of two we could use `& (index.length-1)` instead of `% index.length`, `%` is as expensive as division.\r\n\r\nAlso is the `Math.abs` needed or is the mask sufficient to make it positive?"", 'comment_created': datetime.datetime(2023, 7, 28, 11, 5, 42, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1277598221, 'comment_body': 'Hmm, I understand your point about float div. \r\n\r\nI\'m not sure I understand the ""we could store an int"" bit, resizing doesn\'t happen at a fixed known number of entries, it happens whenever the ratio of slots used (hash.size) to the total number of slots (index.length/2) exceeds a threshold. At least, you would need an int[] lookup table to replace that, not a single int. You have to somehow encode ""for each total number of slots, how many occupied slots is too many ?"", right ?\r\n\r\nAlternatively, I found that SO question https://stackoverflow.com/questions/20788793/c-how-to-calculate-a-percentageperthousands-without-floating-point-precision, where people found a way to encode a ration using ints (25.5 --> 255, etc...). To calculate a/b that way you just do (100*a + b/2)/b, so just a const multiplication, a shift (/2), addition, and integer divsion. Is that efficient enough ?', 'comment_created': datetime.datetime(2023, 7, 28, 14, 15, 25, tzinfo=datetime.timezone.utc), 'commenter': 'moste00', 'type': 'User'}, {'comment_id': 1277649908, 'comment_body': ""Index.length is not always a power of two, it's just always even. I can enforce that it's always a power of 2, but I feel that's pretty memory-inefficient at larger sizes, the closest power of 2 to 1025 is 2048 so we're potentially wasting 1/2 of the index, and it only gets worse from there. \r\n\r\nI searched SO and Hacker's Delight for a bit and there doesn't seem to be an efficient shortcut for even numbers. "", 'comment_created': datetime.datetime(2023, 7, 28, 14, 51, 20, tzinfo=datetime.timezone.utc), 'commenter': 'moste00', 'type': 'User'}, {'comment_id': 1277709190, 'comment_body': ""> it happens whenever the ratio of slots used (hash.size) to the total number of slots (index.length/2) exceeds a threshold\r\n\r\nSo whenever you actually resize (and in constructor), you compute `threshold = loadFactor * index.length / 2`. And whenever we add an entry via e.g. Hash#[]= we'd only check `if (hash.size == threshold)` to know if we need to resize."", 'comment_created': datetime.datetime(2023, 7, 28, 15, 38, 7, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1277710081, 'comment_body': ""Yes, make it a power of 2. Anyway hash tables typically double or more their capacity on resize, so it's not worse."", 'comment_created': datetime.datetime(2023, 7, 28, 15, 38, 58, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1277713438, 'comment_body': ""I looked at EconomicMapImpl and it just multiplies by 2, I think would be really wasteful most of the time. \r\n\r\nHow about we just overallocate by a factor of 1.4 or something, i.e. we allocate 2 * ((int) (initialCapacity * 1.2)) entries for the index array. I feel that's enough for some breathing room without being too wasteful. Or maybe we can overallocate additevely by some constant amount, for example initialCapacity + 64."", 'comment_created': datetime.datetime(2023, 7, 28, 15, 42, 13, tzinfo=datetime.timezone.utc), 'commenter': 'moste00', 'type': 'User'}, {'comment_id': 1288928543, 'comment_body': '```suggestion\r\n    /* We view the index array as consisting of ""Slots"", each slot is 2 array positions. index[0] and index[1] is one\r\n```', 'comment_created': datetime.datetime(2023, 8, 9, 17, 12, 57, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1288932926, 'comment_body': ""We need a multiple of two size to be able to `&` instead of `%`.\r\nLet's just use the power of 2 > initialCapacity, and some extra room so I would follow what `EconomicMapImpl#createHash` does:\r\n```java\r\n    private void createHash() {\r\n        int entryCount = size();\r\n\r\n        // Calculate smallest 2^n that is greater number of entries.\r\n        int size = getHashThreshold();\r\n        while (size <= entryCount) {\r\n            size <<= 1;\r\n        }\r\n\r\n        // Give extra size to avoid collisions.\r\n        size <<= 1;\r\n```"", 'comment_created': datetime.datetime(2023, 8, 9, 17, 17, 12, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1288933766, 'comment_body': ""That's done in the new diff, great"", 'comment_created': datetime.datetime(2023, 8, 9, 17, 18, 6, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1288939091, 'comment_body': 'It seems best to check that, either with an `assert` or a `if (...) throw CompilerDirectives.shouldNotReachHere()`', 'comment_created': datetime.datetime(2023, 8, 9, 17, 23, 19, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1288942198, 'comment_body': 'Could you move this above `public CompactHashStore(int capacity) {` so constructors stay together and simplest first?', 'comment_created': datetime.datetime(2023, 8, 9, 17, 26, 3, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1288944437, 'comment_body': 'This is a lot of work so we want to move that logic behind a boundary and we want a CondiitonProfile on the check above', 'comment_created': datetime.datetime(2023, 8, 9, 17, 27, 48, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1288946942, 'comment_body': ""Could you `InlinedConditionProfile` instead?\r\nThat's warned on `jt build`. Also there is currently an error when building this branch as the CI shows."", 'comment_created': datetime.datetime(2023, 8, 9, 17, 29, 44, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1288963713, 'comment_body': ""Would `h & ((1<<31)-1)` do the same? (if so it seems more efficient)\r\nAnd if isn't the `h & (max - 1)` already enough on its own to make it positive?\r\nMaybe we can even use `return h & (max - 2)` to do all of it at once? And `assert max >= 4 && isPowerOfTwo(4)`.\r\nThere is a definition of `isPowerOfTwo()` in IntegerNodes, you could move it to RubyGuards to reuse it.\r\n\r\nI'm not sure we should discard the lowest bit of the hash though, it might be better to `(h & ((index.length>>1) - 1)) << 1` instead"", 'comment_created': datetime.datetime(2023, 8, 9, 17, 42, 35, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1293940301, 'comment_body': 'Could you expand a bit on why we should move the logic behind a boundary ? My understanding is that boundaries are for things PE are bad at, like e.g. Recursion. Why would PE struggle with that allocation and loop ?', 'comment_created': datetime.datetime(2023, 8, 14, 20, 29, 59, tzinfo=datetime.timezone.utc), 'commenter': 'moste00', 'type': 'User'}, {'comment_id': 1293968895, 'comment_body': '>Would h & ((1<<31)-1) do the same?\r\n\r\nHmmm, ((1 << 31) - 1) is the bitmask <0><1 {31 times}> right ? I had this idea too, although I thought of it more directly in terms of the mask shutting down the sign bit of the 2 comp representation. \r\n\r\nI rejected the idea at first because I thought it would be ""less fair"" than the shifted absolute value function I\'m using, meaning that it results in some indices having more collisions than others. I don\'t remember my reasoning, but it was wrong! I checked now and that \'&\' actually have the same property as the absolute value, it just maps each negative numbers to exactly one positive number, just not its abs. Yup, checks out, it would work.\r\n\r\n', 'comment_created': datetime.datetime(2023, 8, 14, 21, 4, 10, tzinfo=datetime.timezone.utc), 'commenter': 'moste00', 'type': 'User'}, {'comment_id': 1293974456, 'comment_body': '> if isn\'t the h & (max - 1) already enough on its own to make it positive?\r\n\r\nAlso yes, thanks for pointing that out. Although I\'m not sure that actually have the same semantics of ""Make positive, THEN take the mod"", but I don\'t think anybody cares about the mod operation per se, all we want is just a number between 0 and max-1, and h & (max - 1) does that nicely.\r\n\r\n> return h & (max - 2)\r\n\r\nBrilliant fusion of operations !\r\n\r\n> assert max >= 4 && isPowerOfTwo(4)\r\n\r\nI think you meant putting max inside the isPowerOfTwo call, not 4. Also, 2 is technically a valid power of 2 right ? it will always result in 0 which is the only valid index anyway. Regardless, max will always be >= 8 by the unstated precondition of the initialCapacity constructor, which is that the passed capacity be greater than or equal to the default initial capacity (8). I can assert that in the constructor itself.\r\n\r\n', 'comment_created': datetime.datetime(2023, 8, 14, 21, 11, 28, tzinfo=datetime.timezone.utc), 'commenter': 'moste00', 'type': 'User'}, {'comment_id': 1293977816, 'comment_body': "">I'm not sure we should discard the lowest bit of the hash though, it might be better to (h & ((index.length>>1) - 1)) << 1 instead\r\n\r\nHmm, can you elaborate further ? The current logic is not discarding the lowest bit of the hash, just the resulting mod (or mod-like) remainder. As far as I can see, that's the simplest way to ensure an even array index. What are some bad consequences of this in your opinion ?"", 'comment_created': datetime.datetime(2023, 8, 14, 21, 16, 5, tzinfo=datetime.timezone.utc), 'commenter': 'moste00', 'type': 'User'}, {'comment_id': 1295681310, 'comment_body': '> I think you meant putting max inside the isPowerOfTwo call, not 4. Also, 2 is technically a valid power of 2 right ? it will always result in 0 which is the only valid index anyway. Regardless, max will always be >= 8 by the unstated precondition of the initialCapacity constructor, which is that the passed capacity be greater than or equal to the default initial capacity (8). I can assert that in the constructor itself.\r\n\r\nYes, it needs be a power of 2 >= 4, because if it\'s 2 then it would `& 0` and only cause collisions.\r\nI would assert it here because this is the place it needs to hold. You can also assert it in other places of course, and e.g. create a helper method to asserts those 2 conditions.\r\n\r\n> Hmm, can you elaborate further ? The current logic is not discarding the lowest bit of the hash, just the resulting mod (or mod-like) remainder. As far as I can see, that\'s the simplest way to ensure an even array index. What are some bad consequences of this in your opinion ?\r\n\r\nIt is keeping keeping the mod remainder, what is above is discarded. But if we do `return h & (max - 2)`, then we also discard the lowest bit, which seems not ideal.\r\n\r\nSuppose I have some hash values like 6 and 7, if we discard the lowest bit, then those collide. But if we didn\'t discard it then they wouldn\'t collide.\r\nWe can\'t take all 32 bits of the hash, because our array will never have that much length, so I think the typical approach is to preserve all lower bits, because lower bits are most likely to differ for objects that are ""close"" in values to each other (e.g. if `int` hash is just itself).', 'comment_created': datetime.datetime(2023, 8, 16, 10, 13, 16, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1296611396, 'comment_body': 'We have a mechanism for supporting options that can be compilation constant so you don\'t impact the compiler. This is probably fine for now, but switching to the other option system isn\'t that hard. To do so, add an entry in _src/options.yml_ (probably under ""Expert/Experimental"") and then run `jt build options`.\r\n\r\nI\'d just look at how other options are set up and it should be pretty easy to figure out how to use them. The generated code will add support for a runtime option that you configure when you invoke Ruby. But, you can set what the default value is to avoid having to pass the option all the time.\r\n\r\nWithout using the compilation-friendly options, I\'d add a boundary around this constructor.', 'comment_created': datetime.datetime(2023, 8, 17, 2, 37, 16, tzinfo=datetime.timezone.utc), 'commenter': 'nirvdrum', 'type': 'User'}, {'comment_id': 1296611687, 'comment_body': ""If we're only going to support two strategies, I'd just make the option a boolean for now and then we can do away with this string comparison."", 'comment_created': datetime.datetime(2023, 8, 17, 2, 38, tzinfo=datetime.timezone.utc), 'commenter': 'nirvdrum', 'type': 'User'}, {'comment_id': 1296613265, 'comment_body': 'Minor, but it reads a bit strangely to end a sentence on a contraction. I\'d change ""where it\'s"" to ""where it is"". I had to read it a couple of times because I thought a word was missing.', 'comment_created': datetime.datetime(2023, 8, 17, 2, 41, 47, tzinfo=datetime.timezone.utc), 'commenter': 'nirvdrum', 'type': 'User'}, {'comment_id': 1296615711, 'comment_body': ""This sounds a little strange to me. Wouldn't the start of the KV array still be position `0`? Do we change to 1-based indexing? Or is the initial entry in the KV store not a validate storage candidate?\r\n\r\nA negative value would look like a better tombstone to me, but I appreciate the advantages of not having to explicitly initialize entries."", 'comment_created': datetime.datetime(2023, 8, 17, 2, 47, 42, tzinfo=datetime.timezone.utc), 'commenter': 'nirvdrum', 'type': 'User'}, {'comment_id': 1296616804, 'comment_body': 'This is fine for an initial implementation, but unbounded memory growth sounds bad. It might even be a DoS vector (I need to think on that a bit more).', 'comment_created': datetime.datetime(2023, 8, 17, 2, 50, 26, tzinfo=datetime.timezone.utc), 'commenter': 'nirvdrum', 'type': 'User'}, {'comment_id': 1296617927, 'comment_body': ""I think we should use `INDEX_SLOT_DELETED_MARKER` instead of `-1` here. It'd make the code easier to read and less error-prone."", 'comment_created': datetime.datetime(2023, 8, 17, 2, 53, 11, tzinfo=datetime.timezone.utc), 'commenter': 'nirvdrum', 'type': 'User'}, {'comment_id': 1296618018, 'comment_body': ""I think we should use `INDEX_SLOT_DELETED_MARKER` instead of `-1` here. It'd make the code easier to read and less error-prone.\r\n\r\nI have this comment throughout the whole file. I started by calling it out with individual comments, but it happens in a lot of places. I've since removed the comments. Please take a pass through this and avoid using magic values where you can, particularly since you already have a constant defined for the value."", 'comment_created': datetime.datetime(2023, 8, 17, 2, 53, 26, tzinfo=datetime.timezone.utc), 'commenter': 'nirvdrum', 'type': 'User'}, {'comment_id': 1296621322, 'comment_body': ""Based on my reading of the callers, this value is the deletion marker. Please make that clear. If it's a logically different marker, please introduce a new constant for that. I'd suggest a different value from the other marker in that case to make debugging easier."", 'comment_created': datetime.datetime(2023, 8, 17, 3, 1, 8, tzinfo=datetime.timezone.utc), 'commenter': 'nirvdrum', 'type': 'User'}, {'comment_id': 1296621941, 'comment_body': ""My understanding is that this value has no relation to `INDEX_SLOT_DELETED_MARKER`, but it uses the same value. That's part of why using the same `-1` literal everywhere is making this code hard to follow. Please use symbolic names where you can to make this easier to follow."", 'comment_created': datetime.datetime(2023, 8, 17, 3, 2, 30, tzinfo=datetime.timezone.utc), 'commenter': 'nirvdrum', 'type': 'User'}, {'comment_id': 1296623316, 'comment_body': 'Please stick to the convention used elsewhere in the runtime. Principally, it\'d be `@Bind(""$node"") Node node`. The `__` isn\'t used anywhere else and makes it a bit hard to follow.', 'comment_created': datetime.datetime(2023, 8, 17, 3, 5, 6, tzinfo=datetime.timezone.utc), 'commenter': 'nirvdrum', 'type': 'User'}, {'comment_id': 1296625474, 'comment_body': ""Here it's just a judgement call. It's an operation that should happen infrequently. Due to its size, it'll likely compile to a large chunk of code and probably won't ever have the chance to pay for itself. Since the loop size isn't fixed, the compiler is limited in just how much it can really improve things here."", 'comment_created': datetime.datetime(2023, 8, 17, 3, 10, 37, tzinfo=datetime.timezone.utc), 'commenter': 'nirvdrum', 'type': 'User'}, {'comment_id': 1296627586, 'comment_body': 'Ultimately, I think we need something like `BucketHashStore.growthCapacityGreaterThan`. If the number of entries are too great, this essentially crashes.', 'comment_created': datetime.datetime(2023, 8, 17, 3, 15, 40, tzinfo=datetime.timezone.utc), 'commenter': 'nirvdrum', 'type': 'User'}, {'comment_id': 1296628307, 'comment_body': ""Why 28? I realize we need the number to be effectively half the max array size so we can store pairs of values, but this seems smaller than I'd expect to be supported."", 'comment_created': datetime.datetime(2023, 8, 17, 3, 17, 21, tzinfo=datetime.timezone.utc), 'commenter': 'nirvdrum', 'type': 'User'}, {'comment_id': 1296628748, 'comment_body': ""Not a big deal, but we've switched to using `var` for object locals in new code."", 'comment_created': datetime.datetime(2023, 8, 17, 3, 18, 37, tzinfo=datetime.timezone.utc), 'commenter': 'nirvdrum', 'type': 'User'}, {'comment_id': 1296629438, 'comment_body': ""I don't think the early exit is buying us anything here. I'd just make it:\r\n\r\n```java\r\nif (kvStoreInsertPos >= kvStore.length) {\r\n  kvStore = Arrays.copyOf(kvStore, 2 * kvStore.length);\r\n}\r\n```"", 'comment_created': datetime.datetime(2023, 8, 17, 3, 20, 19, tzinfo=datetime.timezone.utc), 'commenter': 'nirvdrum', 'type': 'User'}, {'comment_id': 1296637215, 'comment_body': ""I don't know if you plan to adjust the formula, but since `this.index.length` is `2 * indexCapacity` and then to calculate this value you divide by 2, would it make more sense to swap it with `indexCapacity * THRESHOLD_LOAD_FACTOR_FOR_INDEX_REBUILD`?"", 'comment_created': datetime.datetime(2023, 8, 17, 3, 28, 40, tzinfo=datetime.timezone.utc), 'commenter': 'nirvdrum', 'type': 'User'}, {'comment_id': 1298123132, 'comment_body': ""> Do we change to 1-based indexing\r\n\r\nYes, exactly. Every kv position is incremented by 1 before storage in the index array, and then decremented again on retrieval. \r\n\r\n(All kv positions stored in the index array would be positions for keys, and since keys are always stored at even positions in KV storage {0,2,...}, that means all kv positions stored in the index array are odd numbers {1,3,...}. That's an expensive constraint to check in .verify(), so I don't. But it should be kept in mind as a debugging redflag.)  \r\n\r\n> A negative value would look like a better tombstone to me\r\n\r\nSame here, 1-shifting was Benoit's idea. Great idea to avoid initializing the array manually, but a rich source of potential bugs to be very careful around !"", 'comment_created': datetime.datetime(2023, 8, 18, 7, 44, 22, tzinfo=datetime.timezone.utc), 'commenter': 'moste00', 'type': 'User'}, {'comment_id': 1298125975, 'comment_body': "">  Or is the initial entry in the KV store not a validate storage candidate\r\n\r\nNope, all entries in the KV is fair game. \r\n\r\n(Deletion from an entry results in null-marking that entry so we don't stumble on it later, and then that entry is never used again, but that's a different issue. Still bad.)"", 'comment_created': datetime.datetime(2023, 8, 18, 7, 47, 18, tzinfo=datetime.timezone.utc), 'commenter': 'moste00', 'type': 'User'}, {'comment_id': 1298133793, 'comment_body': ""I'm with you on that one, there is a method resizeKvIfNeeded() that is currently responsible for expanding the KV, I could also make it shrink the KV as well, triggering a compaction pass if hash.size is too small relative to the Kv.size. \r\n\r\nThe problem is that compaction probably implies both a rehash and touching the entire index array, there might be a clever way to avoid both but I'm not sure I got all the details right."", 'comment_created': datetime.datetime(2023, 8, 18, 7, 54, 7, tzinfo=datetime.timezone.utc), 'commenter': 'moste00', 'type': 'User'}, {'comment_id': 1298139377, 'comment_body': 'Good idea, sorry about that.\r\n\r\nAs you anticipated in a following comment, that -1 actually doesn\'t mean ""deleted"", it just means ""not found"", possibly because it was never inserted in the first place. \r\n\r\nI didn\'t think of adding a constant for it because I\'m too used to array-search code returning -1 for ""not found"", but it never hurts to name things.', 'comment_created': datetime.datetime(2023, 8, 18, 7, 59, 37, tzinfo=datetime.timezone.utc), 'commenter': 'moste00', 'type': 'User'}, {'comment_id': 1298142661, 'comment_body': 'Fair point, done.\r\n\r\nI named it like that because I hated how it obscured the actual comparison in profiled If conditions, I wanted something with no letters to make the comparison stand out more and _ is already reserved. ', 'comment_created': datetime.datetime(2023, 8, 18, 8, 3, 3, tzinfo=datetime.timezone.utc), 'commenter': 'moste00', 'type': 'User'}, {'comment_id': 1298152201, 'comment_body': 'Well, that number will be rounded upwards to the nearest power of 2. So 2^28 + 1 wil be rounded upwards to 2^29. That will be the kv capacity, the index capacity is 2 times that, so 2^30. That\'s a problem, because the capacity is in entries, so we allocate twice 2^30 array entries for the index, so 2^31, but that\'s negative !\r\n\r\nThe thing we can remove to mitigate that is the requirement that the kv size be a multiple of 2, there is no real reason for that, we technically only require that index.length is a power of 2 for efficient mod. So we technically can use the supplied capacity as-is for the KV, and then round upwards for the index capacity. \r\n\r\nBut there\'s a pathological edge case there, what if the supplied capacity was already a power of 2 ? rouding ""upwards"" will yield the same power of 2, and then you end up with a KV and an index array of the same size, which is a too crowded index.', 'comment_created': datetime.datetime(2023, 8, 18, 8, 12, 11, tzinfo=datetime.timezone.utc), 'commenter': 'moste00', 'type': 'User'}, {'comment_id': 1298266831, 'comment_body': ""Thanks! Reading system properties deep inside non-config code like that rubbed me the wrong way, I will investiagte what the options systems you're talking about.\r\n\r\nAnd thanks for the very detailed tutorial about truffle boundaries, really appreciate it!"", 'comment_created': datetime.datetime(2023, 8, 18, 9, 59, 52, tzinfo=datetime.timezone.utc), 'commenter': 'moste00', 'type': 'User'}, {'comment_id': 1298287993, 'comment_body': ""If you don't mind, I have some general questions about condition profiles, in decreasing order of importance :\r\n\r\n1- If I have a non-message non-specialization plain old method, and I want to profile its conditionals, should I : \r\n                 1- Make a new node type especially for it ? \r\n\r\n                 2- Pass a condition profile down to it from its message-or- \r\n                     specialization callers ?\r\n\r\n                  3- Do some other thing I don't yet know ?\r\n\r\n(1) Seems too verbose, (2) won't scale well if you're calling 2+ levels deep, (3) might not exist.\r\n\r\n2- Why do InlineConditionProfile require an extra argument ? this article (https://docs.oracle.com/en/graalvm/jdk/20/docs/graalvm-as-a-platform/language-implementation-framework/DSLNodeObjectInlining/) about inlined nodes seems to suggest that the methods of inlined objects become sort of like static methods, and the object state is instead kept in the parent node. Is that understanding correct-ish ?\r\n\r\n(On a seperate note, I haven't noticed us using inlined nodes in the parts of the code I have seen, am I not paying attention or is there something preventing us from using them (e.g truffle version) ?)\r\n\r\n3- Are inlinedConditionProfile objects maximally efficient ? do they fit 16 object-state per int ? Sounds like something Truffle engineers would already think of but it never hurts to check and report if not."", 'comment_created': datetime.datetime(2023, 8, 18, 10, 22, 35, tzinfo=datetime.timezone.utc), 'commenter': 'moste00', 'type': 'User'}, {'comment_id': 1305786712, 'comment_body': ""1. If it's just a single ConditionProfile it's often OK to just pass it as an argument, if it's more a inlineable node is better as it encapsulates those details.\r\n2.\r\n> Is that understanding correct-ish ?\r\n\r\nYes-ish. The methods don't move (they can't) but the state/fields are moved to the parent node.\r\n\r\n> (On a seperate note, I haven't noticed us using inlined nodes in the parts of the code I have seen, am I not paying attention or is there something preventing us from using them (e.g truffle version) ?)\r\n\r\nWe use it in quite a few places but not everywhere, it's a lot of work to migrate but for new nodes we should always consider it.\r\n\r\n3. Yes, they only use 2 bits, see InlinedConditionProfile#REQUIRED_STATE_BITS"", 'comment_created': datetime.datetime(2023, 8, 25, 15, 7, 58, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1305788999, 'comment_body': ""Regarding the system property, you could just read it in a static initializer and then store the result in a `static final` field.\r\nBecause it's meant to be a temporary option (we'd just remove the old Buckets impl at the end), and on native language options would cause to skip the pre-initialized context so a language option wouldn't be a good fit anyway (and a context option would incur overhead)."", 'comment_created': datetime.datetime(2023, 8, 25, 15, 10, 1, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1308481984, 'comment_body': ""That should be removed, `CompareHashKeysNode` will do the appropriate check.\r\nNotably it's wrong for boxed primitives to use `==`."", 'comment_created': datetime.datetime(2023, 8, 29, 9, 26, 8, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1308485794, 'comment_body': 'This should be its own specialization and then in a `guards`. Notably it will avoid creating the CompareHashKeysNode for that case.', 'comment_created': datetime.datetime(2023, 8, 29, 9, 29, 6, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1331526257, 'comment_body': ""This ordering won't share the keys/values from `dest`, if `hash` is shared, which is incorrect.\r\nWe should add a spec for that case if there isn't one yet.\r\n\r\nJust swapping the order will not work either, because WriteBarrierNode on `hash` if it is already shared will noop and not share the keys/values.\r\nSo we need to share the keys/values explicitly here, unless `dest` is shared in which case there is nothing to do."", 'comment_created': datetime.datetime(2023, 9, 20, 12, 2, 38, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1331531470, 'comment_body': ""Ah actually I think it's fine.\r\nIf `hash` is shared, then its elements are already shared, and we only need to mark `dest` itself as shared.\r\nIf `hash` is not shared, nothing to do.\r\n"", 'comment_created': datetime.datetime(2023, 9, 20, 12, 7, 23, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1337235329, 'comment_body': 'This usage of InlinedLoopConditionProfile is not correct (it never reports the number of iterations done), it needs to be like https://github.com/oracle/truffleruby/pull/3172/commits/4ec8e4d17f3bd9018c7632b980b6a9ff7ddcef6d & in other places? Could you fix all InlinedLoopConditionProfile to match that?', 'comment_created': datetime.datetime(2023, 9, 26, 13, 42, 50, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1337242045, 'comment_body': ""The heavy logic with the loop below, that's good to be behind a TruffleBoundary, there is almost no value to partial evaluate that, and it would make warmup slower.\r\nBut the early check `if (indexResizingIsNotNeeded.profile(node, size < store.numSlotsForIndexRebuild)) {` that must be moved to each caller, we don't want to make a boundary call if it's not needed."", 'comment_created': datetime.datetime(2023, 9, 26, 13, 47, 18, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1337242699, 'comment_body': 'See https://github.com/oracle/truffleruby/pull/3172/files#r1337242045', 'comment_created': datetime.datetime(2023, 9, 26, 13, 47, 39, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1337249832, 'comment_body': 'This option affects new Hash literals but does *not* affect packed hashes becoming too big to be packed, those still transition to the buckets strategy. You need to change this in `org.truffleruby.core.hash.library.PackedHashStoreLibrary#promoteToBuckets` or its only caller, so if the option is set then it promotes to CompactHashStore instead.', 'comment_created': datetime.datetime(2023, 9, 26, 13, 52, 12, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1337257874, 'comment_body': 'It looks like this is something we did not handle in BucketsHashStore either, and java.util.HashMap does not seem to do it either.\r\nBut yes maybe we should have a lower threshold too, maybe if falling below 0.20 * capacity entries or maybe even a lower factor. It needs to not trigger though e.g. when we create a new Hash with capacity=8 and add the first entries.\r\nI think something to revisit later.', 'comment_created': datetime.datetime(2023, 9, 26, 13, 57, 35, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1337261439, 'comment_body': 'OK so 2^28 is correct then, could you add a comment explaining that?', 'comment_created': datetime.datetime(2023, 9, 26, 13, 59, 49, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1337270275, 'comment_body': 'What does this do, could you document it? Is it necessary?', 'comment_created': datetime.datetime(2023, 9, 26, 14, 5, 25, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1337827780, 'comment_body': ""This just reuses deleted slots along the lookup chain. If we didn't do this, lots of deleted keys will slow down lookup considerably by lengthening the chain.\n\nThe way it works is that : hash lookup logic keeps track of the first deleted slot encountered, and returns it along with the position of the hash it's looking for (avoiding allocation via the IntPair clever hack, packing 2 ints in a long). The caller of hash lookup logic is then responsible for calling the relocation logic **after** it uses the hash position to lookup the hash. \n\nYes it's not very pretty ¯\\_(ツ)_/¯"", 'comment_created': datetime.datetime(2023, 9, 26, 22, 5, 22, tzinfo=datetime.timezone.utc), 'commenter': 'moste00', 'type': 'User'}, {'comment_id': 1373362297, 'comment_body': 'Could you update this so it defaults to your new CompactHashStore? (i.e. use it unless `BigHashStrategy == ""buckets""`)\r\nThen we\'ll be sure the new strategy passes the whole CI.', 'comment_created': datetime.datetime(2023, 10, 26, 15, 28, 5, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1373365214, 'comment_body': 'The same logic is duplicated in src/main/java/org/truffleruby/core/hash/HashLiteralNode.java, could you deduplicate?', 'comment_created': datetime.datetime(2023, 10, 26, 15, 30, 19, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1376064295, 'comment_body': 'I think it would be nicer here to pass `PROMOTION_SIZE` and define that above as `PROMOTION_SIZE = MAX_ENTRIES + 1`, that likely compiles slightly better.\r\nAnd we can `assert size == PROMOTION_SIZE` before  `promoteToBigHash.execute(node, store, hash);` below.', 'comment_created': datetime.datetime(2023, 10, 30, 11, 39, 23, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1376065463, 'comment_body': ""In more details it's valuable that the compiler knows a fixed compile-time array size, because then it can use partial escape analysis on the arrays and otherwise it cannot."", 'comment_created': datetime.datetime(2023, 10, 30, 11, 40, 24, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}, {'comment_id': 1376071287, 'comment_body': 'This feels too hacky, could you instead pass RubyLanguage to `HashLiteralNode.create`, and make `BIG_HASH_STRATEGY_IS_BUCKETS` a language option? (see `LANGUAGE_OPTIONS:` in options.yml)', 'comment_created': datetime.datetime(2023, 10, 30, 11, 45, 52, tzinfo=datetime.timezone.utc), 'commenter': 'eregon', 'type': 'User'}]","[{'commit_sha': 'c903f985db532431db817f994a69210fe7aedef4', 'committer_username': 'moste00', 'committer_name': 'مصطفي محمود كمال الدين', 'committer_email': None, 'commit_date': datetime.datetime(2019, 3, 14, 18, 50, 41, tzinfo=datetime.timezone.utc)}, {'commit_sha': '7edc49f9c4774472151b23954ca305396c1c5553', 'committer_username': 'eregon', 'committer_name': 'Benoit Daloze', 'committer_email': None, 'commit_date': datetime.datetime(2009, 12, 17, 8, 20, 43, tzinfo=datetime.timezone.utc)}, {'commit_sha': '9f68b74fe7befb4b5bc885698029591ab5bf3ea7', 'committer_username': 'eregon', 'committer_name': 'Benoit Daloze', 'committer_email': None, 'commit_date': datetime.datetime(2009, 12, 17, 8, 20, 43, tzinfo=datetime.timezone.utc)}, {'commit_sha': '117d827e2bbccf1871453f50bf622b1e99387e63', 'committer_username': 'eregon', 'committer_name': 'Benoit Daloze', 'committer_email': None, 'commit_date': datetime.datetime(2009, 12, 17, 8, 20, 43, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'c5e3d56f5f7f20d694d028daf578f63db34e52c6', 'committer_username': 'eregon', 'committer_name': 'Benoit Daloze', 'committer_email': None, 'commit_date': datetime.datetime(2009, 12, 17, 8, 20, 43, tzinfo=datetime.timezone.utc)}, {'commit_sha': '4f45d982c99a1b63ad3f3cdaccf014fffd080444', 'committer_username': 'moste00', 'committer_name': 'مصطفي محمود كمال الدين', 'committer_email': None, 'commit_date': datetime.datetime(2019, 3, 14, 18, 50, 41, tzinfo=datetime.timezone.utc)}, {'commit_sha': '6e37773d5b09aa143cc9ece5d379ffa247d683fc', 'committer_username': 'moste00', 'committer_name': 'مصطفي محمود كمال الدين', 'committer_email': None, 'commit_date': datetime.datetime(2019, 3, 14, 18, 50, 41, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'a9b95ca0ce9c370878c101a11b7757ffeaa4852a', 'committer_username': 'eregon', 'committer_name': 'Benoit Daloze', 'committer_email': None, 'commit_date': datetime.datetime(2009, 12, 17, 8, 20, 43, tzinfo=datetime.timezone.utc)}, {'commit_sha': '2c653aeffd2d457d4e23a09fcd5449cbbfad2b72', 'committer_username': 'eregon', 'committer_name': 'Benoit Daloze', 'committer_email': None, 'commit_date': datetime.datetime(2009, 12, 17, 8, 20, 43, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'db1bd9bd76840c9acfda6a1eb5b9b036df514081', 'committer_username': 'eregon', 'committer_name': 'Benoit Daloze', 'committer_email': None, 'commit_date': datetime.datetime(2009, 12, 17, 8, 20, 43, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ef7e1ef18d7dd8cafdc6d6c28f16745c92a41979', 'committer_username': 'eregon', 'committer_name': 'Benoit Daloze', 'committer_email': None, 'commit_date': datetime.datetime(2009, 12, 17, 8, 20, 43, tzinfo=datetime.timezone.utc)}, {'commit_sha': '03eca56a2477bc1b565f49c24bec60b8745e40e8', 'committer_username': 'eregon', 'committer_name': 'Benoit Daloze', 'committer_email': None, 'commit_date': datetime.datetime(2009, 12, 17, 8, 20, 43, tzinfo=datetime.timezone.utc)}, {'commit_sha': '77047dfe3b481f76b682c4c6d1aa7e4a21136a1a', 'committer_username': 'eregon', 'committer_name': 'Benoit Daloze', 'committer_email': None, 'commit_date': datetime.datetime(2009, 12, 17, 8, 20, 43, tzinfo=datetime.timezone.utc)}, {'commit_sha': '2ad59845dea03bd8745351090db90fadfe32393e', 'committer_username': 'moste00', 'committer_name': 'مصطفي محمود كمال الدين', 'committer_email': None, 'commit_date': datetime.datetime(2019, 3, 14, 18, 50, 41, tzinfo=datetime.timezone.utc)}, {'commit_sha': '6a74271bb0ef76e2367fbebb0f2d4bc5ad4ac48c', 'committer_username': 'moste00', 'committer_name': 'مصطفي محمود كمال الدين', 'committer_email': None, 'commit_date': datetime.datetime(2019, 3, 14, 18, 50, 41, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'a116b2252090f5f2d6daa0c69492e3a9ee341073', 'committer_username': 'moste00', 'committer_name': 'مصطفي محمود كمال الدين', 'committer_email': None, 'commit_date': datetime.datetime(2019, 3, 14, 18, 50, 41, tzinfo=datetime.timezone.utc)}, {'commit_sha': '2f78a96451469dbaa02fdf31f0823253e1fe08c8', 'committer_username': 'moste00', 'committer_name': 'مصطفي محمود كمال الدين', 'committer_email': None, 'commit_date': datetime.datetime(2019, 3, 14, 18, 50, 41, tzinfo=datetime.timezone.utc)}, {'commit_sha': '9de37391c1ef8ad6c8846a1d738787bf3c71798a', 'committer_username': 'eregon', 'committer_name': 'Benoit Daloze', 'committer_email': None, 'commit_date': datetime.datetime(2009, 12, 17, 8, 20, 43, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'fa79ed973d3fac07f024eb8dc239abdcc0fc5083', 'committer_username': 'eregon', 'committer_name': 'Benoit Daloze', 'committer_email': None, 'commit_date': datetime.datetime(2009, 12, 17, 8, 20, 43, tzinfo=datetime.timezone.utc)}, {'commit_sha': '7c2239317472db8c4a38f7d5c2a398fd2a071bec', 'committer_username': 'eregon', 'committer_name': 'Benoit Daloze', 'committer_email': None, 'commit_date': datetime.datetime(2009, 12, 17, 8, 20, 43, tzinfo=datetime.timezone.utc)}, {'commit_sha': '455d7fc3d8ee1eb1850b8b0b885b1a6396d07c79', 'committer_username': 'eregon', 'committer_name': 'Benoit Daloze', 'committer_email': None, 'commit_date': datetime.datetime(2009, 12, 17, 8, 20, 43, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'e5b2b6515f018ccb8620e970c7ed816141e85a19', 'committer_username': 'eregon', 'committer_name': 'Benoit Daloze', 'committer_email': None, 'commit_date': datetime.datetime(2009, 12, 17, 8, 20, 43, tzinfo=datetime.timezone.utc)}, {'commit_sha': '2beafa596ec6d99fdbfbecbfdbc1b7bcba49dc07', 'committer_username': 'eregon', 'committer_name': 'Benoit Daloze', 'committer_email': None, 'commit_date': datetime.datetime(2009, 12, 17, 8, 20, 43, tzinfo=datetime.timezone.utc)}, {'commit_sha': '984b4a66752a7074d410bb5d449e5cce829cb581', 'committer_username': 'eregon', 'committer_name': 'Benoit Daloze', 'committer_email': None, 'commit_date': datetime.datetime(2009, 12, 17, 8, 20, 43, tzinfo=datetime.timezone.utc)}, {'commit_sha': '867d26e18be7aa4cefb8926e610f50f091313540', 'committer_username': 'eregon', 'committer_name': 'Benoit Daloze', 'committer_email': None, 'commit_date': datetime.datetime(2009, 12, 17, 8, 20, 43, tzinfo=datetime.timezone.utc)}, {'commit_sha': '0c4cfdb61dca0d42bf22b670d960c38fc5172a60', 'committer_username': 'eregon', 'committer_name': 'Benoit Daloze', 'committer_email': None, 'commit_date': datetime.datetime(2009, 12, 17, 8, 20, 43, tzinfo=datetime.timezone.utc)}, {'commit_sha': '8c9072c8f1bd1e0f0d389289761f52e6f3183265', 'committer_username': 'eregon', 'committer_name': 'Benoit Daloze', 'committer_email': None, 'commit_date': datetime.datetime(2009, 12, 17, 8, 20, 43, tzinfo=datetime.timezone.utc)}, {'commit_sha': '8062a74317dcd0f6775b6e7797f4dbb99f5b3b78', 'committer_username': 'eregon', 'committer_name': 'Benoit Daloze', 'committer_email': None, 'commit_date': datetime.datetime(2009, 12, 17, 8, 20, 43, tzinfo=datetime.timezone.utc)}, {'commit_sha': '6a3ddad29f54d6c7745819115b0177c9f5adb88b', 'committer_username': 'eregon', 'committer_name': 'Benoit Daloze', 'committer_email': None, 'commit_date': datetime.datetime(2009, 12, 17, 8, 20, 43, tzinfo=datetime.timezone.utc)}, {'commit_sha': '07e1d837f04c764e569a32de4f61df51421a15ce', 'committer_username': 'eregon', 'committer_name': 'Benoit Daloze', 'committer_email': None, 'commit_date': datetime.datetime(2009, 12, 17, 8, 20, 43, tzinfo=datetime.timezone.utc)}]",مصطفي محمود كمال الدين,48567303,,User,,37,,6,31

Project_ID,Name,Full_name,Language,Forks,Stars,Watchers,contributors,commits,issues,branches,PRs_count,contributor pullrequests
51164398,truffleruby,oracle/truffleruby,Ruby,183,2995,78,485,67739,168,43,8,"[{'id': 1622654813, 'number': 3341, 'closed': datetime.datetime(2024, 1, 16, 2, 7, 46, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 11, 29, 21, 58, 21, tzinfo=datetime.timezone.utc), 'time_taken': 4075765.0, 'time_delta': '47 days, 4:09:25', 'additions': 307, 'deletions': 44, 'state': 'closed'}, {'id': 1525358670, 'number': 3275, 'closed': datetime.datetime(2023, 10, 30, 22, 59, 25, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 9, 21, 18, 17, 33, tzinfo=datetime.timezone.utc), 'time_taken': 3386512.0, 'time_delta': '39 days, 4:41:52', 'additions': 15, 'deletions': 15, 'state': 'closed'}, {'id': 1445428848, 'number': 3172, 'closed': datetime.datetime(2023, 12, 13, 14, 37, 36, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 7, 22, 21, 51, 14, tzinfo=datetime.timezone.utc), 'time_taken': 12415582.0, 'time_delta': '143 days, 16:46:22', 'additions': 981, 'deletions': 191, 'state': 'closed'}, {'id': 1265096711, 'number': 2909, 'closed': datetime.datetime(2023, 3, 14, 17, 51, 35, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 3, 6, 20, 0, 59, tzinfo=datetime.timezone.utc), 'time_taken': 683436.0, 'time_delta': '7 days, 21:50:36', 'additions': 29, 'deletions': 5, 'state': 'closed'}, {'id': 1265012828, 'number': 2908, 'closed': datetime.datetime(2023, 3, 15, 18, 20, 55, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 3, 6, 18, 50, 19, tzinfo=datetime.timezone.utc), 'time_taken': 775836.0, 'time_delta': '8 days, 23:30:36', 'additions': 3, 'deletions': 3, 'state': 'closed'}, {'id': 1264973958, 'number': 2907, 'closed': datetime.datetime(2023, 3, 15, 13, 51, 39, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 3, 6, 18, 16, 13, tzinfo=datetime.timezone.utc), 'time_taken': 761726.0, 'time_delta': '8 days, 19:35:26', 'additions': 83, 'deletions': 53, 'state': 'closed'}, {'id': 1262433391, 'number': 2905, 'closed': datetime.datetime(2023, 3, 7, 21, 49, 14, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 3, 3, 17, 47, 20, tzinfo=datetime.timezone.utc), 'time_taken': 360114.0, 'time_delta': '4 days, 4:01:54', 'additions': 27, 'deletions': 12, 'state': 'closed'}]"
