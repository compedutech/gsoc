pr_id,pr_title,pr_body,is_merged,pr_number,pr_url,pr_html_url,pr_state,additions,deletions,pr_changed_files,pr_commits_count,pr_comments_count,pr_review_comments_count,pr_labels_count,pr_assignees_count,pr_labels,pr_created_at,pr_closed_at,time_taken,time_delta,pr_review_comments,pr_commits,contributor,contributor_id,contributor_email,contributor_type,contributions,contributor_public_repos,contributor_private_repos,contributor_followings,contributor_followers
448615340,[GSoC] Implement Corrected Commit Date,"This patch series implements the corrected commit date offsets as generation number v2, along with other pre-requisites.

Git uses topological levels in the commit-graph file for commit-graph traversal operations like 'git log --graph'. Unfortunately, topological levels can perform worse than committer date when parents of a commit differ greatly in generation numbers [1]. For example, 'git merge-base v4.8 v4.9' on the Linux repository walks 635,579 commits using topological levels and walks 167,468 using committer date. Since 091f4cf3 (commit: don't use generation numbers if not needed, 2018-08-30), 'git merge-base' uses committer date heuristic unless there is a cutoff because of the performance hit.

[1] https://lore.kernel.org/git/efa3720fb40638e5d61c6130b55e3348d8e4339e.1535633886.git.gitgitgadget@gmail.com/

Thus, the need for generation number v2 was born. As Git used to die when graph version understood by it and in the commit-graph file are different [2], we needed a way to distinguish between the old and new generation number without incrementing the graph version.

[2] https://lore.kernel.org/git/87a7gdspo4.fsf@evledraar.gmail.com/

The following candidates were proposed (https://github.com/derrickstolee/gen-test, https://github.com/abhishekkumar2718/git/pull/1):
- (Epoch, Date) Pairs.
- Maximum Generation Numbers.
- Corrected Commit Date.
- FELINE Index.
- Corrected Commit Date with Monotonically Increasing Offsets.

Based on performance, local computability, and immutability (along with the introduction of an additional commit-graph chunk which relieved the requirement of backwards-compatibility) Corrected Commit Date was chosen as generation number v2 and is defined as follows:

For a commit C, let its corrected commit date  be the maximum of the commit date of C and the corrected commit dates of its parents plus 1. Then corrected commit date offset is the difference between corrected commit date of C and commit date of C. As a special case, a root commit with the timestamp zero has corrected commit date of 1 to distinguish it from GENERATION_NUMBER_ZERO (that is, an uncomputed generation number).

While it was proposed initially to store corrected commit date offsets within Commit Data Chunk, storing the offsets in a new chunk did not affect the performance measurably. The new chunk is ""Generation DATa (GDAT) chunk"" and it stores corrected commit date offsets while CDAT chunk stores topological level. The old versions of Git would ignore GDAT chunk, using topological levels from CDAT chunk. In contrast, new versions of Git would use corrected commit dates, falling back to topological level if the generation data chunk is absent in the commit-graph file.

While storing corrected commit date offsets saves us 4 bytes per commit (as compared with storing corrected commit dates directly), it's however possible for the offset to overflow the space allocated. To handle such cases, we introduce a new chunk, _Generation Data Overflow_ (GDOV) that stores the corrected commit date. For overflowing offsets, we set MSB and store the position into the GDOV chunk, in a mechanism similar to the Extra Edges list chunk.

For mixed generation number environment (for example new Git on the command line, old Git used by GUI client), we can encounter a mixed-chain commit-graph (a commit-graph chain where some of split commit-graph files have GDAT chunk and others do not). As backward compatibility is one of the goals, we can define the following behavior:

While reading a mixed-chain commit-graph version, we fall back on topological levels as corrected commit dates and topological levels cannot be compared directly.

When adding new layer to the split commit-graph file, and when merging some or all layers (replacing them in the latter case), the new layer will have GDAT chunk if and only if in the final result there would be no layer without GDAT chunk just below it.

Thanks to Dr. Stolee, Dr. Narębski, Taylor Blau and SZEDER Gábor for their reviews.

I look forward to everyone's reviews!

Thanks
- Abhishek

-----

Improvements left for a future series:
- Save commits with generation data overflow and extra edge commits instead of looping over all commits. cf. <858sbel67n.fsf@gmail.com>
- Verify both topological levels and corrected commit dates when present. cf. <85pn4tnk8u.fsf@gmail.com>

Changes in version 7:
- Moved the documentation patch ahead of ""commit-graph: implement corrected commit date"" and elaborated on the introduction of generation number v2.

Changes in version 6:
- Fixed typos in commit message for ""commit-graph: implement corrected commit date"".
- Removed an unnecessary else-block in ""commit-graph: implement corrected commit date"".
- Validate mixed generation chain correctly while writing in ""commit-graph: use generation v2 only if the entire chain does"".
- Die if the GDAT chunk indicates data has overflown but there are is no generation data overflow chunk.

Changes in version 5:
- Explained a possible reason for no change in performance for ""commit-graph: fix regression when computing bloom-filters""
- Clarified about the addition of a new test for 11-digit octal implementations of ustar.
- Fixed duplicate test names in ""commit-graph: consolidate fill_commit_graph_info"".
- Swapped the order ""commit-graph: return 64-bit generation number"", ""commit-graph: add a slab to store topological levels"" to minimize lines changed.
- Fixed the mismerge in ""commit-graph: return 64-bit generation number""
- Clarified the preparatory steps are for the larger goal of implementing generation number v2 in ""commit-graph: return 64-bit generation number"".
- Moved the rename of ""run_three_modes()"" to ""run_all_modes()"" into a new patch ""t6600-test-reach: generalize *_three_modes"".
- Explained and removed the checks for `GENERATION_NUMBER_INFINITY` that can never be true in ""commit-graph: add a slab to store topological levels"".
- Fixed incorrect logic for verifying commit-graph in ""commit-graph: implement corrected commit date"".
- Added minor improvements to commit message of ""commit-graph: implement generation data chunk"".
- Added '--date <date>' option to test_commit() in 'test-lib-functions.sh' in ""commit-graph: implement generation data chunk"".
- Improved coding style (also in tests) for ""commit-graph: use generation v2 only if entire chain does"".
- Simplified test repository structure in ""commit-graph: use generation v2 only if entire chain does"" as only the number of commits in a split commit-graph layer are relevant.
- Added a new test in ""commit-graph: use generation v2 only if entire chain does"" to check if the layers are merged correctly.
- Explicitly mentioned commit ""091f4cf3"" in the commit-message of ""commit-graph: use corrected commit dates in paint_down_to_common()"".
- Minor corrections to documentation in ""doc: add corrected commit date info"".
- Minor corrections to coding style.

Changes in version 4:
- Added GDOV to handle overflows in generation data.
- Added a test for writing tip graph for a generation number v2 graph chain in t5324-split-commit-graph.sh
- Added a section on how mixed generation number chains are handled in `Documentation/technical/commit-graph-format.txt`
- Reverted unimportant whitespace, style changes in commit-graph.c
- Added header comments about the order of comparision for  compare_commits_by_gen_then_commit_date in commit.h, compare_commits_by_gen in commit-graph.h
- Elaborated on why t6404 fails with corrected commit date and must be run with GIT_TEST_COMMIT_GRAPH=1in the commit ""commit-reach: use corrected commit dates in paint_down_to_common()""
- Elaborated on write behavior for mixed generation number chains in the commit ""commit-graph: use generation v2 only if entire chain does""
- Added notes about adding the topo_level slab to struct write_commit_graph_context as well as struct commit_graph.
- Clarified commit message for ""commit-graph: consolidate fill_commit_graph_info""
- Removed the claim ""GDAT can store future generation numbers"" because it hasn't been tested yet.


Changes in version 3:
- Reordered patches to implement corrected commit date before generation data chunk [3].
- Split ""implement corrected commit date"" into two patches - one introducing the topo level slab and other implementing corrected commit dates.
- Extended split-commit-graph tests to verify at the end of test.
- Use topological levels as generation number if any of split commit-graph files do not have generation data chunk.

[3] https://lore.kernel.org/git/aee0ae56-3395-6848-d573-27a318d72755@gmail.com/

Changes in version 2:
- Add tests for generation data chunk.
- Add an option `GIT_TEST_COMMIT_GRAPH_NO_GDAT` to control whether to write generation data chunk.
- Compare commits with corrected commit dates if present in paint_down_to_common().
- Update technical documentation.
- Handle mixed generation commit chains.
- Improve commit messages for ""commit-graph: fix regression when computing bloom filter"", ""commit-graph: consolidate fill_commit_graph_info"",
- Revert unnecessary whitespace changes.
- Split uint_32 -> timestamp_t change into a new commit.

cc: Derrick Stolee <stolee@gmail.com>, Jakub Narębski <jnareb@gmail.com>
cc: Abhishek Kumar <abhishekkumar8222@gmail.com>
cc: SZEDER Gábor <szeder.dev@gmail.com>
cc: Taylor Blau <me@ttaylorr.com>",False,676,https://api.github.com/repos/gitgitgadget/git/pulls/676,https://github.com/gitgitgadget/git/pull/676,closed,667,154,19,11,181,110,3,0,"[{'name': 'master'}, {'name': 'next'}, {'name': 'seen'}]",2020-07-14 03:10:29+00:00,2021-02-19 00:12:26+00:00,18997317.0,"219 days, 21:01:57","[{'comment_id': 458064665, 'comment_body': '`return -ret_val;`', 'comment_created': datetime.datetime(2020, 7, 21, 12, 41, 16, tzinfo=datetime.timezone.utc), 'commenter': 'derrickstolee', 'type': 'User'}, {'comment_id': 458066466, 'comment_body': ""1. You shouldn't need a `V2_INFINITY`, just change the value of `GENERATION_NUMBER_INFINITY`\r\n2. This value is wrong, isn't it? You have 9 hex digits. Perhaps make it super-clear by using something like `((1L << 63)-1)`, which will get compiled to the right constant."", 'comment_created': datetime.datetime(2020, 7, 21, 12, 44, 21, tzinfo=datetime.timezone.utc), 'commenter': 'derrickstolee', 'type': 'User'}, {'comment_id': 458067837, 'comment_body': 'This is incorrect, no? You need to add `item->date` to the offset that is returned.\r\n\r\n```c\r\nif (g->chunk_generation_data) {\r\n    timestamp_t offset =  get_be32(g->chunk_generation_data + sizeof(uint32_t) * lex_index);\r\n    graph_data->generation = item->date + offset;\r\n} else ...\r\n```\r\n```', 'comment_created': datetime.datetime(2020, 7, 21, 12, 46, 40, tzinfo=datetime.timezone.utc), 'commenter': 'derrickstolee', 'type': 'User'}, {'comment_id': 458069420, 'comment_body': 'Again, this isn\'t what you want: you want\r\n\r\n```\r\ntimestamp_t gen_v2 = commit_graph_data_at(*list)->generation;\r\ntimestamp_t offset = gen_v2 - (*list)->date;\r\n/* TODO: insert check if offset is too big, and write special offset for ""infinity"" */\r\nhashwrite_be32(f, offset);\r\n```', 'comment_created': datetime.datetime(2020, 7, 21, 12, 49, 19, tzinfo=datetime.timezone.utc), 'commenter': 'derrickstolee', 'type': 'User'}, {'comment_id': 458070037, 'comment_body': ""Keep in mind that you haven't actually computed the proper generation numbers yet. You've only computed v1 generation numbers and are storing them in a new location. Maybe this will make sense in a later commit."", 'comment_created': datetime.datetime(2020, 7, 21, 12, 50, 15, tzinfo=datetime.timezone.utc), 'commenter': 'derrickstolee', 'type': 'User'}, {'comment_id': 458070891, 'comment_body': 'Perhaps mark this as `test_expect_failure` so it can be handled as a TODO to fix later?', 'comment_created': datetime.datetime(2020, 7, 21, 12, 51, 44, tzinfo=datetime.timezone.utc), 'commenter': 'derrickstolee', 'type': 'User'}, {'comment_id': 458072103, 'comment_body': 'this should just be `uint64_t generation` and you fill it with the generation number available. Avoid multiple additions required in your comparisons.', 'comment_created': datetime.datetime(2020, 7, 21, 12, 53, 42, tzinfo=datetime.timezone.utc), 'commenter': 'derrickstolee', 'type': 'User'}, {'comment_id': 458305791, 'comment_body': ""I can see why you went this way, but it's due to a later commit implementing generation number v2 in a non-obvious way."", 'comment_created': datetime.datetime(2020, 7, 21, 18, 32, 13, tzinfo=datetime.timezone.utc), 'commenter': 'derrickstolee', 'type': 'User'}, {'comment_id': 458307314, 'comment_body': ""I think `data` should just have a `uint64_t generation`, and you fill that value with the v2 generation number (`date + offset`) when parsing the commit OR fill it with the v1 generation number if `GDAT` doesn't exist (again, when parsing the commit). That makes all of your other edits unnecessary, as we can just compare the `generation` directly and know we are correct one way or another."", 'comment_created': datetime.datetime(2020, 7, 21, 18, 34, 54, tzinfo=datetime.timezone.utc), 'commenter': 'derrickstolee', 'type': 'User'}, {'comment_id': 458307857, 'comment_body': ""I don't think we will want `level` at all if we have generation v2, right?"", 'comment_created': datetime.datetime(2020, 7, 21, 18, 35, 50, tzinfo=datetime.timezone.utc), 'commenter': 'derrickstolee', 'type': 'User'}, {'comment_id': 458308135, 'comment_body': 'But, if we are persisting it across the files, then I understand why you want to keep it in the struct.', 'comment_created': datetime.datetime(2020, 7, 21, 18, 36, 22, tzinfo=datetime.timezone.utc), 'commenter': 'derrickstolee', 'type': 'User'}, {'comment_id': 461562069, 'comment_body': ""[On the Git mailing list](https://lore.kernel.org/git/b997b649-cfeb-4b55-9c83-1c0ee2a5677c@gmail.com), Derrick Stolee wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn 7/28/2020 5:13 AM, Abhishek Kumar via GitGitGadget wrote:\n> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> \n> In indegree_walk_step(), we add unvisited parents to the indegree queue.\n> However, parents are not guaranteed to be parsed. As the indegree queue\n> sorts by generation number, let's parse parents before inserting them to\n> ensure the correct priority order.\n\nYou mentioned this in your blog post. I'm sorry that such a small\nissue caused you pain. Perhaps you could summarize a little bit of\nhow that investigation led you to find this issue?\n\nQuestion: is this something that is only necessary when we change\nthe generation number, or is it something that is only _exposed_\nby the test suite when we change the generation number? It seems that\nit is likely to be an existing bug, but it might be hard to expose\nin a test case.\n\n> Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> ---\n>  revision.c | 3 +++\n>  1 file changed, 3 insertions(+)\n> \n> diff --git a/revision.c b/revision.c\n> index 6aa7f4f567..23287d26c3 100644\n> --- a/revision.c\n> +++ b/revision.c\n> @@ -3343,6 +3343,9 @@ static void indegree_walk_step(struct rev_info *revs)\n>  \t\tstruct commit *parent = p->item;\n>  \t\tint *pi = indegree_slab_at(&info->indegree, parent);\n>  \n> +\t\tif (parse_commit_gently(parent, 1) < 0)\n> +\t\t\treturn ;\n\nDrop the extra space.\n\nThanks,\n-Stolee\n``````````\n"", 'comment_created': datetime.datetime(2020, 7, 28, 13, 3, 55, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 461572137, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/a9d50995-566d-cad2-ff67-8b8604b52eed@gmail.com), Derrick Stolee wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn 7/28/2020 5:13 AM, Abhishek Kumar via GitGitGadget wrote:\n> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> \n> Both fill_commit_graph_info() and fill_commit_in_graph() parse\n> information present in commit data chunk. Let\'s simplify the\n> implementation by calling fill_commit_graph_info() within\n> fill_commit_in_graph().\n> \n> The test \'generate tar with future mtime\' creates a commit with commit\n> time of (2 ^ 36 + 1) seconds since EPOCH. The commit time overflows into\n> generation number and has undefined behavior. The test used to pass as\n> fill_commit_in_graph() did not read commit time from commit graph,\n> reading commit date from odb instead.\n\nI was first confused as to why fill_commit_graph_info() did not\nload the timestamp, but the reason is that it is only used by\ntwo methods:\n\n1. fill_commit_in_graph(): this actually leaves the commit in a\n   ""parsed"" state, so the date must be correct. Thus, it parses\n   the date out of the commit-graph.\n\n2. load_commit_graph_info(): this only helps to guarantee we\n   know the graph_pos and generation number values.\n\nPerhaps add this extra context: you will _need_ the commit date\nfrom the commit-graph in order to populate the generation number\nv2 in fill_commit_graph_info().\n\n> Let\'s fix that by setting commit time of (2 ^ 34 - 1) seconds.\n\nThe timestamp limit placed in the commit-graph is more restrictive\nthan 64-bit timestamps, but as your test points out, the maximum\ntimestamp allowed takes place in the year 2514. That is far enough\naway for all real data.\n\n> Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> ---\n>  commit-graph.c      | 31 ++++++++++++-------------------\n>  t/t5000-tar-tree.sh |  4 ++--\n>  2 files changed, 14 insertions(+), 21 deletions(-)\n> \n> diff --git a/commit-graph.c b/commit-graph.c\n> index 5d3c9bd23c..204eb454b2 100644\n> --- a/commit-graph.c\n> +++ b/commit-graph.c\n> @@ -735,15 +735,24 @@ static void fill_commit_graph_info(struct commit *item, struct commit_graph *g,\n>  \tconst unsigned char *commit_data;\n>  \tstruct commit_graph_data *graph_data;\n>  \tuint32_t lex_index;\n> +\tuint64_t date_high, date_low;\n>  \n>  \twhile (pos < g->num_commits_in_base)\n>  \t\tg = g->base_graph;\n>  \n> +\tif (pos >= g->num_commits + g->num_commits_in_base)\n> +\t\tdie(_(""invalid commit position. commit-graph is likely corrupt""));\n> +\n>  \tlex_index = pos - g->num_commits_in_base;\n>  \tcommit_data = g->chunk_commit_data + GRAPH_DATA_WIDTH * lex_index;\n>  \n>  \tgraph_data = commit_graph_data_at(item);\n>  \tgraph_data->graph_pos = pos;\n> +\n> +\tdate_high = get_be32(commit_data + g->hash_len + 8) & 0x3;\n> +\tdate_low = get_be32(commit_data + g->hash_len + 12);\n> +\titem->date = (timestamp_t)((date_high << 32) | date_low);\n> +\n>  \tgraph_data->generation = get_be32(commit_data + g->hash_len + 8) >> 2;\n>  }\n>  \n> @@ -758,38 +767,22 @@ static int fill_commit_in_graph(struct repository *r,\n>  {\n>  \tuint32_t edge_value;\n>  \tuint32_t *parent_data_ptr;\n> -\tuint64_t date_low, date_high;\n>  \tstruct commit_list **pptr;\n> -\tstruct commit_graph_data *graph_data;\n>  \tconst unsigned char *commit_data;\n>  \tuint32_t lex_index;\n>  \n> +\tfill_commit_graph_info(item, g, pos);\n> +\n>  \twhile (pos < g->num_commits_in_base)\n>  \t\tg = g->base_graph;\n\nThis \'while\' loop happens in both implementations, so you could\nsave a miniscule amount of time by placing the call to\nfill_commit_graph_info() after the while loop.\n\n> -\tif (pos >= g->num_commits + g->num_commits_in_base)\n> -\t\tdie(_(""invalid commit position. commit-graph is likely corrupt""));\n\n> -\t/*\n> -\t * Store the ""full"" position, but then use the\n> -\t * ""local"" position for the rest of the calculation.\n> -\t */\n> -\tgraph_data = commit_graph_data_at(item);\n> -\tgraph_data->graph_pos = pos;\n>  \tlex_index = pos - g->num_commits_in_base;\n> -\n> -\tcommit_data = g->chunk_commit_data + (g->hash_len + 16) * lex_index;\n> +\tcommit_data = g->chunk_commit_data + GRAPH_DATA_WIDTH * lex_index;\n\nI was about to complain about this change, but GRAPH_DATA_WIDTH\nis a macro that does an equivalent thing (except the_hash_algo->rawsz\ninstead of g->hash_len).\n\n>  \n>  \titem->object.parsed = 1;\n>  \n>  \tset_commit_tree(item, NULL);\n>  \n> -\tdate_high = get_be32(commit_data + g->hash_len + 8) & 0x3;\n> -\tdate_low = get_be32(commit_data + g->hash_len + 12);\n> -\titem->date = (timestamp_t)((date_high << 32) | date_low);\n> -\n> -\tgraph_data->generation = get_be32(commit_data + g->hash_len + 8) >> 2;\n> -\n>  \tpptr = &item->parents;\n>  \n>  \tedge_value = get_be32(commit_data + g->hash_len);\n> diff --git a/t/t5000-tar-tree.sh b/t/t5000-tar-tree.sh\n> index 37655a237c..1986354fc3 100755\n> --- a/t/t5000-tar-tree.sh\n> +++ b/t/t5000-tar-tree.sh\n> @@ -406,7 +406,7 @@ test_expect_success TIME_IS_64BIT \'set up repository with far-future commit\' \'\n>  \trm -f .git/index &&\n>  \techo content >file &&\n>  \tgit add file &&\n> -\tGIT_COMMITTER_DATE=""@68719476737 +0000"" \\\n> +\tGIT_COMMITTER_DATE=""@17179869183 +0000"" \\\n>  \t\tgit commit -m ""tempori parendum""\n>  \'\n>  \n> @@ -415,7 +415,7 @@ test_expect_success TIME_IS_64BIT \'generate tar with future mtime\' \'\n>  \'\n>  \n>  test_expect_success TAR_HUGE,TIME_IS_64BIT,TIME_T_IS_64BIT \'system tar can read our future mtime\' \'\n> -\techo 4147 >expect &&\n> +\techo 2514 >expect &&\n>  \ttar_info future.tar | cut -d"" "" -f2 >actual &&\n>  \ttest_cmp expect actual\n>  \'\n> \n\nThanks,\n-Stolee\n``````````\n', 'comment_created': datetime.datetime(2020, 7, 28, 13, 18, 55, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 461667996, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/d4a613c1-f3e8-3789-2548-8344c4b976e9@web.de), René Scharfe wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\n[Had to remove stolee@gmail.com because with it my mail provider\n rejected this email with the following error message:\n\n   Requested action not taken: mailbox unavailable\n   invalid DNS MX or A/AAAA resource record.]\n\nAm 28.07.20 um 15:14 schrieb Derrick Stolee:\n> On 7/28/2020 5:13 AM, Abhishek Kumar via GitGitGadget wrote:\n>> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n>>\n>> Both fill_commit_graph_info() and fill_commit_in_graph() parse\n>> information present in commit data chunk. Let\'s simplify the\n>> implementation by calling fill_commit_graph_info() within\n>> fill_commit_in_graph().\n>>\n>> The test \'generate tar with future mtime\' creates a commit with commit\n>> time of (2 ^ 36 + 1) seconds since EPOCH. The commit time overflows into\n>> generation number and has undefined behavior. The test used to pass as\n>> fill_commit_in_graph() did not read commit time from commit graph,\n>> reading commit date from odb instead.\n>\n> I was first confused as to why fill_commit_graph_info() did not\n> load the timestamp, but the reason is that it is only used by\n> two methods:\n>\n> 1. fill_commit_in_graph(): this actually leaves the commit in a\n>    ""parsed"" state, so the date must be correct. Thus, it parses\n>    the date out of the commit-graph.\n>\n> 2. load_commit_graph_info(): this only helps to guarantee we\n>    know the graph_pos and generation number values.\n>\n> Perhaps add this extra context: you will _need_ the commit date\n> from the commit-graph in order to populate the generation number\n> v2 in fill_commit_graph_info().\n>\n>> Let\'s fix that by setting commit time of (2 ^ 34 - 1) seconds.\n>\n> The timestamp limit placed in the commit-graph is more restrictive\n> than 64-bit timestamps, but as your test points out, the maximum\n> timestamp allowed takes place in the year 2514. That is far enough\n> away for all real data.\n\nWe all may feel like the end of the world is imminent, but do we really\nneed to set such an arbitrary limit?  OK, that limit was already set two\nyears ago, and I\'m really late.  But still: It\'s sad to see anything\nelse than signed 64-bit timestamps to be used in fresh code (after Y2K).\nThe extra four bytes would fatten up the structures less than the\ntransition from SHA-1 to SHA-256 will, and no bit twiddling would be\nrequired.  *sigh*\n\nRené\n``````````\n', 'comment_created': datetime.datetime(2020, 7, 28, 15, 22, 27, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 461674341, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/20200728152844.GB87373@syl.lan), Taylor Blau wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Tue, Jul 28, 2020 at 09:13:46AM +0000, Abhishek Kumar via GitGitGadget wrote:\n> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n>\n> With 3d112755 (commit-graph: examine commits by generation number), Git\n> knew to sort by generation number before examining the diff when not\n> using pack order. c49c82aa (commit: move members graph_pos, generation\n> to a slab, 2020-06-17) moved generation number into a slab and\n> introduced a helper which returns GENERATION_NUMBER_INFINITY when\n> writing the graph. Sorting is no longer useful and essentially reverts\n> the earlier commit.\n\nThis last sentence is slightly confusing. Do you think it would be more\nclear if you said elaborated a bit? Perhaps something like:\n\n  [...]\n\n  commit_gen_cmp is used when writing a commit-graph to sort commits in\n  generation order before computing Bloom filters. Since c49c82aa made\n  it so that \'commit_graph_generation()\' returns\n  \'GENERATION_NUMBER_INFINITY\' during writing, we cannot call it within\n  this function. Instead, access the generation number directly through\n  the slab (i.e., by calling \'commit_graph_data_at(c)->generation\') in\n  order to access it while writing.\n\nI think the above would be a good extra paragraph in the commit message\nprovided that you remove the sentence beginning with ""Sorting is no\nlonger useful...""\n\n> Let\'s fix this by accessing generation number directly through the slab.\n>\n> Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> ---\n>  commit-graph.c | 5 +++--\n>  1 file changed, 3 insertions(+), 2 deletions(-)\n>\n> diff --git a/commit-graph.c b/commit-graph.c\n> index 1af68c297d..5d3c9bd23c 100644\n> --- a/commit-graph.c\n> +++ b/commit-graph.c\n> @@ -144,8 +144,9 @@ static int commit_gen_cmp(const void *va, const void *vb)\n>  \tconst struct commit *a = *(const struct commit **)va;\n>  \tconst struct commit *b = *(const struct commit **)vb;\n>\n> -\tuint32_t generation_a = commit_graph_generation(a);\n> -\tuint32_t generation_b = commit_graph_generation(b);\n> +\tuint32_t generation_a = commit_graph_data_at(a)->generation;\n> +\tuint32_t generation_b = commit_graph_data_at(b)->generation;\n> +\n\nNit; this whitespace diff is extraneous, but it\'s not hurting anything\neither. Since it looks like you\'re rerolling anyway, it would be good to\njust get rid of it.\n\nOtherwise this fix makes sense to me.\n\n>  \t/* lower generation commits first */\n>  \tif (generation_a < generation_b)\n>  \t\treturn -1;\n> --\n> gitgitgadget\n\nThanks,\nTaylor\n``````````\n', 'comment_created': datetime.datetime(2020, 7, 28, 15, 31, 6, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 461676751, 'comment_body': ""[On the Git mailing list](https://lore.kernel.org/git/20200728153042.GC87373@syl.lan), Taylor Blau wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Tue, Jul 28, 2020 at 09:00:51AM -0400, Derrick Stolee wrote:\n> On 7/28/2020 5:13 AM, Abhishek Kumar via GitGitGadget wrote:\n> > From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> >\n> > In indegree_walk_step(), we add unvisited parents to the indegree queue.\n> > However, parents are not guaranteed to be parsed. As the indegree queue\n> > sorts by generation number, let's parse parents before inserting them to\n> > ensure the correct priority order.\n>\n> You mentioned this in your blog post. I'm sorry that such a small\n> issue caused you pain. Perhaps you could summarize a little bit of\n> how that investigation led you to find this issue?\n\nIndeed ;-). I feel like forgetting to call 'parse_commit_gently()' is a\nrite of passage for this part of the code in some sense.\n\n> Question: is this something that is only necessary when we change\n> the generation number, or is it something that is only _exposed_\n> by the test suite when we change the generation number? It seems that\n> it is likely to be an existing bug, but it might be hard to expose\n> in a test case.\n\nI tend to agree that this bug probably existed before Abhishek's\nchanges, but that it's probably more trouble than it's worth to tickle\nwith a test case. So, I'd be fine with this fix as it is (provided that\nthe style nit is addressed below, too).\n\n> > Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> > ---\n> >  revision.c | 3 +++\n> >  1 file changed, 3 insertions(+)\n> >\n> > diff --git a/revision.c b/revision.c\n> > index 6aa7f4f567..23287d26c3 100644\n> > --- a/revision.c\n> > +++ b/revision.c\n> > @@ -3343,6 +3343,9 @@ static void indegree_walk_step(struct rev_info *revs)\n> >  \t\tstruct commit *parent = p->item;\n> >  \t\tint *pi = indegree_slab_at(&info->indegree, parent);\n> >\n> > +\t\tif (parse_commit_gently(parent, 1) < 0)\n> > +\t\t\treturn ;\n>\n> Drop the extra space.\n>\n> Thanks,\n> -Stolee\n\nThanks,\nTaylor\n``````````\n"", 'comment_created': datetime.datetime(2020, 7, 28, 15, 34, 40, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 461693498, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/e8646aaa-667f-b7d8-f8f2-efbaaeb8877d@gmail.com), Derrick Stolee wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn 7/28/2020 5:13 AM, Abhishek Kumar via GitGitGadget wrote:\n> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> \n> With preparations done,...\n\nI feel like this commit could have been made smaller by doing the\nuint32_t -> timestamp_t conversion in a separate patch. That would\nmake it easier to focus on the changes to the generation number v2\nlogic.\n\n> let\'s implement corrected commit date offset.\n> We add a new commit-slab to store topological levels while writing\n\nIt\'s important to add: we store topological levels to ensure that older\nversions of Git will still have the performance benefits from generation\nnumber v1.\n\n> commit graph and upgrade number of struct commit_graph_data to 64-bits.\n\nDo you mean ""update the generation member in struct commit_graph_data\nto a 64-bit timestamp""? The struct itself also has the 32-bit graph_pos\nmember.\n\n> We have to touch many files, upgrading generation number from uint32_t\n> to timestamp_t.\n\nYes, that\'s why I recommend doing that in a different step.\n\n> We drop \'detect incorrect generation number\' from t5318-commit-graph.sh,\n> which tests if verify can detect if a commit graph have\n> GENERATION_NUMBER_ZERO for a commit, followed by a non-zero generation.\n> With corrected commit dates, GENERATION_NUMBER_ZERO is possible only if\n> one of dates is Unix epoch zero.\n\nWhat about the topological levels? Are we caring about verifying the data\nthat we start to ignore in this new version? I\'m hesitant to drop this\nright now, but I\'m open to it if we really don\'t see it as a valuable test.\n\n> Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> ---\n>  blame.c                 |   2 +-\n>  commit-graph.c          | 109 ++++++++++++++++++++++------------------\n>  commit-graph.h          |   4 +-\n>  commit-reach.c          |  32 ++++++------\n>  commit-reach.h          |   2 +-\n>  commit.h                |   3 ++\n>  revision.c              |  14 +++---\n>  t/t5318-commit-graph.sh |   2 +-\n>  upload-pack.c           |   2 +-\n>  9 files changed, 93 insertions(+), 77 deletions(-)\n> \n> diff --git a/blame.c b/blame.c\n> index 82fa16d658..48aa632461 100644\n> --- a/blame.c\n> +++ b/blame.c\n> @@ -1272,7 +1272,7 @@ static int maybe_changed_path(struct repository *r,\n>  \tif (!bd)\n>  \t\treturn 1;\n>  \n> -\tif (commit_graph_generation(origin->commit) == GENERATION_NUMBER_INFINITY)\n> +\tif (commit_graph_generation(origin->commit) == GENERATION_NUMBER_V2_INFINITY)\n>  \t\treturn 1;\n\nI don\'t see value in changing the name of this macro. It\nis only used as the default value for a commit not in the\ncommit-graph. Changing its value to 0xFFFFFFFF works for\nboth versions when the type is updated to timestamp_t.\n\nThe actually-important change in this patch (not just the\ntype change) is here:\n\n> -static void compute_generation_numbers(struct write_commit_graph_context *ctx)\n> +static void compute_corrected_commit_date_offsets(struct write_commit_graph_context *ctx)\n>  {\n>  \tint i;\n>  \tstruct commit_list *list = NULL;\n> @@ -1326,11 +1334,11 @@ static void compute_generation_numbers(struct write_commit_graph_context *ctx)\n>  \t\t\t\t\t_(""Computing commit graph generation numbers""),\n>  \t\t\t\t\tctx->commits.nr);\n>  \tfor (i = 0; i < ctx->commits.nr; i++) {\n> -\t\tuint32_t generation = commit_graph_data_at(ctx->commits.list[i])->generation;\n> +\t\tuint32_t topo_level = *topo_level_slab_at(ctx->topo_levels, ctx->commits.list[i]);\n>  \n>  \t\tdisplay_progress(ctx->progress, i + 1);\n> -\t\tif (generation != GENERATION_NUMBER_INFINITY &&\n> -\t\t    generation != GENERATION_NUMBER_ZERO)\n> +\t\tif (topo_level != GENERATION_NUMBER_INFINITY &&\n> +\t\t    topo_level != GENERATION_NUMBER_ZERO)\n>  \t\t\tcontinue;\n\nHere, our ""skip"" condition is that the topo_level has been computed.\nThis should be fine, as we are never reading that out of the commit-graph.\nWe will never be in a mode where topo_level is computed but corrected\ncommit-date is not.\n\n>  \t\tcommit_list_insert(ctx->commits.list[i], &list);\n> @@ -1338,29 +1346,38 @@ static void compute_generation_numbers(struct write_commit_graph_context *ctx)\n>  \t\t\tstruct commit *current = list->item;\n>  \t\t\tstruct commit_list *parent;\n>  \t\t\tint all_parents_computed = 1;\n> -\t\t\tuint32_t max_generation = 0;\n> +\t\t\tuint32_t max_level = 0;\n> +\t\t\ttimestamp_t max_corrected_commit_date = current->date;\n\nLater you assign data->generation to be ""max_corrected_commit_date + 1"",\nwhich made me think this should be ""current->date - 1"". Is that so? Or,\ndo we want most offsets to be one instead of zero? Is there value there?\n\n>  \n>  \t\t\tfor (parent = current->parents; parent; parent = parent->next) {\n> -\t\t\t\tgeneration = commit_graph_data_at(parent->item)->generation;\n> +\t\t\t\ttopo_level = *topo_level_slab_at(ctx->topo_levels, parent->item);\n>  \n> -\t\t\t\tif (generation == GENERATION_NUMBER_INFINITY ||\n> -\t\t\t\t    generation == GENERATION_NUMBER_ZERO) {\n> +\t\t\t\tif (topo_level == GENERATION_NUMBER_INFINITY ||\n> +\t\t\t\t    topo_level == GENERATION_NUMBER_ZERO) {\n>  \t\t\t\t\tall_parents_computed = 0;\n>  \t\t\t\t\tcommit_list_insert(parent->item, &list);\n>  \t\t\t\t\tbreak;\n> -\t\t\t\t} else if (generation > max_generation) {\n> -\t\t\t\t\tmax_generation = generation;\n> +\t\t\t\t} else {\n> +\t\t\t\t\tstruct commit_graph_data *data = commit_graph_data_at(parent->item);\n> +\n> +\t\t\t\t\tif (topo_level > max_level)\n> +\t\t\t\t\t\tmax_level = topo_level;\n> +\n> +\t\t\t\t\tif (data->generation > max_corrected_commit_date)\n> +\t\t\t\t\t\tmax_corrected_commit_date = data->generation;\n>  \t\t\t\t}\n>  \t\t\t}\n>  \n>  \t\t\tif (all_parents_computed) {\n>  \t\t\t\tstruct commit_graph_data *data = commit_graph_data_at(current);\n>  \n> -\t\t\t\tdata->generation = max_generation + 1;\n> -\t\t\t\tpop_commit(&list);\n> +\t\t\t\tif (max_level > GENERATION_NUMBER_MAX - 1)\n> +\t\t\t\t\tmax_level = GENERATION_NUMBER_MAX - 1;\n> +\n> +\t\t\t\t*topo_level_slab_at(ctx->topo_levels, current) = max_level + 1;\n> +\t\t\t\tdata->generation = max_corrected_commit_date + 1;\n>  \n> -\t\t\t\tif (data->generation > GENERATION_NUMBER_MAX)\n> -\t\t\t\t\tdata->generation = GENERATION_NUMBER_MAX;\n> +\t\t\t\tpop_commit(&list);\n>  \t\t\t}\n>  \t\t}\n>  \t}\n\nThis looks correct, and I\'ve done a tiny bit of perf tests locally.\n\n> @@ -2085,6 +2102,7 @@ int write_commit_graph(struct object_directory *odb,\n>  \tuint32_t i, count_distinct = 0;\n>  \tint res = 0;\n>  \tint replace = 0;\n> +\tstruct topo_level_slab topo_levels;\n>  \n>  \tif (!commit_graph_compatible(the_repository))\n>  \t\treturn 0;\n> @@ -2099,6 +2117,9 @@ int write_commit_graph(struct object_directory *odb,\n>  \tctx->changed_paths = flags & COMMIT_GRAPH_WRITE_BLOOM_FILTERS ? 1 : 0;\n>  \tctx->total_bloom_filter_data_size = 0;\n>  \n> +\tinit_topo_level_slab(&topo_levels);\n> +\tctx->topo_levels = &topo_levels;\n> +\n>  \tif (ctx->split) {\n>  \t\tstruct commit_graph *g;\n>  \t\tprepare_commit_graph(ctx->r);\n> @@ -2197,7 +2218,7 @@ int write_commit_graph(struct object_directory *odb,\n>  \t} else\n>  \t\tctx->num_commit_graphs_after = 1;\n>  \n> -\tcompute_generation_numbers(ctx);\n> +\tcompute_corrected_commit_date_offsets(ctx);\n\nThis rename might not be necessary. You are computing both\nversions (v1 and v2) so the name change is actually less\naccurate than the old name.\n\nThanks,\n-Stolee\n\n``````````\n', 'comment_created': datetime.datetime(2020, 7, 28, 15, 58, 12, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 461695693, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/542e98f1-f793-5290-02ae-3e4706765b80@gmail.com), Derrick Stolee wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn 7/28/2020 11:19 AM, René Scharfe wrote:\n> [Had to remove stolee@gmail.com because with it my mail provider\n>  rejected this email with the following error message:\n> \n>    Requested action not taken: mailbox unavailable\n>    invalid DNS MX or A/AAAA resource record.]\n> \n> Am 28.07.20 um 15:14 schrieb Derrick Stolee:\n>> On 7/28/2020 5:13 AM, Abhishek Kumar via GitGitGadget wrote:\n>>> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n>>>\n>>> Both fill_commit_graph_info() and fill_commit_in_graph() parse\n>>> information present in commit data chunk. Let\'s simplify the\n>>> implementation by calling fill_commit_graph_info() within\n>>> fill_commit_in_graph().\n>>>\n>>> The test \'generate tar with future mtime\' creates a commit with commit\n>>> time of (2 ^ 36 + 1) seconds since EPOCH. The commit time overflows into\n>>> generation number and has undefined behavior. The test used to pass as\n>>> fill_commit_in_graph() did not read commit time from commit graph,\n>>> reading commit date from odb instead.\n>>\n>> I was first confused as to why fill_commit_graph_info() did not\n>> load the timestamp, but the reason is that it is only used by\n>> two methods:\n>>\n>> 1. fill_commit_in_graph(): this actually leaves the commit in a\n>>    ""parsed"" state, so the date must be correct. Thus, it parses\n>>    the date out of the commit-graph.\n>>\n>> 2. load_commit_graph_info(): this only helps to guarantee we\n>>    know the graph_pos and generation number values.\n>>\n>> Perhaps add this extra context: you will _need_ the commit date\n>> from the commit-graph in order to populate the generation number\n>> v2 in fill_commit_graph_info().\n>>\n>>> Let\'s fix that by setting commit time of (2 ^ 34 - 1) seconds.\n>>\n>> The timestamp limit placed in the commit-graph is more restrictive\n>> than 64-bit timestamps, but as your test points out, the maximum\n>> timestamp allowed takes place in the year 2514. That is far enough\n>> away for all real data.\n> \n> We all may feel like the end of the world is imminent, but do we really\n> need to set such an arbitrary limit?  OK, that limit was already set two\n> years ago, and I\'m really late.  But still: It\'s sad to see anything\n> else than signed 64-bit timestamps to be used in fresh code (after Y2K).\n> The extra four bytes would fatten up the structures less than the\n> transition from SHA-1 to SHA-256 will, and no bit twiddling would be\n> required.  *sigh*\n\nOne thing to consider after generation number v2 is out long enough\nis if we could drop the topo-levels and write zeroes for the topo-\nlevel portion. This was valid data in the first version of the\ncommit-graph, so it would still be valid. Then, we could allow\nfull 64-bit timestamps again.\n\nThis is something to think about again in a year, maybe.\n\nThanks,\n-Stolee\n\n``````````\n', 'comment_created': datetime.datetime(2020, 7, 28, 16, 1, 19, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 461697617, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/20200728160134.GD87373@syl.lan), Taylor Blau wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Tue, Jul 28, 2020 at 09:14:42AM -0400, Derrick Stolee wrote:\n> On 7/28/2020 5:13 AM, Abhishek Kumar via GitGitGadget wrote:\n> > From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> >\n> > Both fill_commit_graph_info() and fill_commit_in_graph() parse\n> > information present in commit data chunk. Let\'s simplify the\n> > implementation by calling fill_commit_graph_info() within\n> > fill_commit_in_graph().\n> >\n> > The test \'generate tar with future mtime\' creates a commit with commit\n> > time of (2 ^ 36 + 1) seconds since EPOCH. The commit time overflows into\n> > generation number and has undefined behavior. The test used to pass as\n> > fill_commit_in_graph() did not read commit time from commit graph,\n> > reading commit date from odb instead.\n>\n> I was first confused as to why fill_commit_graph_info() did not\n> load the timestamp, but the reason is that it is only used by\n> two methods:\n>\n> 1. fill_commit_in_graph(): this actually leaves the commit in a\n>    ""parsed"" state, so the date must be correct. Thus, it parses\n>    the date out of the commit-graph.\n>\n> 2. load_commit_graph_info(): this only helps to guarantee we\n>    know the graph_pos and generation number values.\n>\n> Perhaps add this extra context: you will _need_ the commit date\n> from the commit-graph in order to populate the generation number\n> v2 in fill_commit_graph_info().\n>\n> > Let\'s fix that by setting commit time of (2 ^ 34 - 1) seconds.\n>\n> The timestamp limit placed in the commit-graph is more restrictive\n> than 64-bit timestamps, but as your test points out, the maximum\n> timestamp allowed takes place in the year 2514. That is far enough\n> away for all real data.\n>\n> > Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> > ---\n> >  commit-graph.c      | 31 ++++++++++++-------------------\n> >  t/t5000-tar-tree.sh |  4 ++--\n> >  2 files changed, 14 insertions(+), 21 deletions(-)\n> >\n> > diff --git a/commit-graph.c b/commit-graph.c\n> > index 5d3c9bd23c..204eb454b2 100644\n> > --- a/commit-graph.c\n> > +++ b/commit-graph.c\n> > @@ -735,15 +735,24 @@ static void fill_commit_graph_info(struct commit *item, struct commit_graph *g,\n> >  \tconst unsigned char *commit_data;\n> >  \tstruct commit_graph_data *graph_data;\n> >  \tuint32_t lex_index;\n> > +\tuint64_t date_high, date_low;\n> >\n> >  \twhile (pos < g->num_commits_in_base)\n> >  \t\tg = g->base_graph;\n> >\n> > +\tif (pos >= g->num_commits + g->num_commits_in_base)\n> > +\t\tdie(_(""invalid commit position. commit-graph is likely corrupt""));\n> > +\n> >  \tlex_index = pos - g->num_commits_in_base;\n> >  \tcommit_data = g->chunk_commit_data + GRAPH_DATA_WIDTH * lex_index;\n> >\n> >  \tgraph_data = commit_graph_data_at(item);\n> >  \tgraph_data->graph_pos = pos;\n> > +\n> > +\tdate_high = get_be32(commit_data + g->hash_len + 8) & 0x3;\n> > +\tdate_low = get_be32(commit_data + g->hash_len + 12);\n> > +\titem->date = (timestamp_t)((date_high << 32) | date_low);\n> > +\n> >  \tgraph_data->generation = get_be32(commit_data + g->hash_len + 8) >> 2;\n> >  }\n> >\n> > @@ -758,38 +767,22 @@ static int fill_commit_in_graph(struct repository *r,\n> >  {\n> >  \tuint32_t edge_value;\n> >  \tuint32_t *parent_data_ptr;\n> > -\tuint64_t date_low, date_high;\n> >  \tstruct commit_list **pptr;\n> > -\tstruct commit_graph_data *graph_data;\n> >  \tconst unsigned char *commit_data;\n> >  \tuint32_t lex_index;\n> >\n> > +\tfill_commit_graph_info(item, g, pos);\n> > +\n> >  \twhile (pos < g->num_commits_in_base)\n> >  \t\tg = g->base_graph;\n>\n> This \'while\' loop happens in both implementations, so you could\n> save a miniscule amount of time by placing the call to\n> fill_commit_graph_info() after the while loop.\n>\n> > -\tif (pos >= g->num_commits + g->num_commits_in_base)\n> > -\t\tdie(_(""invalid commit position. commit-graph is likely corrupt""));\n>\n> > -\t/*\n> > -\t * Store the ""full"" position, but then use the\n> > -\t * ""local"" position for the rest of the calculation.\n> > -\t */\n> > -\tgraph_data = commit_graph_data_at(item);\n> > -\tgraph_data->graph_pos = pos;\n> >  \tlex_index = pos - g->num_commits_in_base;\n> > -\n> > -\tcommit_data = g->chunk_commit_data + (g->hash_len + 16) * lex_index;\n> > +\tcommit_data = g->chunk_commit_data + GRAPH_DATA_WIDTH * lex_index;\n>\n> I was about to complain about this change, but GRAPH_DATA_WIDTH\n> is a macro that does an equivalent thing (except the_hash_algo->rawsz\n> instead of g->hash_len).\n>\n> >\n> >  \titem->object.parsed = 1;\n> >\n> >  \tset_commit_tree(item, NULL);\n> >\n> > -\tdate_high = get_be32(commit_data + g->hash_len + 8) & 0x3;\n> > -\tdate_low = get_be32(commit_data + g->hash_len + 12);\n> > -\titem->date = (timestamp_t)((date_high << 32) | date_low);\n> > -\n> > -\tgraph_data->generation = get_be32(commit_data + g->hash_len + 8) >> 2;\n> > -\n> >  \tpptr = &item->parents;\n> >\n> >  \tedge_value = get_be32(commit_data + g->hash_len);\n> > diff --git a/t/t5000-tar-tree.sh b/t/t5000-tar-tree.sh\n> > index 37655a237c..1986354fc3 100755\n> > --- a/t/t5000-tar-tree.sh\n> > +++ b/t/t5000-tar-tree.sh\n> > @@ -406,7 +406,7 @@ test_expect_success TIME_IS_64BIT \'set up repository with far-future commit\' \'\n> >  \trm -f .git/index &&\n> >  \techo content >file &&\n> >  \tgit add file &&\n> > -\tGIT_COMMITTER_DATE=""@68719476737 +0000"" \\\n> > +\tGIT_COMMITTER_DATE=""@17179869183 +0000"" \\\n> >  \t\tgit commit -m ""tempori parendum""\n> >  \'\n> >\n> > @@ -415,7 +415,7 @@ test_expect_success TIME_IS_64BIT \'generate tar with future mtime\' \'\n> >  \'\n> >\n> >  test_expect_success TAR_HUGE,TIME_IS_64BIT,TIME_T_IS_64BIT \'system tar can read our future mtime\' \'\n> > -\techo 4147 >expect &&\n> > +\techo 2514 >expect &&\n> >  \ttar_info future.tar | cut -d"" "" -f2 >actual &&\n> >  \ttest_cmp expect actual\n> >  \'\n> >\n>\n> Thanks,\n> -Stolee\n\nAgreed with Stolee\'s review, but otherwise this looks like a faithful\ntransformation.\n\nThanks,\nTaylor\n``````````\n', 'comment_created': datetime.datetime(2020, 7, 28, 16, 4, 13, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 461697635, 'comment_body': ""[On the Git mailing list](https://lore.kernel.org/git/20200728160326.GE87373@syl.lan), Taylor Blau wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Tue, Jul 28, 2020 at 09:13:49AM +0000, Abhishek Kumar via GitGitGadget wrote:\n> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n>\n> Comparing commits by generation has been independently defined twice, in\n> commit-reach and commit. Let's simplify the implementation by moving\n> compare_commits_by_gen() to commit-graph.\n>\n> Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> ---\n>  commit-graph.c | 15 +++++++++++++++\n>  commit-graph.h |  2 ++\n>  commit-reach.c | 15 ---------------\n>  commit.c       |  9 +++------\n>  4 files changed, 20 insertions(+), 21 deletions(-)\n\nAll looks good to me.\n\n  Reviewed-by: Taylor Blau <me@ttaylorr.com>\n\nThanks,\nTaylor\n``````````\n"", 'comment_created': datetime.datetime(2020, 7, 28, 16, 4, 14, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 461705830, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/20200728161250.GF87373@syl.lan), Taylor Blau wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Tue, Jul 28, 2020 at 09:13:50AM +0000, Abhishek Kumar via GitGitGadget wrote:\n> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n>\n> One of the essential pre-requisites before implementing generation\n> number as to distinguish between generation numbers v1 and v2 while\n\ns/as/is\n\n> still being compatible with old Git.\n\nMaybe you could add a section here to talk about why this is needed\nspecifically? That is, you mention it\'s a prerequisite, but a reader in\na year or two may not remember why. Adding that information here would\nbe good.\n\n> We are going to introduce a new chunk called Generation Data chunk (or\n> GDAT). GDAT stores generation number v2 (and any subsequent versions),\n> whereas CDAT will still store topological level.\n>\n> Old Git does not understand GDAT chunk and would ignore it, reading\n> topological levels from CDAT. Newer versions of Git can parse GDAT and\n> take advantage of newer generation numbers, falling back to topological\n> levels when GDAT chunk is missing (as it would happen with a commit\n> graph written by old Git).\n\n...this is exactly the paragraph that I was looking for above. Could you\nswap the order of these last two paragraphs? I think that it would make\nthe patch message far clearer.\n>\n> Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> ---\n>  commit-graph.c                | 33 +++++++++++++++++++++++++++++----\n>  commit-graph.h                |  1 +\n>  t/helper/test-read-graph.c    |  2 ++\n>  t/t4216-log-bloom.sh          |  4 ++--\n>  t/t5318-commit-graph.sh       | 19 +++++++++++--------\n>  t/t5324-split-commit-graph.sh | 12 ++++++------\n>  6 files changed, 51 insertions(+), 20 deletions(-)\n>\n> diff --git a/commit-graph.c b/commit-graph.c\n> index 1c98f38d69..ab714f4a76 100644\n> --- a/commit-graph.c\n> +++ b/commit-graph.c\n> @@ -38,11 +38,12 @@ void git_test_write_commit_graph_or_die(void)\n>  #define GRAPH_CHUNKID_OIDFANOUT 0x4f494446 /* ""OIDF"" */\n>  #define GRAPH_CHUNKID_OIDLOOKUP 0x4f49444c /* ""OIDL"" */\n>  #define GRAPH_CHUNKID_DATA 0x43444154 /* ""CDAT"" */\n> +#define GRAPH_CHUNKID_GENERATION_DATA 0x47444154 /* ""GDAT"" */\n>  #define GRAPH_CHUNKID_EXTRAEDGES 0x45444745 /* ""EDGE"" */\n>  #define GRAPH_CHUNKID_BLOOMINDEXES 0x42494458 /* ""BIDX"" */\n>  #define GRAPH_CHUNKID_BLOOMDATA 0x42444154 /* ""BDAT"" */\n>  #define GRAPH_CHUNKID_BASE 0x42415345 /* ""BASE"" */\n> -#define MAX_NUM_CHUNKS 7\n> +#define MAX_NUM_CHUNKS 8\n\nUgh. I am simultaneously working on a new chunk myself (so a bad\nconflict resolution would look at both of us incrementing this number\nto the same value without generating a conflict.)\n\nI think the right thing to do here would be to define an enum over chunk\nnames, and then index an array by that enum (where the value at each\nindex is the chunk identifier). Then, the last value of that enum would\nbe a \'__COUNT\' which you could use to initialize the array (as well as\nwithin the commit-graph writing routines).\n\nAnyway, I think that it\'s probably not worth it in the meantime, but it\nis something that Junio should look out for when merging (if yours and\nmy topic happen to get merged around the same time, which they may not).\n\n>  #define GRAPH_DATA_WIDTH (the_hash_algo->rawsz + 16)\n>\n> @@ -389,6 +390,13 @@ struct commit_graph *parse_commit_graph(void *graph_map, size_t graph_size)\n>  \t\t\t\tgraph->chunk_commit_data = data + chunk_offset;\n>  \t\t\tbreak;\n>\n> +\t\tcase GRAPH_CHUNKID_GENERATION_DATA:\n> +\t\t\tif (graph->chunk_generation_data)\n> +\t\t\t\tchunk_repeated = 1;\n> +\t\t\telse\n> +\t\t\t\tgraph->chunk_generation_data = data + chunk_offset;\n> +\t\t\tbreak;\n> +\n>  \t\tcase GRAPH_CHUNKID_EXTRAEDGES:\n>  \t\t\tif (graph->chunk_extra_edges)\n>  \t\t\t\tchunk_repeated = 1;\n> @@ -768,7 +776,10 @@ static void fill_commit_graph_info(struct commit *item, struct commit_graph *g,\n>  \tdate_low = get_be32(commit_data + g->hash_len + 12);\n>  \titem->date = (timestamp_t)((date_high << 32) | date_low);\n>\n> -\tgraph_data->generation = get_be32(commit_data + g->hash_len + 8) >> 2;\n> +\tif (g->chunk_generation_data)\n> +\t\tgraph_data->generation = get_be32(g->chunk_generation_data + sizeof(uint32_t) * lex_index);\n> +\telse\n> +\t\tgraph_data->generation = get_be32(commit_data + g->hash_len + 8) >> 2;\n>  }\n>\n>  static inline void set_commit_tree(struct commit *c, struct tree *t)\n> @@ -1100,6 +1111,17 @@ static void write_graph_chunk_data(struct hashfile *f, int hash_len,\n>  \t}\n>  }\n>\n> +static void write_graph_chunk_generation_data(struct hashfile *f,\n> +\t\t\t\t\t      struct write_commit_graph_context *ctx)\n> +{\n> +\tstruct commit **list = ctx->commits.list;\n> +\tint count;\n> +\tfor (count = 0; count < ctx->commits.nr; count++, list++) {\n> +\t\tdisplay_progress(ctx->progress, ++ctx->progress_cnt);\n> +\t\thashwrite_be32(f, commit_graph_data_at(*list)->generation);\n> +\t}\n> +}\n> +\n\nThis pointer arithmetic is not necessary. Why not like:\n\n  int i;\n  for (i = 0; i < ctx->commits.nr; i++) {\n    struct commit *c = ctx->commits.list[i];\n    display_progress(ctx->progress, ++ctx->progress_cnt);\n    hashwrite_be32(f, commit_graph_data_at(c)->generation);\n  }\n\ninstead?\n\n>  static void write_graph_chunk_extra_edges(struct hashfile *f,\n>  \t\t\t\t\t  struct write_commit_graph_context *ctx)\n>  {\n> @@ -1605,7 +1627,7 @@ static int write_commit_graph_file(struct write_commit_graph_context *ctx)\n>  \tuint64_t chunk_offsets[MAX_NUM_CHUNKS + 1];\n>  \tconst unsigned hashsz = the_hash_algo->rawsz;\n>  \tstruct strbuf progress_title = STRBUF_INIT;\n> -\tint num_chunks = 3;\n> +\tint num_chunks = 4;\n>  \tstruct object_id file_hash;\n>  \tconst struct bloom_filter_settings bloom_settings = DEFAULT_BLOOM_FILTER_SETTINGS;\n>\n> @@ -1656,6 +1678,7 @@ static int write_commit_graph_file(struct write_commit_graph_context *ctx)\n>  \tchunk_ids[0] = GRAPH_CHUNKID_OIDFANOUT;\n>  \tchunk_ids[1] = GRAPH_CHUNKID_OIDLOOKUP;\n>  \tchunk_ids[2] = GRAPH_CHUNKID_DATA;\n> +\tchunk_ids[3] = GRAPH_CHUNKID_GENERATION_DATA;\n>  \tif (ctx->num_extra_edges) {\n>  \t\tchunk_ids[num_chunks] = GRAPH_CHUNKID_EXTRAEDGES;\n>  \t\tnum_chunks++;\n> @@ -1677,8 +1700,9 @@ static int write_commit_graph_file(struct write_commit_graph_context *ctx)\n>  \tchunk_offsets[1] = chunk_offsets[0] + GRAPH_FANOUT_SIZE;\n>  \tchunk_offsets[2] = chunk_offsets[1] + hashsz * ctx->commits.nr;\n>  \tchunk_offsets[3] = chunk_offsets[2] + (hashsz + 16) * ctx->commits.nr;\n> +\tchunk_offsets[4] = chunk_offsets[3] + sizeof(uint32_t) * ctx->commits.nr;\n>\n> -\tnum_chunks = 3;\n> +\tnum_chunks = 4;\n>  \tif (ctx->num_extra_edges) {\n>  \t\tchunk_offsets[num_chunks + 1] = chunk_offsets[num_chunks] +\n>  \t\t\t\t\t\t4 * ctx->num_extra_edges;\n> @@ -1728,6 +1752,7 @@ static int write_commit_graph_file(struct write_commit_graph_context *ctx)\n>  \twrite_graph_chunk_fanout(f, ctx);\n>  \twrite_graph_chunk_oids(f, hashsz, ctx);\n>  \twrite_graph_chunk_data(f, hashsz, ctx);\n> +\twrite_graph_chunk_generation_data(f, ctx);\n>  \tif (ctx->num_extra_edges)\n>  \t\twrite_graph_chunk_extra_edges(f, ctx);\n>  \tif (ctx->changed_paths) {\n> diff --git a/commit-graph.h b/commit-graph.h\n> index 98cc5a3b9d..e3d4ba96f4 100644\n> --- a/commit-graph.h\n> +++ b/commit-graph.h\n> @@ -67,6 +67,7 @@ struct commit_graph {\n>  \tconst uint32_t *chunk_oid_fanout;\n>  \tconst unsigned char *chunk_oid_lookup;\n>  \tconst unsigned char *chunk_commit_data;\n> +\tconst unsigned char *chunk_generation_data;\n>  \tconst unsigned char *chunk_extra_edges;\n>  \tconst unsigned char *chunk_base_graphs;\n>  \tconst unsigned char *chunk_bloom_indexes;\n> diff --git a/t/helper/test-read-graph.c b/t/helper/test-read-graph.c\n> index 6d0c962438..1c2a5366c7 100644\n> --- a/t/helper/test-read-graph.c\n> +++ b/t/helper/test-read-graph.c\n> @@ -32,6 +32,8 @@ int cmd__read_graph(int argc, const char **argv)\n>  \t\tprintf("" oid_lookup"");\n>  \tif (graph->chunk_commit_data)\n>  \t\tprintf("" commit_metadata"");\n> +\tif (graph->chunk_generation_data)\n> +\t\tprintf("" generation_data"");\n>  \tif (graph->chunk_extra_edges)\n>  \t\tprintf("" extra_edges"");\n>  \tif (graph->chunk_bloom_indexes)\n> diff --git a/t/t4216-log-bloom.sh b/t/t4216-log-bloom.sh\n> index c855bcd3e7..780855e691 100755\n> --- a/t/t4216-log-bloom.sh\n> +++ b/t/t4216-log-bloom.sh\n> @@ -33,11 +33,11 @@ test_expect_success \'setup test - repo, commits, commit graph, log outputs\' \'\n>  \tgit commit-graph write --reachable --changed-paths\n>  \'\n>  graph_read_expect () {\n> -\tNUM_CHUNKS=5\n> +\tNUM_CHUNKS=6\n>  \tcat >expect <<- EOF\n>  \theader: 43475048 1 1 $NUM_CHUNKS 0\n>  \tnum_commits: $1\n> -\tchunks: oid_fanout oid_lookup commit_metadata bloom_indexes bloom_data\n> +\tchunks: oid_fanout oid_lookup commit_metadata generation_data bloom_indexes bloom_data\n>  \tEOF\n>  \ttest-tool read-graph >actual &&\n>  \ttest_cmp expect actual\n> diff --git a/t/t5318-commit-graph.sh b/t/t5318-commit-graph.sh\n> index 26f332d6a3..3ec5248d70 100755\n> --- a/t/t5318-commit-graph.sh\n> +++ b/t/t5318-commit-graph.sh\n> @@ -71,16 +71,16 @@ graph_git_behavior \'no graph\' full commits/3 commits/1\n>\n>  graph_read_expect() {\n>  \tOPTIONAL=""""\n> -\tNUM_CHUNKS=3\n> +\tNUM_CHUNKS=4\n>  \tif test ! -z $2\n>  \tthen\n>  \t\tOPTIONAL="" $2""\n> -\t\tNUM_CHUNKS=$((3 + $(echo ""$2"" | wc -w)))\n> +\t\tNUM_CHUNKS=$((4 + $(echo ""$2"" | wc -w)))\n>  \tfi\n>  \tcat >expect <<- EOF\n>  \theader: 43475048 1 1 $NUM_CHUNKS 0\n>  \tnum_commits: $1\n> -\tchunks: oid_fanout oid_lookup commit_metadata$OPTIONAL\n> +\tchunks: oid_fanout oid_lookup commit_metadata generation_data$OPTIONAL\n>  \tEOF\n>  \ttest-tool read-graph >output &&\n>  \ttest_cmp expect output\n> @@ -433,7 +433,7 @@ GRAPH_BYTE_HASH=5\n>  GRAPH_BYTE_CHUNK_COUNT=6\n>  GRAPH_CHUNK_LOOKUP_OFFSET=8\n>  GRAPH_CHUNK_LOOKUP_WIDTH=12\n> -GRAPH_CHUNK_LOOKUP_ROWS=5\n> +GRAPH_CHUNK_LOOKUP_ROWS=6\n>  GRAPH_BYTE_OID_FANOUT_ID=$GRAPH_CHUNK_LOOKUP_OFFSET\n>  GRAPH_BYTE_OID_LOOKUP_ID=$(($GRAPH_CHUNK_LOOKUP_OFFSET + \\\n>  \t\t\t    1 * $GRAPH_CHUNK_LOOKUP_WIDTH))\n> @@ -451,11 +451,14 @@ GRAPH_BYTE_COMMIT_TREE=$GRAPH_COMMIT_DATA_OFFSET\n>  GRAPH_BYTE_COMMIT_PARENT=$(($GRAPH_COMMIT_DATA_OFFSET + $HASH_LEN))\n>  GRAPH_BYTE_COMMIT_EXTRA_PARENT=$(($GRAPH_COMMIT_DATA_OFFSET + $HASH_LEN + 4))\n>  GRAPH_BYTE_COMMIT_WRONG_PARENT=$(($GRAPH_COMMIT_DATA_OFFSET + $HASH_LEN + 3))\n> -GRAPH_BYTE_COMMIT_GENERATION=$(($GRAPH_COMMIT_DATA_OFFSET + $HASH_LEN + 11))\n>  GRAPH_BYTE_COMMIT_DATE=$(($GRAPH_COMMIT_DATA_OFFSET + $HASH_LEN + 12))\n>  GRAPH_COMMIT_DATA_WIDTH=$(($HASH_LEN + 16))\n> -GRAPH_OCTOPUS_DATA_OFFSET=$(($GRAPH_COMMIT_DATA_OFFSET + \\\n> -\t\t\t     $GRAPH_COMMIT_DATA_WIDTH * $NUM_COMMITS))\n> +GRAPH_GENERATION_DATA_OFFSET=$(($GRAPH_COMMIT_DATA_OFFSET + \\\n> +\t\t\t\t$GRAPH_COMMIT_DATA_WIDTH * $NUM_COMMITS))\n> +GRAPH_GENERATION_DATA_WIDTH=4\n> +GRAPH_BYTE_COMMIT_GENERATION=$(($GRAPH_GENERATION_DATA_OFFSET + 3))\n> +GRAPH_OCTOPUS_DATA_OFFSET=$(($GRAPH_GENERATION_DATA_OFFSET + \\\n> +\t\t\t     $GRAPH_GENERATION_DATA_WIDTH * $NUM_COMMITS))\n>  GRAPH_BYTE_OCTOPUS=$(($GRAPH_OCTOPUS_DATA_OFFSET + 4))\n>  GRAPH_BYTE_FOOTER=$(($GRAPH_OCTOPUS_DATA_OFFSET + 4 * $NUM_OCTOPUS_EDGES))\n>\n> @@ -594,7 +597,7 @@ test_expect_success \'detect incorrect generation number\' \'\n>  \'\n>\n>  test_expect_success \'detect incorrect generation number\' \'\n> -\tcorrupt_graph_and_verify $GRAPH_BYTE_COMMIT_GENERATION ""\\01"" \\\n> +\tcorrupt_graph_and_verify $GRAPH_BYTE_COMMIT_GENERATION ""\\00"" \\\n>  \t\t""non-zero generation number""\n>  \'\n>\n> diff --git a/t/t5324-split-commit-graph.sh b/t/t5324-split-commit-graph.sh\n> index 269d0964a3..096a96ec41 100755\n> --- a/t/t5324-split-commit-graph.sh\n> +++ b/t/t5324-split-commit-graph.sh\n> @@ -14,11 +14,11 @@ test_expect_success \'setup repo\' \'\n>  \tgraphdir=""$infodir/commit-graphs"" &&\n>  \ttest_oid_init &&\n>  \ttest_oid_cache <<-EOM\n> -\tshallow sha1:1760\n> -\tshallow sha256:2064\n> +\tshallow sha1:2132\n> +\tshallow sha256:2436\n>\n> -\tbase sha1:1376\n> -\tbase sha256:1496\n> +\tbase sha1:1408\n> +\tbase sha256:1528\n>  \tEOM\n>  \'\n>\n> @@ -29,9 +29,9 @@ graph_read_expect() {\n>  \t\tNUM_BASE=$2\n>  \tfi\n>  \tcat >expect <<- EOF\n> -\theader: 43475048 1 1 3 $NUM_BASE\n> +\theader: 43475048 1 1 4 $NUM_BASE\n>  \tnum_commits: $1\n> -\tchunks: oid_fanout oid_lookup commit_metadata\n> +\tchunks: oid_fanout oid_lookup commit_metadata generation_data\n>  \tEOF\n>  \ttest-tool read-graph >output &&\n>  \ttest_cmp expect output\n> --\n> gitgitgadget\n>\n\nAll of this looks good to me.\n\nThanks,\nTaylor\n``````````\n', 'comment_created': datetime.datetime(2020, 7, 28, 16, 16, 20, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 461711836, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/20200728162315.GG87373@syl.lan), Taylor Blau wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Tue, Jul 28, 2020 at 11:55:12AM -0400, Derrick Stolee wrote:\n> On 7/28/2020 5:13 AM, Abhishek Kumar via GitGitGadget wrote:\n> > From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> >\n> > With preparations done,...\n>\n> I feel like this commit could have been made smaller by doing the\n> uint32_t -> timestamp_t conversion in a separate patch. That would\n> make it easier to focus on the changes to the generation number v2\n> logic.\n\nYep, agreed.\n\n> > let\'s implement corrected commit date offset.\n> > We add a new commit-slab to store topological levels while writing\n>\n> It\'s important to add: we store topological levels to ensure that older\n> versions of Git will still have the performance benefits from generation\n> number v1.\n>\n> > commit graph and upgrade number of struct commit_graph_data to 64-bits.\n>\n> Do you mean ""update the generation member in struct commit_graph_data\n> to a 64-bit timestamp""? The struct itself also has the 32-bit graph_pos\n> member.\n>\n> > We have to touch many files, upgrading generation number from uint32_t\n> > to timestamp_t.\n>\n> Yes, that\'s why I recommend doing that in a different step.\n>\n> > We drop \'detect incorrect generation number\' from t5318-commit-graph.sh,\n> > which tests if verify can detect if a commit graph have\n> > GENERATION_NUMBER_ZERO for a commit, followed by a non-zero generation.\n> > With corrected commit dates, GENERATION_NUMBER_ZERO is possible only if\n> > one of dates is Unix epoch zero.\n>\n> What about the topological levels? Are we caring about verifying the data\n> that we start to ignore in this new version? I\'m hesitant to drop this\n> right now, but I\'m open to it if we really don\'t see it as a valuable test.\n>\n> > Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> > ---\n> >  blame.c                 |   2 +-\n> >  commit-graph.c          | 109 ++++++++++++++++++++++------------------\n> >  commit-graph.h          |   4 +-\n> >  commit-reach.c          |  32 ++++++------\n> >  commit-reach.h          |   2 +-\n> >  commit.h                |   3 ++\n> >  revision.c              |  14 +++---\n> >  t/t5318-commit-graph.sh |   2 +-\n> >  upload-pack.c           |   2 +-\n> >  9 files changed, 93 insertions(+), 77 deletions(-)\n> >\n> > diff --git a/blame.c b/blame.c\n> > index 82fa16d658..48aa632461 100644\n> > --- a/blame.c\n> > +++ b/blame.c\n> > @@ -1272,7 +1272,7 @@ static int maybe_changed_path(struct repository *r,\n> >  \tif (!bd)\n> >  \t\treturn 1;\n> >\n> > -\tif (commit_graph_generation(origin->commit) == GENERATION_NUMBER_INFINITY)\n> > +\tif (commit_graph_generation(origin->commit) == GENERATION_NUMBER_V2_INFINITY)\n> >  \t\treturn 1;\n>\n> I don\'t see value in changing the name of this macro. It\n> is only used as the default value for a commit not in the\n> commit-graph. Changing its value to 0xFFFFFFFF works for\n> both versions when the type is updated to timestamp_t.\n>\n> The actually-important change in this patch (not just the\n> type change) is here:\n>\n> > -static void compute_generation_numbers(struct write_commit_graph_context *ctx)\n> > +static void compute_corrected_commit_date_offsets(struct write_commit_graph_context *ctx)\n> >  {\n> >  \tint i;\n> >  \tstruct commit_list *list = NULL;\n> > @@ -1326,11 +1334,11 @@ static void compute_generation_numbers(struct write_commit_graph_context *ctx)\n> >  \t\t\t\t\t_(""Computing commit graph generation numbers""),\n> >  \t\t\t\t\tctx->commits.nr);\n> >  \tfor (i = 0; i < ctx->commits.nr; i++) {\n> > -\t\tuint32_t generation = commit_graph_data_at(ctx->commits.list[i])->generation;\n> > +\t\tuint32_t topo_level = *topo_level_slab_at(ctx->topo_levels, ctx->commits.list[i]);\n> >\n> >  \t\tdisplay_progress(ctx->progress, i + 1);\n> > -\t\tif (generation != GENERATION_NUMBER_INFINITY &&\n> > -\t\t    generation != GENERATION_NUMBER_ZERO)\n> > +\t\tif (topo_level != GENERATION_NUMBER_INFINITY &&\n> > +\t\t    topo_level != GENERATION_NUMBER_ZERO)\n> >  \t\t\tcontinue;\n>\n> Here, our ""skip"" condition is that the topo_level has been computed.\n> This should be fine, as we are never reading that out of the commit-graph.\n> We will never be in a mode where topo_level is computed but corrected\n> commit-date is not.\n>\n> >  \t\tcommit_list_insert(ctx->commits.list[i], &list);\n> > @@ -1338,29 +1346,38 @@ static void compute_generation_numbers(struct write_commit_graph_context *ctx)\n> >  \t\t\tstruct commit *current = list->item;\n> >  \t\t\tstruct commit_list *parent;\n> >  \t\t\tint all_parents_computed = 1;\n> > -\t\t\tuint32_t max_generation = 0;\n> > +\t\t\tuint32_t max_level = 0;\n> > +\t\t\ttimestamp_t max_corrected_commit_date = current->date;\n>\n> Later you assign data->generation to be ""max_corrected_commit_date + 1"",\n> which made me think this should be ""current->date - 1"". Is that so? Or,\n> do we want most offsets to be one instead of zero? Is there value there?\n>\n> >\n> >  \t\t\tfor (parent = current->parents; parent; parent = parent->next) {\n> > -\t\t\t\tgeneration = commit_graph_data_at(parent->item)->generation;\n> > +\t\t\t\ttopo_level = *topo_level_slab_at(ctx->topo_levels, parent->item);\n> >\n> > -\t\t\t\tif (generation == GENERATION_NUMBER_INFINITY ||\n> > -\t\t\t\t    generation == GENERATION_NUMBER_ZERO) {\n> > +\t\t\t\tif (topo_level == GENERATION_NUMBER_INFINITY ||\n> > +\t\t\t\t    topo_level == GENERATION_NUMBER_ZERO) {\n> >  \t\t\t\t\tall_parents_computed = 0;\n> >  \t\t\t\t\tcommit_list_insert(parent->item, &list);\n> >  \t\t\t\t\tbreak;\n> > -\t\t\t\t} else if (generation > max_generation) {\n> > -\t\t\t\t\tmax_generation = generation;\n> > +\t\t\t\t} else {\n> > +\t\t\t\t\tstruct commit_graph_data *data = commit_graph_data_at(parent->item);\n> > +\n> > +\t\t\t\t\tif (topo_level > max_level)\n> > +\t\t\t\t\t\tmax_level = topo_level;\n> > +\n> > +\t\t\t\t\tif (data->generation > max_corrected_commit_date)\n> > +\t\t\t\t\t\tmax_corrected_commit_date = data->generation;\n> >  \t\t\t\t}\n> >  \t\t\t}\n> >\n> >  \t\t\tif (all_parents_computed) {\n> >  \t\t\t\tstruct commit_graph_data *data = commit_graph_data_at(current);\n> >\n> > -\t\t\t\tdata->generation = max_generation + 1;\n> > -\t\t\t\tpop_commit(&list);\n> > +\t\t\t\tif (max_level > GENERATION_NUMBER_MAX - 1)\n> > +\t\t\t\t\tmax_level = GENERATION_NUMBER_MAX - 1;\n> > +\n> > +\t\t\t\t*topo_level_slab_at(ctx->topo_levels, current) = max_level + 1;\n> > +\t\t\t\tdata->generation = max_corrected_commit_date + 1;\n> >\n> > -\t\t\t\tif (data->generation > GENERATION_NUMBER_MAX)\n> > -\t\t\t\t\tdata->generation = GENERATION_NUMBER_MAX;\n> > +\t\t\t\tpop_commit(&list);\n> >  \t\t\t}\n> >  \t\t}\n> >  \t}\n>\n> This looks correct, and I\'ve done a tiny bit of perf tests locally.\n>\n> > @@ -2085,6 +2102,7 @@ int write_commit_graph(struct object_directory *odb,\n> >  \tuint32_t i, count_distinct = 0;\n> >  \tint res = 0;\n> >  \tint replace = 0;\n> > +\tstruct topo_level_slab topo_levels;\n> >\n> >  \tif (!commit_graph_compatible(the_repository))\n> >  \t\treturn 0;\n> > @@ -2099,6 +2117,9 @@ int write_commit_graph(struct object_directory *odb,\n> >  \tctx->changed_paths = flags & COMMIT_GRAPH_WRITE_BLOOM_FILTERS ? 1 : 0;\n> >  \tctx->total_bloom_filter_data_size = 0;\n> >\n> > +\tinit_topo_level_slab(&topo_levels);\n> > +\tctx->topo_levels = &topo_levels;\n> > +\n> >  \tif (ctx->split) {\n> >  \t\tstruct commit_graph *g;\n> >  \t\tprepare_commit_graph(ctx->r);\n> > @@ -2197,7 +2218,7 @@ int write_commit_graph(struct object_directory *odb,\n> >  \t} else\n> >  \t\tctx->num_commit_graphs_after = 1;\n> >\n> > -\tcompute_generation_numbers(ctx);\n> > +\tcompute_corrected_commit_date_offsets(ctx);\n>\n> This rename might not be necessary. You are computing both\n> versions (v1 and v2) so the name change is actually less\n> accurate than the old name.\n>\n> Thanks,\n> -Stolee\n\nI don\'t have anything to add that Stolee hasn\'t already pointed out.\nThanks for your work on this series, and I\'m looking forward to another\nreroll.\n\nThanks,\nTaylor\n``````````\n', 'comment_created': datetime.datetime(2020, 7, 28, 16, 25, 22, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 462743882, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/20200730052429.GA50429@Abhishek-Arch), Abhishek Kumar wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Tue, Jul 28, 2020 at 11:28:44AM -0400, Taylor Blau wrote:\n> On Tue, Jul 28, 2020 at 09:13:46AM +0000, Abhishek Kumar via GitGitGadget wrote:\n> > From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> >\n> > With 3d112755 (commit-graph: examine commits by generation number), Git\n> > knew to sort by generation number before examining the diff when not\n> > using pack order. c49c82aa (commit: move members graph_pos, generation\n> > to a slab, 2020-06-17) moved generation number into a slab and\n> > introduced a helper which returns GENERATION_NUMBER_INFINITY when\n> > writing the graph. Sorting is no longer useful and essentially reverts\n> > the earlier commit.\n> \n> This last sentence is slightly confusing. Do you think it would be more\n> clear if you said elaborated a bit? Perhaps something like:\n> \n>   [...]\n> \n>   commit_gen_cmp is used when writing a commit-graph to sort commits in\n>   generation order before computing Bloom filters. Since c49c82aa made\n>   it so that \'commit_graph_generation()\' returns\n>   \'GENERATION_NUMBER_INFINITY\' during writing, we cannot call it within\n>   this function. Instead, access the generation number directly through\n>   the slab (i.e., by calling \'commit_graph_data_at(c)->generation\') in\n>   order to access it while writing.\n> \n\nThanks! That is clearer. Will change.\n\n> I think the above would be a good extra paragraph in the commit message\n> provided that you remove the sentence beginning with ""Sorting is no\n> longer useful...""\n> \n> > Let\'s fix this by accessing generation number directly through the slab.\n> >\n> > Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> > ---\n> >  commit-graph.c | 5 +++--\n> >  1 file changed, 3 insertions(+), 2 deletions(-)\n> >\n> > diff --git a/commit-graph.c b/commit-graph.c\n> > index 1af68c297d..5d3c9bd23c 100644\n> > --- a/commit-graph.c\n> > +++ b/commit-graph.c\n> > @@ -144,8 +144,9 @@ static int commit_gen_cmp(const void *va, const void *vb)\n> >  \tconst struct commit *a = *(const struct commit **)va;\n> >  \tconst struct commit *b = *(const struct commit **)vb;\n> >\n> > -\tuint32_t generation_a = commit_graph_generation(a);\n> > -\tuint32_t generation_b = commit_graph_generation(b);\n> > +\tuint32_t generation_a = commit_graph_data_at(a)->generation;\n> > +\tuint32_t generation_b = commit_graph_data_at(b)->generation;\n> > +\n> \n> Nit; this whitespace diff is extraneous, but it\'s not hurting anything\n> either. Since it looks like you\'re rerolling anyway, it would be good to\n> just get rid of it.\n> \n> Otherwise this fix makes sense to me.\n> \n> >  \t/* lower generation commits first */\n> >  \tif (generation_a < generation_b)\n> >  \t\treturn -1;\n> > --\n> > gitgitgadget\n> \n> Thanks,\n> Taylor\n``````````\n', 'comment_created': datetime.datetime(2020, 7, 30, 5, 29, 17, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 462756872, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/20200730060732.GB50429@Abhishek-Arch), Abhishek Kumar wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Tue, Jul 28, 2020 at 09:14:42AM -0400, Derrick Stolee wrote:\n> On 7/28/2020 5:13 AM, Abhishek Kumar via GitGitGadget wrote:\n> > From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> > \n> > Both fill_commit_graph_info() and fill_commit_in_graph() parse\n> > information present in commit data chunk. Let\'s simplify the\n> > implementation by calling fill_commit_graph_info() within\n> > fill_commit_in_graph().\n> > \n> > The test \'generate tar with future mtime\' creates a commit with commit\n> > time of (2 ^ 36 + 1) seconds since EPOCH. The commit time overflows into\n> > generation number and has undefined behavior. The test used to pass as\n> > fill_commit_in_graph() did not read commit time from commit graph,\n> > reading commit date from odb instead.\n> \n> I was first confused as to why fill_commit_graph_info() did not\n> load the timestamp, but the reason is that it is only used by\n> two methods:\n> \n> 1. fill_commit_in_graph(): this actually leaves the commit in a\n>    ""parsed"" state, so the date must be correct. Thus, it parses\n>    the date out of the commit-graph.\n> \n> 2. load_commit_graph_info(): this only helps to guarantee we\n>    know the graph_pos and generation number values.\n> \n> Perhaps add this extra context: you will _need_ the commit date\n> from the commit-graph in order to populate the generation number\n> v2 in fill_commit_graph_info().\n\nThanks, that makes sense. I have revised the commit message to:\n\ncommit-graph: consolidate fill_commit_graph_info\n    \n    Both fill_commit_graph_info() and fill_commit_in_graph() parse\n    information present in commit data chunk. Let\'s simplify the\n    implementation by calling fill_commit_graph_info() within\n    fill_commit_in_graph().\n    \n    The test \'generate tar with future mtime\' creates a commit with commit\n    time of (2 ^ 36 + 1) seconds since EPOCH. The commit time overflows into\n    generation number (within CDAT chunk) and has undefined behavior.\n    \n    The test used to pass as fill_commit_in_graph() guarantees the values of\n    graph position and generation number, and did not load timestamp.\n    However, with corrected commit date we will need load the timestamp as\n    well to populate the generation number.\n> \n> > Let\'s fix that by setting commit time of (2 ^ 34 - 1) seconds.\n> \n> The timestamp limit placed in the commit-graph is more restrictive\n> than 64-bit timestamps, but as your test points out, the maximum\n> timestamp allowed takes place in the year 2514. That is far enough\n> away for all real data.\n> \n> > Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> > ---\n> >  commit-graph.c      | 31 ++++++++++++-------------------\n> >  t/t5000-tar-tree.sh |  4 ++--\n> >  2 files changed, 14 insertions(+), 21 deletions(-)\n> > \n> > diff --git a/commit-graph.c b/commit-graph.c\n> > index 5d3c9bd23c..204eb454b2 100644\n> > --- a/commit-graph.c\n> > +++ b/commit-graph.c\n> > @@ -735,15 +735,24 @@ static void fill_commit_graph_info(struct commit *item, struct commit_graph *g,\n> >  \tconst unsigned char *commit_data;\n> >  \tstruct commit_graph_data *graph_data;\n> >  \tuint32_t lex_index;\n> > +\tuint64_t date_high, date_low;\n> >  \n> >  \twhile (pos < g->num_commits_in_base)\n> >  \t\tg = g->base_graph;\n> >  \n> > +\tif (pos >= g->num_commits + g->num_commits_in_base)\n> > +\t\tdie(_(""invalid commit position. commit-graph is likely corrupt""));\n> > +\n> >  \tlex_index = pos - g->num_commits_in_base;\n> >  \tcommit_data = g->chunk_commit_data + GRAPH_DATA_WIDTH * lex_index;\n> >  \n> >  \tgraph_data = commit_graph_data_at(item);\n> >  \tgraph_data->graph_pos = pos;\n> > +\n> > +\tdate_high = get_be32(commit_data + g->hash_len + 8) & 0x3;\n> > +\tdate_low = get_be32(commit_data + g->hash_len + 12);\n> > +\titem->date = (timestamp_t)((date_high << 32) | date_low);\n> > +\n> >  \tgraph_data->generation = get_be32(commit_data + g->hash_len + 8) >> 2;\n> >  }\n> >  \n> > @@ -758,38 +767,22 @@ static int fill_commit_in_graph(struct repository *r,\n> >  {\n> >  \tuint32_t edge_value;\n> >  \tuint32_t *parent_data_ptr;\n> > -\tuint64_t date_low, date_high;\n> >  \tstruct commit_list **pptr;\n> > -\tstruct commit_graph_data *graph_data;\n> >  \tconst unsigned char *commit_data;\n> >  \tuint32_t lex_index;\n> >  \n> > +\tfill_commit_graph_info(item, g, pos);\n> > +\n> >  \twhile (pos < g->num_commits_in_base)\n> >  \t\tg = g->base_graph;\n> \n> This \'while\' loop happens in both implementations, so you could\n> save a miniscule amount of time by placing the call to\n> fill_commit_graph_info() after the while loop.\n> \n> > -\tif (pos >= g->num_commits + g->num_commits_in_base)\n> > -\t\tdie(_(""invalid commit position. commit-graph is likely corrupt""));\n> \n> > -\t/*\n> > -\t * Store the ""full"" position, but then use the\n> > -\t * ""local"" position for the rest of the calculation.\n> > -\t */\n> > -\tgraph_data = commit_graph_data_at(item);\n> > -\tgraph_data->graph_pos = pos;\n> >  \tlex_index = pos - g->num_commits_in_base;\n> > -\n> > -\tcommit_data = g->chunk_commit_data + (g->hash_len + 16) * lex_index;\n> > +\tcommit_data = g->chunk_commit_data + GRAPH_DATA_WIDTH * lex_index;\n> \n> I was about to complain about this change, but GRAPH_DATA_WIDTH\n> is a macro that does an equivalent thing (except the_hash_algo->rawsz\n> instead of g->hash_len).\n> \n> >  \n> >  \titem->object.parsed = 1;\n> >  \n> >  \tset_commit_tree(item, NULL);\n> >  \n> > -\tdate_high = get_be32(commit_data + g->hash_len + 8) & 0x3;\n> > -\tdate_low = get_be32(commit_data + g->hash_len + 12);\n> > -\titem->date = (timestamp_t)((date_high << 32) | date_low);\n> > -\n> > -\tgraph_data->generation = get_be32(commit_data + g->hash_len + 8) >> 2;\n> > -\n> >  \tpptr = &item->parents;\n> >  \n> >  \tedge_value = get_be32(commit_data + g->hash_len);\n> > diff --git a/t/t5000-tar-tree.sh b/t/t5000-tar-tree.sh\n> > index 37655a237c..1986354fc3 100755\n> > --- a/t/t5000-tar-tree.sh\n> > +++ b/t/t5000-tar-tree.sh\n> > @@ -406,7 +406,7 @@ test_expect_success TIME_IS_64BIT \'set up repository with far-future commit\' \'\n> >  \trm -f .git/index &&\n> >  \techo content >file &&\n> >  \tgit add file &&\n> > -\tGIT_COMMITTER_DATE=""@68719476737 +0000"" \\\n> > +\tGIT_COMMITTER_DATE=""@17179869183 +0000"" \\\n> >  \t\tgit commit -m ""tempori parendum""\n> >  \'\n> >  \n> > @@ -415,7 +415,7 @@ test_expect_success TIME_IS_64BIT \'generate tar with future mtime\' \'\n> >  \'\n> >  \n> >  test_expect_success TAR_HUGE,TIME_IS_64BIT,TIME_T_IS_64BIT \'system tar can read our future mtime\' \'\n> > -\techo 4147 >expect &&\n> > +\techo 2514 >expect &&\n> >  \ttar_info future.tar | cut -d"" "" -f2 >actual &&\n> >  \ttest_cmp expect actual\n> >  \'\n> > \n> \n> Thanks,\n> -Stolee\n``````````\n', 'comment_created': datetime.datetime(2020, 7, 30, 6, 11, 19, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 462780624, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/20200730065234.GA2395@Abhishek-Arch), Abhishek Kumar wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Tue, Jul 28, 2020 at 12:12:50PM -0400, Taylor Blau wrote:\n> On Tue, Jul 28, 2020 at 09:13:50AM +0000, Abhishek Kumar via GitGitGadget wrote:\n> > From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> >\n> > One of the essential pre-requisites before implementing generation\n> > number as to distinguish between generation numbers v1 and v2 while\n> \n> s/as/is\n> \n> > still being compatible with old Git.\n> \n> Maybe you could add a section here to talk about why this is needed\n> specifically? That is, you mention it\'s a prerequisite, but a reader in\n> a year or two may not remember why. Adding that information here would\n> be good.\n> \n> > We are going to introduce a new chunk called Generation Data chunk (or\n> > GDAT). GDAT stores generation number v2 (and any subsequent versions),\n> > whereas CDAT will still store topological level.\n> >\n> > Old Git does not understand GDAT chunk and would ignore it, reading\n> > topological levels from CDAT. Newer versions of Git can parse GDAT and\n> > take advantage of newer generation numbers, falling back to topological\n> > levels when GDAT chunk is missing (as it would happen with a commit\n> > graph written by old Git).\n> \n> ...this is exactly the paragraph that I was looking for above. Could you\n> swap the order of these last two paragraphs? I think that it would make\n> the patch message far clearer.\n\nHere\'s revised commit message:\n\n  commit-graph: implement generation data chunk\n    \n  As discovered by �var, we cannot increment graph version to\n  distinguish between generation numbers v1 and v2 [1]. Thus, one of\n  pre-requistes before implementing generation number v2 was to\n  distinguish generation numbers in a backwards compatible manner\n  without increment graph version.\n  \n  We are going to introduce a new chunk called Generation Data chunk (or\n  GDAT). GDAT stores generation number v2 (and any subsequent versions),\n  whereas CDAT will still store topological level.\n  \n  Old Git does not understand GDAT chunk and would ignore it, reading\n  topological levels from CDAT. New Git can parse GDAT and take advantage\n  of newer generation numbers, falling back to topological levels when\n  GDAT chunk is missing (as it would happen with a commit graph written\n  by old Git).\n \n  [1]: https://lore.kernel.org/git/87a7gdspo4.fsf@evledraar.gmail.com/\n\nFirst paragraph explains why we need this patch (cannot increment graph\nversion) second explains what this patch does (introduce a new chunk)\nand third proves why it works (Old Git ignores GDAT, New Git parses GDAT).\n\nCan we improve this commit message further? \n\n> >\n> > Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> > ---\n> >  commit-graph.c                | 33 +++++++++++++++++++++++++++++----\n> >  commit-graph.h                |  1 +\n> >  t/helper/test-read-graph.c    |  2 ++\n> >  t/t4216-log-bloom.sh          |  4 ++--\n> >  t/t5318-commit-graph.sh       | 19 +++++++++++--------\n> >  t/t5324-split-commit-graph.sh | 12 ++++++------\n> >  6 files changed, 51 insertions(+), 20 deletions(-)\n> >\n> > diff --git a/commit-graph.c b/commit-graph.c\n> > index 1c98f38d69..ab714f4a76 100644\n> > --- a/commit-graph.c\n> > +++ b/commit-graph.c\n> > @@ -38,11 +38,12 @@ void git_test_write_commit_graph_or_die(void)\n> >  #define GRAPH_CHUNKID_OIDFANOUT 0x4f494446 /* ""OIDF"" */\n> >  #define GRAPH_CHUNKID_OIDLOOKUP 0x4f49444c /* ""OIDL"" */\n> >  #define GRAPH_CHUNKID_DATA 0x43444154 /* ""CDAT"" */\n> > +#define GRAPH_CHUNKID_GENERATION_DATA 0x47444154 /* ""GDAT"" */\n> >  #define GRAPH_CHUNKID_EXTRAEDGES 0x45444745 /* ""EDGE"" */\n> >  #define GRAPH_CHUNKID_BLOOMINDEXES 0x42494458 /* ""BIDX"" */\n> >  #define GRAPH_CHUNKID_BLOOMDATA 0x42444154 /* ""BDAT"" */\n> >  #define GRAPH_CHUNKID_BASE 0x42415345 /* ""BASE"" */\n> > -#define MAX_NUM_CHUNKS 7\n> > +#define MAX_NUM_CHUNKS 8\n> \n> Ugh. I am simultaneously working on a new chunk myself (so a bad\n> conflict resolution would look at both of us incrementing this number\n> to the same value without generating a conflict.)\n> \n> I think the right thing to do here would be to define an enum over chunk\n> names, and then index an array by that enum (where the value at each\n> index is the chunk identifier). Then, the last value of that enum would\n> be a \'__COUNT\' which you could use to initialize the array (as well as\n> within the commit-graph writing routines).\n> \n> Anyway, I think that it\'s probably not worth it in the meantime, but it\n> is something that Junio should look out for when merging (if yours and\n> my topic happen to get merged around the same time, which they may not).\n> \n> >  #define GRAPH_DATA_WIDTH (the_hash_algo->rawsz + 16)\n> >\n> > @@ -389,6 +390,13 @@ struct commit_graph *parse_commit_graph(void *graph_map, size_t graph_size)\n> >  \t\t\t\tgraph->chunk_commit_data = data + chunk_offset;\n> >  \t\t\tbreak;\n> >\n> > +\t\tcase GRAPH_CHUNKID_GENERATION_DATA:\n> > +\t\t\tif (graph->chunk_generation_data)\n> > +\t\t\t\tchunk_repeated = 1;\n> > +\t\t\telse\n> > +\t\t\t\tgraph->chunk_generation_data = data + chunk_offset;\n> > +\t\t\tbreak;\n> > +\n> >  \t\tcase GRAPH_CHUNKID_EXTRAEDGES:\n> >  \t\t\tif (graph->chunk_extra_edges)\n> >  \t\t\t\tchunk_repeated = 1;\n> > @@ -768,7 +776,10 @@ static void fill_commit_graph_info(struct commit *item, struct commit_graph *g,\n> >  \tdate_low = get_be32(commit_data + g->hash_len + 12);\n> >  \titem->date = (timestamp_t)((date_high << 32) | date_low);\n> >\n> > -\tgraph_data->generation = get_be32(commit_data + g->hash_len + 8) >> 2;\n> > +\tif (g->chunk_generation_data)\n> > +\t\tgraph_data->generation = get_be32(g->chunk_generation_data + sizeof(uint32_t) * lex_index);\n> > +\telse\n> > +\t\tgraph_data->generation = get_be32(commit_data + g->hash_len + 8) >> 2;\n> >  }\n> >\n> >  static inline void set_commit_tree(struct commit *c, struct tree *t)\n> > @@ -1100,6 +1111,17 @@ static void write_graph_chunk_data(struct hashfile *f, int hash_len,\n> >  \t}\n> >  }\n> >\n> > +static void write_graph_chunk_generation_data(struct hashfile *f,\n> > +\t\t\t\t\t      struct write_commit_graph_context *ctx)\n> > +{\n> > +\tstruct commit **list = ctx->commits.list;\n> > +\tint count;\n> > +\tfor (count = 0; count < ctx->commits.nr; count++, list++) {\n> > +\t\tdisplay_progress(ctx->progress, ++ctx->progress_cnt);\n> > +\t\thashwrite_be32(f, commit_graph_data_at(*list)->generation);\n> > +\t}\n> > +}\n> > +\n> \n> This pointer arithmetic is not necessary. Why not like:\n> \n>   int i;\n>   for (i = 0; i < ctx->commits.nr; i++) {\n>     struct commit *c = ctx->commits.list[i];\n>     display_progress(ctx->progress, ++ctx->progress_cnt);\n>     hashwrite_be32(f, commit_graph_data_at(c)->generation);\n>   }\n> \n> instead?\n> \n> >  static void write_graph_chunk_extra_edges(struct hashfile *f,\n> >  \t\t\t\t\t  struct write_commit_graph_context *ctx)\n> >  {\n> > @@ -1605,7 +1627,7 @@ static int write_commit_graph_file(struct write_commit_graph_context *ctx)\n> >  \tuint64_t chunk_offsets[MAX_NUM_CHUNKS + 1];\n> >  \tconst unsigned hashsz = the_hash_algo->rawsz;\n> >  \tstruct strbuf progress_title = STRBUF_INIT;\n> > -\tint num_chunks = 3;\n> > +\tint num_chunks = 4;\n> >  \tstruct object_id file_hash;\n> >  \tconst struct bloom_filter_settings bloom_settings = DEFAULT_BLOOM_FILTER_SETTINGS;\n> >\n> > @@ -1656,6 +1678,7 @@ static int write_commit_graph_file(struct write_commit_graph_context *ctx)\n> >  \tchunk_ids[0] = GRAPH_CHUNKID_OIDFANOUT;\n> >  \tchunk_ids[1] = GRAPH_CHUNKID_OIDLOOKUP;\n> >  \tchunk_ids[2] = GRAPH_CHUNKID_DATA;\n> > +\tchunk_ids[3] = GRAPH_CHUNKID_GENERATION_DATA;\n> >  \tif (ctx->num_extra_edges) {\n> >  \t\tchunk_ids[num_chunks] = GRAPH_CHUNKID_EXTRAEDGES;\n> >  \t\tnum_chunks++;\n> > @@ -1677,8 +1700,9 @@ static int write_commit_graph_file(struct write_commit_graph_context *ctx)\n> >  \tchunk_offsets[1] = chunk_offsets[0] + GRAPH_FANOUT_SIZE;\n> >  \tchunk_offsets[2] = chunk_offsets[1] + hashsz * ctx->commits.nr;\n> >  \tchunk_offsets[3] = chunk_offsets[2] + (hashsz + 16) * ctx->commits.nr;\n> > +\tchunk_offsets[4] = chunk_offsets[3] + sizeof(uint32_t) * ctx->commits.nr;\n> >\n> > -\tnum_chunks = 3;\n> > +\tnum_chunks = 4;\n> >  \tif (ctx->num_extra_edges) {\n> >  \t\tchunk_offsets[num_chunks + 1] = chunk_offsets[num_chunks] +\n> >  \t\t\t\t\t\t4 * ctx->num_extra_edges;\n> > @@ -1728,6 +1752,7 @@ static int write_commit_graph_file(struct write_commit_graph_context *ctx)\n> >  \twrite_graph_chunk_fanout(f, ctx);\n> >  \twrite_graph_chunk_oids(f, hashsz, ctx);\n> >  \twrite_graph_chunk_data(f, hashsz, ctx);\n> > +\twrite_graph_chunk_generation_data(f, ctx);\n> >  \tif (ctx->num_extra_edges)\n> >  \t\twrite_graph_chunk_extra_edges(f, ctx);\n> >  \tif (ctx->changed_paths) {\n> > diff --git a/commit-graph.h b/commit-graph.h\n> > index 98cc5a3b9d..e3d4ba96f4 100644\n> > --- a/commit-graph.h\n> > +++ b/commit-graph.h\n> > @@ -67,6 +67,7 @@ struct commit_graph {\n> >  \tconst uint32_t *chunk_oid_fanout;\n> >  \tconst unsigned char *chunk_oid_lookup;\n> >  \tconst unsigned char *chunk_commit_data;\n> > +\tconst unsigned char *chunk_generation_data;\n> >  \tconst unsigned char *chunk_extra_edges;\n> >  \tconst unsigned char *chunk_base_graphs;\n> >  \tconst unsigned char *chunk_bloom_indexes;\n> > diff --git a/t/helper/test-read-graph.c b/t/helper/test-read-graph.c\n> > index 6d0c962438..1c2a5366c7 100644\n> > --- a/t/helper/test-read-graph.c\n> > +++ b/t/helper/test-read-graph.c\n> > @@ -32,6 +32,8 @@ int cmd__read_graph(int argc, const char **argv)\n> >  \t\tprintf("" oid_lookup"");\n> >  \tif (graph->chunk_commit_data)\n> >  \t\tprintf("" commit_metadata"");\n> > +\tif (graph->chunk_generation_data)\n> > +\t\tprintf("" generation_data"");\n> >  \tif (graph->chunk_extra_edges)\n> >  \t\tprintf("" extra_edges"");\n> >  \tif (graph->chunk_bloom_indexes)\n> > diff --git a/t/t4216-log-bloom.sh b/t/t4216-log-bloom.sh\n> > index c855bcd3e7..780855e691 100755\n> > --- a/t/t4216-log-bloom.sh\n> > +++ b/t/t4216-log-bloom.sh\n> > @@ -33,11 +33,11 @@ test_expect_success \'setup test - repo, commits, commit graph, log outputs\' \'\n> >  \tgit commit-graph write --reachable --changed-paths\n> >  \'\n> >  graph_read_expect () {\n> > -\tNUM_CHUNKS=5\n> > +\tNUM_CHUNKS=6\n> >  \tcat >expect <<- EOF\n> >  \theader: 43475048 1 1 $NUM_CHUNKS 0\n> >  \tnum_commits: $1\n> > -\tchunks: oid_fanout oid_lookup commit_metadata bloom_indexes bloom_data\n> > +\tchunks: oid_fanout oid_lookup commit_metadata generation_data bloom_indexes bloom_data\n> >  \tEOF\n> >  \ttest-tool read-graph >actual &&\n> >  \ttest_cmp expect actual\n> > diff --git a/t/t5318-commit-graph.sh b/t/t5318-commit-graph.sh\n> > index 26f332d6a3..3ec5248d70 100755\n> > --- a/t/t5318-commit-graph.sh\n> > +++ b/t/t5318-commit-graph.sh\n> > @@ -71,16 +71,16 @@ graph_git_behavior \'no graph\' full commits/3 commits/1\n> >\n> >  graph_read_expect() {\n> >  \tOPTIONAL=""""\n> > -\tNUM_CHUNKS=3\n> > +\tNUM_CHUNKS=4\n> >  \tif test ! -z $2\n> >  \tthen\n> >  \t\tOPTIONAL="" $2""\n> > -\t\tNUM_CHUNKS=$((3 + $(echo ""$2"" | wc -w)))\n> > +\t\tNUM_CHUNKS=$((4 + $(echo ""$2"" | wc -w)))\n> >  \tfi\n> >  \tcat >expect <<- EOF\n> >  \theader: 43475048 1 1 $NUM_CHUNKS 0\n> >  \tnum_commits: $1\n> > -\tchunks: oid_fanout oid_lookup commit_metadata$OPTIONAL\n> > +\tchunks: oid_fanout oid_lookup commit_metadata generation_data$OPTIONAL\n> >  \tEOF\n> >  \ttest-tool read-graph >output &&\n> >  \ttest_cmp expect output\n> > @@ -433,7 +433,7 @@ GRAPH_BYTE_HASH=5\n> >  GRAPH_BYTE_CHUNK_COUNT=6\n> >  GRAPH_CHUNK_LOOKUP_OFFSET=8\n> >  GRAPH_CHUNK_LOOKUP_WIDTH=12\n> > -GRAPH_CHUNK_LOOKUP_ROWS=5\n> > +GRAPH_CHUNK_LOOKUP_ROWS=6\n> >  GRAPH_BYTE_OID_FANOUT_ID=$GRAPH_CHUNK_LOOKUP_OFFSET\n> >  GRAPH_BYTE_OID_LOOKUP_ID=$(($GRAPH_CHUNK_LOOKUP_OFFSET + \\\n> >  \t\t\t    1 * $GRAPH_CHUNK_LOOKUP_WIDTH))\n> > @@ -451,11 +451,14 @@ GRAPH_BYTE_COMMIT_TREE=$GRAPH_COMMIT_DATA_OFFSET\n> >  GRAPH_BYTE_COMMIT_PARENT=$(($GRAPH_COMMIT_DATA_OFFSET + $HASH_LEN))\n> >  GRAPH_BYTE_COMMIT_EXTRA_PARENT=$(($GRAPH_COMMIT_DATA_OFFSET + $HASH_LEN + 4))\n> >  GRAPH_BYTE_COMMIT_WRONG_PARENT=$(($GRAPH_COMMIT_DATA_OFFSET + $HASH_LEN + 3))\n> > -GRAPH_BYTE_COMMIT_GENERATION=$(($GRAPH_COMMIT_DATA_OFFSET + $HASH_LEN + 11))\n> >  GRAPH_BYTE_COMMIT_DATE=$(($GRAPH_COMMIT_DATA_OFFSET + $HASH_LEN + 12))\n> >  GRAPH_COMMIT_DATA_WIDTH=$(($HASH_LEN + 16))\n> > -GRAPH_OCTOPUS_DATA_OFFSET=$(($GRAPH_COMMIT_DATA_OFFSET + \\\n> > -\t\t\t     $GRAPH_COMMIT_DATA_WIDTH * $NUM_COMMITS))\n> > +GRAPH_GENERATION_DATA_OFFSET=$(($GRAPH_COMMIT_DATA_OFFSET + \\\n> > +\t\t\t\t$GRAPH_COMMIT_DATA_WIDTH * $NUM_COMMITS))\n> > +GRAPH_GENERATION_DATA_WIDTH=4\n> > +GRAPH_BYTE_COMMIT_GENERATION=$(($GRAPH_GENERATION_DATA_OFFSET + 3))\n> > +GRAPH_OCTOPUS_DATA_OFFSET=$(($GRAPH_GENERATION_DATA_OFFSET + \\\n> > +\t\t\t     $GRAPH_GENERATION_DATA_WIDTH * $NUM_COMMITS))\n> >  GRAPH_BYTE_OCTOPUS=$(($GRAPH_OCTOPUS_DATA_OFFSET + 4))\n> >  GRAPH_BYTE_FOOTER=$(($GRAPH_OCTOPUS_DATA_OFFSET + 4 * $NUM_OCTOPUS_EDGES))\n> >\n> > @@ -594,7 +597,7 @@ test_expect_success \'detect incorrect generation number\' \'\n> >  \'\n> >\n> >  test_expect_success \'detect incorrect generation number\' \'\n> > -\tcorrupt_graph_and_verify $GRAPH_BYTE_COMMIT_GENERATION ""\\01"" \\\n> > +\tcorrupt_graph_and_verify $GRAPH_BYTE_COMMIT_GENERATION ""\\00"" \\\n> >  \t\t""non-zero generation number""\n> >  \'\n> >\n> > diff --git a/t/t5324-split-commit-graph.sh b/t/t5324-split-commit-graph.sh\n> > index 269d0964a3..096a96ec41 100755\n> > --- a/t/t5324-split-commit-graph.sh\n> > +++ b/t/t5324-split-commit-graph.sh\n> > @@ -14,11 +14,11 @@ test_expect_success \'setup repo\' \'\n> >  \tgraphdir=""$infodir/commit-graphs"" &&\n> >  \ttest_oid_init &&\n> >  \ttest_oid_cache <<-EOM\n> > -\tshallow sha1:1760\n> > -\tshallow sha256:2064\n> > +\tshallow sha1:2132\n> > +\tshallow sha256:2436\n> >\n> > -\tbase sha1:1376\n> > -\tbase sha256:1496\n> > +\tbase sha1:1408\n> > +\tbase sha256:1528\n> >  \tEOM\n> >  \'\n> >\n> > @@ -29,9 +29,9 @@ graph_read_expect() {\n> >  \t\tNUM_BASE=$2\n> >  \tfi\n> >  \tcat >expect <<- EOF\n> > -\theader: 43475048 1 1 3 $NUM_BASE\n> > +\theader: 43475048 1 1 4 $NUM_BASE\n> >  \tnum_commits: $1\n> > -\tchunks: oid_fanout oid_lookup commit_metadata\n> > +\tchunks: oid_fanout oid_lookup commit_metadata generation_data\n> >  \tEOF\n> >  \ttest-tool read-graph >output &&\n> >  \ttest_cmp expect output\n> > --\n> > gitgitgadget\n> >\n> \n> All of this looks good to me.\n> \n> Thanks,\n> Taylor\n``````````\n', 'comment_created': datetime.datetime(2020, 7, 30, 6, 56, 24, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 462804467, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/20200730072714.GA964@Abhishek-Arch), Abhishek Kumar wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Tue, Jul 28, 2020 at 11:55:12AM -0400, Derrick Stolee wrote:\n> On 7/28/2020 5:13 AM, Abhishek Kumar via GitGitGadget wrote:\n> > From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> > \n> > With preparations done,...\n> \n> I feel like this commit could have been made smaller by doing the\n> uint32_t -> timestamp_t conversion in a separate patch. That would\n> make it easier to focus on the changes to the generation number v2\n> logic.\n> \n\nSure, would seperate into two patches.\n\n> > let\'s implement corrected commit date offset.\n> > We add a new commit-slab to store topological levels while writing\n> \n> It\'s important to add: we store topological levels to ensure that older\n> versions of Git will still have the performance benefits from generation\n> number v1.\n> \n\nWill do.\n\n> > commit graph and upgrade number of struct commit_graph_data to 64-bits.\n> \n> Do you mean ""update the generation member in struct commit_graph_data\n> to a 64-bit timestamp""? The struct itself also has the 32-bit graph_pos\n> member.\n> \n\nYes, ""update the generation number"".\n\n> > We have to touch many files, upgrading generation number from uint32_t\n> > to timestamp_t.\n> \n> Yes, that\'s why I recommend doing that in a different step.\n> \n> > We drop \'detect incorrect generation number\' from t5318-commit-graph.sh,\n> > which tests if verify can detect if a commit graph have\n> > GENERATION_NUMBER_ZERO for a commit, followed by a non-zero generation.\n> > With corrected commit dates, GENERATION_NUMBER_ZERO is possible only if\n> > one of dates is Unix epoch zero.\n> \n> What about the topological levels? Are we caring about verifying the data\n> that we start to ignore in this new version? I\'m hesitant to drop this\n> right now, but I\'m open to it if we really don\'t see it as a valuable test.\n> \n\nWe haven\'t tested the scenario ""New Git reads a commit graph without\nGDAT chunk"" yet. Verifying topological levels (along with many of the\nchanged offsets) would be a part of the scenario.\n\nNow that I think about it, those tests should have been included with\nthis patch.\n\n> > Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> \n> [...]\n>\n> Later you assign data->generation to be ""max_corrected_commit_date + 1"",\n> which made me think this should be ""current->date - 1"". Is that so? Or,\n> do we want most offsets to be one instead of zero? Is there value there?\n> \n\nDoes it? \n\nI had hoped most of the offsets could have been zero, as we could take\nadvantage of the fact that commit-slab zero initializes values and avoid\na commit-slab access.\n\nRight, What I meant to do was:\n\n        /*\n         * max_parent_corrected_commit_date is initialized with zero and\n         * takes the maximum of\n         * (parent->item->date + commit_graph_data_at(parent->item)->generation)\n        */\n\n        if (max_parent_corrected_commit_date >= current->date)\n        {\n                struct commit_graph_data *data = commit_graph_data_at(current);\n                data->generation = max_parent_corrected_commit_date + 1;\n        }\n\nThanks for pointing this out!\n\n> [...]\n\n- Abhishek\n``````````\n', 'comment_created': datetime.datetime(2020, 7, 30, 7, 32, 27, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 464736345, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/85eeonutj4.fsf@gmail.com), jnareb@gmail.com (Jakub Narębski) wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\n""Abhishek Kumar via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n\n> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n>\n> With 3d112755 (commit-graph: examine commits by generation number), Git\n> knew to sort by generation number before examining the diff when not\n> using pack order. c49c82aa (commit: move members graph_pos, generation\n> to a slab, 2020-06-17) moved generation number into a slab and\n> introduced a helper which returns GENERATION_NUMBER_INFINITY when\n> writing the graph. Sorting is no longer useful and essentially reverts\n> the earlier commit.\n>\n> Let\'s fix this by accessing generation number directly through the slab.\n\nIt looks like unfortunate and unforeseen consequence of putting together\ngraph position and generation number in the commit_graph_data struct.\nDuring writing of the commit-graph file generation number is computed,\nbut graph position is undefined (yet), and commit_graph_generation()\nuses graph_pos field to find if the data for commit is initialized;\nin this case wrongly.\n\nAnyway, when writing the commit graph we first compute generation\nnumber, then (if requested) the changed-paths Bloom filter.  Skipping\nthe unnecessary check is a good thing... assuming that commit_gen_cmp()\nis used only when writing the commit graph, and not when traversing it\n(because then some commits may not have generation number set, and maybe\neven do not have any data on the commit slab) - which is the case.\n\n>\n> Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> ---\n>  commit-graph.c | 5 +++--\n>  1 file changed, 3 insertions(+), 2 deletions(-)\n>\n> diff --git a/commit-graph.c b/commit-graph.c\n> index 1af68c297d..5d3c9bd23c 100644\n> --- a/commit-graph.c\n> +++ b/commit-graph.c\n\nWe might want to add function comment either here or in the header that\nthis comparisonn function is to be used only for `git commit-graph\nwrite`, and not for graph traversal (even if similar funnction exists in\nother modules).\n\n> @@ -144,8 +144,9 @@ static int commit_gen_cmp(const void *va, const void *vb)\n>  \tconst struct commit *a = *(const struct commit **)va;\n>  \tconst struct commit *b = *(const struct commit **)vb;\n>\n> -\tuint32_t generation_a = commit_graph_generation(a);\n> -\tuint32_t generation_b = commit_graph_generation(b);\n> +\tuint32_t generation_a = commit_graph_data_at(a)->generation;\n> +\tuint32_t generation_b = commit_graph_data_at(b)->generation;\n> +\n>  \t/* lower generation commits first */\n>  \tif (generation_a < generation_b)\n>  \t\treturn -1;\n\nBest,\n--\nJakub Narębski\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 4, 0, 48, 36, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 464738540, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/20200804005658.GB75662@syl.lan), Taylor Blau wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Tue, Aug 04, 2020 at 02:46:55AM +0200, Jakub Narębski wrote:\n> ""Abhishek Kumar via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n>\n> > From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> >\n> > With 3d112755 (commit-graph: examine commits by generation number), Git\n> > knew to sort by generation number before examining the diff when not\n> > using pack order. c49c82aa (commit: move members graph_pos, generation\n> > to a slab, 2020-06-17) moved generation number into a slab and\n> > introduced a helper which returns GENERATION_NUMBER_INFINITY when\n> > writing the graph. Sorting is no longer useful and essentially reverts\n> > the earlier commit.\n> >\n> > Let\'s fix this by accessing generation number directly through the slab.\n>\n> It looks like unfortunate and unforeseen consequence of putting together\n> graph position and generation number in the commit_graph_data struct.\n> During writing of the commit-graph file generation number is computed,\n> but graph position is undefined (yet), and commit_graph_generation()\n> uses graph_pos field to find if the data for commit is initialized;\n> in this case wrongly.\n>\n> Anyway, when writing the commit graph we first compute generation\n> number, then (if requested) the changed-paths Bloom filter.  Skipping\n> the unnecessary check is a good thing... assuming that commit_gen_cmp()\n> is used only when writing the commit graph, and not when traversing it\n> (because then some commits may not have generation number set, and maybe\n> even do not have any data on the commit slab) - which is the case.\n>\n> >\n> > Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> > ---\n> >  commit-graph.c | 5 +++--\n> >  1 file changed, 3 insertions(+), 2 deletions(-)\n> >\n> > diff --git a/commit-graph.c b/commit-graph.c\n> > index 1af68c297d..5d3c9bd23c 100644\n> > --- a/commit-graph.c\n> > +++ b/commit-graph.c\n>\n> We might want to add function comment either here or in the header that\n> this comparisonn function is to be used only for `git commit-graph\n> write`, and not for graph traversal (even if similar funnction exists in\n> other modules).\n\nI think that probably within the function is just fine, and that we can\navoid touching commit-graph.h here.\n\n>\n> > @@ -144,8 +144,9 @@ static int commit_gen_cmp(const void *va, const void *vb)\n> >  \tconst struct commit *a = *(const struct commit **)va;\n> >  \tconst struct commit *b = *(const struct commit **)vb;\n\nMaybe something like:\n\n  /*\n   * Access the generation number directly with\n   * \'commit_graph_data_at(...)->generation\' instead of going through\n   * the slab as usual to avoid accessing a yet-uncomputed value.\n   */\n\nFolks that are curious for more can blame this commit and read there.\nI\'d err on the side of being brief in the code comment and verbose in\nthe commit message than the other way around ;).\n\n> >\n> > -\tuint32_t generation_a = commit_graph_generation(a);\n> > -\tuint32_t generation_b = commit_graph_generation(b);\n> > +\tuint32_t generation_a = commit_graph_data_at(a)->generation;\n> > +\tuint32_t generation_b = commit_graph_data_at(b)->generation;\n> > +\n> >  \t/* lower generation commits first */\n> >  \tif (generation_a < generation_b)\n> >  \t\treturn -1;\n>\n> Best,\n> --\n> Jakub Narębski\n\nThanks,\nTaylor\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 4, 0, 57, 39, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 464869717, 'comment_body': ""[On the Git mailing list](https://lore.kernel.org/git/857duevo9m.fsf@gmail.com), jnareb@gmail.com (Jakub Narębski) wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nJakub Narębski <jnareb@gmail.com> writes:\n\n[...]\n>> @@ -144,8 +144,9 @@ static int commit_gen_cmp(const void *va, const void *vb)\n>>  \tconst struct commit *a = *(const struct commit **)va;\n>>  \tconst struct commit *b = *(const struct commit **)vb;\n>>\n>> -\tuint32_t generation_a = commit_graph_generation(a);\n>> -\tuint32_t generation_b = commit_graph_generation(b);\n>> +\tuint32_t generation_a = commit_graph_data_at(a)->generation;\n>> +\tuint32_t generation_b = commit_graph_data_at(b)->generation;\n>> +\n>>  \t/* lower generation commits first */\n>>  \tif (generation_a < generation_b)\n>>  \t\treturn -1;\n\nNOTE: One more thing: we would want to check if corrected commit date\n(generation number v2) or topological level (generation number v1) is\nbetter for this purpose, that is gives better performance.\n\nThe commit 3d11275505 (commit-graph: examine commits by generation\nnumber) which introduced using commit_gen_cmp when writing commit graph\nwhen finding commits via `--reachable` flags describes the following\nperformance improvement:\n\n    On the Linux kernel repository, this change reduced the computation\n    time for 'git commit-graph write --reachable --changed-paths' from\n    3m00s to 1m37s.\n\nWe would probably want time for no sorting, for sorting by generation\nnumber v2, and for sorting by topological level (generation number v1)\nfor the same or similar case.\n\nBest,\n--\nJakub Narębski\n``````````\n"", 'comment_created': datetime.datetime(2020, 8, 4, 7, 58, 5, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 464946712, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/85wo2eu3gc.fsf@gmail.com), jnareb@gmail.com (Jakub Narębski) wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nTaylor Blau <me@ttaylorr.com> writes:\n> On Tue, Aug 04, 2020 at 02:46:55AM +0200, Jakub Narębski wrote:\n>> ""Abhishek Kumar via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n\n[...]\n>>> diff --git a/commit-graph.c b/commit-graph.c\n>>> index 1af68c297d..5d3c9bd23c 100644\n>>> --- a/commit-graph.c\n>>> +++ b/commit-graph.c\n>>\n>> We might want to add function comment either here or in the header that\n>> this comparisonn function is to be used only for `git commit-graph\n>> write`, and not for graph traversal (even if similar funnction exists in\n>> other modules).\n>\n> I think that probably within the function is just fine, and that we can\n> avoid touching commit-graph.h here.\n>\n>>\n>>> @@ -144,8 +144,9 @@ static int commit_gen_cmp(const void *va, const void *vb)\n>>>  \tconst struct commit *a = *(const struct commit **)va;\n>>>  \tconst struct commit *b = *(const struct commit **)vb;\n>\n> Maybe something like:\n>\n>   /*\n>    * Access the generation number directly with\n>    * \'commit_graph_data_at(...)->generation\' instead of going through\n>    * the slab as usual to avoid accessing a yet-uncomputed value.\n>    */\n\nI think the last part of this comment should read:\n\n[...]\n     * \'commit_graph_data_at(...)->generation\' instead of going through\n     * the commit_graph_generation() helper function to access just\n     * computed data [during `git commit-graph write --reachable --changed-paths`].\n     */\n\nOr something like that (the part in square brackets is optional; I am\nnot sure if adding it helps or not).\n\n>\n> Folks that are curious for more can blame this commit and read there.\n> I\'d err on the side of being brief in the code comment and verbose in\n> the commit message than the other way around ;).\n\nI agree.\n\n>>>\n>>> -\tuint32_t generation_a = commit_graph_generation(a);\n>>> -\tuint32_t generation_b = commit_graph_generation(b);\n>>> +\tuint32_t generation_a = commit_graph_data_at(a)->generation;\n>>> +\tuint32_t generation_b = commit_graph_data_at(b)->generation;\n>>> +\n>>>  \t/* lower generation commits first */\n>>>  \tif (generation_a < generation_b)\n>>>  \t\treturn -1;\n\nBest,\n-- \nJakub Narębski\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 4, 10, 13, 11, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 466555720, 'comment_body': 'This is absolutely the right way to structure this condition.', 'comment_created': datetime.datetime(2020, 8, 6, 17, 2, 50, tzinfo=datetime.timezone.utc), 'commenter': 'derrickstolee', 'type': 'User'}, {'comment_id': 466557899, 'comment_body': ""This doesn't need to be a config, as we don't really want users to toggle this. It could be a `GIT_TEST_COMMIT_GRAPH_NO_GDAT` environment variable. Then, your test could write with `GIT_TEST_COMMIT_GRAPH_NO_GDAT=1` and then check all of the reading cases.\r\n\r\nA good way to check that everything still works properly would be to extend `t/t6600-test-reach.sh` to write one commit-graph file in this mode (say, `commit-graph-no-gdat` to match the `commit-graph-[full|half]` that already exist), then update `run_three_modes` to be `test_all_modes` and run one test using that `-no-gdat` file."", 'comment_created': datetime.datetime(2020, 8, 6, 17, 6, 43, tzinfo=datetime.timezone.utc), 'commenter': 'derrickstolee', 'type': 'User'}, {'comment_id': 466569975, 'comment_body': ""@derrickstolee @jnareb @ttaylorr\r\n\r\nWhile writing test for split commit-graph, I wondered about the following scenario:\r\n\r\nWe start off with New Git and create a base commit-graph. Then we switch to old Git (possibly installed with an IDE, for example) and add some more commits. If we try to write to a new commit-graph file, we wind up with a chain of commit-graph files with and without GDAT chunks.\r\n\r\nIn such a case, I have disabled generation numbers and print out a warning.\r\n\r\nWe could have tried to salvage some of the performance boost by using topological level. I am thinking of setting up adding another flag to struct commit_graph to indicate whether to read topological level or corrected commit date. \r\n\r\nWe won't handle mixed graph versions for any of the later generation/graph versions. Will making it work for corrected commit dates be worth the trouble?"", 'comment_created': datetime.datetime(2020, 8, 6, 17, 24, 40, tzinfo=datetime.timezone.utc), 'commenter': 'abhishekkumar2718', 'type': 'User'}, {'comment_id': 466578432, 'comment_body': 'When we are writing a split commit-graph, we should not add a GDAT chunk if the base commit graph doesn\'t have one. This will prevent ""holes"" in the middle of a chain, as you described. It means we won\'t get a GDAT chunk on top of old commit-graphs unless we merge all of the levels.\r\n\r\nWith this in mind, it would be good to write a commit-graph without a GDAT chunk (using `GIT_TEST_COMMIT_GRAPH_NO_GDAT=1`), then add a new layer on top (without that env var) and see that the GDAT chunk doesn\'t exist there. Finally, rewrite the whole commit-graph using `--split=replace` and see that the single layer _does_ have a GDAT chunk.\r\n\r\nDoes that make sense?', 'comment_created': datetime.datetime(2020, 8, 6, 17, 38, 50, tzinfo=datetime.timezone.utc), 'commenter': 'derrickstolee', 'type': 'User'}, {'comment_id': 466748083, 'comment_body': ""I agree with @derrickstolee that when writing section of a split commit-graph we should not add a GDAT chunk if the previous file in the chain doesn't have it -- this solution simplifies reasoning (and should be only temporary measure until all Git is upgraded to generation number v2 capable version).\r\n\r\nI'm not sure if another flag in `struct commit_graph` would be necessary, though it might be the best solution anyway. If the topmost commit we start from, or the top file in the commit-graph chain doesn't have generation number v2 (no GDAT chunk), we switch to generation number v1. Otherwise we can safely use generation number v2."", 'comment_created': datetime.datetime(2020, 8, 7, 0, 1, 11, tzinfo=datetime.timezone.utc), 'commenter': 'jnareb', 'type': 'User'}, {'comment_id': 467187681, 'comment_body': ""Wow! That's so simple.\r\n\r\nI spent a week wondering all the ways I should test reachability without GDAT chunk and the answer was as simple as to leverage the hard work that done by you and other contributers!\r\n\r\nThanks for the detailed response."", 'comment_created': datetime.datetime(2020, 8, 7, 17, 56, 25, tzinfo=datetime.timezone.utc), 'commenter': 'abhishekkumar2718', 'type': 'User'}, {'comment_id': 467192197, 'comment_body': '> When we are writing a split commit-graph, we should not add a GDAT chunk if the base commit graph doesn\'t have one. This will prevent ""holes"" in the middle of a chain, as you described. It means we won\'t get a GDAT chunk on top of old commit-graphs unless we merge all of the levels.\r\n> \r\n> With this in mind, it would be good to write a commit-graph without a GDAT chunk (using `GIT_TEST_COMMIT_GRAPH_NO_GDAT=1`), then add a new layer on top (without that env var) and see that the GDAT chunk doesn\'t exist there. Finally, rewrite the whole commit-graph using `--split=replace` and see that the single layer _does_ have a GDAT chunk.\r\n> \r\n> Does that make sense?\r\n\r\nYes, that makes complete sense to me. I can see why we shouldn\'t merge split commit-graph chain unless explicitly ordered by the user. Replace is a very costly operation, which is exactly the point of using split commit graphs.', 'comment_created': datetime.datetime(2020, 8, 7, 18, 5, 52, tzinfo=datetime.timezone.utc), 'commenter': 'abhishekkumar2718', 'type': 'User'}, {'comment_id': 467941228, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/a3910f82-ab2e-bf35-ac43-c30d77f3c96b@gmail.com), Derrick Stolee wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn 8/8/2020 10:53 PM, Abhishek Kumar via GitGitGadget wrote:\n> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> \n> With most of preparations done, let\'s implement corrected commit date\n> offset. We add a new commit-slab to store topogical levels while\n> writing commit graph and upgrade the generation member in struct\n> commit_graph_data to a 64-bit timestamp. We store topological levels to\n> ensure that older versions of Git will still have the performance\n> benefits from generation number v2.\n> \n> Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> ---\n\n> @@ -767,7 +764,10 @@ static void fill_commit_graph_info(struct commit *item, struct commit_graph *g,\n>  \titem->date = (timestamp_t)((date_high << 32) | date_low);\n>  \n>  \tif (g->chunk_generation_data)\n> -\t\tgraph_data->generation = get_be32(g->chunk_generation_data + sizeof(uint32_t) * lex_index);\n> +\t{\n> +\t\tgraph_data->generation = item->date +\n> +\t\t\t(timestamp_t) get_be32(g->chunk_generation_data + sizeof(uint32_t) * lex_index);\n> +\t}\n\nYou don\'t need curly braces here, since this is only one line\nin the block. Even if you did, these braces are in the wrong\nlocation.\n\nThere is a subtle issue with this interpretation, and it\ninvolves the case where the following happens:\n\n1. A new version of Git writes a commit-graph using the\n   GDAT chunk.\n\n2. An older version of Git adds a new layer without the\n   GDAT chunk.\n\nAt that point, the tip commit-graph does not have GDAT,\nso the commits in that layer will get ""generation"" set\nwith the topological level, which is likely to be much\nlower than the corrected commit dates set in the\n""generation"" field for commits in the lower layer.\n\nThe crux of the issue is that we are only considering\nthe current layer when interpreting the generation number\nvalue.\n\nThe patch below inserts a flag into fill_commit_graph_info()\ncorresponding to the ""global"" state of whether the top\ncommit-graph layer has a GDAT chunk. By your later protection\nto not write GDAT chunks on top of commit-graphs without\na GDAT chunk, this top commit-graph has all of the information\nwe need for this check.\n\nThanks,\n-Stolee\n\n--- >8 ---\n\nFrom 62189709fad3b051cedbd36193f5244fcce17e1f Mon Sep 17 00:00:00 2001\nFrom: Derrick Stolee <dstolee@microsoft.com>\nDate: Mon, 10 Aug 2020 10:06:47 -0400\nSubject: [PATCH] commit-graph: use generation v2 only if entire chain does\n\nSince there are released versions of Git that understand generation\nnumbers in the commit-graph\'s CDAT chunk but do not understand the GDAT\nchunk, the following scenario is possible:\n\n 1. ""New"" Git writes a commit-graph with the GDAT chunk.\n 2. ""Old"" Git writes a split commit-graph on top without a GDAT chunk.\n\nBecause of the current use of inspecting the current layer for a\ngeneration_data_chunk pointer, the commits in the lower layer will be\ninterpreted as having very large generation values (commit date plus\noffset) compared to the generation numbers in the top layer (topological\nlevel). This violates the expectation that the generation of a parent is\nstrictly smaller than the generation of a child.\n\nIt is difficult to expose this issue in a test. Since we _start_ with\nartificially low generation numbers, any commit walk that prioritizes\ngeneration numbers will walk all of the commits with high generation\nnumber before walking the commits with low generation number. In all the\ncases I tried, the commit-graph layers themselves ""protect"" any\nincorrect behavior since none of the commits in the lower layer can\nreach the commits in the upper layer.\n\nThis issue would manifest itself as a performance problem in this\ncase, especially with something like ""git log --graph"" since the low\ngeneration numbers would cause the in-degree queue to walk all of the\ncommits in the lower layer before allowing the topo-order queue to write\nanything to output (depending on the size of the upper layer).\n\nSigned-off-by: Derrick Stolee <dstolee@microsoft.com>\n---\n commit-graph.c | 24 ++++++++++++++++++------\n 1 file changed, 18 insertions(+), 6 deletions(-)\n\ndiff --git a/commit-graph.c b/commit-graph.c\nindex eb78af3dad..17623274d9 100644\n--- a/commit-graph.c\n+++ b/commit-graph.c\n@@ -762,7 +762,9 @@ static struct commit_list **insert_parent_or_die(struct repository *r,\n \treturn &commit_list_insert(c, pptr)->next;\n }\n \n-static void fill_commit_graph_info(struct commit *item, struct commit_graph *g, uint32_t pos)\n+#define COMMIT_GRAPH_GENERATION_V2 (1 << 0)\n+\n+static void fill_commit_graph_info(struct commit *item, struct commit_graph *g, uint32_t pos, int flags)\n {\n \tconst unsigned char *commit_data;\n \tstruct commit_graph_data *graph_data;\n@@ -785,11 +787,9 @@ static void fill_commit_graph_info(struct commit *item, struct commit_graph *g,\n \tdate_low = get_be32(commit_data + g->hash_len + 12);\n \titem->date = (timestamp_t)((date_high << 32) | date_low);\n \n-\tif (g->chunk_generation_data)\n-\t{\n+\tif (g->chunk_generation_data && (flags & COMMIT_GRAPH_GENERATION_V2))\n \t\tgraph_data->generation = item->date +\n \t\t\t(timestamp_t) get_be32(g->chunk_generation_data + sizeof(uint32_t) * lex_index);\n-\t}\n \telse\n \t\tgraph_data->generation = get_be32(commit_data + g->hash_len + 8) >> 2;\n }\n@@ -799,6 +799,10 @@ static inline void set_commit_tree(struct commit *c, struct tree *t)\n \tc->maybe_tree = t;\n }\n \n+/*\n+ * In the case of a split commit-graph, this method expects the given\n+ * commit-graph \'g\' to be the top layer.\n+ */\n static int fill_commit_in_graph(struct repository *r,\n \t\t\t\tstruct commit *item,\n \t\t\t\tstruct commit_graph *g, uint32_t pos)\n@@ -808,11 +812,15 @@ static int fill_commit_in_graph(struct repository *r,\n \tstruct commit_list **pptr;\n \tconst unsigned char *commit_data;\n \tuint32_t lex_index;\n+\tint flags = 0;\n+\n+\tif (g->chunk_generation_data)\n+\t\tflags |= COMMIT_GRAPH_GENERATION_V2;\n \n \twhile (pos < g->num_commits_in_base)\n \t\tg = g->base_graph;\n \n-\tfill_commit_graph_info(item, g, pos);\n+\tfill_commit_graph_info(item, g, pos, flags);\n \n \tlex_index = pos - g->num_commits_in_base;\n \tcommit_data = g->chunk_commit_data + GRAPH_DATA_WIDTH * lex_index;\n@@ -904,10 +912,14 @@ int parse_commit_in_graph(struct repository *r, struct commit *item)\n void load_commit_graph_info(struct repository *r, struct commit *item)\n {\n \tuint32_t pos;\n+\tint flags = 0;\n+\n \tif (!prepare_commit_graph(r))\n \t\treturn;\n+\tif (r->objects->commit_graph->chunk_generation_data)\n+\t\tflags |= COMMIT_GRAPH_GENERATION_V2;\n \tif (find_commit_in_graph(item, r->objects->commit_graph, &pos))\n-\t\tfill_commit_graph_info(item, r->objects->commit_graph, pos);\n+\t\tfill_commit_graph_info(item, r->objects->commit_graph, pos, flags);\n }\n \n static struct tree *load_tree_for_commit(struct repository *r,\n-- \n2.28.0.38.gc6f546511c1\n\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 10, 14, 25, 54, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 468029925, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/aee0ae56-3395-6848-d573-27a318d72755@gmail.com), Derrick Stolee wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn 8/8/2020 10:53 PM, Abhishek Kumar via GitGitGadget wrote:\n> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> \n> As discovered by Ævar, we cannot increment graph version to\n> distinguish between generation numbers v1 and v2 [1]. Thus, one of\n> pre-requistes before implementing generation number was to distinguish\n> between graph versions in a backwards compatible manner.\n> \n> We are going to introduce a new chunk called Generation Data chunk (or\n> GDAT). GDAT stores generation number v2 (and any subsequent versions),\n> whereas CDAT will still store topological level.\n> \n> Old Git does not understand GDAT chunk and would ignore it, reading\n> topological levels from CDAT. New Git can parse GDAT and take advantage\n> of newer generation numbers, falling back to topological levels when\n> GDAT chunk is missing (as it would happen with a commit graph written\n> by old Git).\n\nThere is a philosophical problem with this patch, and I\'m not sure\nabout the right way to fix it, or if there really is a problem at all.\nAt minimum, the commit message needs to be improved to make the issue\nclear:\n\nThis version of the chunk does not store corrected commit date offsets!\n\nThis commit add a chunk named ""GDAT"" and fills it with topological\nlevels. This is _different_ than the intended final format. For that\nreason, the commit-graph-format.txt document is not updated.\n\nThe reason I say this is a ""philosophical"" problem is that this patch\nintroduces a version of Git that has a different interpretation of the\nGDAT chunk than the version presented two patches later. While this\nversion would never be released, it still exists in history and could\npresent difficulty if someone were to bisect on an issue with the GDAT\nchunk (using external data, not data produced by the compiled binary\nat that version).\n\nThe justification for this commit the way you did it is clear: there\nis a lot of test fallout to just including a new chunk. The question\nis whether it is enough to justify this ""dummy"" implementation for\nnow?\n\nThe tricky bit is the series of three patches starting with this\none.\n\n1. The next patch ""commit-graph: return 64-bit generation number"" can\n   be reordered to be before this patch, no problem. I don\'t think\n   there will be any text conflicts _except_ inside the\n   write_graph_chunk_generation_data() method introduced here.\n\n2. The patch after that, ""commit-graph: implement corrected commit date""\n   only has a small dependence: it writes to the GDAT chunk and parses\n   it out. If you remove the interaction with the GDAT chunk, then you\n   still have the computation as part of compute_generation_numbers()\n   that is valuable. You will need to be careful about the exit\n   condition, though, since you also introduce the topo_level chunk.\n\nPatches 5-7 could perhaps be reorganized as follows:\n\n  i. commit-graph: return 64-bit generation number, as-is.\n\n ii. Add a topo_level slab that is parsed from CDAT. Modify\n     compute_generation_numbers() to populate this value and modify\n     write_graph_chunk_data() to read this value. Simultaneously\n     populate the ""generation"" member with the same value.\n\niii. ""commit-graph: implement corrected commit date"" without any GDAT\n     chunk interaction. Make sure the algorithm in\n     compute_generation_numbers() walks commits if either topo_level or\n     generation are unset. There is a trick here: the generation value\n     _is_ set if the commit is parsed from the existing commit-graph!\n     Is this case covered by the existing logic to not write GDAT when\n     writing a split commit-graph file with a base that does not have\n     GDAT? Note that the non-split case does not load the commit-graph\n     for parsing, so the interesting case is ""--split-replace"". Worth\n     a test (after we write the GDAT chunk), which you have in ""commit-graph:\n     handle mixed generation commit chains"".\n\n iv. This patch, introducing the chunk and the read/write logic.\n\n  v. Add the remaining patches.\n\nAgain, this is a complicated patch-reorganization. The hope is that\nthe end result is something that is easy to review as well as something\nthat produces an as-sane-as-possible history for future bisecters.\n\nPerhaps other reviewers have similar feelings, or can say that I am\nbeing too picky.\n\n> We introduce a test environment variable \'GIT_TEST_COMMIT_GRAPH_NO_GDAT\'\n> which forces commit-graph file to be written without generation data\n> chunk to emulate a commit-graph file written by old Git.\n\nThank you for introducing this. It really makes it clear what the\nbenefit is when looking at the t6600-test-reach.sh changes. However,\nthe changes to that script are more ""here is an opportunity for extra\ncoverage"" as opposed to a necessary change immediately upon creating\nthe GDAT chunk. That could be separated out and justified on its own.\nRecall that the justification is that the new version of Git will\ncontinue to work with commit-graph files without a GDAT chunk.\n\n> +static int write_graph_chunk_generation_data(struct hashfile *f,\n> +\t\t\t\t\t      struct write_commit_graph_context *ctx)\n> +{\n> +\tint i;\n> +\tfor (i = 0; i < ctx->commits.nr; i++) {\n> +\t\tstruct commit *c = ctx->commits.list[i];\n> +\t\tdisplay_progress(ctx->progress, ++ctx->progress_cnt);\n> +\t\thashwrite_be32(f, commit_graph_data_at(c)->generation);\n\nHere is the ""incorrect"" data being written.\n\n> +\t}\n> +\n> +\treturn 0;\n> +}\n> +\n\n> --- a/t/t5318-commit-graph.sh\n> +++ b/t/t5318-commit-graph.sh\n> @@ -72,7 +72,7 @@ graph_git_behavior \'no graph\' full commits/3 commits/1\n>  graph_read_expect() {\n>  \tOPTIONAL=""""\n>  \tNUM_CHUNKS=3\n> -\tif test ! -z $2\n> +\tif test ! -z ""$2""\n\nA subtle change, but important because we now have multiple ""extra""\nchunks possible here. Good.\n\n>  graph_git_behavior \'bare repo with graph, commit 8 vs merge 1\' bare commits/8 merge/1\n> @@ -421,8 +421,9 @@ test_expect_success \'replace-objects invalidates commit-graph\' \'\n>  \n>  test_expect_success \'git commit-graph verify\' \'\n>  \tcd ""$TRASH_DIRECTORY/full"" &&\n> -\tgit rev-parse commits/8 | git commit-graph write --stdin-commits &&\n> -\tgit commit-graph verify >output\n> +\tgit rev-parse commits/8 | GIT_TEST_COMMIT_GRAPH_NO_GDAT=1 git commit-graph write --stdin-commits &&\n> +\tgit commit-graph verify >output &&\n> +\tgraph_read_expect 9 extra_edges\n>  \'\n\nAnd it is this case as to why we don\'t just add ""generation_data"" to our\nlist of expected chunks.\n\n> @@ -29,9 +29,9 @@ graph_read_expect() {\n>  \t\tNUM_BASE=$2\n>  \tfi\n>  \tcat >expect <<- EOF\n> -\theader: 43475048 1 1 3 $NUM_BASE\n> +\theader: 43475048 1 1 4 $NUM_BASE\n>  \tnum_commits: $1\n> -\tchunks: oid_fanout oid_lookup commit_metadata\n> +\tchunks: oid_fanout oid_lookup commit_metadata generation_data\n\nIn this script, you _do_ add it to the default chunk list, which\nsaves some extra work in the rest of the tests. Good.\n\n\nThanks,\n-Stolee\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 10, 16, 29, 12, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 468038806, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/0d741fb2-e25a-be05-9f2b-81ba2b4ced3f@gmail.com), Derrick Stolee wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn 8/8/2020 10:53 PM, Abhishek Kumar via GitGitGadget wrote:\n> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> \n> As corrected commit dates and topological levels cannot be compared\n> directly, we must handle commit graph chains with mixed generation\n> number definitions.\n> \n> While reading a commit graph file, we disable generation numbers if the\n> chain contains mixed generation numbers.\n> \n> While writing to commit graph chain, we write generation data chunk only\n> if the previous tip of chain had a generation data chunk. Using\n> `--split=replace` overwrites the existing chain and writes generation\n> data chunk regardless of previous tip.\n> \n> In t5324-split-commit-graph, we set up a repo with twelve commits and\n> write a base commit graph file with no generation data chunk. When add\n> three commits and write to chain again, Git does not write generation\n> data chunk even without setting GIT_TEST_COMMIT_GRAPH_NO_GDAT=1. Then,\n> as we replace the existing chain, Git writes a commit graph file with\n> generation data chunk.\n> \n> Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> ---\n>  commit-graph.c                | 14 ++++++++\n>  t/t5324-split-commit-graph.sh | 66 +++++++++++++++++++++++++++++++++++\n>  2 files changed, 80 insertions(+)\n> \n> diff --git a/commit-graph.c b/commit-graph.c\n> index d0f977852b..c6b6111adf 100644\n> --- a/commit-graph.c\n> +++ b/commit-graph.c\n> @@ -674,6 +674,14 @@ int generation_numbers_enabled(struct repository *r)\n>  \tif (!g->num_commits)\n>  \t\treturn 0;\n>  \n> +\t/* We cannot compare topological levels and corrected commit dates */\n> +\twhile (g->base_graph) {\n> +\t\twarning(_(""commit-graph-chain contains mixed generation versions""));\n\nThis warning is premature. It will add a warning whenever we have\na split commit-graph, regardless of an incorrect chain.\n\n> +\t\tif ((g->chunk_generation_data == NULL) ^ (g->base_graph->chunk_generation_data == NULL))\n\nHm. A bit-wise XOR here? That seems unfortunate. I think that it\nis easier to focus on the \n\n\n\n> +\t\t\treturn 0;\n> +\t\tg = g->base_graph;\n> +\t}\n> +\n\nHm. So this scenario actually disables generation numbers completely\nin the event that anything in the chain disagrees. I think this is\nnot the right way to approach the situation, as it will significantly\npunish users in this state with slow performance.\n\nThe patch I sent [1] is probably better: it uses generation number\nv1 if the tip of the chain does not have a GDAT chunk.\n\n[1] https://lore.kernel.org/git/a3910f82-ab2e-bf35-ac43-c30d77f3c96b@gmail.com/\n\n>  \tfirst_generation = get_be32(g->chunk_commit_data +\n>  \t\t\t\t    g->hash_len + 8) >> 2;\n>  \n> @@ -2186,6 +2194,9 @@ int write_commit_graph(struct object_directory *odb,\n>  \n>  \t\tg = ctx->r->objects->commit_graph;\n>  \n> +\t\tif (g && !g->chunk_generation_data)\n> +\t\t\tctx->write_generation_data = 0;\n> +\n>  \t\twhile (g) {\n>  \t\t\tctx->num_commit_graphs_before++;\n>  \t\t\tg = g->base_graph;\n> @@ -2204,6 +2215,9 @@ int write_commit_graph(struct object_directory *odb,\n>  \n>  \t\tif (ctx->split_opts)\n>  \t\t\treplace = ctx->split_opts->flags & COMMIT_GRAPH_SPLIT_REPLACE;\n> +\n> +\t\tif (replace)\n> +\t\t\tctx->write_generation_data = 1;\n>  \t}\n\nPlease make a point to move the line that checks GIT_TEST_COMMIT_GRAPH_NO_GDAT\nfrom its current location to after this line. We want to make sure that the\nenvironment variable is checked _last_. The best location is likely the start\nof the implementation of compute_generation_numbers(), or immediately before\nthe call to the method.\n\n> +test_expect_success \'setup repo for mixed generation commit-graph-chain\' \'\n> +\tmkdir mixed &&\n> +\tgraphdir="".git/objects/info/commit-graphs"" &&\n> +\tcd ""$TRASH_DIRECTORY/mixed"" &&\n> +\tgit init &&\n> +\tgit config core.commitGraph true &&\n> +\tgit config gc.writeCommitGraph false &&\n> +\tfor i in $(test_seq 3)\n> +\tdo\n> +\t\ttest_commit $i &&\n> +\t\tgit branch commits/$i || return 1\n> +\tdone &&\n> +\tgit reset --hard commits/1 &&\n> +\tfor i in $(test_seq 4 5)\n> +\tdo\n> +\t\ttest_commit $i &&\n> +\t\tgit branch commits/$i || return 1\n> +\tdone &&\n> +\tgit reset --hard commits/2 &&\n> +\tfor i in $(test_seq 6 10)\n> +\tdo\n> +\t\ttest_commit $i &&\n> +\t\tgit branch commits/$i || return 1\n> +\tdone &&\n> +\tgit reset --hard commits/2 &&\n> +\tgit merge commits/4 &&\n> +\tgit branch merge/1 &&\n> +\tgit reset --hard commits/4 &&\n> +\tgit merge commits/6 &&\n> +\tgit branch merge/2 &&\n> +\tGIT_TEST_COMMIT_GRAPH_NO_GDAT=1 git commit-graph write --reachable --split &&\n> +\ttest-tool read-graph >output &&\n> +\tcat >expect <<-EOF &&\n> +\theader: 43475048 1 1 3 0\n> +\tnum_commits: 12\n> +\tchunks: oid_fanout oid_lookup commit_metadata\n> +\tEOF\n> +\ttest_cmp expect output\n> +\'\n> +\n> +test_expect_success \'does not write generation data chunk if not present on existing tip\' \'\n> +\tcd ""$TRASH_DIRECTORY/mixed"" &&\n> +\tgit reset --hard commits/3 &&\n> +\tgit merge merge/1 &&\n> +\tgit merge commits/5 &&\n> +\tgit merge merge/2 &&\n> +\tgit branch merge/3 &&\n> +\tgit commit-graph write --reachable --split &&\n> +\ttest-tool read-graph >output &&\n> +\tcat >expect <<-EOF &&\n> +\theader: 43475048 1 1 4 1\n> +\tnum_commits: 3\n> +\tchunks: oid_fanout oid_lookup commit_metadata\n> +\tEOF\n> +\ttest_cmp expect output\n> +\'\n> +\n> +test_expect_success \'writes generation data chunk when commit-graph chain is replaced\' \'\n> +\tcd ""$TRASH_DIRECTORY/mixed"" &&\n> +\tgit commit-graph write --reachable --split=\'replace\' &&\n> +\ttest_path_is_file $graphdir/commit-graph-chain &&\n> +\ttest_line_count = 1 $graphdir/commit-graph-chain &&\n> +\tverify_chain_files_exist $graphdir &&\n> +\tgraph_read_expect 15\n> +\'\n\nIt would be valuable to double-check here that the values in the GDAT chunk\nare correct. I\'m concerned about the possibility that the \'generation\'\nmember of struct commit_graph_data gets filled with topological level during\nparsing and then that is written as an offset into the CDAT chunk.\n\nPerhaps this is best left for a follow-up series that updates the \'verify\'\nsubcommand to check the GDAT chunk.\n\nThanks,\n-Stolee\n\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 10, 16, 44, 15, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 468499903, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/20200811110316.GA3220@Abhishek-Arch), Abhishek Kumar wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Mon, Aug 10, 2020 at 12:28:10PM -0400, Derrick Stolee wrote:\n> On 8/8/2020 10:53 PM, Abhishek Kumar via GitGitGadget wrote:\n> > From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> > \n> > As discovered by �var, we cannot increment graph version to\n> > distinguish between generation numbers v1 and v2 [1]. Thus, one of\n> > pre-requistes before implementing generation number was to distinguish\n> > between graph versions in a backwards compatible manner.\n> > \n> > We are going to introduce a new chunk called Generation Data chunk (or\n> > GDAT). GDAT stores generation number v2 (and any subsequent versions),\n> > whereas CDAT will still store topological level.\n> > \n> > Old Git does not understand GDAT chunk and would ignore it, reading\n> > topological levels from CDAT. New Git can parse GDAT and take advantage\n> > of newer generation numbers, falling back to topological levels when\n> > GDAT chunk is missing (as it would happen with a commit graph written\n> > by old Git).\n> \n> There is a philosophical problem with this patch, and I\'m not sure\n> about the right way to fix it, or if there really is a problem at all.\n> At minimum, the commit message needs to be improved to make the issue\n> clear:\n> \n> This version of the chunk does not store corrected commit date offsets!\n> \n> This commit add a chunk named ""GDAT"" and fills it with topological\n> levels. This is _different_ than the intended final format. For that\n> reason, the commit-graph-format.txt document is not updated.\n> \n> The reason I say this is a ""philosophical"" problem is that this patch\n> introduces a version of Git that has a different interpretation of the\n> GDAT chunk than the version presented two patches later. While this\n> version would never be released, it still exists in history and could\n> present difficulty if someone were to bisect on an issue with the GDAT\n> chunk (using external data, not data produced by the compiled binary\n> at that version).\n> \n\nYes, that is correct. I did often wonder that our inference that ""commit\ngraph has a generation data chunk implies commit graph stores corrected\ncommit date offsets"" is not always true because of this ""dummy""\nimplementation. \n\n> The justification for this commit the way you did it is clear: there\n> is a lot of test fallout to just including a new chunk. The question\n> is whether it is enough to justify this ""dummy"" implementation for\n> now?\n> \n> The tricky bit is the series of three patches starting with this\n> one.\n> \n> 1. The next patch ""commit-graph: return 64-bit generation number"" can\n>    be reordered to be before this patch, no problem. I don\'t think\n>    there will be any text conflicts _except_ inside the\n>    write_graph_chunk_generation_data() method introduced here.\n> \n> 2. The patch after that, ""commit-graph: implement corrected commit date""\n>    only has a small dependence: it writes to the GDAT chunk and parses\n>    it out. If you remove the interaction with the GDAT chunk, then you\n>    still have the computation as part of compute_generation_numbers()\n>    that is valuable. You will need to be careful about the exit\n>    condition, though, since you also introduce the topo_level chunk.\n> \n> Patches 5-7 could perhaps be reorganized as follows:\n> \n>   i. commit-graph: return 64-bit generation number, as-is.\n> \n>  ii. Add a topo_level slab that is parsed from CDAT. Modify\n>      compute_generation_numbers() to populate this value and modify\n>      write_graph_chunk_data() to read this value. Simultaneously\n>      populate the ""generation"" member with the same value.\n> \n> iii. ""commit-graph: implement corrected commit date"" without any GDAT\n>      chunk interaction. Make sure the algorithm in\n>      compute_generation_numbers() walks commits if either topo_level or\n>      generation are unset. There is a trick here: the generation value\n>      _is_ set if the commit is parsed from the existing commit-graph!\n>      Is this case covered by the existing logic to not write GDAT when\n>      writing a split commit-graph file with a base that does not have\n>      GDAT? Note that the non-split case does not load the commit-graph\n>      for parsing, so the interesting case is ""--split-replace"". Worth\n>      a test (after we write the GDAT chunk), which you have in ""commit-graph:\n>      handle mixed generation commit chains"".\n> \n\nRight, so at the end of this patch we compute corrected commit dates but\ndon\'t write them to graph file.\n\nAlthough, writing ii. and iii. together in the same patch makes more\nsense to me. Would it be hard to follow for someone who has no context\nof this discussion?\n\n>  iv. This patch, introducing the chunk and the read/write logic.\n> \n>   v. Add the remaining patches.\n> \n> Again, this is a complicated patch-reorganization. The hope is that\n> the end result is something that is easy to review as well as something\n> that produces an as-sane-as-possible history for future bisecters.\n> \n> Perhaps other reviewers have similar feelings, or can say that I am\n> being too picky.\n> \n\nI can see how the reorganization helps us avoid a rather nasty\nsituation to be in. Should not be too hard to reorganize.\n\n> > We introduce a test environment variable \'GIT_TEST_COMMIT_GRAPH_NO_GDAT\'\n> > which forces commit-graph file to be written without generation data\n> > chunk to emulate a commit-graph file written by old Git.\n> \n> ...\n> \n> Thanks,\n> -Stolee\n\nThanks\n- Abhishek\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 11, 11, 6, 26, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 468515717, 'comment_body': ""[On the Git mailing list](https://lore.kernel.org/git/20200811113621.GB3220@Abhishek-Arch), Abhishek Kumar wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Mon, Aug 10, 2020 at 12:42:29PM -0400, Derrick Stolee wrote:\n> On 8/8/2020 10:53 PM, Abhishek Kumar via GitGitGadget wrote:\n> \n> ...\n>\n> Hm. So this scenario actually disables generation numbers completely\n> in the event that anything in the chain disagrees. I think this is\n> not the right way to approach the situation, as it will significantly\n> punish users in this state with slow performance.\n> \n> The patch I sent [1] is probably better: it uses generation number\n> v1 if the tip of the chain does not have a GDAT chunk.\n> \n> [1] https://lore.kernel.org/git/a3910f82-ab2e-bf35-ac43-c30d77f3c96b@gmail.com/\n> \n\nYes, the patch is an clear improvement over my (convoluted and incorrect)\nlogic. Will add.\n\n>\n> ...\n> \n> Please make a point to move the line that checks GIT_TEST_COMMIT_GRAPH_NO_GDAT\n> from its current location to after this line. We want to make sure that the\n> environment variable is checked _last_. The best location is likely the start\n> of the implementation of compute_generation_numbers(), or immediately before\n> the call to the method.\n> \n\nSure, will do.\n\n>\n> ...\n> \n> It would be valuable to double-check here that the values in the GDAT chunk\n> are correct. I'm concerned about the possibility that the 'generation'\n> member of struct commit_graph_data gets filled with topological level during\n> parsing and then that is written as an offset into the CDAT chunk.\n> \n> Perhaps this is best left for a follow-up series that updates the 'verify'\n> subcommand to check the GDAT chunk.\n\nIf I can understand it correctly, one of ways to update 'verify'\nsubcommand to check the GDAT chunk as well would to be make use of the\nflag variable introduced in your patch. We can isolate generation number\nrelated checks and run checks once with flag = 1 (checking corrected\ncommit dates) and once with flag = 0 (checking topological levels).\n\nThis has the unfortunate effect of filling all commits twice, but as we\ncannot change the commit_graph_data->generation any other way, I see no\nalternatives without changing how commit_graph_generation() works.\n\nWould it make more sense if we add the flag to struct commit_graph\ninstead of making it depend solely on g->chunk_generation_data and set\nit within parse_commit_graph()?\n\nWe would be able to control the behavior of fill_commit_graph_info() and\nwe will not need to check g->chunk_generation_data before filling every\ncommit.\n\n> \n> Thanks,\n> -Stolee\n> \n\nThanks\n- Abhishek\n``````````\n"", 'comment_created': datetime.datetime(2020, 8, 11, 11, 39, 31, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 468542968, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/3c053281-f5af-1ac8-75ef-9eb8ce4f539d@gmail.com), Derrick Stolee wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn 8/11/2020 7:03 AM, Abhishek Kumar wrote:\n> On Mon, Aug 10, 2020 at 12:28:10PM -0400, Derrick Stolee wrote:\n>> Patches 5-7 could perhaps be reorganized as follows:\n>>\n>>   i. commit-graph: return 64-bit generation number, as-is.\n>>\n>>  ii. Add a topo_level slab that is parsed from CDAT. Modify\n>>      compute_generation_numbers() to populate this value and modify\n>>      write_graph_chunk_data() to read this value. Simultaneously\n>>      populate the ""generation"" member with the same value.\n>>\n>> iii. ""commit-graph: implement corrected commit date"" without any GDAT\n>>      chunk interaction. Make sure the algorithm in\n>>      compute_generation_numbers() walks commits if either topo_level or\n>>      generation are unset. There is a trick here: the generation value\n>>      _is_ set if the commit is parsed from the existing commit-graph!\n>>      Is this case covered by the existing logic to not write GDAT when\n>>      writing a split commit-graph file with a base that does not have\n>>      GDAT? Note that the non-split case does not load the commit-graph\n>>      for parsing, so the interesting case is ""--split-replace"". Worth\n>>      a test (after we write the GDAT chunk), which you have in ""commit-graph:\n>>      handle mixed generation commit chains"".\n>>\n> \n> Right, so at the end of this patch we compute corrected commit dates but\n> don\'t write them to graph file.\n> \n> Although, writing ii. and iii. together in the same patch makes more\n> sense to me. Would it be hard to follow for someone who has no context\n> of this discussion?\n\nIt is always easier to combine two patches than to split one into two.\n\nWith that in mind, I recommend starting with a split version and then\nseeing how each patch looks. I think that these are ""independent enough""\nideas that justify the separate patches.\n\n>>  iv. This patch, introducing the chunk and the read/write logic.\n>>\n>>   v. Add the remaining patches.\n>>\n>> Again, this is a complicated patch-reorganization. The hope is that\n>> the end result is something that is easy to review as well as something\n>> that produces an as-sane-as-possible history for future bisecters.\n>>\n>> Perhaps other reviewers have similar feelings, or can say that I am\n>> being too picky.\n>>\n> \n> I can see how the reorganization helps us avoid a rather nasty\n> situation to be in. Should not be too hard to reorganize.\n\nI hope not. Hopefully you get some more review on this version\nbefore jumping in on such a big reorg (in case someone else has\na different opinion).\n\nThanks,\n-Stolee\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 11, 12, 30, 39, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 468551406, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/4043ffbc-84df-0cd6-5c75-af80383a56cf@gmail.com), Derrick Stolee wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn 8/11/2020 7:36 AM, Abhishek Kumar wrote:\n> On Mon, Aug 10, 2020 at 12:42:29PM -0400, Derrick Stolee wrote:\n>> On 8/8/2020 10:53 PM, Abhishek Kumar via GitGitGadget wrote:\n>>\n>> ...\n>>\n>> Hm. So this scenario actually disables generation numbers completely\n>> in the event that anything in the chain disagrees. I think this is\n>> not the right way to approach the situation, as it will significantly\n>> punish users in this state with slow performance.\n>>\n>> The patch I sent [1] is probably better: it uses generation number\n>> v1 if the tip of the chain does not have a GDAT chunk.\n>>\n>> [1] https://lore.kernel.org/git/a3910f82-ab2e-bf35-ac43-c30d77f3c96b@gmail.com/\n>>\n> \n> Yes, the patch is an clear improvement over my (convoluted and incorrect)\n> logic. Will add.\n> \n>>\n>> ...\n>>\n>> Please make a point to move the line that checks GIT_TEST_COMMIT_GRAPH_NO_GDAT\n>> from its current location to after this line. We want to make sure that the\n>> environment variable is checked _last_. The best location is likely the start\n>> of the implementation of compute_generation_numbers(), or immediately before\n>> the call to the method.\n>>\n> \n> Sure, will do.\n> \n>>\n>> ...\n>>\n>> It would be valuable to double-check here that the values in the GDAT chunk\n>> are correct. I\'m concerned about the possibility that the \'generation\'\n>> member of struct commit_graph_data gets filled with topological level during\n>> parsing and then that is written as an offset into the CDAT chunk.\n>>\n>> Perhaps this is best left for a follow-up series that updates the \'verify\'\n>> subcommand to check the GDAT chunk.\n> \n> If I can understand it correctly, one of ways to update \'verify\'\n> subcommand to check the GDAT chunk as well would to be make use of the\n> flag variable introduced in your patch. We can isolate generation number\n> related checks and run checks once with flag = 1 (checking corrected\n> commit dates) and once with flag = 0 (checking topological levels).\n> \n> This has the unfortunate effect of filling all commits twice, but as we\n> cannot change the commit_graph_data->generation any other way, I see no\n> alternatives without changing how commit_graph_generation() works.\n> \n> Would it make more sense if we add the flag to struct commit_graph\n> instead of making it depend solely on g->chunk_generation_data and set\n> it within parse_commit_graph()?\n> \n> We would be able to control the behavior of fill_commit_graph_info() and\n> we will not need to check g->chunk_generation_data before filling every\n> commit.\n\nI missed that you _already_ updated the logic in verify_commit_graph()\nbased on the generation. That logic should catch the problem, so it\nmight be enough to just add some ""git commit-graph verify"" commands into\nyour multi-level tests.\n\nSpecifically, the end result is this check:\n\n\tcorrected_commit_date = commit_graph_generation(graph_commit);\n\tif (corrected_commit_date < max_parent_corrected_commit_date + 1)\n\t\tgraph_report(_(""commit-graph generation for commit %s is %""PRItime"" < %""PRItime),\n\t\t\t     oid_to_hex(&cur_oid),\n\t\t\t     corrected_commit_date,\n\t\t\t     max_parent_corrected_commit_date + 1);\n\nThis will catch the order violations I was proposing could happen. It\ndoesn\'t go the extra mile to ensure that the commit-graph stores the\nexact correct value or that the two bits of data are correct (both\ntopo-level and corrected commit date). That is fine for now, and we\ncan revisit if necessary.\n\nThe diff below makes some tweaks to your split-level test to show the\nlogic _was_ incorrect without my patch. Please incorporate the test\nchanges into your series. Note in particular that I added a base\nlayer that includes the GDAT chunk and _then_ adds a layer without\nthe GDAT chunk. That is an important case!\n\nThanks,\n-Stolee\n\n--- >8 ---\n\ndiff --git a/commit-graph.c b/commit-graph.c\nindex 17623274d9..d891a8ba3a 100644\n--- a/commit-graph.c\n+++ b/commit-graph.c\n@@ -674,14 +674,6 @@ int generation_numbers_enabled(struct repository *r)\n \tif (!g->num_commits)\n \t\treturn 0;\n \n-\t/* We cannot compare topological levels and corrected commit dates */\n-\twhile (g->base_graph) {\n-\t\twarning(_(""commit-graph-chain contains mixed generation versions""));\n-\t\tif ((g->chunk_generation_data == NULL) ^ (g->base_graph->chunk_generation_data == NULL))\n-\t\t\treturn 0;\n-\t\tg = g->base_graph;\n-\t}\n-\n \tfirst_generation = get_be32(g->chunk_commit_data +\n \t\t\t\t    g->hash_len + 8) >> 2;\n \n@@ -787,7 +779,7 @@ static void fill_commit_graph_info(struct commit *item, struct commit_graph *g,\n \tdate_low = get_be32(commit_data + g->hash_len + 12);\n \titem->date = (timestamp_t)((date_high << 32) | date_low);\n \n-\tif (g->chunk_generation_data && (flags & COMMIT_GRAPH_GENERATION_V2))\n+\tif (g->chunk_generation_data)\n \t\tgraph_data->generation = item->date +\n \t\t\t(timestamp_t) get_be32(g->chunk_generation_data + sizeof(uint32_t) * lex_index);\n \telse\ndiff --git a/t/t5324-split-commit-graph.sh b/t/t5324-split-commit-graph.sh\nindex 1a9be5e656..721515cc23 100755\n--- a/t/t5324-split-commit-graph.sh\n+++ b/t/t5324-split-commit-graph.sh\n@@ -443,6 +443,7 @@ test_expect_success \'setup repo for mixed generation commit-graph-chain\' \'\n \t\ttest_commit $i &&\n \t\tgit branch commits/$i || return 1\n \tdone &&\n+\tgit commit-graph write --reachable --split &&\n \tgit reset --hard commits/2 &&\n \tfor i in $(test_seq 6 10)\n \tdo\n@@ -455,14 +456,15 @@ test_expect_success \'setup repo for mixed generation commit-graph-chain\' \'\n \tgit reset --hard commits/4 &&\n \tgit merge commits/6 &&\n \tgit branch merge/2 &&\n-\tGIT_TEST_COMMIT_GRAPH_NO_GDAT=1 git commit-graph write --reachable --split &&\n+\tGIT_TEST_COMMIT_GRAPH_NO_GDAT=1 git commit-graph write --reachable --split=no-merge &&\n \ttest-tool read-graph >output &&\n \tcat >expect <<-EOF &&\n-\theader: 43475048 1 1 3 0\n-\tnum_commits: 12\n+\theader: 43475048 1 1 4 1\n+\tnum_commits: 7\n \tchunks: oid_fanout oid_lookup commit_metadata\n \tEOF\n-\ttest_cmp expect output\n+\ttest_cmp expect output &&\n+\tgit commit-graph verify\n \'\n \n test_expect_success \'does not write generation data chunk if not present on existing tip\' \'\n@@ -472,23 +474,25 @@ test_expect_success \'does not write generation data chunk if not present on exis\n \tgit merge commits/5 &&\n \tgit merge merge/2 &&\n \tgit branch merge/3 &&\n-\tgit commit-graph write --reachable --split &&\n+\tgit commit-graph write --reachable --split=no-merge &&\n \ttest-tool read-graph >output &&\n \tcat >expect <<-EOF &&\n \theader: 43475048 1 1 4 1\n \tnum_commits: 3\n \tchunks: oid_fanout oid_lookup commit_metadata\n \tEOF\n-\ttest_cmp expect output\n+\ttest_cmp expect output &&\n+\tgit commit-graph verify\n \'\n \n test_expect_success \'writes generation data chunk when commit-graph chain is replaced\' \'\n \tcd ""$TRASH_DIRECTORY/mixed"" &&\n-\tgit commit-graph write --reachable --split=\'replace\' &&\n+\tgit commit-graph write --reachable --split=replace &&\n \ttest_path_is_file $graphdir/commit-graph-chain &&\n \ttest_line_count = 1 $graphdir/commit-graph-chain &&\n \tverify_chain_files_exist $graphdir &&\n-\tgraph_read_expect 15\n+\tgraph_read_expect 15 &&\n+\tgit commit-graph verify\n \'\n \n test_done\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 11, 12, 45, 37, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 468800477, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/20200811185839.GA34058@syl.lan), Taylor Blau wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Tue, Aug 11, 2020 at 08:27:41AM -0400, Derrick Stolee wrote:\n> On 8/11/2020 7:03 AM, Abhishek Kumar wrote:\n> > On Mon, Aug 10, 2020 at 12:28:10PM -0400, Derrick Stolee wrote:\n> >> Patches 5-7 could perhaps be reorganized as follows:\n> >>\n> >>   i. commit-graph: return 64-bit generation number, as-is.\n> >>\n> >>  ii. Add a topo_level slab that is parsed from CDAT. Modify\n> >>      compute_generation_numbers() to populate this value and modify\n> >>      write_graph_chunk_data() to read this value. Simultaneously\n> >>      populate the ""generation"" member with the same value.\n> >>\n> >> iii. ""commit-graph: implement corrected commit date"" without any GDAT\n> >>      chunk interaction. Make sure the algorithm in\n> >>      compute_generation_numbers() walks commits if either topo_level or\n> >>      generation are unset. There is a trick here: the generation value\n> >>      _is_ set if the commit is parsed from the existing commit-graph!\n> >>      Is this case covered by the existing logic to not write GDAT when\n> >>      writing a split commit-graph file with a base that does not have\n> >>      GDAT? Note that the non-split case does not load the commit-graph\n> >>      for parsing, so the interesting case is ""--split-replace"". Worth\n> >>      a test (after we write the GDAT chunk), which you have in ""commit-graph:\n> >>      handle mixed generation commit chains"".\n> >>\n> >\n> > Right, so at the end of this patch we compute corrected commit dates but\n> > don\'t write them to graph file.\n> >\n> > Although, writing ii. and iii. together in the same patch makes more\n> > sense to me. Would it be hard to follow for someone who has no context\n> > of this discussion?\n>\n> It is always easier to combine two patches than to split one into two.\n>\n> With that in mind, I recommend starting with a split version and then\n> seeing how each patch looks. I think that these are ""independent enough""\n> ideas that justify the separate patches.\n>\n> >>  iv. This patch, introducing the chunk and the read/write logic.\n> >>\n> >>   v. Add the remaining patches.\n> >>\n> >> Again, this is a complicated patch-reorganization. The hope is that\n> >> the end result is something that is easy to review as well as something\n> >> that produces an as-sane-as-possible history for future bisecters.\n> >>\n> >> Perhaps other reviewers have similar feelings, or can say that I am\n> >> being too picky.\n> >>\n> >\n> > I can see how the reorganization helps us avoid a rather nasty\n> > situation to be in. Should not be too hard to reorganize.\n>\n> I hope not. Hopefully you get some more review on this version\n> before jumping in on such a big reorg (in case someone else has\n> a different opinion).\n\nI think the direction makes sense. We should avoid having the dummy\nimplementation of the GDAT chunk in the interim if at all possible (and\nit seems like it is). What Stolee is proposing is what I\'d suggest, too.\n\nPlease let us know if you need any help restructuring these patches.\nPlease make sure to give them a careful review since it is easy to move\na hunk into the wrong commit, or let a detail in the patch text become\nout-of-date. Looking over ""git log -p origin/master..HEAD"" and ""git\nrebase -x make -j8 DEVELOPER=1 test\' origin/master"" never hurts ;).\n\n> Thanks,\n> -Stolee\n\nThanks,\nTaylor\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 11, 19, 1, 14, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 470411997, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/20200814045957.GA1380@Abhishek-Arch), Abhishek Kumar wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Mon, Aug 10, 2020 at 10:23:32AM -0400, Derrick Stolee wrote:\n> ....\n> --- >8 ---\n> \n> From 62189709fad3b051cedbd36193f5244fcce17e1f Mon Sep 17 00:00:00 2001\n> From: Derrick Stolee <dstolee@microsoft.com>\n> Date: Mon, 10 Aug 2020 10:06:47 -0400\n> Subject: [PATCH] commit-graph: use generation v2 only if entire chain does\n> \n> Since there are released versions of Git that understand generation\n> numbers in the commit-graph\'s CDAT chunk but do not understand the GDAT\n> chunk, the following scenario is possible:\n> \n>  1. ""New"" Git writes a commit-graph with the GDAT chunk.\n>  2. ""Old"" Git writes a split commit-graph on top without a GDAT chunk.\n> \n> Because of the current use of inspecting the current layer for a\n> generation_data_chunk pointer, the commits in the lower layer will be\n> interpreted as having very large generation values (commit date plus\n> offset) compared to the generation numbers in the top layer (topological\n> level). This violates the expectation that the generation of a parent is\n> strictly smaller than the generation of a child.\n> \n> It is difficult to expose this issue in a test. Since we _start_ with\n> artificially low generation numbers, any commit walk that prioritizes\n> generation numbers will walk all of the commits with high generation\n> number before walking the commits with low generation number. In all the\n> cases I tried, the commit-graph layers themselves ""protect"" any\n> incorrect behavior since none of the commits in the lower layer can\n> reach the commits in the upper layer.\n> \n> This issue would manifest itself as a performance problem in this\n> case, especially with something like ""git log --graph"" since the low\n> generation numbers would cause the in-degree queue to walk all of the\n> commits in the lower layer before allowing the topo-order queue to write\n> anything to output (depending on the size of the upper layer).\n> \n> Signed-off-by: Derrick Stolee <dstolee@microsoft.com>\n> ---\n>  commit-graph.c | 24 ++++++++++++++++++------\n>  1 file changed, 18 insertions(+), 6 deletions(-)\n> \n> diff --git a/commit-graph.c b/commit-graph.c\n> index eb78af3dad..17623274d9 100644\n> --- a/commit-graph.c\n> +++ b/commit-graph.c\n> @@ -762,7 +762,9 @@ static struct commit_list **insert_parent_or_die(struct repository *r,\n>  \treturn &commit_list_insert(c, pptr)->next;\n>  }\n>  \n> -static void fill_commit_graph_info(struct commit *item, struct commit_graph *g, uint32_t pos)\n> +#define COMMIT_GRAPH_GENERATION_V2 (1 << 0)\n> +\n> +static void fill_commit_graph_info(struct commit *item, struct commit_graph *g, uint32_t pos, int flags)\n>  {\n>  \tconst unsigned char *commit_data;\n>  \tstruct commit_graph_data *graph_data;\n> @@ -785,11 +787,9 @@ static void fill_commit_graph_info(struct commit *item, struct commit_graph *g,\n>  \tdate_low = get_be32(commit_data + g->hash_len + 12);\n>  \titem->date = (timestamp_t)((date_high << 32) | date_low);\n>  \n> -\tif (g->chunk_generation_data)\n> -\t{\n> +\tif (g->chunk_generation_data && (flags & COMMIT_GRAPH_GENERATION_V2))\n>  \t\tgraph_data->generation = item->date +\n>  \t\t\t(timestamp_t) get_be32(g->chunk_generation_data + sizeof(uint32_t) * lex_index);\n> -\t}\n>  \telse\n>  \t\tgraph_data->generation = get_be32(commit_data + g->hash_len + 8) >> 2;\n>  }\n> @@ -799,6 +799,10 @@ static inline void set_commit_tree(struct commit *c, struct tree *t)\n>  \tc->maybe_tree = t;\n>  }\n>  \n> +/*\n> + * In the case of a split commit-graph, this method expects the given\n> + * commit-graph \'g\' to be the top layer.\n> + */\n\nUnfortunately, this turns out to be an optimistic assumption. After\nadding in changes from this patch and extended tests for\nsplit-commit-graph [1], the tests fail with `git commit-graph verify` as\nGit tries to compare topological level with corrected commit dates.\n\nThe problem lies in assuming that `g` is always the top layer, without\nany way to assert if that\'s true. In case of `commit-graph verify`, we\nupdate `g = g->base_graph` and verify recursively.\n\nIf we can assume such behavior is only the part of verify subcommand, I\ncan update the tests to no longer verify at the end.\n\n[1]: https://lore.kernel.org/git/4043ffbc-84df-0cd6-5c75-af80383a56cf@gmail.com/\n\n>  static int fill_commit_in_graph(struct repository *r,\n>  \t\t\t\tstruct commit *item,\n>  \t\t\t\tstruct commit_graph *g, uint32_t pos)\n> @@ -808,11 +812,15 @@ static int fill_commit_in_graph(struct repository *r,\n>  \tstruct commit_list **pptr;\n>  \tconst unsigned char *commit_data;\n>  \tuint32_t lex_index;\n> +\tint flags = 0;\n> +\n> +\tif (g->chunk_generation_data)\n> +\t\tflags |= COMMIT_GRAPH_GENERATION_V2;\n>  \n>  \twhile (pos < g->num_commits_in_base)\n>  \t\tg = g->base_graph;\n>  \n> -\tfill_commit_graph_info(item, g, pos);\n> +\tfill_commit_graph_info(item, g, pos, flags);\n>  \n>  \tlex_index = pos - g->num_commits_in_base;\n>  \tcommit_data = g->chunk_commit_data + GRAPH_DATA_WIDTH * lex_index;\n> @@ -904,10 +912,14 @@ int parse_commit_in_graph(struct repository *r, struct commit *item)\n>  void load_commit_graph_info(struct repository *r, struct commit *item)\n>  {\n>  \tuint32_t pos;\n> +\tint flags = 0;\n> +\n>  \tif (!prepare_commit_graph(r))\n>  \t\treturn;\n> +\tif (r->objects->commit_graph->chunk_generation_data)\n> +\t\tflags |= COMMIT_GRAPH_GENERATION_V2;\n>  \tif (find_commit_in_graph(item, r->objects->commit_graph, &pos))\n> -\t\tfill_commit_graph_info(item, r->objects->commit_graph, pos);\n> +\t\tfill_commit_graph_info(item, r->objects->commit_graph, pos, flags);\n>  }\n>  \n>  static struct tree *load_tree_for_commit(struct repository *r,\n> -- \n> 2.28.0.38.gc6f546511c1\n> \n\nI solved the issue by adding a new member to struct commit_graph\n`read_generation_data` to maintain the ""global"" state of the entire\ncommit-graph chain instead.\n\nThe relevant changes are in validate_mixed_generation_chain(),\nread_commit_graph_one() and fill_commit_graph_info().\n\nThanks\n- Abhishek\n\n--- >8 ---\nFrom aaf8c27bfec6e110a8bb12173c2dd612a8c6b8b9 Mon Sep 17 00:00:00 2001\nFrom: Abhishek Kumar <abhishekkumar8222@gmail.com>\nDate: Thu, 6 Aug 2020 19:08:52 +0530\nSubject: [PATCH] commit-graph: use generation v2 only if entire chain does\n\nSince there are released versions of Git that understand generation\nnumbers in the commit-graph\'s CDAT chunk but do not understand the GDAT\nchunk, the following scenario is possible:\n\n1. ""New"" Git writes a commit-graph with the GDAT chunk.\n2. ""Old"" Git writes a split commit-graph on top without a GDAT chunk.\n\nBecause of the current use of inspecting the current layer for a\nchunk_generation_data pointer, the commits in the lower layer will be\ninterpreted as having very large generation values (commit date plus\noffset) compared to the generation numbers in the top layer (topological\nlevel). This violates the expectation that the generation of a parent is\nstrictly smaller than the generation of a child.\n\nIt is difficult to expose this issue in a test. Since we _start_ with\nartificially low generation numbers, any commit walk that prioritizes\ngeneration numbers will walk all of the commits with high generation\nnumber before walking the commits with low generation number. In all the\ncases I tried, the commit-graph layers themselves ""protect"" any\nincorrect behavior since none of the commits in the lower layer can\nreach the commits in the upper layer.\n\nThis issue would manifest itself as a performance problem in this case,\nespecially with something like ""git log --graph"" since the low\ngeneration numbers would cause the in-degree queue to walk all of the\ncommits in the lower layer before allowing the topo-order queue to write\nanything to output (depending on the size of the upper layer).\n\nSigned-off-by: Derrick Stolee <dstolee@microsoft.com>\nSigned-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n---\n commit-graph.c                | 36 ++++++++++++++++--\n commit-graph.h                |  1 +\n t/t5324-split-commit-graph.sh | 70 +++++++++++++++++++++++++++++++++++\n 3 files changed, 104 insertions(+), 3 deletions(-)\n\ndiff --git a/commit-graph.c b/commit-graph.c\nindex d0f977852b..10309f870f 100644\n--- a/commit-graph.c\n+++ b/commit-graph.c\n@@ -597,6 +597,27 @@ static struct commit_graph *load_commit_graph_chain(struct repository *r,\n \treturn graph_chain;\n }\n \n+static void validate_mixed_generation_chain(struct repository *r)\n+{\n+\tstruct commit_graph *g = r->objects->commit_graph;\n+\tint read_generation_data = 1;\n+\n+\twhile (g) {\n+\t\tif (!g->chunk_generation_data) {\n+\t\t\tread_generation_data = 0;\n+\t\t\tbreak;\n+\t\t}\n+\t\tg = g->base_graph;\n+\t}\n+\n+\tg = r->objects->commit_graph;\n+\n+\twhile (g) {\n+\t\tg->read_generation_data = read_generation_data;\n+\t\tg = g->base_graph;\n+\t}\n+}\n+\n struct commit_graph *read_commit_graph_one(struct repository *r,\n \t\t\t\t\t   struct object_directory *odb)\n {\n@@ -605,6 +626,8 @@ struct commit_graph *read_commit_graph_one(struct repository *r,\n \tif (!g)\n \t\tg = load_commit_graph_chain(r, odb);\n \n+\tvalidate_mixed_generation_chain(r);\n+\n \treturn g;\n }\n \n@@ -740,6 +763,8 @@ static struct commit_list **insert_parent_or_die(struct repository *r,\n \treturn &commit_list_insert(c, pptr)->next;\n }\n \n+#define COMMIT_GRAPH_GENERATION_V2 (1 << 0)\n+\n static void fill_commit_graph_info(struct commit *item, struct commit_graph *g, uint32_t pos)\n {\n \tconst unsigned char *commit_data;\n@@ -763,11 +788,9 @@ static void fill_commit_graph_info(struct commit *item, struct commit_graph *g,\n \tdate_low = get_be32(commit_data + g->hash_len + 12);\n \titem->date = (timestamp_t)((date_high << 32) | date_low);\n \n-\tif (g->chunk_generation_data)\n-\t{\n+\tif (g->chunk_generation_data && g->read_generation_data)\n \t\tgraph_data->generation = item->date +\n \t\t\t(timestamp_t) get_be32(g->chunk_generation_data + sizeof(uint32_t) * lex_index);\n-\t}\n \telse\n \t\tgraph_data->generation = get_be32(commit_data + g->hash_len + 8) >> 2;\n }\n@@ -884,6 +907,7 @@ void load_commit_graph_info(struct repository *r, struct commit *item)\n \tuint32_t pos;\n \tif (!prepare_commit_graph(r))\n \t\treturn;\n+\n \tif (find_commit_in_graph(item, r->objects->commit_graph, &pos))\n \t\tfill_commit_graph_info(item, r->objects->commit_graph, pos);\n }\n@@ -2186,6 +2210,9 @@ int write_commit_graph(struct object_directory *odb,\n \n \t\tg = ctx->r->objects->commit_graph;\n \n+\t\tif (g && !g->chunk_generation_data)\n+\t\t\tctx->write_generation_data = 0;\n+\n \t\twhile (g) {\n \t\t\tctx->num_commit_graphs_before++;\n \t\t\tg = g->base_graph;\n@@ -2204,6 +2231,9 @@ int write_commit_graph(struct object_directory *odb,\n \n \t\tif (ctx->split_opts)\n \t\t\treplace = ctx->split_opts->flags & COMMIT_GRAPH_SPLIT_REPLACE;\n+\n+\t\tif (replace)\n+\t\t\tctx->write_generation_data = 1;\n \t}\n \n \tctx->approx_nr_objects = approximate_object_count();\ndiff --git a/commit-graph.h b/commit-graph.h\nindex f89614ecd5..305c332b7e 100644\n--- a/commit-graph.h\n+++ b/commit-graph.h\n@@ -63,6 +63,7 @@ struct commit_graph {\n \tstruct object_directory *odb;\n \n \tuint32_t num_commits_in_base;\n+\tuint32_t read_generation_data;\n \tstruct commit_graph *base_graph;\n \n \tconst uint32_t *chunk_oid_fanout;\ndiff --git a/t/t5324-split-commit-graph.sh b/t/t5324-split-commit-graph.sh\nindex 531016f405..ac5e7783fb 100755\n--- a/t/t5324-split-commit-graph.sh\n+++ b/t/t5324-split-commit-graph.sh\n@@ -424,4 +424,74 @@ done <<\\EOF\n 0600 -r--------\n EOF\n \n+test_expect_success \'setup repo for mixed generation commit-graph-chain\' \'\n+\tmkdir mixed &&\n+\tgraphdir="".git/objects/info/commit-graphs"" &&\n+\tcd ""$TRASH_DIRECTORY/mixed"" &&\n+\tgit init &&\n+\tgit config core.commitGraph true &&\n+\tgit config gc.writeCommitGraph false &&\n+\tfor i in $(test_seq 3)\n+\tdo\n+\t\ttest_commit $i &&\n+\t\tgit branch commits/$i || return 1\n+\tdone &&\n+\tgit reset --hard commits/1 &&\n+\tfor i in $(test_seq 4 5)\n+\tdo\n+\t\ttest_commit $i &&\n+\t\tgit branch commits/$i || return 1\n+\tdone &&\n+\tgit reset --hard commits/2 &&\n+\tfor i in $(test_seq 6 10)\n+\tdo\n+\t\ttest_commit $i &&\n+\t\tgit branch commits/$i || return 1\n+\tdone &&\n+\tgit commit-graph write --reachable --split &&\n+\tgit reset --hard commits/2 &&\n+\tgit merge commits/4 &&\n+\tgit branch merge/1 &&\n+\tgit reset --hard commits/4 &&\n+\tgit merge commits/6 &&\n+\tgit branch merge/2 &&\n+\tGIT_TEST_COMMIT_GRAPH_NO_GDAT=1 git commit-graph write --reachable --split=no-merge &&\n+\ttest-tool read-graph >output &&\n+\tcat >expect <<-EOF &&\n+\theader: 43475048 1 1 4 1\n+\tnum_commits: 2\n+\tchunks: oid_fanout oid_lookup commit_metadata\n+\tEOF\n+\ttest_cmp expect output &&\n+\tgit commit-graph verify\n+\'\n+\n+test_expect_success \'does not write generation data chunk if not present on existing tip\' \'\n+\tcd ""$TRASH_DIRECTORY/mixed"" &&\n+\tgit reset --hard commits/3 &&\n+\tgit merge merge/1 &&\n+\tgit merge commits/5 &&\n+\tgit merge merge/2 &&\n+\tgit branch merge/3 &&\n+\tgit commit-graph write --reachable --split=no-merge &&\n+\ttest-tool read-graph >output &&\n+\tcat >expect <<-EOF &&\n+\theader: 43475048 1 1 4 2\n+\tnum_commits: 3\n+\tchunks: oid_fanout oid_lookup commit_metadata\n+\tEOF\n+\ttest_cmp expect output &&\n+\tgit commit-graph verify\n+\'\n+\n+test_expect_success \'writes generation data chunk when commit-graph chain is replaced\' \'\n+\tcd ""$TRASH_DIRECTORY/mixed"" &&\n+\tgit commit-graph write --reachable --split=replace &&\n+\ttest_path_is_file $graphdir/commit-graph-chain &&\n+\ttest_line_count = 1 $graphdir/commit-graph-chain &&\n+\tverify_chain_files_exist $graphdir &&\n+\tgraph_read_expect 15 &&\n+\tgit commit-graph verify\n+\'\n+\n test_done\n-- \n2.28.0\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 14, 5, 5, 23, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 470592929, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/2c7ee14e-1c80-9860-7bcc-633ac43910a6@gmail.com), Derrick Stolee wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn 8/14/2020 12:59 AM, Abhishek Kumar wrote:\n> I solved the issue by adding a new member to struct commit_graph\n> `read_generation_data` to maintain the ""global"" state of the entire\n> commit-graph chain instead.\n> \n> The relevant changes are in validate_mixed_generation_chain(),\n> read_commit_graph_one() and fill_commit_graph_info().\n\nI think this is a good way to go. Adding that restriction about\nthe tip commit-graph was short-sighted of me and was likely to\nbreak in the future.\n\nI think your solution here to store extra state from the entire\nchain into each layer makes a lot of sense.\n\nThanks!\n-Stolee\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 14, 12, 27, 2, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 471475602, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/79ab9d8c-9767-430a-9744-01fa81bdf9bc@gmail.com), Derrick Stolee wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn 8/15/2020 12:39 PM, Abhishek Kumar via GitGitGadget wrote:\n> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> \n> Comparing commits by generation has been independently defined twice, in\n> commit-reach and commit. Let\'s simplify the implementation by moving\n> compare_commits_by_gen() to commit-graph.\n> \n> Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> Reviewed-by: Taylor Blau <me@ttaylorr.com>\n> Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n\nWhoops! Be sure to add the ""Reviewed-by: above the ""Signed-off-by"" line(s)\nso re-signing off doesn\'t add a duplicate like this.\n\nThanks,\n-Stolee\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 17, 13, 24, 23, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 471810336, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/85r1s4ykgm.fsf@gmail.com), jnareb@gmail.com (Jakub Narębski) wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\n""Abhishek Kumar via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n\n> Subject: [PATCH v3 01/11] commit-graph: fix regression when computing bloom filter\n\ns/bloom filter/Bloom filters/\n\n> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n>\n> commit_gen_cmp is used when writing a commit-graph to sort commits in\n> generation order before computing Bloom filters. Since c49c82aa (commit:\n> move members graph_pos, generation to a slab, 2020-06-17) made it so\n> that \'commit_graph_generation()\' returns \'GENERATION_NUMBER_INFINITY\'\n> during writing, we cannot call it within this function. Instead, access\n> the generation number directly through the slab (i.e., by calling\n> \'commit_graph_data_at(c)->generation\') in order to access it while\n> writing.\n\nTwo things that might not be obvious from the commit message:\n\n- Is commit_gen_cmp in commit-graph.c used by anything but writing\n  Bloom filters for changed paths?\n\n- That the generation number is computed during `commit-graph write`\n  before computing Bloom filters.\n\nAlso, after this series \'generation\' would be generation number v2, that\nis corrected commit date, and not v1, that is topological levels.  We\nshould check, just in case, that it does not lead to significant\nperformance regression for `git commit-graph write --reachable <...>`\ncase (the one that uses commit_gen_cmp sort).\n\n>\n> Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> ---\n>  commit-graph.c | 4 ++--\n>  1 file changed, 2 insertions(+), 2 deletions(-)\n>\n> diff --git a/commit-graph.c b/commit-graph.c\n> index e51c91dd5b..ace7400a1a 100644\n> --- a/commit-graph.c\n> +++ b/commit-graph.c\n> @@ -144,8 +144,8 @@ static int commit_gen_cmp(const void *va, const void *vb)\n>  \tconst struct commit *a = *(const struct commit **)va;\n>  \tconst struct commit *b = *(const struct commit **)vb;\n>\n> -\tuint32_t generation_a = commit_graph_generation(a);\n> -\tuint32_t generation_b = commit_graph_generation(b);\n> +\tuint32_t generation_a = commit_graph_data_at(a)->generation;\n> +\tuint32_t generation_b = commit_graph_data_at(b)->generation;\n\nNice and easy.\n\n>  \t/* lower generation commits first */\n>  \tif (generation_a < generation_b)\n>  \t\treturn -1;\n\nBest,\n-- \nJakub Narębski\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 17, 22, 31, 11, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 472233549, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/85imdgxck6.fsf@gmail.com), jnareb@gmail.com (Jakub Narębski) wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\n""Abhishek Kumar via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n\n> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n>\n> In indegree_walk_step(), we add unvisited parents to the indegree queue.\n> However, parents are not guaranteed to be parsed. As the indegree queue\n> sorts by generation number, let\'s parse parents before inserting them to\n> ensure the correct priority order.\n\nAll right, we need to have commit parsed to have correct value for its\ngeneration number.\n\n>\n> Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> ---\n>  revision.c | 3 +++\n>  1 file changed, 3 insertions(+)\n>\n> diff --git a/revision.c b/revision.c\n> index 3dcf689341..ecf757c327 100644\n> --- a/revision.c\n> +++ b/revision.c\n> @@ -3363,6 +3363,9 @@ static void indegree_walk_step(struct rev_info *revs)\n>  \t\tstruct commit *parent = p->item;\n>  \t\tint *pi = indegree_slab_at(&info->indegree, parent);\n>\n> +\t\tif (parse_commit_gently(parent, 1) < 0)\n> +\t\t\treturn;\n> +\n\nAll right, this is exactly what is done in this function for commit \'c\'\ntaken from indegree_queue, whose parents we process here:\n\n\tif (parse_commit_gently(c, 1) < 0)\n\t\treturn;\n\n>  \t\tif (*pi)\n>  \t\t\t(*pi)++;\n>  \t\telse\n\nLooks good to me.\n\nBest,\n-- \nJakub Narębski\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 18, 14, 19, 49, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 473220675, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/857dtuo71v.fsf@gmail.com), jnareb@gmail.com (Jakub Narębski) wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\n""Abhishek Kumar via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n\n> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n>\n> Both fill_commit_graph_info() and fill_commit_in_graph() parse\n> information present in commit data chunk. Let\'s simplify the\n> implementation by calling fill_commit_graph_info() within\n> fill_commit_in_graph().\n>\n> The test \'generate tar with future mtime\' creates a commit with commit\n> time of (2 ^ 36 + 1) seconds since EPOCH. The commit time overflows into\n> generation number (within CDAT chunk) and has undefined behavior.\n>\n> The test used to pass\n\nCould you please tell us how does this test starts to fail without the\nchange to the test described there?  What is the error message, etc.?\n\n>                       as fill_commit_in_graph() guarantees the values of\n                           ^^^^^^^^^^^^^^^^^^^^^^\n\ns/fill_commit_in_graph()/fill_commit_graph_info()/\n\nIt is fill_commit_graph_info() that changes its behavior in this patch.\n\n> graph position and generation number, and did not load timestamp.\n> However, with corrected commit date we will need load the timestamp as\n> well to populate the generation number.\n>\n> Let\'s fix the test by setting a timestamp of (2 ^ 34 - 1) seconds.\n\nI think this commit should be split into two commits:\n- fix to the \'generate tar with future mtime\' test\n- simplify implementation of fill_commit_in_graph()\n\nThe test \'generate tar with future mtime\' in t/t5000-tar-tree.sh creates\na commit with commit time of (2 ^ 36 - 1) seconds since EPOCH\n(68719476737). However, the commit-graph file format version 1 provides\nonly 34-bits for storing committer date (32 + 2 bits), not 64-bits.\nTherefore maximum far in the future commit time can only be at most\n(2 ^ 34 - 1) seconds since EPOCH, as Stolee said in commet for v1\nof this series.\n\nThis ""limitation"" is not a problem in practice, because the maximum\ntimestamp allowed takes place in the year 2514. I hope at that time\nthere would be no Git version in use that still crashes on changing the\nversion field in the commit-graph format -- then we can simply get rid\nof storing topological levels (generation number v1) in those 30 bits of\nCDAT chunk and use full 64 bits for committer date.\n\nGit does not perform any bounds checking for committer date value in\nwrite_graph_chunk_data():\n\n\tuint32_t packedDate[2];\n\n\t/* ... */\n\n\tif (sizeof((*list)->date) > 4)\n\t\tpackedDate[0] = htonl(((*list)->date >> 32) & 0x3);\n\telse\n\t\tpackedDate[0] = 0;\n\n\tpackedDate[0] |= htonl(commit_graph_data_at(*list)->generation << 2);\n\n\tpackedDate[1] = htonl((*list)->date);\n\thashwrite(f, packedDate, 8);\n\nThis means that the date is trimmed to 34 bits on save discarding most\nsignificant bits, assuming that unsigned overflow simply discards most\nsignificant bits truncating the signed (?) value.\n\nIn this case running the test with GIT_TEST_COMMIT_GRAPH=1 would lead to\nerrors, as the committer date read from the commit graph would be\nincorrect, and therefore generation number v2 would also be incorrect.\n\n\nI don\'t quite understand however how second part of this patch in its\ncurrent iteration, namely simplifing the implementation of\nfill_commit_in_graph() makes this bug / error shows...\n\nDo I understand it correctly that before this change the committer date\nwould always be parsed out of the commit object, instead of reading it\nfrom the commit-graph file?  However the only user of static\nfill_commit_in_graph() is the parse_commit_in_graph(), which in turn is\nused by parse_commit_gently(); but fill_commit_in_graph() read commit\ndate from commit-graph before this change... color me confused.\n\nAh, after the change fill_commit_graph_info() changes its behavior, not\nfill_commit_in_graph() as said in the commit message. Before this commit\nit used to only load graph position and generation number, and did not\nload the timestamp. The function fill_commit_graph_info() is used in\nturn by public-facing load_commit_graph_info():\n\n  /*\n   * It is possible that we loaded commit contents from the commit buffer,\n   * but we also want to ensure the commit-graph content is correctly\n   * checked and filled. Fill the graph_pos and generation members of\n   * the given commit.\n   */\n  void load_commit_graph_info(struct repository *r, struct commit *item);\n\nThis function is used in turn by get_bloom_filter(), contains_tag_algo()\nand parse_commit_buffer(), change in any of which behavior can lead to\nfailing \'generate tar with future mtime\' test.\n\n>\n> Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> ---\n>  commit-graph.c      | 29 +++++++++++------------------\n>  t/t5000-tar-tree.sh |  4 ++--\n>  2 files changed, 13 insertions(+), 20 deletions(-)\n>\n> diff --git a/commit-graph.c b/commit-graph.c\n> index ace7400a1a..af8d9cc45e 100644\n> --- a/commit-graph.c\n> +++ b/commit-graph.c\n> @@ -725,15 +725,24 @@ static void fill_commit_graph_info(struct commit *item, struct commit_graph *g,\n>  \tconst unsigned char *commit_data;\n>  \tstruct commit_graph_data *graph_data;\n>  \tuint32_t lex_index;\n> +\tuint64_t date_high, date_low;\n>\n>  \twhile (pos < g->num_commits_in_base)\n>  \t\tg = g->base_graph;\n>\n> +\tif (pos >= g->num_commits + g->num_commits_in_base)\n> +\t\tdie(_(""invalid commit position. commit-graph is likely corrupt""));\n> +\n\nAll right, if we want to use fill_commit_graph_info() function to load\nthe graph data (graph position and generation number) in the\nfill_commit_in_graph() we need to perform this check.\n\nI\'d think that this check should be here from the beginning, just in\ncase.\n\n\nSidenote: I wonder if it would be good idea to print more information in\nthe above error message, for example:\n\n\tdie(_(""invalid commit position %ld. commit-graph \'%s\' is likely corrupt""),\n        pos, g->filename);\n\nBut this is unrelated thing, tangential to this change, and it might not\nadd anything useful.\n\n>  \tlex_index = pos - g->num_commits_in_base;\n>  \tcommit_data = g->chunk_commit_data + GRAPH_DATA_WIDTH * lex_index;\n>\n>  \tgraph_data = commit_graph_data_at(item);\n>  \tgraph_data->graph_pos = pos;\n> +\n> +\tdate_high = get_be32(commit_data + g->hash_len + 8) & 0x3;\n> +\tdate_low = get_be32(commit_data + g->hash_len + 12);\n> +\titem->date = (timestamp_t)((date_high << 32) | date_low);\n> +\n\nI think this change, moving loading of commit date from commit-graph out\nof fill_commit_in_graph() and into fill_commit_graph_info(), is in my\nopinion a bit inadequatly described in the commit message. As I\nunderstand it this change prepares fill_commit_graph_info() for\ngeneration number v2, that is Corrected Commit Date, where loading\ncommit date from CDAT together with loading offset from GDAT would be\nnecessary to correctly set the \'generation\' field of \'struct\ncommit_graph_data\' (on the commit_graph_data_slab).\n\nI\'m not sure if it would be worth it splitting this refactoring change\n(Move Statements into Function) into a separate patch -- it would split\nthis commit into three, changing 11 part series into 13 part series.\n\n\nNote that we might want to update the description of\nload_commit_graph_info() in commit-graph.h to include that it\nincidentally loads commit date from the commit-graph.  Butthis might be\nnot worth it -- it is a side effect, not the major goal of this\nfunction.\n\n>  \tgraph_data->generation = get_be32(commit_data + g->hash_len + 8) >> 2;\n>  }\n>\n> @@ -748,38 +757,22 @@ static int fill_commit_in_graph(struct repository *r,\n>  {\n>  \tuint32_t edge_value;\n>  \tuint32_t *parent_data_ptr;\n> -\tuint64_t date_low, date_high;\n>  \tstruct commit_list **pptr;\n> -\tstruct commit_graph_data *graph_data;\n>  \tconst unsigned char *commit_data;\n>  \tuint32_t lex_index;\n>\n>  \twhile (pos < g->num_commits_in_base)\n>  \t\tg = g->base_graph;\n>\n> -\tif (pos >= g->num_commits + g->num_commits_in_base)\n> -\t\tdie(_(""invalid commit position. commit-graph is likely corrupt""));\n> +\tfill_commit_graph_info(item, g, pos);\n\nAll right, the check got moved into fill_commit_graph_info().\n\n>\n> -\t/*\n> -\t * Store the ""full"" position, but then use the\n> -\t * ""local"" position for the rest of the calculation.\n> -\t */\n> -\tgraph_data = commit_graph_data_at(item);\n> -\tgraph_data->graph_pos = pos;\n\nAll right, \'graph_pos\' field in the graph data (on commit slab) got\nfilled by just called load_commit_graph_info().\n\n>  \tlex_index = pos - g->num_commits_in_base;\n> -\n> -\tcommit_data = g->chunk_commit_data + (g->hash_len + 16) * lex_index;\n> +\tcommit_data = g->chunk_commit_data + GRAPH_DATA_WIDTH * lex_index;\n\nAll right, unrelated cleanup in the neighbourhood.\n\n>\n>  \titem->object.parsed = 1;\n>\n>  \tset_commit_tree(item, NULL);\n>\n> -\tdate_high = get_be32(commit_data + g->hash_len + 8) & 0x3;\n> -\tdate_low = get_be32(commit_data + g->hash_len + 12);\n> -\titem->date = (timestamp_t)((date_high << 32) | date_low);\n> -\n\nAll right, this code got moved down the call chain into just called\nload_commit_graph_info().\n\n> -\tgraph_data->generation = get_be32(commit_data + g->hash_len + 8) >> 2;\n> -\n\n\nAll right, \'generation\' field in the graph data (on commit slab) got\nfilled by load_commit_graph_info() called at the beginning of the\nfunction.\n\n\n\n>  \tpptr = &item->parents;\n>\n>  \tedge_value = get_be32(commit_data + g->hash_len);\n> diff --git a/t/t5000-tar-tree.sh b/t/t5000-tar-tree.sh\n> index 37655a237c..1986354fc3 100755\n> --- a/t/t5000-tar-tree.sh\n> +++ b/t/t5000-tar-tree.sh\n> @@ -406,7 +406,7 @@ test_expect_success TIME_IS_64BIT \'set up repository with far-future commit\' \'\n>  \trm -f .git/index &&\n>  \techo content >file &&\n>  \tgit add file &&\n> -\tGIT_COMMITTER_DATE=""@68719476737 +0000"" \\\n> +\tGIT_COMMITTER_DATE=""@17179869183 +0000"" \\\n>  \t\tgit commit -m ""tempori parendum""\n>  \'\n>\n> @@ -415,7 +415,7 @@ test_expect_success TIME_IS_64BIT \'generate tar with future mtime\' \'\n>  \'\n>\n>  test_expect_success TAR_HUGE,TIME_IS_64BIT,TIME_T_IS_64BIT \'system tar can read our future mtime\' \'\n> -\techo 4147 >expect &&\n> +\techo 2514 >expect &&\n>  \ttar_info future.tar | cut -d"" "" -f2 >actual &&\n>  \ttest_cmp expect actual\n>  \'\n\nLooks good to me.\n\nBest,\n-- \nJakub Narębski\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 19, 17, 57, 47, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 474398556, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/20200821041124.GA39355@Abhishek-Arch), Abhishek Kumar wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Wed, Aug 19, 2020 at 07:54:20PM +0200, Jakub Narębski wrote:\n> ""Abhishek Kumar via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n> \n> > From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> >\n> > Both fill_commit_graph_info() and fill_commit_in_graph() parse\n> > information present in commit data chunk. Let\'s simplify the\n> > implementation by calling fill_commit_graph_info() within\n> > fill_commit_in_graph().\n> >\n> > The test \'generate tar with future mtime\' creates a commit with commit\n> > time of (2 ^ 36 + 1) seconds since EPOCH. The commit time overflows into\n> > generation number (within CDAT chunk) and has undefined behavior.\n> >\n> > The test used to pass\n> \n> Could you please tell us how does this test starts to fail without the\n> change to the test described there?  What is the error message, etc.?\n> \n\nHere\'s what I revised the commit message to:\n\ncommit-graph: consolidate fill_commit_graph_info\n\nBoth fill_commit_graph_info() and fill_commit_in_graph() parse\ninformation present in commit data chunk. Let\'s simplify the\nimplementation by calling fill_commit_graph_info() within\nfill_commit_in_graph().\n\nThe test \'generate tar with future mtime\' creates a commit with commit\ntime of (2 ^ 36 + 1) seconds since EPOCH. The CDAT chunk provides\n34-bits for storing commiter date, thus committer time overflows into\ngeneration number (within CDAT chunk) and has undefined behavior.\n\nThe test used to pass as fill_commit_graph_info() would not set struct\nmember `date` of struct commit and loads committer date from the object\ndatabase, generating a tar file with the expected mtime.\n\nHowever, with corrected commit date, we will load the committer date\nfrom CDAT chunk (truncated to lower 34-bits) to populate the generation\nnumber. Thus, fill_commit_graph_info() sets date and generates tar file\nwith the truncated mtime and the test fails.\n\nLet\'s fix the test by setting a timestamp of (2 ^ 34 - 1) seconds, which\nwill not be truncated.\n\n> >                       as fill_commit_in_graph() guarantees the values of\n>                            ^^^^^^^^^^^^^^^^^^^^^^\n> \n> s/fill_commit_in_graph()/fill_commit_graph_info()/\n> \n> ...\n> \n> Ah, after the change fill_commit_graph_info() changes its behavior, not\n> fill_commit_in_graph() as said in the commit message. Before this commit\n> it used to only load graph position and generation number, and did not\n> load the timestamp. The function fill_commit_graph_info() is used in\n> turn by public-facing load_commit_graph_info():\n> \n\nThat\'s exactly it. I should have elaborated better in the commit\nmessage. Thanks for the through investigation.\n\n>   /*\n>    * It is possible that we loaded commit contents from the commit buffer,\n>    * but we also want to ensure the commit-graph content is correctly\n>    * checked and filled. Fill the graph_pos and generation members of\n>    * the given commit.\n>    */\n>   void load_commit_graph_info(struct repository *r, struct commit *item);\n> \n> ...\n> \n> Looks good to me.\n> \n> Best,\n> -- \n> Jakub Narębski\n\nThanks\n- Abhishek\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 21, 4, 14, 31, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 474630648, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/85sgcgmf80.fsf@gmail.com), jnareb@gmail.com (Jakub Narębski) wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\n""Abhishek Kumar via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n\n> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n>\n> Comparing commits by generation has been independently defined twice, in\n> commit-reach and commit. Let\'s simplify the implementation by moving\n> compare_commits_by_gen() to commit-graph.\n\nAll right, seems reasonable.\n\nThough it might be not obvious that the second repetition of code\ncomparing commits by generation is part of commit.c\'s\ncompare_commits_by_gen_then_commit_date().\n\nIs\'t it micro-pessimization though, or can the compiler inline function\nacross different files?  On the other hand it reduces code duplication...\n\n>\n> Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> Reviewed-by: Taylor Blau <me@ttaylorr.com>\n> Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> ---\n>  commit-graph.c | 15 +++++++++++++++\n>  commit-graph.h |  2 ++\n>  commit-reach.c | 15 ---------------\n>  commit.c       |  9 +++------\n>  4 files changed, 20 insertions(+), 21 deletions(-)\n>\n> diff --git a/commit-graph.c b/commit-graph.c\n> index af8d9cc45e..fb6e2bf18f 100644\n> --- a/commit-graph.c\n> +++ b/commit-graph.c\n> @@ -112,6 +112,21 @@ uint32_t commit_graph_generation(const struct commit *c)\n>  \treturn data->generation;\n>  }\n>\n> +int compare_commits_by_gen(const void *_a, const void *_b)\n> +{\n> +\tconst struct commit *a = _a, *b = _b;\n> +\tconst uint32_t generation_a = commit_graph_generation(a);\n> +\tconst uint32_t generation_b = commit_graph_generation(b);\n\nAll right, this function used protected access to generation number of a\ncommit, that is it correctly handles the case where commit \'_a\' and/or\n\'_b\' are new enough to be not present in the commit graph.\n\nThat is why we cannot simply use commit_gen_cmp(), that is the function\nused for sorting during `git commit-graph write --reachable --changed-paths`,\nbecause after 1st patch it access the slab directly.\n\n> +\n> +\t/* older commits first */\n\nNice!  Thanks for adding this comment.\n\nThough it might be good idea to add this comment also to the header\nfile, commit-graph.h, because the fact that compare_commits_by_gen()\nand compare_commits_by_gen_then_commit_date() sort in different\norder is not something that we can see from their names.  Well,\nthey have slightly different sigatures...\n\n> +\tif (generation_a < generation_b)\n> +\t\treturn -1;\n> +\telse if (generation_a > generation_b)\n> +\t\treturn 1;\n> +\n> +\treturn 0;\n> +}\n> +\n>  static struct commit_graph_data *commit_graph_data_at(const struct commit *c)\n>  {\n>  \tunsigned int i, nth_slab;\n> diff --git a/commit-graph.h b/commit-graph.h\n> index 09a97030dc..701e3d41aa 100644\n> --- a/commit-graph.h\n> +++ b/commit-graph.h\n> @@ -146,4 +146,6 @@ struct commit_graph_data {\n>   */\n>  uint32_t commit_graph_generation(const struct commit *);\n>  uint32_t commit_graph_position(const struct commit *);\n> +\n> +int compare_commits_by_gen(const void *_a, const void *_b);\n\nAll right.\n\n>  #endif\n> diff --git a/commit-reach.c b/commit-reach.c\n> index efd5925cbb..c83cc291e7 100644\n> --- a/commit-reach.c\n> +++ b/commit-reach.c\n> @@ -561,21 +561,6 @@ int commit_contains(struct ref_filter *filter, struct commit *commit,\n>  \treturn repo_is_descendant_of(the_repository, commit, list);\n>  }\n>\n> -static int compare_commits_by_gen(const void *_a, const void *_b)\n> -{\n> -\tconst struct commit *a = *(const struct commit * const *)_a;\n> -\tconst struct commit *b = *(const struct commit * const *)_b;\n> -\n> -\tuint32_t generation_a = commit_graph_generation(a);\n> -\tuint32_t generation_b = commit_graph_generation(b);\n> -\n> -\tif (generation_a < generation_b)\n> -\t\treturn -1;\n> -\tif (generation_a > generation_b)\n> -\t\treturn 1;\n> -\treturn 0;\n> -}\n\nAll right, commit-reach.c includes commit-graph.h, so now it simply uses\ncompare_commits_by_gen() that was copied to commit-graph.c.\n\n> -\n>  int can_all_from_reach_with_flag(struct object_array *from,\n>  \t\t\t\t unsigned int with_flag,\n>  \t\t\t\t unsigned int assign_flag,\n> diff --git a/commit.c b/commit.c\n> index 4ce8cb38d5..bd6d5e587f 100644\n> --- a/commit.c\n> +++ b/commit.c\n> @@ -731,14 +731,11 @@ int compare_commits_by_author_date(const void *a_, const void *b_,\n>  int compare_commits_by_gen_then_commit_date(const void *a_, const void *b_, void *unused)\n>  {\n>  \tconst struct commit *a = a_, *b = b_;\n> -\tconst uint32_t generation_a = commit_graph_generation(a),\n> -\t\t       generation_b = commit_graph_generation(b);\n> +\tint ret_val = compare_commits_by_gen(a_, b_);\n>\n>  \t/* newer commits first */\n\nMaybe this comment should be put in the header file, near this functionn\ndeclaration?\n\n> -\tif (generation_a < generation_b)\n> -\t\treturn 1;\n> -\telse if (generation_a > generation_b)\n> -\t\treturn -1;\n> +\tif (ret_val)\n> +\t\treturn -ret_val;\n\nAll right, this handles reversed sorting order of compare_commits_by_gen().\n\n>\n>  \t/* use date as a heuristic when generations are equal */\n>  \tif (a->date < b->date)\n\nBest,\n-- \nJakub Narębski\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 21, 11, 8, 46, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 474690190, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/85d03km98l.fsf@gmail.com), jnareb@gmail.com (Jakub Narębski) wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\n""Abhishek Kumar via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n\n> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n>\n> In a preparatory step, let\'s return timestamp_t values from\n> commit_graph_generation(), use timestamp_t for local variables\n\nAll right, this is all good.\n\n> and define GENERATION_NUMBER_INFINITY as (2 ^ 63 - 1) instead.\n\nThis needs more detailed examination.  There are two similar constants,\nGENERATION_NUMBER_INFINITY and GENERATION_NUMBER_MAX.  The former is\nused for newest commits outside the commit-graph, while the latter is\nmaximum number that commits in the commit-graph can have (because of the\nstorage limitations).  We therefore need GENERATION_NUMBER_INFINITY\nto be larger than GENERATION_NUMBER_MAX, and it is (and was).\n\nThe GENERATION_NUMBER_INFINITY is because of the above requirement\ntraditionally taken as maximum value that can be represented in the data\ntype used to store commit\'s generation number _in memory_, but it can be\nless.  For timestamp_t the maximum value that can be represented\nis (2 ^ 63 - 1).\n\nAll right then.\n\n>\n\nThe commit message says nothing about the new symbolic constant\nGENERATION_NUMBER_V1_INFINITY, though.\n\nI\'m not sure it is even needed (see comments below).\n\n> Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> ---\n>  commit-graph.c | 18 +++++++++---------\n>  commit-graph.h |  4 ++--\n>  commit-reach.c | 32 ++++++++++++++++----------------\n>  commit-reach.h |  2 +-\n>  commit.h       |  3 ++-\n>  revision.c     | 10 +++++-----\n>  upload-pack.c  |  2 +-\n>  7 files changed, 36 insertions(+), 35 deletions(-)\n\nI hope that changing the type returned by commit_graph_generation() and\nstored in \'generation\' field of `struct commit_graph_data` would mean\nthat the compiler or at least the linter would catch all the places that\nneed updating the type.\n\nJust in case, I have performed a simple code search and it agrees with\nthe above list (one search result missing, in commit.c, was handled by\nprevious patch).\n\n>\n> diff --git a/commit-graph.c b/commit-graph.c\n> index fb6e2bf18f..7f9f858577 100644\n> --- a/commit-graph.c\n> +++ b/commit-graph.c\n> @@ -99,7 +99,7 @@ uint32_t commit_graph_position(const struct commit *c)\n>  \treturn data ? data->graph_pos : COMMIT_NOT_FROM_GRAPH;\n>  }\n>\n> -uint32_t commit_graph_generation(const struct commit *c)\n> +timestamp_t commit_graph_generation(const struct commit *c)\n>  {\n>  \tstruct commit_graph_data *data =\n>  \t\tcommit_graph_data_slab_peek(&commit_graph_data_slab, c);\n> @@ -115,8 +115,8 @@ uint32_t commit_graph_generation(const struct commit *c)\n>  int compare_commits_by_gen(const void *_a, const void *_b)\n>  {\n>  \tconst struct commit *a = _a, *b = _b;\n> -\tconst uint32_t generation_a = commit_graph_generation(a);\n> -\tconst uint32_t generation_b = commit_graph_generation(b);\n> +\tconst timestamp_t generation_a = commit_graph_generation(a);\n> +\tconst timestamp_t generation_b = commit_graph_generation(b);\n>\n>  \t/* older commits first */\n>  \tif (generation_a < generation_b)\n> @@ -159,8 +159,8 @@ static int commit_gen_cmp(const void *va, const void *vb)\n>  \tconst struct commit *a = *(const struct commit **)va;\n>  \tconst struct commit *b = *(const struct commit **)vb;\n>\n> -\tuint32_t generation_a = commit_graph_data_at(a)->generation;\n> -\tuint32_t generation_b = commit_graph_data_at(b)->generation;\n> +\tconst timestamp_t generation_a = commit_graph_data_at(a)->generation;\n> +\tconst timestamp_t generation_b = commit_graph_data_at(b)->generation;\n>  \t/* lower generation commits first */\n>  \tif (generation_a < generation_b)\n>  \t\treturn -1;\n\nAll right.\n\n> @@ -1338,7 +1338,7 @@ static void compute_generation_numbers(struct write_commit_graph_context *ctx)\n>  \t\tuint32_t generation = commit_graph_data_at(ctx->commits.list[i])->generation;\n\nShouldn\'t this be\n\n-  \t\tuint32_t generation = commit_graph_data_at(ctx->commits.list[i])->generation;\n+  \t\ttimestamp_t generation = commit_graph_data_at(ctx->commits.list[i])->generation;\n\n\n>\n>  \t\tdisplay_progress(ctx->progress, i + 1);\n> -\t\tif (generation != GENERATION_NUMBER_INFINITY &&\n> +\t\tif (generation != GENERATION_NUMBER_V1_INFINITY &&\n\nThen there would be no need for this change, isn\'t it?\n\n>  \t\t    generation != GENERATION_NUMBER_ZERO)\n>  \t\t\tcontinue;\n>\n> @@ -1352,7 +1352,7 @@ static void compute_generation_numbers(struct write_commit_graph_context *ctx)\n>  \t\t\tfor (parent = current->parents; parent; parent = parent->next) {\n>  \t\t\t\tgeneration = commit_graph_data_at(parent->item)->generation;\n>\n> -\t\t\t\tif (generation == GENERATION_NUMBER_INFINITY ||\n> +\t\t\t\tif (generation == GENERATION_NUMBER_V1_INFINITY ||\n\nAnd this one either.\n\n>  \t\t\t\t    generation == GENERATION_NUMBER_ZERO) {\n>  \t\t\t\t\tall_parents_computed = 0;\n>  \t\t\t\t\tcommit_list_insert(parent->item, &list);\n> @@ -2355,8 +2355,8 @@ int verify_commit_graph(struct repository *r, struct commit_graph *g, int flags)\n>  \tfor (i = 0; i < g->num_commits; i++) {\n>  \t\tstruct commit *graph_commit, *odb_commit;\n>  \t\tstruct commit_list *graph_parents, *odb_parents;\n> -\t\tuint32_t max_generation = 0;\n> -\t\tuint32_t generation;\n> +\t\ttimestamp_t max_generation = 0;\n> +\t\ttimestamp_t generation;\n\nAll right.\n\n>\n>  \t\tdisplay_progress(progress, i + 1);\n>  \t\thashcpy(cur_oid.hash, g->chunk_oid_lookup + g->hash_len * i);\n> diff --git a/commit-graph.h b/commit-graph.h\n> index 701e3d41aa..430bc830bb 100644\n> --- a/commit-graph.h\n> +++ b/commit-graph.h\n> @@ -138,13 +138,13 @@ void disable_commit_graph(struct repository *r);\n>\n>  struct commit_graph_data {\n>  \tuint32_t graph_pos;\n> -\tuint32_t generation;\n> +\ttimestamp_t generation;\n>  };\n\nAll right; this is the main part of this change.\n\n>\n>  /*\n>   * Commits should be parsed before accessing generation, graph positions.\n>   */\n> -uint32_t commit_graph_generation(const struct commit *);\n> +timestamp_t commit_graph_generation(const struct commit *);\n>  uint32_t commit_graph_position(const struct commit *);\n\nAs is this one.\n\n>\n>  int compare_commits_by_gen(const void *_a, const void *_b);\n> diff --git a/commit-reach.c b/commit-reach.c\n> index c83cc291e7..470bc80139 100644\n> --- a/commit-reach.c\n> +++ b/commit-reach.c\n> @@ -32,12 +32,12 @@ static int queue_has_nonstale(struct prio_queue *queue)\n>  static struct commit_list *paint_down_to_common(struct repository *r,\n>  \t\t\t\t\t\tstruct commit *one, int n,\n>  \t\t\t\t\t\tstruct commit **twos,\n> -\t\t\t\t\t\tint min_generation)\n> +\t\t\t\t\t\ttimestamp_t min_generation)\n>  {\n>  \tstruct prio_queue queue = { compare_commits_by_gen_then_commit_date };\n>  \tstruct commit_list *result = NULL;\n>  \tint i;\n> -\tuint32_t last_gen = GENERATION_NUMBER_INFINITY;\n> +\ttimestamp_t last_gen = GENERATION_NUMBER_INFINITY;\n>\n>  \tif (!min_generation)\n>  \t\tqueue.compare = compare_commits_by_commit_date;\n\nAll right.\n\n> @@ -58,10 +58,10 @@ static struct commit_list *paint_down_to_common(struct repository *r,\n>  \t\tstruct commit *commit = prio_queue_get(&queue);\n>  \t\tstruct commit_list *parents;\n>  \t\tint flags;\n> -\t\tuint32_t generation = commit_graph_generation(commit);\n> +\t\ttimestamp_t generation = commit_graph_generation(commit);\n>\n>  \t\tif (min_generation && generation > last_gen)\n> -\t\t\tBUG(""bad generation skip %8x > %8x at %s"",\n> +\t\t\tBUG(""bad generation skip %""PRItime"" > %""PRItime"" at %s"",\n>  \t\t\t    generation, last_gen,\n>  \t\t\t    oid_to_hex(&commit->object.oid));\n>  \t\tlast_gen = generation;\n\nAll right.\n\n> @@ -177,12 +177,12 @@ static int remove_redundant(struct repository *r, struct commit **array, int cnt\n>  \t\trepo_parse_commit(r, array[i]);\n>  \tfor (i = 0; i < cnt; i++) {\n>  \t\tstruct commit_list *common;\n> -\t\tuint32_t min_generation = commit_graph_generation(array[i]);\n> +\t\ttimestamp_t min_generation = commit_graph_generation(array[i]);\n>\n>  \t\tif (redundant[i])\n>  \t\t\tcontinue;\n>  \t\tfor (j = filled = 0; j < cnt; j++) {\n> -\t\t\tuint32_t curr_generation;\n> +\t\t\ttimestamp_t curr_generation;\n>  \t\t\tif (i == j || redundant[j])\n>  \t\t\t\tcontinue;\n>  \t\t\tfilled_index[filled] = j;\n\nAll right.\n\n> @@ -321,7 +321,7 @@ int repo_in_merge_bases_many(struct repository *r, struct commit *commit,\n>  {\n>  \tstruct commit_list *bases;\n>  \tint ret = 0, i;\n> -\tuint32_t generation, min_generation = GENERATION_NUMBER_INFINITY;\n> +\ttimestamp_t generation, min_generation = GENERATION_NUMBER_INFINITY;\n>\n>  \tif (repo_parse_commit(r, commit))\n>  \t\treturn ret;\n\nAll right,\n\n> @@ -470,7 +470,7 @@ static int in_commit_list(const struct commit_list *want, struct commit *c)\n>  static enum contains_result contains_test(struct commit *candidate,\n>  \t\t\t\t\t  const struct commit_list *want,\n>  \t\t\t\t\t  struct contains_cache *cache,\n> -\t\t\t\t\t  uint32_t cutoff)\n> +\t\t\t\t\t  timestamp_t cutoff)\n\nAll right.\n\n(Sidenote: this one I have missed in my simple search.)\n\n>  {\n>  \tenum contains_result *cached = contains_cache_at(cache, candidate);\n>\n> @@ -506,11 +506,11 @@ static enum contains_result contains_tag_algo(struct commit *candidate,\n>  {\n>  \tstruct contains_stack contains_stack = { 0, 0, NULL };\n>  \tenum contains_result result;\n> -\tuint32_t cutoff = GENERATION_NUMBER_INFINITY;\n> +\ttimestamp_t cutoff = GENERATION_NUMBER_INFINITY;\n>  \tconst struct commit_list *p;\n>\n>  \tfor (p = want; p; p = p->next) {\n> -\t\tuint32_t generation;\n> +\t\ttimestamp_t generation;\n>  \t\tstruct commit *c = p->item;\n>  \t\tload_commit_graph_info(the_repository, c);\n>  \t\tgeneration = commit_graph_generation(c);\n\nAll right.\n\n> @@ -565,7 +565,7 @@ int can_all_from_reach_with_flag(struct object_array *from,\n>  \t\t\t\t unsigned int with_flag,\n>  \t\t\t\t unsigned int assign_flag,\n>  \t\t\t\t time_t min_commit_date,\n> -\t\t\t\t uint32_t min_generation)\n> +\t\t\t\t timestamp_t min_generation)\n>  {\n>  \tstruct commit **list = NULL;\n>  \tint i;\n> @@ -666,13 +666,13 @@ int can_all_from_reach(struct commit_list *from, struct commit_list *to,\n>  \ttime_t min_commit_date = cutoff_by_min_date ? from->item->date : 0;\n>  \tstruct commit_list *from_iter = from, *to_iter = to;\n>  \tint result;\n> -\tuint32_t min_generation = GENERATION_NUMBER_INFINITY;\n> +\ttimestamp_t min_generation = GENERATION_NUMBER_INFINITY;\n>\n>  \twhile (from_iter) {\n>  \t\tadd_object_array(&from_iter->item->object, NULL, &from_objs);\n>\n>  \t\tif (!parse_commit(from_iter->item)) {\n> -\t\t\tuint32_t generation;\n> +\t\t\ttimestamp_t generation;\n>  \t\t\tif (from_iter->item->date < min_commit_date)\n>  \t\t\t\tmin_commit_date = from_iter->item->date;\n>\n> @@ -686,7 +686,7 @@ int can_all_from_reach(struct commit_list *from, struct commit_list *to,\n>\n>  \twhile (to_iter) {\n>  \t\tif (!parse_commit(to_iter->item)) {\n> -\t\t\tuint32_t generation;\n> +\t\t\ttimestamp_t generation;\n>  \t\t\tif (to_iter->item->date < min_commit_date)\n>  \t\t\t\tmin_commit_date = to_iter->item->date;\n>\n\nAll right.\n\n> @@ -726,13 +726,13 @@ struct commit_list *get_reachable_subset(struct commit **from, int nr_from,\n>  \tstruct commit_list *found_commits = NULL;\n>  \tstruct commit **to_last = to + nr_to;\n>  \tstruct commit **from_last = from + nr_from;\n> -\tuint32_t min_generation = GENERATION_NUMBER_INFINITY;\n> +\ttimestamp_t min_generation = GENERATION_NUMBER_INFINITY;\n>  \tint num_to_find = 0;\n>\n>  \tstruct prio_queue queue = { compare_commits_by_gen_then_commit_date };\n>\n>  \tfor (item = to; item < to_last; item++) {\n> -\t\tuint32_t generation;\n> +\t\ttimestamp_t generation;\n>  \t\tstruct commit *c = *item;\n>\n>  \t\tparse_commit(c);\n\nAll right.\n\n> diff --git a/commit-reach.h b/commit-reach.h\n> index b49ad71a31..148b56fea5 100644\n> --- a/commit-reach.h\n> +++ b/commit-reach.h\n> @@ -87,7 +87,7 @@ int can_all_from_reach_with_flag(struct object_array *from,\n>  \t\t\t\t unsigned int with_flag,\n>  \t\t\t\t unsigned int assign_flag,\n>  \t\t\t\t time_t min_commit_date,\n> -\t\t\t\t uint32_t min_generation);\n> +\t\t\t\t timestamp_t min_generation);\n>  int can_all_from_reach(struct commit_list *from, struct commit_list *to,\n>  \t\t       int commit_date_cutoff);\n>\n\nAll right.\n\n> diff --git a/commit.h b/commit.h\n> index e901538909..bc0732a4fe 100644\n> --- a/commit.h\n> +++ b/commit.h\n> @@ -11,7 +11,8 @@\n>  #include ""commit-slab.h""\n>\n>  #define COMMIT_NOT_FROM_GRAPH 0xFFFFFFFF\n> -#define GENERATION_NUMBER_INFINITY 0xFFFFFFFF\n> +#define GENERATION_NUMBER_INFINITY ((1ULL << 63) - 1)\n> +#define GENERATION_NUMBER_V1_INFINITY 0xFFFFFFFF\n>  #define GENERATION_NUMBER_MAX 0x3FFFFFFF\n>  #define GENERATION_NUMBER_ZERO 0\n>\n\nWhy do we even need GENERATION_NUMBER_V1_INFINITY?  It is about marking\nout-of-graph commits, and it is about in-memory storage.\n\nWe would need separate GENERATION_NUMBER_V1_MAX and GENERATION_NUMBER_V2_MAX\nbecause of different _on-disk_ storage, or in other words file format\nlimitations.  But that is for the future commit.\n\n> diff --git a/revision.c b/revision.c\n> index ecf757c327..411852468b 100644\n> --- a/revision.c\n> +++ b/revision.c\n> @@ -3290,7 +3290,7 @@ define_commit_slab(indegree_slab, int);\n>  define_commit_slab(author_date_slab, timestamp_t);\n>\n>  struct topo_walk_info {\n> -\tuint32_t min_generation;\n> +\ttimestamp_t min_generation;\n>  \tstruct prio_queue explore_queue;\n>  \tstruct prio_queue indegree_queue;\n>  \tstruct prio_queue topo_queue;\n\nAll right.\n\n> @@ -3336,7 +3336,7 @@ static void explore_walk_step(struct rev_info *revs)\n>  }\n>\n>  static void explore_to_depth(struct rev_info *revs,\n> -\t\t\t     uint32_t gen_cutoff)\n> +\t\t\t     timestamp_t gen_cutoff)\n>  {\n>  \tstruct topo_walk_info *info = revs->topo_walk_info;\n>  \tstruct commit *c;\n\nAll right.\n\n> @@ -3379,7 +3379,7 @@ static void indegree_walk_step(struct rev_info *revs)\n>  }\n>\n>  static void compute_indegrees_to_depth(struct rev_info *revs,\n> -\t\t\t\t       uint32_t gen_cutoff)\n> +\t\t\t\t       timestamp_t gen_cutoff)\n>  {\n>  \tstruct topo_walk_info *info = revs->topo_walk_info;\n>  \tstruct commit *c;\n> @@ -3437,7 +3437,7 @@ static void init_topo_walk(struct rev_info *revs)\n>  \tinfo->min_generation = GENERATION_NUMBER_INFINITY;\n>  \tfor (list = revs->commits; list; list = list->next) {\n>  \t\tstruct commit *c = list->item;\n> -\t\tuint32_t generation;\n> +\t\ttimestamp_t generation;\n>\n>  \t\tif (parse_commit_gently(c, 1))\n>  \t\t\tcontinue;\n\nAll right.\n\n> @@ -3498,7 +3498,7 @@ static void expand_topo_walk(struct rev_info *revs, struct commit *commit)\n>  \tfor (p = commit->parents; p; p = p->next) {\n>  \t\tstruct commit *parent = p->item;\n>  \t\tint *pi;\n> -\t\tuint32_t generation;\n> +\t\ttimestamp_t generation;\n>\n>  \t\tif (parent->object.flags & UNINTERESTING)\n>  \t\t\tcontinue;\n\nAll right.\n\n> diff --git a/upload-pack.c b/upload-pack.c\n> index 80ad9a38d8..bcb8b5dfda 100644\n> --- a/upload-pack.c\n> +++ b/upload-pack.c\n> @@ -497,7 +497,7 @@ static int got_oid(struct upload_pack_data *data,\n>\n>  static int ok_to_give_up(struct upload_pack_data *data)\n>  {\n> -\tuint32_t min_generation = GENERATION_NUMBER_ZERO;\n> +\ttimestamp_t min_generation = GENERATION_NUMBER_ZERO;\n>\n>  \tif (!data->have_obj.nr)\n>  \t\treturn 0;\n\nAll right.\n\n\nBest,\n-- \nJakub Narębski\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 21, 13, 17, 58, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 474867011, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/85d03jlu05.fsf@gmail.com), jnareb@gmail.com (Jakub Narębski) wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nHello,\n\n""Abhishek Kumar via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n\n> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n>\n> As we are writing topological levels to commit data chunk to ensure\n> backwards compatibility with ""Old"" Git and the member `generation` of\n> struct commit_graph_data will store corrected commit date in a later\n> commit, let\'s introduce a commit-slab to store topological levels while\n> writing commit-graph.\n\nIn my opinion the above it would be easier to follow if rephrased in the\nfollowing way:\n\n  In a later commit we will introduce corrected commit date as the\n  generation number v2.  This value will be stored in the new separate\n  GDAT chunk.  However to ensure backwards compatibility with ""Old"" Git\n  we need to continue to write generation number v1, which is\n  topological level, to the commit data chunk (CDAT).  This means that\n  we need to compute both versions of generation numbers when writing\n  the commit-graph file.  Let\'s therefore introduce a commit-slab\n  to store topological levels; corrected commit date will be stored\n  in the member `generation` of struct commit_graph_data.\n\nWhat do you think?\n\n\nBy the way, do I understand it correctly that in backward-compatibility\nmode (that is, in mixed-version environment where at least some\ncommit-graph files were written by ""Old"" Git and are lacking GDAT chunk\nand generation number v2 data) the `generation` member of commit graph\ndata chunk will be populated and will store generation number v1, that\nis topological level? And that the commit-slab for topological levels is\nonly there for writing and re-writing?\n\n>\n> When Git creates a split commit-graph, it takes advantage of the\n> generation values that have been computed already and present in\n> existing commit-graph files.\n>\n> So, let\'s add a pointer to struct commit_graph to the topological level\n> commit-slab and populate it with topological levels while writing a\n> split commit-graph.\n\nAll right, looks sensible.\n\n>\n> Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> ---\n>  commit-graph.c | 47 ++++++++++++++++++++++++++++++++---------------\n>  commit-graph.h |  1 +\n>  commit.h       |  1 +\n>  3 files changed, 34 insertions(+), 15 deletions(-)\n>\n> diff --git a/commit-graph.c b/commit-graph.c\n> index 7f9f858577..a2f15b2825 100644\n> --- a/commit-graph.c\n> +++ b/commit-graph.c\n> @@ -64,6 +64,8 @@ void git_test_write_commit_graph_or_die(void)\n>  /* Remember to update object flag allocation in object.h */\n>  #define REACHABLE       (1u<<15)\n>\n> +define_commit_slab(topo_level_slab, uint32_t);\n> +\n\nAll right.\n\nAlso, here we might need GENERATION_NUMBER_V1_INFINITY, but I don\'t\nthink it would be necessary.\n\n>  /* Keep track of the order in which commits are added to our list. */\n>  define_commit_slab(commit_pos, int);\n>  static struct commit_pos commit_pos = COMMIT_SLAB_INIT(1, commit_pos);\n> @@ -759,6 +761,9 @@ static void fill_commit_graph_info(struct commit *item, struct commit_graph *g,\n>  \titem->date = (timestamp_t)((date_high << 32) | date_low);\n>\n>  \tgraph_data->generation = get_be32(commit_data + g->hash_len + 8) >> 2;\n> +\n> +\tif (g->topo_levels)\n> +\t\t*topo_level_slab_at(g->topo_levels, item) = get_be32(commit_data + g->hash_len + 8) >> 2;\n>  }\n\nAll right, here we store topological levels on commit-slab to avoid\nrecomputing them.\n\nDo I understand it correctly that the `topo_levels` member of the `struct\ncommit_graph` would be non-null only when we are updating the\ncommit-graph?\n\n>\n>  static inline void set_commit_tree(struct commit *c, struct tree *t)\n> @@ -953,6 +958,7 @@ struct write_commit_graph_context {\n>  \t\t changed_paths:1,\n>  \t\t order_by_pack:1;\n>\n> +\tstruct topo_level_slab *topo_levels;\n>  \tconst struct split_commit_graph_opts *split_opts;\n>  \tsize_t total_bloom_filter_data_size;\n>  \tconst struct bloom_filter_settings *bloom_settings;\n\nWhy do we need `topo_levels` member *both* in `struct commit_graph` and\nin `struct write_commit_graph_context`?\n\n[After examining the change further I have realized why both are needed,\n and written about the reasoning later in this email.]\n\n\nNote that the commit message talks only about `struct commit_graph`...\n\n> @@ -1094,7 +1100,7 @@ static int write_graph_chunk_data(struct hashfile *f,\n>  \t\telse\n>  \t\t\tpackedDate[0] = 0;\n>\n> -\t\tpackedDate[0] |= htonl(commit_graph_data_at(*list)->generation << 2);\n> +\t\tpackedDate[0] |= htonl(*topo_level_slab_at(ctx->topo_levels, *list) << 2);\n\nAll right, here we prepare for writing to the CDAT chunk using data that\nis now stored on newly introduced topo_levels slab (either computed, or\ntaken from commit-graph file being rewritten).\n\nAssuming that ctx->topo_levels is not-null, and that the values are\nproperly calculated before this -- and we did compute topological levels\nbefore writing the commit-graph.\n\n>\n>  \t\tpackedDate[1] = htonl((*list)->date);\n>  \t\thashwrite(f, packedDate, 8);\n> @@ -1335,11 +1341,11 @@ static void compute_generation_numbers(struct write_commit_graph_context *ctx)\n>  \t\t\t\t\t_(""Computing commit graph generation numbers""),\n>  \t\t\t\t\tctx->commits.nr);\n>  \tfor (i = 0; i < ctx->commits.nr; i++) {\n> -\t\tuint32_t generation = commit_graph_data_at(ctx->commits.list[i])->generation;\n> +\t\tuint32_t level = *topo_level_slab_at(ctx->topo_levels, ctx->commits.list[i]);\n\nAll right, so that is why this \'generation\' variable was not converted\nto timestamp_t type.\n\n>\n>  \t\tdisplay_progress(ctx->progress, i + 1);\n> -\t\tif (generation != GENERATION_NUMBER_V1_INFINITY &&\n> -\t\t    generation != GENERATION_NUMBER_ZERO)\n> +\t\tif (level != GENERATION_NUMBER_V1_INFINITY &&\n> +\t\t    level != GENERATION_NUMBER_ZERO)\n>  \t\t\tcontinue;\n\nHere we use GENERATION_NUMBER*_INFINITY to check if the commit is\noutside commit-graph files, and therefore we would need its topological\nlevel computed.\n\nHowever, I don\'t understand how it works.  We have had created the\ncommit_graph_data_at() and use it instead of commit_graph_data_slab_at()\nto provide default values for `struct commit_graph`... but only for\n`graph_pos` member.  It is commit_graph_generation() that returns\nGENERATION_NUMBER_INFINITY for commits not in graph.\n\nBut neither commit_graph_data_at()->generation nor topo_level_slab_at()\nhandles this special case, so I don\'t see how \'generation\' variable can\n*ever* be GENERATION_NUMBER_INFINITY, and \'level\' variable can ever be\nGENERATION_NUMBER_V1_INFINITY for commits not in graph.\n\nDoes it work *accidentally*, because the default value for uninitialized\ndata on commit-slab is 0, which matches GENERATION_NUMBER_ZERO?  It\ncertainly looks like it does.  And GENERATION_NUMBER_ZERO is an artifact\nof commit-graph feature development history, namely the short time where\nGit didn\'t use any generation numbers and stored 0 in the place set for\nit in the commit-graph format...  On the other hand this is not the case\nfor corrected commit date (generation number v2), as it could\n""legitimately"" be 0 if some root commit (without any parents) had\ncommitterdate of epoch 0, i.e. 1 January 1970 00:00:00 UTC, perhaps\ncaused by malformed but valid commit object.\n\nUgh...\n\n>\n>  \t\tcommit_list_insert(ctx->commits.list[i], &list);\n> @@ -1347,29 +1353,27 @@ static void compute_generation_numbers(struct write_commit_graph_context *ctx)\n>  \t\t\tstruct commit *current = list->item;\n>  \t\t\tstruct commit_list *parent;\n>  \t\t\tint all_parents_computed = 1;\n> -\t\t\tuint32_t max_generation = 0;\n> +\t\t\tuint32_t max_level = 0;\n>\n>  \t\t\tfor (parent = current->parents; parent; parent = parent->next) {\n> -\t\t\t\tgeneration = commit_graph_data_at(parent->item)->generation;\n> +\t\t\t\tlevel = *topo_level_slab_at(ctx->topo_levels, parent->item);\n>\n> -\t\t\t\tif (generation == GENERATION_NUMBER_V1_INFINITY ||\n> -\t\t\t\t    generation == GENERATION_NUMBER_ZERO) {\n> +\t\t\t\tif (level == GENERATION_NUMBER_V1_INFINITY ||\n> +\t\t\t\t    level == GENERATION_NUMBER_ZERO) {\n>  \t\t\t\t\tall_parents_computed = 0;\n>  \t\t\t\t\tcommit_list_insert(parent->item, &list);\n>  \t\t\t\t\tbreak;\n> -\t\t\t\t} else if (generation > max_generation) {\n> -\t\t\t\t\tmax_generation = generation;\n> +\t\t\t\t} else if (level > max_level) {\n> +\t\t\t\t\tmax_level = level;\n>  \t\t\t\t}\n>  \t\t\t}\n\nThis is the same case as for previous chunk; see the comment above.\n\nThis code checks if parents have generation number / topological level\ncomputed, and tracks maximum value of it among all parents.\n\n>\n>  \t\t\tif (all_parents_computed) {\n> -\t\t\t\tstruct commit_graph_data *data = commit_graph_data_at(current);\n> -\n> -\t\t\t\tdata->generation = max_generation + 1;\n>  \t\t\t\tpop_commit(&list);\n>\n> -\t\t\t\tif (data->generation > GENERATION_NUMBER_MAX)\n> -\t\t\t\t\tdata->generation = GENERATION_NUMBER_MAX;\n> +\t\t\t\tif (max_level > GENERATION_NUMBER_MAX - 1)\n> +\t\t\t\t\tmax_level = GENERATION_NUMBER_MAX - 1;\n> +\t\t\t\t*topo_level_slab_at(ctx->topo_levels, current) = max_level + 1;\n\nOK, this is safer way of handling GENERATION_NUMBER*_MAX, especially if\nthis value can be maximum value that can be safely stored in a given\ndata type.  Previously GENERATION_NUMBER_MAX was smaller than maximum\nvalue that can be safely stored in uint32_t, so generation+1 had no\nchance to overflow.  This is no longer the case; the reorganization done\nhere leads to more defensive code (safer).\n\nAll good.  However I think that we should clamp the value of topological\nlevel to the maximum value that can be safely stored *on disk*, in the\n30 bits of the CDAT chunk reserved for generation number v1.  Otherwise\nthe code to write topological level would get more complicated.\n\nIn my opinion the symbolic constant used here should be named\nGENERATION_NUMBER_V1_MAX, and its value should be at most (2 ^ 30 - 1);\nit should be the current value of GENERATION_NUMBER_MAX, that is\n0x3FFFFFFF.\n\n>  \t\t\t}\n>  \t\t}\n>  \t}\n> @@ -2101,6 +2105,7 @@ int write_commit_graph(struct object_directory *odb,\n>  \tuint32_t i, count_distinct = 0;\n>  \tint res = 0;\n>  \tint replace = 0;\n> +\tstruct topo_level_slab topo_levels;\n>\n\nAll right, we will be using topo_level slab for writing the\ncommit-graph, and only for this purpose, so it is good to put it here.\n\n>  \tif (!commit_graph_compatible(the_repository))\n>  \t\treturn 0;\n> @@ -2179,6 +2184,18 @@ int write_commit_graph(struct object_directory *odb,\n>  \t\t}\n>  \t}\n>\n> +\tinit_topo_level_slab(&topo_levels);\n> +\tctx->topo_levels = &topo_levels;\n> +\n> +\tif (ctx->r->objects->commit_graph) {\n> +\t\tstruct commit_graph *g = ctx->r->objects->commit_graph;\n> +\n> +\t\twhile (g) {\n> +\t\t\tg->topo_levels = &topo_levels;\n> +\t\t\tg = g->base_graph;\n> +\t\t}\n> +\t}\n\nAll right, now I see why we need `topo_levels` member both in the\n`struct write_commit_graph_context` and in `struct commit_graph`.\nThe former is for functions that write the commit-graph, the latter for\nfill_commit_graph_info() functions that is deep in the callstack, but it\nneeds to know whether to load topological level to commit-slab, or maybe\nput it as generation number (and in the future -- discard it, if not\nneeded).\n\n\nSidenote: this fragment of code, that fills with a given value some\nmember of the `struct commit_graph` throughout the split commit-graph\nchain, will be repeated as similar code in patches later in series.\nHowever without resorting to preprocessor macros I have no idea how to\ngeneralize it to avoid code duplication (well, almost).\n\n> +\n>  \tif (pack_indexes) {\n>  \t\tctx->order_by_pack = 1;\n>  \t\tif ((res = fill_oids_from_packs(ctx, pack_indexes)))\n> diff --git a/commit-graph.h b/commit-graph.h\n> index 430bc830bb..1152a9642e 100644\n> --- a/commit-graph.h\n> +++ b/commit-graph.h\n> @@ -72,6 +72,7 @@ struct commit_graph {\n>  \tconst unsigned char *chunk_bloom_indexes;\n>  \tconst unsigned char *chunk_bloom_data;\n>\n> +\tstruct topo_level_slab *topo_levels;\n>  \tstruct bloom_filter_settings *bloom_filter_settings;\n>  };\n\nAll right: `struct commit_graph` is public, `struct\nwrite_commit_graph_context` is not.\n\n>\n> diff --git a/commit.h b/commit.h\n> index bc0732a4fe..bb846e0025 100644\n> --- a/commit.h\n> +++ b/commit.h\n> @@ -15,6 +15,7 @@\n>  #define GENERATION_NUMBER_V1_INFINITY 0xFFFFFFFF\n>  #define GENERATION_NUMBER_MAX 0x3FFFFFFF\n\nThe name GENERATION_NUMBER_MAX for 0x3FFFFFFF should be instead\nGENERATION_NUMBER_V1_MAX, but that may be done in a later commit.\n\n>  #define GENERATION_NUMBER_ZERO 0\n> +#define GENERATION_NUMBER_V2_OFFSET_MAX 0xFFFFFFFF\n\nThis value is never used, so why it is defined in this commit.\n\n>\n>  struct commit_list {\n>  \tstruct commit *item;\n\nBest,\n-- \nJakub Narębski\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 21, 18, 45, 55, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 475016849, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/85wo1rk0iy.fsf@gmail.com), jnareb@gmail.com (Jakub Narębski) wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\n""Abhishek Kumar via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n\n> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n>\n> With most of preparations done, let\'s implement corrected commit date.\n>\n> The corrected commit date for a commit is defined as:\n>\n> * A commit with no parents (a root commit) has corrected commit date\n>   equal to its committer date.\n> * A commit with at least one parent has corrected commit date equal to\n>   the maximum of its commit date and one more than the largest corrected\n>   commit date among its parents.\n\nGood.\n\n>\n> To minimize the space required to store corrected commit date, Git\n> stores corrected commit date offsets into the commit-graph file. The\n> corrected commit date offset for a commit is defined as the difference\n> between its corrected commit date and actual commit date.\n\nPerhaps we should add more details about data type sizes in question.\n\nStoring corrected commit date requires sizeof(timestamp_t) bytes, which\nin most cases is 64 bits (uintmax_t).  However corrected commit date\noffsets can be safely stored^* using only 32 bits.  This halves the size\nof GDAT chunk, reducing per-commit storage from 2*H + 16 + 8 bytes to\n2*H + 16 + 4 bytes, which is reduction of around 6%, not including\nheader, fanout table (OIDF) and extra edges list (EDGE).\n\nWhich might mean that the extra complication is not worth it, and we\nshould store corrected commit date directly instead.\n\n*) unless for example one of commits is malformed but valid,\n   and has committerdate of 0 Unix time, 1 January 1970.\n\n>\n> While Git does not write out offsets at this stage, Git stores the\n> corrected commit dates in member generation of struct commit_graph_data.\n> It will begin writing commit date offsets with the introduction of\n> generation data chunk.\n\nOK, so the agenda for introducing geeration number v2 is as follows:\n- compute generation numbers v2, i.e. corrected commit date\n- store corrected commit date [offsets] in new GDAT chunk,\n  unless backward-compatibility concerns require us to not to\n- load [and compute] corrected commit date from commit-graph\n  storing it as \'generation\' field of `struct commit_graph_data`,\n  unless backward-compatibility concerns require us to store\n  topological levels (generation number v1) in there instead\n\nBecause the reachability condition for corrected commit date and for\ntopological level is exactly the same, we don\'t need to do anything to\ntake advantage of generation number v2.\n\nThough we can use generation number v2 in more cases, where we turned\noff use of generation numbers because v1 gave worse performance than\ndate heuristics.\n\nDid I got this right?\n\n>\n> Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> ---\n>  commit-graph.c | 58 +++++++++++++++++++++++++++-----------------------\n>  1 file changed, 31 insertions(+), 27 deletions(-)\n>\n> diff --git a/commit-graph.c b/commit-graph.c\n> index a2f15b2825..fd69534dd5 100644\n> --- a/commit-graph.c\n> +++ b/commit-graph.c\n> @@ -169,11 +169,6 @@ static int commit_gen_cmp(const void *va, const void *vb)\n>  \telse if (generation_a > generation_b)\n>  \t\treturn 1;\n>\n> -\t/* use date as a heuristic when generations are equal */\n> -\tif (a->date < b->date)\n> -\t\treturn -1;\n> -\telse if (a->date > b->date)\n> -\t\treturn 1;\n\nAt first I was wondering why this tie-breaking is beig removed; wouldn\'t\nbe needed for backward-compatibility?  But then I remembered that this\ncomparison function is used _only_ for sorting commits when writing\nBloom filters, for `git commit-graph write --reachable --changed-paths ...`\n\nAssuming that when writing the commit graph we always compute geeration\nnumber v2 and \'generation\' field stores corrected commit date, we don\'t\nneed to use date as a heuristic when generations are equal, and it would\nnot help in tie-breaking anyway.\n\nAll right.\n\n>  \treturn 0;\n>  }\n>\n> @@ -1342,10 +1337,14 @@ static void compute_generation_numbers(struct write_commit_graph_context *ctx)\n>  \t\t\t\t\tctx->commits.nr);\n>  \tfor (i = 0; i < ctx->commits.nr; i++) {\n>  \t\tuint32_t level = *topo_level_slab_at(ctx->topo_levels, ctx->commits.list[i]);\n> +\t\ttimestamp_t corrected_commit_date = commit_graph_data_at(ctx->commits.list[i])->generation;\n\nAll right, so the pattern is to add \'corrected_commit_date\' stuff after\n\'topological_level\' stuff.\n\n>\n>  \t\tdisplay_progress(ctx->progress, i + 1);\n>  \t\tif (level != GENERATION_NUMBER_V1_INFINITY &&\n> -\t\t    level != GENERATION_NUMBER_ZERO)\n> +\t\t    level != GENERATION_NUMBER_ZERO &&\n> +\t\t    corrected_commit_date != GENERATION_NUMBER_INFINITY &&\n> +\t\t    corrected_commit_date != GENERATION_NUMBER_ZERO\n> +\t\t    )\n>  \t\t\tcontinue;\n>\n>  \t\tcommit_list_insert(ctx->commits.list[i], &list);\n> @@ -1354,17 +1353,26 @@ static void compute_generation_numbers(struct write_commit_graph_context *ctx)\n>  \t\t\tstruct commit_list *parent;\n>  \t\t\tint all_parents_computed = 1;\n>  \t\t\tuint32_t max_level = 0;\n> +\t\t\ttimestamp_t max_corrected_commit_date = 0;\n>\n>  \t\t\tfor (parent = current->parents; parent; parent = parent->next) {\n>  \t\t\t\tlevel = *topo_level_slab_at(ctx->topo_levels, parent->item);\n> +\t\t\t\tcorrected_commit_date = commit_graph_data_at(parent->item)->generation;\n>\n>  \t\t\t\tif (level == GENERATION_NUMBER_V1_INFINITY ||\n> -\t\t\t\t    level == GENERATION_NUMBER_ZERO) {\n> +\t\t\t\t    level == GENERATION_NUMBER_ZERO ||\n> +\t\t\t\t    corrected_commit_date == GENERATION_NUMBER_INFINITY ||\n> +\t\t\t\t    corrected_commit_date == GENERATION_NUMBER_ZERO\n> +\t\t\t\t    ) {\n>  \t\t\t\t\tall_parents_computed = 0;\n>  \t\t\t\t\tcommit_list_insert(parent->item, &list);\n>  \t\t\t\t\tbreak;\n> -\t\t\t\t} else if (level > max_level) {\n> -\t\t\t\t\tmax_level = level;\n> +\t\t\t\t} else {\n> +\t\t\t\t\tif (level > max_level)\n> +\t\t\t\t\t\tmax_level = level;\n> +\n> +\t\t\t\t\tif (corrected_commit_date > max_corrected_commit_date)\n> +\t\t\t\t\t\tmax_corrected_commit_date = corrected_commit_date;\n>  \t\t\t\t}\n>  \t\t\t}\n>\n> @@ -1374,6 +1382,10 @@ static void compute_generation_numbers(struct write_commit_graph_context *ctx)\n>  \t\t\t\tif (max_level > GENERATION_NUMBER_MAX - 1)\n>  \t\t\t\t\tmax_level = GENERATION_NUMBER_MAX - 1;\n>  \t\t\t\t*topo_level_slab_at(ctx->topo_levels, current) = max_level + 1;\n> +\n> +\t\t\t\tif (current->date > max_corrected_commit_date)\n> +\t\t\t\t\tmax_corrected_commit_date = current->date - 1;\n> +\t\t\t\tcommit_graph_data_at(current)->generation = max_corrected_commit_date + 1;\n>  \t\t\t}\n>  \t\t}\n>  \t}\n\nAll right.  Looks good to me.\n\n> @@ -2372,8 +2384,8 @@ int verify_commit_graph(struct repository *r, struct commit_graph *g, int flags)\n>  \tfor (i = 0; i < g->num_commits; i++) {\n>  \t\tstruct commit *graph_commit, *odb_commit;\n>  \t\tstruct commit_list *graph_parents, *odb_parents;\n> -\t\ttimestamp_t max_generation = 0;\n> -\t\ttimestamp_t generation;\n> +\t\ttimestamp_t max_corrected_commit_date = 0;\n> +\t\ttimestamp_t corrected_commit_date;\n\nThis is simple, and perhaps unnecessary, rename of variables.\nShouldn\'t we however verify *both* topological level, and\n(if exists) corrected commit date?\n\n>\n>  \t\tdisplay_progress(progress, i + 1);\n>  \t\thashcpy(cur_oid.hash, g->chunk_oid_lookup + g->hash_len * i);\n> @@ -2412,9 +2424,9 @@ int verify_commit_graph(struct repository *r, struct commit_graph *g, int flags)\n>  \t\t\t\t\t     oid_to_hex(&graph_parents->item->object.oid),\n>  \t\t\t\t\t     oid_to_hex(&odb_parents->item->object.oid));\n>\n> -\t\t\tgeneration = commit_graph_generation(graph_parents->item);\n> -\t\t\tif (generation > max_generation)\n> -\t\t\t\tmax_generation = generation;\n> +\t\t\tcorrected_commit_date = commit_graph_generation(graph_parents->item);\n> +\t\t\tif (corrected_commit_date > max_corrected_commit_date)\n> +\t\t\t\tmax_corrected_commit_date = corrected_commit_date;\n\nActually, commit_graph_generation(<commit>) can return either corrected\ncommit date, or topological level, the latter in backward-compatibility\ncase (if at least one commit-graph file is lacking GDAT chunk, because\n[some of] it was created by the ""Old"" Git).\n\n>\n>  \t\t\tgraph_parents = graph_parents->next;\n>  \t\t\todb_parents = odb_parents->next;\n> @@ -2436,20 +2448,12 @@ int verify_commit_graph(struct repository *r, struct commit_graph *g, int flags)\n>  \t\tif (generation_zero == GENERATION_ZERO_EXISTS)\n>  \t\t\tcontinue;\n>\n> -\t\t/*\n> -\t\t * If one of our parents has generation GENERATION_NUMBER_MAX, then\n> -\t\t * our generation is also GENERATION_NUMBER_MAX. Decrement to avoid\n> -\t\t * extra logic in the following condition.\n> -\t\t */\n> -\t\tif (max_generation == GENERATION_NUMBER_MAX)\n> -\t\t\tmax_generation--;\n\nAll right, this was needed for checking the correctness of topological\nlevels (generation number v1) because we were checking not that it\nfullfills the reachability condition, but more strict one: namely that\ntopological level of commit is equal to maximum of topological levels of\nits parents plus one.\n\nThe comment about checking both generation number v1 and v2 still\napplies.\n\n> -\n> -\t\tgeneration = commit_graph_generation(graph_commit);\n> -\t\tif (generation != max_generation + 1)\n> -\t\t\tgraph_report(_(""commit-graph generation for commit %s is %u != %u""),\n> +\t\tcorrected_commit_date = commit_graph_generation(graph_commit);\n> +\t\tif (corrected_commit_date < max_corrected_commit_date + 1)\n> +\t\t\tgraph_report(_(""commit-graph generation for commit %s is %""PRItime"" < %""PRItime),\n>  \t\t\t\t     oid_to_hex(&cur_oid),\n> -\t\t\t\t     generation,\n> -\t\t\t\t     max_generation + 1);\n> +\t\t\t\t     corrected_commit_date,\n> +\t\t\t\t     max_corrected_commit_date + 1);\n\nAll right, we check less strict condition for corrected commit date.\n\n>\n>  \t\tif (graph_commit->date != odb_commit->date)\n>  \t\t\tgraph_report(_(""commit date for commit %s in commit-graph is %""PRItime"" != %""PRItime),\n\nBest,\n-- \nJakub Narębski\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 22, 0, 8, 15, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 475089024, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/85tuwuj08g.fsf@gmail.com), jnareb@gmail.com (Jakub Narębski) wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nAll right, it looks like this patch implements first part of step 2.)\nand step 3.) in the following plan of adding support for geeration\nnumber v2:\n\n1. compute generation numbers v2, i.e. corrected commit date\n2. store corrected commit date [offsets] in new GDAT chunk,\n   unless backward-compatibility concerns require us to not to\n3. load [and compute] corrected commit date from commit-graph\n   storing it as \'generation\' field of `struct commit_graph_data`,\n   unless backward-compatibility concerns require us to store\n   topological levels (generation number v1) in there instead\n4. use generation number v2 in more places, where we had to turn\n   off using v1 for performance reasons\n\n\n""Abhishek Kumar via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n\n> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n>\n> As discovered by Ævar, we cannot increment graph version to\n> distinguish between generation numbers v1 and v2 [1]. Thus, one of\n> pre-requistes before implementing generation number was to distinguish\n> between graph versions in a backwards compatible manner.\n\nFortunately, we have fixed this issue, and Git does no longer die when\nit encounters commit-graph format version that it does not understand.\n\n>\n> We are going to introduce a new chunk called Generation Data chunk (or\n> GDAT). GDAT stores generation number v2 (and any subsequent versions),\n> whereas CDAT will still store topological level.\n\nShould we say anything about storing 64 bit corrected commit date\n(geeration number v2) as 32 bit corrected commit date offset?\n\n>\n> Old Git does not understand GDAT chunk and would ignore it, reading\n> topological levels from CDAT. New Git can parse GDAT and take advantage\n> of newer generation numbers, falling back to topological levels when\n> GDAT chunk is missing (as it would happen with a commit graph written\n> by old Git).\n\nNote that the fact that we do not have special code for handling\nmixed-version layers in split commit-graph is not [that] dangerous, as\nwe don\'t read this new data yet.  Splitting it to patch 09/11 (next\npatch) makes this patch simpler.\n\n>\n> We introduce a test environment variable \'GIT_TEST_COMMIT_GRAPH_NO_GDAT\'\n> which forces commit-graph file to be written without generation data\n> chunk to emulate a commit-graph file written by old Git.\n\nAll right.\n\n>\n> [1]: https://lore.kernel.org/git/87a7gdspo4.fsf@evledraar.gmail.com/\n>\n> Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> ---\n>  commit-graph.c                | 48 ++++++++++++++++++++++++---\n>  commit-graph.h                |  2 ++\n>  t/README                      |  3 ++\n>  t/helper/test-read-graph.c    |  2 ++\n>  t/t4216-log-bloom.sh          |  4 +--\n>  t/t5318-commit-graph.sh       | 27 +++++++--------\n>  t/t5324-split-commit-graph.sh | 12 +++----\n>  t/t6600-test-reach.sh         | 62 +++++++++++++++++++----------------\n>  8 files changed, 107 insertions(+), 53 deletions(-)\n\nIt might be a good idea to add documentation of this chunk (and only\nabout this chunk) to Documentation/technical/commit-graph-format.txt\n\n>\n> diff --git a/commit-graph.c b/commit-graph.c\n> index fd69534dd5..b7a72b40db 100644\n> --- a/commit-graph.c\n> +++ b/commit-graph.c\n> @@ -38,11 +38,12 @@ void git_test_write_commit_graph_or_die(void)\n>  #define GRAPH_CHUNKID_OIDFANOUT 0x4f494446 /* ""OIDF"" */\n>  #define GRAPH_CHUNKID_OIDLOOKUP 0x4f49444c /* ""OIDL"" */\n>  #define GRAPH_CHUNKID_DATA 0x43444154 /* ""CDAT"" */\n> +#define GRAPH_CHUNKID_GENERATION_DATA 0x47444154 /* ""GDAT"" */\n>  #define GRAPH_CHUNKID_EXTRAEDGES 0x45444745 /* ""EDGE"" */\n>  #define GRAPH_CHUNKID_BLOOMINDEXES 0x42494458 /* ""BIDX"" */\n>  #define GRAPH_CHUNKID_BLOOMDATA 0x42444154 /* ""BDAT"" */\n>  #define GRAPH_CHUNKID_BASE 0x42415345 /* ""BASE"" */\n> -#define MAX_NUM_CHUNKS 7\n> +#define MAX_NUM_CHUNKS 8\n\nAll right, define new chunk and increase the maximum number of chunks\ncommit-graph file can have.\n\n>\n>  #define GRAPH_DATA_WIDTH (the_hash_algo->rawsz + 16)\n>\n> @@ -389,6 +390,13 @@ struct commit_graph *parse_commit_graph(void *graph_map, size_t graph_size)\n>  \t\t\t\tgraph->chunk_commit_data = data + chunk_offset;\n>  \t\t\tbreak;\n>\n> +\t\tcase GRAPH_CHUNKID_GENERATION_DATA:\n> +\t\t\tif (graph->chunk_generation_data)\n> +\t\t\t\tchunk_repeated = 1;\n> +\t\t\telse\n> +\t\t\t\tgraph->chunk_generation_data = data + chunk_offset;\n> +\t\t\tbreak;\n> +\n\nAll right.  The size of GDAT chunk is defined by the number of commits,\nso nothink more is needed.\n\n>  \t\tcase GRAPH_CHUNKID_EXTRAEDGES:\n>  \t\t\tif (graph->chunk_extra_edges)\n>  \t\t\t\tchunk_repeated = 1;\n> @@ -755,7 +763,11 @@ static void fill_commit_graph_info(struct commit *item, struct commit_graph *g,\n>  \tdate_low = get_be32(commit_data + g->hash_len + 12);\n>  \titem->date = (timestamp_t)((date_high << 32) | date_low);\n>\n> -\tgraph_data->generation = get_be32(commit_data + g->hash_len + 8) >> 2;\n> +\tif (g->chunk_generation_data)\n> +\t\tgraph_data->generation = item->date +\n> +\t\t\t(timestamp_t) get_be32(g->chunk_generation_data + sizeof(uint32_t) * lex_index);\n\nWARNING: The above does not properly handle clamped data.\n\nIf the offset is maximum value that can be stored in 32 bit field, that\nis GENERATION_NUMBER_V2_OFFSET_MAX for more that one commit, we wouldn\'t\nknow which commit has greater generation number v2 because of this clamping.\nThe \'generation\' data needs to be set to GENERATION_NUMBER_V2_MAX (which\nin turn needs to be smaller than GENERATION_NUMBER_INFINITY).  This is\nnot done here!\n\nAll the above complication would not be an issue if we stored 64 bit\ncorrected commit date directly, instead of storing 32 bit corrected\ncommit date offsets. Storing offsets saves at most 4/(2*H + 16 + 4) = 7%\nof commit-graph file size (OIDL + CDAT + GDAT with offsets), when\n160-bit/20-byte SHA-1 hash is used.\n\n> +\telse\n> +\t\tgraph_data->generation = get_be32(commit_data + g->hash_len + 8) >> 2;\n\nShould we convert GENERATION_NUMBER_V1_MAX into GENERATION_NUMBER_MAX\nhere, for easier handling of clamped values of generation numbers later\non in backward-compatibile way, without special-casing for v1 and v2?\n\n\nHere we load and perhaps compute generation number, using v2 if possible\n(from GDAT + commit date), with fallback to v1 (from CDAT).\n\nAlmost all right... but should this reading be a part of this patch, or\nsplit off into separate patch?\n\n>\n>  \tif (g->topo_levels)\n>  \t\t*topo_level_slab_at(g->topo_levels, item) = get_be32(commit_data + g->hash_len + 8) >> 2;\n> @@ -951,7 +963,8 @@ struct write_commit_graph_context {\n>  \t\t report_progress:1,\n>  \t\t split:1,\n>  \t\t changed_paths:1,\n> -\t\t order_by_pack:1;\n> +\t\t order_by_pack:1,\n> +\t\t write_generation_data:1;\n\nAll right, here we store the iformation if we should write the GDAT\nchunk, taking into account among other things state of the\nGIT_TEST_COMMIT_GRAPH_NO_GDAT enviroment variable.\n\n>\n>  \tstruct topo_level_slab *topo_levels;\n>  \tconst struct split_commit_graph_opts *split_opts;\n> @@ -1106,8 +1119,25 @@ static int write_graph_chunk_data(struct hashfile *f,\n>  \treturn 0;\n>  }\n>\n> +static int write_graph_chunk_generation_data(struct hashfile *f,\n> +\t\t\t\t\t      struct write_commit_graph_context *ctx)\n> +{\n> +\tint i;\n> +\tfor (i = 0; i < ctx->commits.nr; i++) {\n\nSide note: it is a bit funny that some of write_graph_chunk_*()\nfunctions use `for` loop, and some `while` loop to process commits.\n\n> +\t\tstruct commit *c = ctx->commits.list[i];\n> +\t\ttimestamp_t offset = commit_graph_data_at(c)->generation - c->date;\n> +\t\tdisplay_progress(ctx->progress, ++ctx->progress_cnt);\n> +\n> +\t\tif (offset > GENERATION_NUMBER_V2_OFFSET_MAX)\n> +\t\t\toffset = GENERATION_NUMBER_V2_OFFSET_MAX;\n\nThis GENERATION_NUMBER_V2_OFFSET_MAX symbolic constant (or equivalet)\nshould be defined in this patch and not in previous one, in my opinion.\n\n> +\t\thashwrite_be32(f, offset);\n> +\t}\n> +\n> +\treturn 0;\n> +}\n> +\n>  static int write_graph_chunk_extra_edges(struct hashfile *f,\n> -\t\t\t\t\t struct write_commit_graph_context *ctx)\n> +\t\t\t\t\t  struct write_commit_graph_context *ctx)\n\nThis change in whitespace is, I think, incorrect.\n\n>  {\n>  \tstruct commit **list = ctx->commits.list;\n>  \tstruct commit **last = ctx->commits.list + ctx->commits.nr;\n> @@ -1726,6 +1756,15 @@ static int write_commit_graph_file(struct write_commit_graph_context *ctx)\n>  \tchunks[2].id = GRAPH_CHUNKID_DATA;\n>  \tchunks[2].size = (hashsz + 16) * ctx->commits.nr;\n>  \tchunks[2].write_fn = write_graph_chunk_data;\n> +\n> +\tif (git_env_bool(GIT_TEST_COMMIT_GRAPH_NO_GDAT, 0))\n> +\t\tctx->write_generation_data = 0;\n\nAll right, here we handle newly introduced GIT_TEST_COMMIT_GRAPH_NO_GDAT\nenvironment variable.\n\n> +\tif (ctx->write_generation_data) {\n> +\t\tchunks[num_chunks].id = GRAPH_CHUNKID_GENERATION_DATA;\n> +\t\tchunks[num_chunks].size = sizeof(uint32_t) * ctx->commits.nr;\n> +\t\tchunks[num_chunks].write_fn = write_graph_chunk_generation_data;\n> +\t\tnum_chunks++;\n> +\t}\n\nHmmm... so the GDAT chunk does not have a header, and is not versioned.\nDoes this mean that to move to generation number v3, or add some\nadditional reachability labeling we would need to either rename the\nchunk or add new one?\n\n>  \tif (ctx->num_extra_edges) {\n>  \t\tchunks[num_chunks].id = GRAPH_CHUNKID_EXTRAEDGES;\n>  \t\tchunks[num_chunks].size = 4 * ctx->num_extra_edges;\n> @@ -2130,6 +2169,7 @@ int write_commit_graph(struct object_directory *odb,\n>  \tctx->split = flags & COMMIT_GRAPH_WRITE_SPLIT ? 1 : 0;\n>  \tctx->split_opts = split_opts;\n>  \tctx->total_bloom_filter_data_size = 0;\n> +\tctx->write_generation_data = 1;\n\nBut by default we do write the GDAT chunk.\n\n>\n>  \tif (flags & COMMIT_GRAPH_WRITE_BLOOM_FILTERS)\n>  \t\tctx->changed_paths = 1;\n> diff --git a/commit-graph.h b/commit-graph.h\n> index 1152a9642e..f78c892fc0 100644\n> --- a/commit-graph.h\n> +++ b/commit-graph.h\n> @@ -6,6 +6,7 @@\n>  #include ""oidset.h""\n>\n>  #define GIT_TEST_COMMIT_GRAPH ""GIT_TEST_COMMIT_GRAPH""\n> +#define GIT_TEST_COMMIT_GRAPH_NO_GDAT ""GIT_TEST_COMMIT_GRAPH_NO_GDAT""\n>  #define GIT_TEST_COMMIT_GRAPH_DIE_ON_PARSE ""GIT_TEST_COMMIT_GRAPH_DIE_ON_PARSE""\n>  #define GIT_TEST_COMMIT_GRAPH_CHANGED_PATHS ""GIT_TEST_COMMIT_GRAPH_CHANGED_PATHS""\n>\n\nAll right.\n\n(Though I wonder about the ordering -- but better not to start ""bike\nshed"" discussion).\n\n> @@ -67,6 +68,7 @@ struct commit_graph {\n>  \tconst uint32_t *chunk_oid_fanout;\n>  \tconst unsigned char *chunk_oid_lookup;\n>  \tconst unsigned char *chunk_commit_data;\n> +\tconst unsigned char *chunk_generation_data;\n>  \tconst unsigned char *chunk_extra_edges;\n>  \tconst unsigned char *chunk_base_graphs;\n>  \tconst unsigned char *chunk_bloom_indexes;\n\nAll right, we need to store position of new GDAT chunk.\n\n> diff --git a/t/README b/t/README\n> index 70ec61cf88..6647ef132e 100644\n> --- a/t/README\n> +++ b/t/README\n> @@ -379,6 +379,9 @@ GIT_TEST_COMMIT_GRAPH=<boolean>, when true, forces the commit-graph to\n>  be written after every \'git commit\' command, and overrides the\n>  \'core.commitGraph\' setting to true.\n>\n> +GIT_TEST_COMMIT_GRAPH_NO_GDAT=<boolean>, when true, forces the\n> +commit-graph to be written without generation data chunk.\n> +\n\nAll right.\n\nThis description could have been more detailed, but I think it is good\nenough.\n\n>  GIT_TEST_COMMIT_GRAPH_CHANGED_PATHS=<boolean>, when true, forces\n>  commit-graph write to compute and write changed path Bloom filters for\n>  every \'git commit-graph write\', as if the `--changed-paths` option was\n> diff --git a/t/helper/test-read-graph.c b/t/helper/test-read-graph.c\n> index 6d0c962438..1c2a5366c7 100644\n> --- a/t/helper/test-read-graph.c\n> +++ b/t/helper/test-read-graph.c\n> @@ -32,6 +32,8 @@ int cmd__read_graph(int argc, const char **argv)\n>  \t\tprintf("" oid_lookup"");\n>  \tif (graph->chunk_commit_data)\n>  \t\tprintf("" commit_metadata"");\n> +\tif (graph->chunk_generation_data)\n> +\t\tprintf("" generation_data"");\n>  \tif (graph->chunk_extra_edges)\n>  \t\tprintf("" extra_edges"");\n>  \tif (graph->chunk_bloom_indexes)\n\nAll right, we examine if GDAT chunk is present.\n\nMany commit-graph tests would probably need to be updated; at least\nthose that make use if `git test-tool read-graph`.\n\n> diff --git a/t/t4216-log-bloom.sh b/t/t4216-log-bloom.sh\n> index c21cc160f3..55c94e9ebd 100755\n> --- a/t/t4216-log-bloom.sh\n> +++ b/t/t4216-log-bloom.sh\n> @@ -33,11 +33,11 @@ test_expect_success \'setup test - repo, commits, commit graph, log outputs\' \'\n>  \tgit commit-graph write --reachable --changed-paths\n>  \'\n>  graph_read_expect () {\n> -\tNUM_CHUNKS=5\n> +\tNUM_CHUNKS=6\n>  \tcat >expect <<- EOF\n>  \theader: 43475048 1 1 $NUM_CHUNKS 0\n>  \tnum_commits: $1\n> -\tchunks: oid_fanout oid_lookup commit_metadata bloom_indexes bloom_data\n> +\tchunks: oid_fanout oid_lookup commit_metadata generation_data bloom_indexes bloom_data\n>  \tEOF\n>  \ttest-tool read-graph >actual &&\n>  \ttest_cmp expect actual\n\nAll right.\n\n> diff --git a/t/t5318-commit-graph.sh b/t/t5318-commit-graph.sh\n> index 044cf8a3de..b41b2160c6 100755\n> --- a/t/t5318-commit-graph.sh\n> +++ b/t/t5318-commit-graph.sh\n> @@ -71,7 +71,7 @@ graph_git_behavior \'no graph\' full commits/3 commits/1\n>  graph_read_expect() {\n>  \tOPTIONAL=""""\n>  \tNUM_CHUNKS=3\n> -\tif test ! -z $2\n> +\tif test ! -z ""$2""\n>  \tthen\n>  \t\tOPTIONAL="" $2""\n>  \t\tNUM_CHUNKS=$((3 + $(echo ""$2"" | wc -w)))\n\nAll right, a fix for issue that is relevant only after this change, now\nthat there can be more than one extra chunk.\n\nSide note: how I wish that helper function in tests were documented...\n\n> @@ -98,14 +98,14 @@ test_expect_success \'exit with correct error on bad input to --stdin-commits\' \'\n>  \t# valid commit and tree OID\n>  \tgit rev-parse HEAD HEAD^{tree} >in &&\n>  \tgit commit-graph write --stdin-commits <in &&\n> -\tgraph_read_expect 3\n> +\tgraph_read_expect 3 generation_data\n\nAll right, we need to treat generation_data as extra, because it can be\nnot there (it\'s existence is conditional).\n\n>  \'\n>\n>  test_expect_success \'write graph\' \'\n>  \tcd ""$TRASH_DIRECTORY/full"" &&\n>  \tgit commit-graph write &&\n>  \ttest_path_is_file $objdir/info/commit-graph &&\n> -\tgraph_read_expect ""3""\n> +\tgraph_read_expect ""3"" generation_data\n\nSide note: I wonder why here we have\n\n  \tgraph_read_expect ""3"" generation_data\n\nbut one test earlier we have\n\n  \tgraph_read_expect 3 generation_data\n\nwithout quotes.\n\n>  \'\n>\n>  test_expect_success POSIXPERM \'write graph has correct permissions\' \'\n> @@ -214,7 +214,7 @@ test_expect_success \'write graph with merges\' \'\n>  \tcd ""$TRASH_DIRECTORY/full"" &&\n>  \tgit commit-graph write &&\n>  \ttest_path_is_file $objdir/info/commit-graph &&\n> -\tgraph_read_expect ""10"" ""extra_edges""\n> +\tgraph_read_expect ""10"" ""generation_data extra_edges""\n\nAll right.  It is why we needed to fix graph_read_expect().\n\n>  \'\n>\n>  graph_git_behavior \'merge 1 vs 2\' full merge/1 merge/2\n> @@ -249,7 +249,7 @@ test_expect_success \'write graph with new commit\' \'\n>  \tcd ""$TRASH_DIRECTORY/full"" &&\n>  \tgit commit-graph write &&\n>  \ttest_path_is_file $objdir/info/commit-graph &&\n> -\tgraph_read_expect ""11"" ""extra_edges""\n> +\tgraph_read_expect ""11"" ""generation_data extra_edges""\n>  \'\n>\n>  graph_git_behavior \'full graph, commit 8 vs merge 1\' full commits/8 merge/1\n> @@ -259,7 +259,7 @@ test_expect_success \'write graph with nothing new\' \'\n>  \tcd ""$TRASH_DIRECTORY/full"" &&\n>  \tgit commit-graph write &&\n>  \ttest_path_is_file $objdir/info/commit-graph &&\n> -\tgraph_read_expect ""11"" ""extra_edges""\n> +\tgraph_read_expect ""11"" ""generation_data extra_edges""\n>  \'\n>\n>  graph_git_behavior \'cleared graph, commit 8 vs merge 1\' full commits/8 merge/1\n> @@ -269,7 +269,7 @@ test_expect_success \'build graph from latest pack with closure\' \'\n>  \tcd ""$TRASH_DIRECTORY/full"" &&\n>  \tcat new-idx | git commit-graph write --stdin-packs &&\n>  \ttest_path_is_file $objdir/info/commit-graph &&\n> -\tgraph_read_expect ""9"" ""extra_edges""\n> +\tgraph_read_expect ""9"" ""generation_data extra_edges""\n>  \'\n>\n>  graph_git_behavior \'graph from pack, commit 8 vs merge 1\' full commits/8 merge/1\n> @@ -282,7 +282,7 @@ test_expect_success \'build graph from commits with closure\' \'\n>  \tgit rev-parse merge/1 >>commits-in &&\n>  \tcat commits-in | git commit-graph write --stdin-commits &&\n>  \ttest_path_is_file $objdir/info/commit-graph &&\n> -\tgraph_read_expect ""6""\n> +\tgraph_read_expect ""6"" ""generation_data""\n>  \'\n>\n>  graph_git_behavior \'graph from commits, commit 8 vs merge 1\' full commits/8 merge/1\n> @@ -292,7 +292,7 @@ test_expect_success \'build graph from commits with append\' \'\n>  \tcd ""$TRASH_DIRECTORY/full"" &&\n>  \tgit rev-parse merge/3 | git commit-graph write --stdin-commits --append &&\n>  \ttest_path_is_file $objdir/info/commit-graph &&\n> -\tgraph_read_expect ""10"" ""extra_edges""\n> +\tgraph_read_expect ""10"" ""generation_data extra_edges""\n>  \'\n>\n>  graph_git_behavior \'append graph, commit 8 vs merge 1\' full commits/8 merge/1\n> @@ -302,7 +302,7 @@ test_expect_success \'build graph using --reachable\' \'\n>  \tcd ""$TRASH_DIRECTORY/full"" &&\n>  \tgit commit-graph write --reachable &&\n>  \ttest_path_is_file $objdir/info/commit-graph &&\n> -\tgraph_read_expect ""11"" ""extra_edges""\n> +\tgraph_read_expect ""11"" ""generation_data extra_edges""\n>  \'\n>\n>  graph_git_behavior \'append graph, commit 8 vs merge 1\' full commits/8 merge/1\n> @@ -323,7 +323,7 @@ test_expect_success \'write graph in bare repo\' \'\n>  \tcd ""$TRASH_DIRECTORY/bare"" &&\n>  \tgit commit-graph write &&\n>  \ttest_path_is_file $baredir/info/commit-graph &&\n> -\tgraph_read_expect ""11"" ""extra_edges""\n> +\tgraph_read_expect ""11"" ""generation_data extra_edges""\n>  \'\n\nAll right, those were the straightforward changes.\n\n>\n>  graph_git_behavior \'bare repo with graph, commit 8 vs merge 1\' bare commits/8 merge/1\n> @@ -420,8 +420,9 @@ test_expect_success \'replace-objects invalidates commit-graph\' \'\n>\n>  test_expect_success \'git commit-graph verify\' \'\n>  \tcd ""$TRASH_DIRECTORY/full"" &&\n> -\tgit rev-parse commits/8 | git commit-graph write --stdin-commits &&\n> -\tgit commit-graph verify >output\n> +\tgit rev-parse commits/8 | GIT_TEST_COMMIT_GRAPH_NO_GDAT=1 git commit-graph write --stdin-commits &&\n> +\tgit commit-graph verify >output &&\n> +\tgraph_read_expect 9 extra_edges\n>  \'\n\nWhat this change is about?  Is it about the fact that we have not added\nsupport for checking correctness of GDAT chunk to `git commit-graph\nverify`?  But in previous commit we did modify verify_commit_graph()...\n\n>\n>  NUM_COMMITS=9\n> diff --git a/t/t5324-split-commit-graph.sh b/t/t5324-split-commit-graph.sh\n> index ea28d522b8..531016f405 100755\n> --- a/t/t5324-split-commit-graph.sh\n> +++ b/t/t5324-split-commit-graph.sh\n> @@ -13,11 +13,11 @@ test_expect_success \'setup repo\' \'\n>  \tinfodir="".git/objects/info"" &&\n>  \tgraphdir=""$infodir/commit-graphs"" &&\n>  \ttest_oid_cache <<-EOM\n> -\tshallow sha1:1760\n> -\tshallow sha256:2064\n> +\tshallow sha1:2132\n> +\tshallow sha256:2436\n>\n> -\tbase sha1:1376\n> -\tbase sha256:1496\n> +\tbase sha1:1408\n> +\tbase sha256:1528\n>  \tEOM\n>  \'\n\nI guess this change is because with GDAT chunk present the positions of\nrelevant bits that we want to corrupt change (I guess because we have\nextra chunk in chunk lookup section).\n\nSomeone else would have to verify if this change is in fact correct, if\nit was not done already.\n\n>\n> @@ -28,9 +28,9 @@ graph_read_expect() {\n>  \t\tNUM_BASE=$2\n>  \tfi\n>  \tcat >expect <<- EOF\n> -\theader: 43475048 1 1 3 $NUM_BASE\n> +\theader: 43475048 1 1 4 $NUM_BASE\n>  \tnum_commits: $1\n> -\tchunks: oid_fanout oid_lookup commit_metadata\n> +\tchunks: oid_fanout oid_lookup commit_metadata generation_data\n\nAll right, we now have 4 chunks not 3 (old ones + generation_data).\n\n>  \tEOF\n>  \ttest-tool read-graph >output &&\n>  \ttest_cmp expect output\n> diff --git a/t/t6600-test-reach.sh b/t/t6600-test-reach.sh\n> index 475564bee7..d14b129f06 100755\n> --- a/t/t6600-test-reach.sh\n> +++ b/t/t6600-test-reach.sh\n> @@ -55,10 +55,13 @@ test_expect_success \'setup\' \'\n>  \tgit show-ref -s commit-5-5 | git commit-graph write --stdin-commits &&\n>  \tmv .git/objects/info/commit-graph commit-graph-half &&\n>  \tchmod u+w commit-graph-half &&\n> +\tGIT_TEST_COMMIT_GRAPH_NO_GDAT=1 git commit-graph write --reachable &&\n> +\tmv .git/objects/info/commit-graph commit-graph-no-gdat &&\n> +\tchmod u+w commit-graph-no-gdat &&\n>  \tgit config core.commitGraph true\n>  \'\n\nAll right, we add setup for testing no GDAT case (as if the commit-graph\nfile was written by ""Old"" Git).\n\n>\n> -run_three_modes () {\n> +run_all_modes () {\n\nAll right, we compare more modes, among others the no-GDAT case.\n\nNice futureproofing!\n\n>  \ttest_when_finished rm -rf .git/objects/info/commit-graph &&\n>  \t""$@"" <input >actual &&\n>  \ttest_cmp expect actual &&\n> @@ -67,11 +70,14 @@ run_three_modes () {\n>  \ttest_cmp expect actual &&\n>  \tcp commit-graph-half .git/objects/info/commit-graph &&\n>  \t""$@"" <input >actual &&\n> +\ttest_cmp expect actual &&\n> +\tcp commit-graph-no-gdat .git/objects/info/commit-graph &&\n> +\t""$@"" <input >actual &&\n>  \ttest_cmp expect actual\n>  }\n\nOK, now we test yet another variant of commit-graph file: one without\nthe GDAT chunk (testing for backward compatibility with ""Old"" Git).\n\n>\n> -test_three_modes () {\n> -\trun_three_modes test-tool reach ""$@""\n> +test_all_modes () {\n> +\trun_all_modes test-tool reach ""$@""\n>  }\n\nAll right.\n\n>\n>  test_expect_success \'ref_newer:miss\' \'\n> @@ -80,7 +86,7 @@ test_expect_success \'ref_newer:miss\' \'\n>  \tB:commit-4-9\n>  \tEOF\n>  \techo ""ref_newer(A,B):0"" >expect &&\n> -\ttest_three_modes ref_newer\n> +\ttest_all_modes ref_newer\n>  \'\n>\n>  test_expect_success \'ref_newer:hit\' \'\n> @@ -89,7 +95,7 @@ test_expect_success \'ref_newer:hit\' \'\n>  \tB:commit-2-3\n>  \tEOF\n>  \techo ""ref_newer(A,B):1"" >expect &&\n> -\ttest_three_modes ref_newer\n> +\ttest_all_modes ref_newer\n>  \'\n>\n>  test_expect_success \'in_merge_bases:hit\' \'\n> @@ -98,7 +104,7 @@ test_expect_success \'in_merge_bases:hit\' \'\n>  \tB:commit-8-8\n>  \tEOF\n>  \techo ""in_merge_bases(A,B):1"" >expect &&\n> -\ttest_three_modes in_merge_bases\n> +\ttest_all_modes in_merge_bases\n>  \'\n>\n>  test_expect_success \'in_merge_bases:miss\' \'\n> @@ -107,7 +113,7 @@ test_expect_success \'in_merge_bases:miss\' \'\n>  \tB:commit-5-9\n>  \tEOF\n>  \techo ""in_merge_bases(A,B):0"" >expect &&\n> -\ttest_three_modes in_merge_bases\n> +\ttest_all_modes in_merge_bases\n>  \'\n>\n>  test_expect_success \'is_descendant_of:hit\' \'\n> @@ -118,7 +124,7 @@ test_expect_success \'is_descendant_of:hit\' \'\n>  \tX:commit-1-1\n>  \tEOF\n>  \techo ""is_descendant_of(A,X):1"" >expect &&\n> -\ttest_three_modes is_descendant_of\n> +\ttest_all_modes is_descendant_of\n>  \'\n>\n>  test_expect_success \'is_descendant_of:miss\' \'\n> @@ -129,7 +135,7 @@ test_expect_success \'is_descendant_of:miss\' \'\n>  \tX:commit-7-6\n>  \tEOF\n>  \techo ""is_descendant_of(A,X):0"" >expect &&\n> -\ttest_three_modes is_descendant_of\n> +\ttest_all_modes is_descendant_of\n>  \'\n>\n>  test_expect_success \'get_merge_bases_many\' \'\n> @@ -144,7 +150,7 @@ test_expect_success \'get_merge_bases_many\' \'\n>  \t\tgit rev-parse commit-5-6 \\\n>  \t\t\t      commit-4-7 | sort\n>  \t} >expect &&\n> -\ttest_three_modes get_merge_bases_many\n> +\ttest_all_modes get_merge_bases_many\n>  \'\n>\n>  test_expect_success \'reduce_heads\' \'\n> @@ -166,7 +172,7 @@ test_expect_success \'reduce_heads\' \'\n>  \t\t\t      commit-2-8 \\\n>  \t\t\t      commit-1-10 | sort\n>  \t} >expect &&\n> -\ttest_three_modes reduce_heads\n> +\ttest_all_modes reduce_heads\n>  \'\n>\n>  test_expect_success \'can_all_from_reach:hit\' \'\n> @@ -189,7 +195,7 @@ test_expect_success \'can_all_from_reach:hit\' \'\n>  \tY:commit-8-1\n>  \tEOF\n>  \techo ""can_all_from_reach(X,Y):1"" >expect &&\n> -\ttest_three_modes can_all_from_reach\n> +\ttest_all_modes can_all_from_reach\n>  \'\n>\n>  test_expect_success \'can_all_from_reach:miss\' \'\n> @@ -211,7 +217,7 @@ test_expect_success \'can_all_from_reach:miss\' \'\n>  \tY:commit-8-5\n>  \tEOF\n>  \techo ""can_all_from_reach(X,Y):0"" >expect &&\n> -\ttest_three_modes can_all_from_reach\n> +\ttest_all_modes can_all_from_reach\n>  \'\n>\n>  test_expect_success \'can_all_from_reach_with_flag: tags case\' \'\n> @@ -234,7 +240,7 @@ test_expect_success \'can_all_from_reach_with_flag: tags case\' \'\n>  \tY:commit-8-1\n>  \tEOF\n>  \techo ""can_all_from_reach_with_flag(X,_,_,0,0):1"" >expect &&\n> -\ttest_three_modes can_all_from_reach_with_flag\n> +\ttest_all_modes can_all_from_reach_with_flag\n>  \'\n>\n>  test_expect_success \'commit_contains:hit\' \'\n> @@ -250,8 +256,8 @@ test_expect_success \'commit_contains:hit\' \'\n>  \tX:commit-9-3\n>  \tEOF\n>  \techo ""commit_contains(_,A,X,_):1"" >expect &&\n> -\ttest_three_modes commit_contains &&\n> -\ttest_three_modes commit_contains --tag\n> +\ttest_all_modes commit_contains &&\n> +\ttest_all_modes commit_contains --tag\n>  \'\n>\n>  test_expect_success \'commit_contains:miss\' \'\n> @@ -267,8 +273,8 @@ test_expect_success \'commit_contains:miss\' \'\n>  \tX:commit-9-3\n>  \tEOF\n>  \techo ""commit_contains(_,A,X,_):0"" >expect &&\n> -\ttest_three_modes commit_contains &&\n> -\ttest_three_modes commit_contains --tag\n> +\ttest_all_modes commit_contains &&\n> +\ttest_all_modes commit_contains --tag\n>  \'\n>\n>  test_expect_success \'rev-list: basic topo-order\' \'\n> @@ -280,7 +286,7 @@ test_expect_success \'rev-list: basic topo-order\' \'\n>  \t\tcommit-6-2 commit-5-2 commit-4-2 commit-3-2 commit-2-2 commit-1-2 \\\n>  \t\tcommit-6-1 commit-5-1 commit-4-1 commit-3-1 commit-2-1 commit-1-1 \\\n>  \t>expect &&\n> -\trun_three_modes git rev-list --topo-order commit-6-6\n> +\trun_all_modes git rev-list --topo-order commit-6-6\n>  \'\n>\n>  test_expect_success \'rev-list: first-parent topo-order\' \'\n> @@ -292,7 +298,7 @@ test_expect_success \'rev-list: first-parent topo-order\' \'\n>  \t\tcommit-6-2 \\\n>  \t\tcommit-6-1 commit-5-1 commit-4-1 commit-3-1 commit-2-1 commit-1-1 \\\n>  \t>expect &&\n> -\trun_three_modes git rev-list --first-parent --topo-order commit-6-6\n> +\trun_all_modes git rev-list --first-parent --topo-order commit-6-6\n>  \'\n>\n>  test_expect_success \'rev-list: range topo-order\' \'\n> @@ -304,7 +310,7 @@ test_expect_success \'rev-list: range topo-order\' \'\n>  \t\tcommit-6-2 commit-5-2 commit-4-2 \\\n>  \t\tcommit-6-1 commit-5-1 commit-4-1 \\\n>  \t>expect &&\n> -\trun_three_modes git rev-list --topo-order commit-3-3..commit-6-6\n> +\trun_all_modes git rev-list --topo-order commit-3-3..commit-6-6\n>  \'\n>\n>  test_expect_success \'rev-list: range topo-order\' \'\n> @@ -316,7 +322,7 @@ test_expect_success \'rev-list: range topo-order\' \'\n>  \t\tcommit-6-2 commit-5-2 commit-4-2 \\\n>  \t\tcommit-6-1 commit-5-1 commit-4-1 \\\n>  \t>expect &&\n> -\trun_three_modes git rev-list --topo-order commit-3-8..commit-6-6\n> +\trun_all_modes git rev-list --topo-order commit-3-8..commit-6-6\n>  \'\n>\n>  test_expect_success \'rev-list: first-parent range topo-order\' \'\n> @@ -328,7 +334,7 @@ test_expect_success \'rev-list: first-parent range topo-order\' \'\n>  \t\tcommit-6-2 \\\n>  \t\tcommit-6-1 commit-5-1 commit-4-1 \\\n>  \t>expect &&\n> -\trun_three_modes git rev-list --first-parent --topo-order commit-3-8..commit-6-6\n> +\trun_all_modes git rev-list --first-parent --topo-order commit-3-8..commit-6-6\n>  \'\n>\n>  test_expect_success \'rev-list: ancestry-path topo-order\' \'\n> @@ -338,7 +344,7 @@ test_expect_success \'rev-list: ancestry-path topo-order\' \'\n>  \t\tcommit-6-4 commit-5-4 commit-4-4 commit-3-4 \\\n>  \t\tcommit-6-3 commit-5-3 commit-4-3 \\\n>  \t>expect &&\n> -\trun_three_modes git rev-list --topo-order --ancestry-path commit-3-3..commit-6-6\n> +\trun_all_modes git rev-list --topo-order --ancestry-path commit-3-3..commit-6-6\n>  \'\n>\n>  test_expect_success \'rev-list: symmetric difference topo-order\' \'\n> @@ -352,7 +358,7 @@ test_expect_success \'rev-list: symmetric difference topo-order\' \'\n>  \t\tcommit-3-8 commit-2-8 commit-1-8 \\\n>  \t\tcommit-3-7 commit-2-7 commit-1-7 \\\n>  \t>expect &&\n> -\trun_three_modes git rev-list --topo-order commit-3-8...commit-6-6\n> +\trun_all_modes git rev-list --topo-order commit-3-8...commit-6-6\n>  \'\n>\n>  test_expect_success \'get_reachable_subset:all\' \'\n> @@ -372,7 +378,7 @@ test_expect_success \'get_reachable_subset:all\' \'\n>  \t\t\t      commit-1-7 \\\n>  \t\t\t      commit-5-6 | sort\n>  \t) >expect &&\n> -\ttest_three_modes get_reachable_subset\n> +\ttest_all_modes get_reachable_subset\n>  \'\n>\n>  test_expect_success \'get_reachable_subset:some\' \'\n> @@ -390,7 +396,7 @@ test_expect_success \'get_reachable_subset:some\' \'\n>  \t\tgit rev-parse commit-3-3 \\\n>  \t\t\t      commit-1-7 | sort\n>  \t) >expect &&\n> -\ttest_three_modes get_reachable_subset\n> +\ttest_all_modes get_reachable_subset\n>  \'\n>\n>  test_expect_success \'get_reachable_subset:none\' \'\n> @@ -404,7 +410,7 @@ test_expect_success \'get_reachable_subset:none\' \'\n>  \tY:commit-2-8\n>  \tEOF\n>  \techo ""get_reachable_subset(X,Y)"" >expect &&\n> -\ttest_three_modes get_reachable_subset\n> +\ttest_all_modes get_reachable_subset\n>  \'\n\nAll right, s/test_three_modes/test_all_modes/... which admitedly could\nhave been separate pure refactoring patch, but it is not necessary.\n\n>\n>  test_done\n\nBest,\n--\nJakub Narębski\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 22, 13, 11, 32, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 475111248, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/85pn7ihabl.fsf@gmail.com), jnareb@gmail.com (Jakub Narębski) wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nHi Abhishek,\n\n""Abhishek Kumar via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n\n> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n>\n> Since there are released versions of Git that understand generation\n> numbers in the commit-graph\'s CDAT chunk but do not understand the GDAT\n> chunk, the following scenario is possible:\n>\n> 1. ""New"" Git writes a commit-graph with the GDAT chunk.\n> 2. ""Old"" Git writes a split commit-graph on top without a GDAT chunk.\n>\n> Because of the current use of inspecting the current layer for a\n> chunk_generation_data pointer, the commits in the lower layer will be\n> interpreted as having very large generation values (commit date plus\n> offset) compared to the generation numbers in the top layer (topological\n> level). This violates the expectation that the generation of a parent is\n> strictly smaller than the generation of a child.\n\nAll right, this explains changes to the *reading* side.  If there is\nsplit commit-graph layer without GDAT chunk (or to be more exact,\ncurrent code checks if there is any layer without GDAT chunk), then we\nfall back to using topological levels, as if all layers / all graphs\nwere without GDAT.  This allows to avoid the issue explained above,\nwhere for some commits \'generation\' holds corrected commit date, and for\nsome it holds topological levels, breaking the reachability condition\nguarantee.\n\n\nHowever the commit message do not say anything about the *writing* side.\n\nWe have decided to not write the GDAT chunk when writing the new layer\nin split commit-graph, and top layer doesn\'t itself have GDAT chunks.\nThat makes for easier reasoning and safer handling: in mixed-version\nenvironment the only possible arrangement is for the lower layers\n(possibly zero) have GDAT chunk, and higher layers (possibly zero) not\nhave GDAT chunks.\n\nRewriting layers follows similar approach: if the topmost layer below\nset of layers being rewritten (in the split commit-graph chain) exists,\nand it does not contain GDAT chunk, then the result of rewrite should\nnot have GDAT chunks either.\n\n\nTo be more detailed, without \'--split=replace\' we would want the following\nlayer merging behavior:\n\n   [layer with GDAT][with GDAT][without GDAT][without GDAT][without GDAT]\n           1              2           3             4            5\n\nIn the split commit-graph chain above, merging two topmost layers\n(layers 4 and 5) should create a layer without GDAT; merging three\ntopmost layers (and any other layers, e.g. two middle ones, i.e. 3 and\n4) should create a new layer with GDAT.\n\n   [layer with GDAT][with GDAT][without GDAT][-------without GDAT-------]\n           1              2           3               merged\n\n   [layer with GDAT][with GDAT][-------------with GDAT------------------]\n           1              2                    merged\n\nI hope those ASCII-art pictures help understanding it\n\n>\n> It is difficult to expose this issue in a test. Since we _start_ with\n> artificially low generation numbers, any commit walk that prioritizes\n> generation numbers will walk all of the commits with high generation\n> number before walking the commits with low generation number. In all the\n> cases I tried, the commit-graph layers themselves ""protect"" any\n> incorrect behavior since none of the commits in the lower layer can\n> reach the commits in the upper layer.\n>\n> This issue would manifest itself as a performance problem in this case,\n> especially with something like ""git log --graph"" since the low\n> generation numbers would cause the in-degree queue to walk all of the\n> commits in the lower layer before allowing the topo-order queue to write\n> anything to output (depending on the size of the upper layer).\n\nWouldn\'t breaking the reachability condition promise make some Git\ncommands to return *incorrect* results if they short-circuit, stop\nwalking if generation number shows that A cannot reach B?\n\nI am talking here about commands that return boolean, or select subset\nfrom given set of revisions:\n- git merge-base --is-ancestor <B> <A>\n- git branch branch-A <A> && git branch --contains <B>\n- git branch branch-B <B> && git branch --merged <A>\n\nGit assumes that generation numbers fulfill the following condition:\n\n  if A can reach B, then gen(A) > gen(B)\n\nNotably this includes commits not in commit-graph, and clamped values.\n\nHowever, in the following case\n\n* if commit A is from higher layer without GDAT\n  and uses topological levels for \'generation\', e.g. 115 (in a small repo)\n* and commit B is from lower layer with GDAT\n  and uses corrected commit date as \'generation\', for example 1598112896,\n\nit may happen that A (later commit) can reach B (earlier commit), but\ngen(B) > gen(A).  The reachability condition promise for generation\nnumbers is broken.\n\n>\n> Signed-off-by: Derrick Stolee <dstolee@microsoft.com>\n> Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> ---\n\nI have reordered files in the patch itself to make it easier to review\nthe proposed changes.\n\n>  commit-graph.h                |  1 +\n>  commit-graph.c                | 32 +++++++++++++++-\n>  t/t5324-split-commit-graph.sh | 70 +++++++++++++++++++++++++++++++++++\n>  3 files changed, 102 insertions(+), 1 deletion(-)\n>\n> diff --git a/commit-graph.h b/commit-graph.h\n> index f78c892fc0..3cf89d895d 100644\n> --- a/commit-graph.h\n> +++ b/commit-graph.h\n> @@ -63,6 +63,7 @@ struct commit_graph {\n>  \tstruct object_directory *odb;\n>\n>  \tuint32_t num_commits_in_base;\n> +\tuint32_t read_generation_data;\n>  \tstruct commit_graph *base_graph;\n>\n\nFirst, why `read_generation_data` is of uint32_t type, when it stores\n(as far as I understand it), a ""boolean"" value of either 0 or 1?\n\nSecond, couldn\'t we simply set chunk_generation_data to NULL?  Or would\nthat interfere with the case of rewriting, where we want to use existing\nGDAT data when writing new commit-graph with GDAT chunk?\n\n>  \tconst uint32_t *chunk_oid_fanout;\n> diff --git a/commit-graph.c b/commit-graph.c\n> index b7a72b40db..c1292f8e08 100644\n> --- a/commit-graph.c\n> +++ b/commit-graph.c\n> @@ -597,6 +597,27 @@ static struct commit_graph *load_commit_graph_chain(struct repository *r,\n>  \treturn graph_chain;\n>  }\n>\n> +static void validate_mixed_generation_chain(struct repository *r)\n> +{\n> +\tstruct commit_graph *g = r->objects->commit_graph;\n> +\tint read_generation_data = 1;\n> +\n> +\twhile (g) {\n> +\t\tif (!g->chunk_generation_data) {\n> +\t\t\tread_generation_data = 0;\n> +\t\t\tbreak;\n> +\t\t}\n> +\t\tg = g->base_graph;\n> +\t}\n\nThis loop checks whole split commit-graph chain for existence of layers\nwithout GDAT chunk.\n\nOn one hand it is more than needed _if_ we assume that the fact that\nonly topmost layers can be without GDAT holds true. On the other hand it\nis safer (an example of defensive coding), and as the length of chain is\nlimited it should be not much of a performance penalty.\n\n> +\n> +\tg = r->objects->commit_graph;\n> +\n> +\twhile (g) {\n> +\t\tg->read_generation_data = read_generation_data;\n> +\t\tg = g->base_graph;\n> +\t}\n\nAll right... though one of earlier commits introduced similar loop, but\nit set chunk_generation_data to NULL instead.  Or did I remember it wrong?\n\n> +}\n> +\n>  struct commit_graph *read_commit_graph_one(struct repository *r,\n>  \t\t\t\t\t   struct object_directory *odb)\n>  {\n> @@ -605,6 +626,8 @@ struct commit_graph *read_commit_graph_one(struct repository *r,\n>  \tif (!g)\n>  \t\tg = load_commit_graph_chain(r, odb);\n>\n> +\tvalidate_mixed_generation_chain(r);\n> +\n\nAll right, when reading the commit-graph, check if we are in forced\nbackward-compatibile mode, and we need to use topological levels for\ngeneration numbers.\n\n>  \treturn g;\n>  }\n>\n> @@ -763,7 +786,7 @@ static void fill_commit_graph_info(struct commit *item, struct commit_graph *g,\n>  \tdate_low = get_be32(commit_data + g->hash_len + 12);\n>  \titem->date = (timestamp_t)((date_high << 32) | date_low);\n>\n> -\tif (g->chunk_generation_data)\n> +\tif (g->chunk_generation_data && g->read_generation_data)\n\nAll right, when deciding whether to use corrected commit date\n(generation number v2 from GDAT chunk), or fall back to using\ntopological levels (generation number v1 from CDAT chunk), we need to\ntake into accout other layers, to not mix v1 and v2.\n\nWe have earlier checked whether we can use generation number v2, now we\nuse the result of this check, propagated down the commit-graph chain.\n\n>  \t\tgraph_data->generation = item->date +\n>  \t\t\t(timestamp_t) get_be32(g->chunk_generation_data + sizeof(uint32_t) * lex_index);\n>  \telse\n> @@ -885,6 +908,7 @@ void load_commit_graph_info(struct repository *r, struct commit *item)\n>  \tuint32_t pos;\n>  \tif (!prepare_commit_graph(r))\n>  \t\treturn;\n> +\n>  \tif (find_commit_in_graph(item, r->objects->commit_graph, &pos))\n>  \t\tfill_commit_graph_info(item, r->objects->commit_graph, pos);\n>  }\n\nThis is unrelated whitespace fix, a ""while at it"" in neighbourhood of\nchanges.  All right then.\n\n> @@ -2192,6 +2216,9 @@ int write_commit_graph(struct object_directory *odb,\n>\n>  \t\tg = ctx->r->objects->commit_graph;\n>\n> +\t\tif (g && !g->chunk_generation_data)\n> +\t\t\tctx->write_generation_data = 0;\n> +\n>  \t\twhile (g) {\n>  \t\t\tctx->num_commit_graphs_before++;\n>  \t\t\tg = g->base_graph;\n> @@ -2210,6 +2237,9 @@ int write_commit_graph(struct object_directory *odb,\n>\n>  \t\tif (ctx->split_opts)\n>  \t\t\treplace = ctx->split_opts->flags & COMMIT_GRAPH_SPLIT_REPLACE;\n> +\n> +\t\tif (replace)\n> +\t\t\tctx->write_generation_data = 1;\n>  \t}\n\n\nThe previous commit introduced `write_generation_data` member in\n`struct write_commit_graph_context`, then used to handle support for\nGIT_TEST_COMMIT_GRAPH_NO_GDAT environment variable.\n\nThose two hunks of changes above are both inside\n\n   if (ctx->split) {\n      ...\n   }\n\nHere we examine the topmost layer of split commit-graph chain, and if it\ndoes not contain GDAT chunk, then we do not store the GDAT chunk, unless\n`git commit-graph write` is ru with `--split=replace` option.\n\nHowever this is overly strict condition.  If we merge layer without GDAT\nwith layer with GDAT below, then we surely can write GDAT; the condition\nfor GDAT-less layers would be still fulfilled (met).  However we can\nconsider it \'good enough\' for now, and relax this condition in later\ncommits.\n\n\nNote that it is the first time in this patch were we make use of\nassumption that if there are layers without GDAT then topmost layer is\nwithout GDAT.\n\n>\n>  \tctx->approx_nr_objects = approximate_object_count();\n> diff --git a/t/t5324-split-commit-graph.sh b/t/t5324-split-commit-graph.sh\n> index 531016f405..ac5e7783fb 100755\n> --- a/t/t5324-split-commit-graph.sh\n> +++ b/t/t5324-split-commit-graph.sh\n> @@ -424,4 +424,74 @@ done <<\\EOF\n>  0600 -r--------\n>  EOF\n>\n\nIt would be nice to have an ASCII-art graph of commits, but earlier\ntests do not have it either...\n\n> +test_expect_success \'setup repo for mixed generation commit-graph-chain\' \'\n> +\tmkdir mixed &&\n> +\tgraphdir="".git/objects/info/commit-graphs"" &&\n> +\tcd ""$TRASH_DIRECTORY/mixed"" &&\n> +\tgit init &&\n> +\tgit config core.commitGraph true &&\n> +\tgit config gc.writeCommitGraph false &&\n> +\tfor i in $(test_seq 3)\n> +\tdo\n> +\t\ttest_commit $i &&\n> +\t\tgit branch commits/$i || return 1\n> +\tdone &&\n> +\tgit reset --hard commits/1 &&\n> +\tfor i in $(test_seq 4 5)\n> +\tdo\n> +\t\ttest_commit $i &&\n> +\t\tgit branch commits/$i || return 1\n> +\tdone &&\n> +\tgit reset --hard commits/2 &&\n> +\tfor i in $(test_seq 6 10)\n> +\tdo\n> +\t\ttest_commit $i &&\n> +\t\tgit branch commits/$i || return 1\n> +\tdone &&\n> +\tgit commit-graph write --reachable --split &&\n> +\tgit reset --hard commits/2 &&\n> +\tgit merge commits/4 &&\n> +\tgit branch merge/1 &&\n> +\tgit reset --hard commits/4 &&\n> +\tgit merge commits/6 &&\n> +\tgit branch merge/2 &&\n> +\tGIT_TEST_COMMIT_GRAPH_NO_GDAT=1 git commit-graph write --reachable --split=no-merge &&\n> +\ttest-tool read-graph >output &&\n> +\tcat >expect <<-EOF &&\n> +\theader: 43475048 1 1 4 1\n> +\tnum_commits: 2\n> +\tchunks: oid_fanout oid_lookup commit_metadata\n> +\tEOF\n> +\ttest_cmp expect output &&\n> +\tgit commit-graph verify\n> +\'\n\nLooks all right to me.\n\n> +\n> +test_expect_success \'does not write generation data chunk if not present on existing tip\' \'\n> +\tcd ""$TRASH_DIRECTORY/mixed"" &&\n> +\tgit reset --hard commits/3 &&\n> +\tgit merge merge/1 &&\n> +\tgit merge commits/5 &&\n> +\tgit merge merge/2 &&\n> +\tgit branch merge/3 &&\n> +\tgit commit-graph write --reachable --split=no-merge &&\n> +\ttest-tool read-graph >output &&\n> +\tcat >expect <<-EOF &&\n> +\theader: 43475048 1 1 4 2\n> +\tnum_commits: 3\n> +\tchunks: oid_fanout oid_lookup commit_metadata\n> +\tEOF\n> +\ttest_cmp expect output &&\n> +\tgit commit-graph verify\n> +\'\n> +\n> +test_expect_success \'writes generation data chunk when commit-graph chain is replaced\' \'\n> +\tcd ""$TRASH_DIRECTORY/mixed"" &&\n> +\tgit commit-graph write --reachable --split=replace &&\n> +\ttest_path_is_file $graphdir/commit-graph-chain &&\n> +\ttest_line_count = 1 $graphdir/commit-graph-chain &&\n> +\tverify_chain_files_exist $graphdir &&\n> +\tgraph_read_expect 15 &&\n> +\tgit commit-graph verify\n> +\'\n\nIt would be nice to have an example with merging layers (whether we\nwould handle it in strict or relaxed way).\n\n> +\n>  test_done\n\nBest,\n-- \nJakub Narębski\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 22, 17, 17, 45, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 476181013, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/20200825050448.GA21012@Abhishek-Arch), Abhishek Kumar wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Fri, Aug 21, 2020 at 03:14:34PM +0200, Jakub Narębski wrote:\n> ""Abhishek Kumar via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n> \n> > From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> >\n> > In a preparatory step, let\'s return timestamp_t values from\n> > commit_graph_generation(), use timestamp_t for local variables\n> \n> All right, this is all good.\n> \n> > and define GENERATION_NUMBER_INFINITY as (2 ^ 63 - 1) instead.\n> \n> This needs more detailed examination.  There are two similar constants,\n> GENERATION_NUMBER_INFINITY and GENERATION_NUMBER_MAX.  The former is\n> used for newest commits outside the commit-graph, while the latter is\n> maximum number that commits in the commit-graph can have (because of the\n> storage limitations).  We therefore need GENERATION_NUMBER_INFINITY\n> to be larger than GENERATION_NUMBER_MAX, and it is (and was).\n> \n> The GENERATION_NUMBER_INFINITY is because of the above requirement\n> traditionally taken as maximum value that can be represented in the data\n> type used to store commit\'s generation number _in memory_, but it can be\n> less.  For timestamp_t the maximum value that can be represented\n> is (2 ^ 63 - 1).\n> \n> All right then.\n> \n> >\n\nRelated to this, by the end of this series we are using\nGENERATION_NUMBER_MAX in just one place - compute_generation_numbers()\nto make sure the topological levels fit within 30 bits.\n\nWould it be more appropriate to rename GENERATION_NUMBER_MAX to\nGENERATION_NUMBER_V1_MAX (along the lines of\nGENERATION_NUMBER_V2_OFFSET_MAX)  to correctly describe that is a\nlimit on topological levels, rather than generation number value?\n\n> \n> The commit message says nothing about the new symbolic constant\n> GENERATION_NUMBER_V1_INFINITY, though.\n> \n> I\'m not sure it is even needed (see comments below).\n\nYes, you are correct. I tried it out with your suggestions and it wasn\'t\nreally needed.\n\nThanks for catching this!\n\n> ...\n\nThanks\n- Abhishek\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 25, 5, 9, 59, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 476202767, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/20200825061418.GA629699@Abhishek-Arch), Abhishek Kumar wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Fri, Aug 21, 2020 at 08:43:38PM +0200, Jakub Narębski wrote:\n> Hello,\n> \n> ""Abhishek Kumar via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n> \n> > From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> >\n> > As we are writing topological levels to commit data chunk to ensure\n> > backwards compatibility with ""Old"" Git and the member `generation` of\n> > struct commit_graph_data will store corrected commit date in a later\n> > commit, let\'s introduce a commit-slab to store topological levels while\n> > writing commit-graph.\n> \n> In my opinion the above it would be easier to follow if rephrased in the\n> following way:\n> \n>   In a later commit we will introduce corrected commit date as the\n>   generation number v2.  This value will be stored in the new separate\n>   GDAT chunk.  However to ensure backwards compatibility with ""Old"" Git\n>   we need to continue to write generation number v1, which is\n>   topological level, to the commit data chunk (CDAT).  This means that\n>   we need to compute both versions of generation numbers when writing\n>   the commit-graph file.  Let\'s therefore introduce a commit-slab\n>   to store topological levels; corrected commit date will be stored\n>   in the member `generation` of struct commit_graph_data.\n> \n> What do you think?\n> \n\nYes, that\'s better.\n\n> \n> By the way, do I understand it correctly that in backward-compatibility\n> mode (that is, in mixed-version environment where at least some\n> commit-graph files were written by ""Old"" Git and are lacking GDAT chunk\n> and generation number v2 data) the `generation` member of commit graph\n> data chunk will be populated and will store generation number v1, that\n> is topological level? And that the commit-slab for topological levels is\n> only there for writing and re-writing?\n> \n\nNo, the topo_levels commit-slab would be always populated when we write\na commit data chunk. The topo_level slab is a workaround for the fact\nthat we are trying to write two independent values (corrected commit\ndate offset, topological levels) but have one struct member to store them in\n(data->generation).\n\nIf we are in a mixed-version environment, we could avoid initializing\nthe slab and fill the topological levels into data->generation instead,\nbut that\'s not how it is implemented right now.\n\n> >\n> > When Git creates a split commit-graph, it takes advantage of the\n> > generation values that have been computed already and present in\n> > existing commit-graph files.\n> >\n> > So, let\'s add a pointer to struct commit_graph to the topological level\n> > commit-slab and populate it with topological levels while writing a\n> > split commit-graph.\n> \n> All right, looks sensible.\n\nI have extend the last paragraph to include write_commit_graph_context\nas well as:\n\n  So, let\'s add a pointer to struct commit_graph as well as struct\n  write_commit_graph_context to the topological level commit-slab and\n  populate it with topological levels while writing a commit-graph file.\n\n> \n> >\n> > Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> > ---\n> >  commit-graph.c | 47 ++++++++++++++++++++++++++++++++---------------\n> >  commit-graph.h |  1 +\n> >  commit.h       |  1 +\n> >  3 files changed, 34 insertions(+), 15 deletions(-)\n> >\n> > diff --git a/commit-graph.c b/commit-graph.c\n> > index 7f9f858577..a2f15b2825 100644\n> > --- a/commit-graph.c\n> > +++ b/commit-graph.c\n> > @@ -64,6 +64,8 @@ void git_test_write_commit_graph_or_die(void)\n> >  /* Remember to update object flag allocation in object.h */\n> >  #define REACHABLE       (1u<<15)\n> >\n> > +define_commit_slab(topo_level_slab, uint32_t);\n> > +\n> \n> All right.\n> \n> Also, here we might need GENERATION_NUMBER_V1_INFINITY, but I don\'t\n> think it would be necessary.\n> \n> >  /* Keep track of the order in which commits are added to our list. */\n> >  define_commit_slab(commit_pos, int);\n> >  static struct commit_pos commit_pos = COMMIT_SLAB_INIT(1, commit_pos);\n> > @@ -759,6 +761,9 @@ static void fill_commit_graph_info(struct commit *item, struct commit_graph *g,\n> >  \titem->date = (timestamp_t)((date_high << 32) | date_low);\n> >\n> >  \tgraph_data->generation = get_be32(commit_data + g->hash_len + 8) >> 2;\n> > +\n> > +\tif (g->topo_levels)\n> > +\t\t*topo_level_slab_at(g->topo_levels, item) = get_be32(commit_data + g->hash_len + 8) >> 2;\n> >  }\n> \n> All right, here we store topological levels on commit-slab to avoid\n> recomputing them.\n> \n> Do I understand it correctly that the `topo_levels` member of the `struct\n> commit_graph` would be non-null only when we are updating the\n> commit-graph?\n> \n\nYes, that\'s correct.\n\n> >\n> >  static inline void set_commit_tree(struct commit *c, struct tree *t)\n> > @@ -953,6 +958,7 @@ struct write_commit_graph_context {\n> >  \t\t changed_paths:1,\n> >  \t\t order_by_pack:1;\n> >\n> > +\tstruct topo_level_slab *topo_levels;\n> >  \tconst struct split_commit_graph_opts *split_opts;\n> >  \tsize_t total_bloom_filter_data_size;\n> >  \tconst struct bloom_filter_settings *bloom_settings;\n> \n> Why do we need `topo_levels` member *both* in `struct commit_graph` and\n> in `struct write_commit_graph_context`?\n> \n> [After examining the change further I have realized why both are needed,\n>  and written about the reasoning later in this email.]\n> \n> \n> Note that the commit message talks only about `struct commit_graph`...\n> \n> > @@ -1094,7 +1100,7 @@ static int write_graph_chunk_data(struct hashfile *f,\n> >  \t\telse\n> >  \t\t\tpackedDate[0] = 0;\n> >\n> > -\t\tpackedDate[0] |= htonl(commit_graph_data_at(*list)->generation << 2);\n> > +\t\tpackedDate[0] |= htonl(*topo_level_slab_at(ctx->topo_levels, *list) << 2);\n> \n> All right, here we prepare for writing to the CDAT chunk using data that\n> is now stored on newly introduced topo_levels slab (either computed, or\n> taken from commit-graph file being rewritten).\n> \n> Assuming that ctx->topo_levels is not-null, and that the values are\n> properly calculated before this -- and we did compute topological levels\n> before writing the commit-graph.\n> \n> >\n> >  \t\tpackedDate[1] = htonl((*list)->date);\n> >  \t\thashwrite(f, packedDate, 8);\n> > @@ -1335,11 +1341,11 @@ static void compute_generation_numbers(struct write_commit_graph_context *ctx)\n> >  \t\t\t\t\t_(""Computing commit graph generation numbers""),\n> >  \t\t\t\t\tctx->commits.nr);\n> >  \tfor (i = 0; i < ctx->commits.nr; i++) {\n> > -\t\tuint32_t generation = commit_graph_data_at(ctx->commits.list[i])->generation;\n> > +\t\tuint32_t level = *topo_level_slab_at(ctx->topo_levels, ctx->commits.list[i]);\n> \n> All right, so that is why this \'generation\' variable was not converted\n> to timestamp_t type.\n> \n> >\n> >  \t\tdisplay_progress(ctx->progress, i + 1);\n> > -\t\tif (generation != GENERATION_NUMBER_V1_INFINITY &&\n> > -\t\t    generation != GENERATION_NUMBER_ZERO)\n> > +\t\tif (level != GENERATION_NUMBER_V1_INFINITY &&\n> > +\t\t    level != GENERATION_NUMBER_ZERO)\n> >  \t\t\tcontinue;\n> \n> Here we use GENERATION_NUMBER*_INFINITY to check if the commit is\n> outside commit-graph files, and therefore we would need its topological\n> level computed.\n> \n> However, I don\'t understand how it works.  We have had created the\n> commit_graph_data_at() and use it instead of commit_graph_data_slab_at()\n> to provide default values for `struct commit_graph`... but only for\n> `graph_pos` member.  It is commit_graph_generation() that returns\n> GENERATION_NUMBER_INFINITY for commits not in graph.\n> \n> But neither commit_graph_data_at()->generation nor topo_level_slab_at()\n> handles this special case, so I don\'t see how \'generation\' variable can\n> *ever* be GENERATION_NUMBER_INFINITY, and \'level\' variable can ever be\n> GENERATION_NUMBER_V1_INFINITY for commits not in graph.\n> \n> Does it work *accidentally*, because the default value for uninitialized\n> data on commit-slab is 0, which matches GENERATION_NUMBER_ZERO?  It\n> certainly looks like it does.  And GENERATION_NUMBER_ZERO is an artifact\n> of commit-graph feature development history, namely the short time where\n> Git didn\'t use any generation numbers and stored 0 in the place set for\n> it in the commit-graph format...  On the other hand this is not the case\n> for corrected commit date (generation number v2), as it could\n> ""legitimately"" be 0 if some root commit (without any parents) had\n> committerdate of epoch 0, i.e. 1 January 1970 00:00:00 UTC, perhaps\n> caused by malformed but valid commit object.\n> \n> Ugh...\n\nIt works accidentally.\n\nOur decision to avoid the cost of initializing both\ncommit_graph_data->generation and commit_graph_data->graph_pos has\nled to some unwieldy choices - the complexity of helper functions,\nbypassing helper functions when writing a commit-graph file [1].\n\nI want to re-visit how commit_graph_data slab is defined in a future series.\n\n[1]: https://lore.kernel.org/git/be28ab7b-0ae4-2cc5-7f2b-92075de3723a@gmail.com/\n\n> \n> >\n> >  \t\tcommit_list_insert(ctx->commits.list[i], &list);\n> > @@ -1347,29 +1353,27 @@ static void compute_generation_numbers(struct write_commit_graph_context *ctx)\n> >  \t\t\tstruct commit *current = list->item;\n> >  \t\t\tstruct commit_list *parent;\n> >  \t\t\tint all_parents_computed = 1;\n> > -\t\t\tuint32_t max_generation = 0;\n> > +\t\t\tuint32_t max_level = 0;\n> >\n> >  \t\t\tfor (parent = current->parents; parent; parent = parent->next) {\n> > -\t\t\t\tgeneration = commit_graph_data_at(parent->item)->generation;\n> > +\t\t\t\tlevel = *topo_level_slab_at(ctx->topo_levels, parent->item);\n> >\n> > -\t\t\t\tif (generation == GENERATION_NUMBER_V1_INFINITY ||\n> > -\t\t\t\t    generation == GENERATION_NUMBER_ZERO) {\n> > +\t\t\t\tif (level == GENERATION_NUMBER_V1_INFINITY ||\n> > +\t\t\t\t    level == GENERATION_NUMBER_ZERO) {\n> >  \t\t\t\t\tall_parents_computed = 0;\n> >  \t\t\t\t\tcommit_list_insert(parent->item, &list);\n> >  \t\t\t\t\tbreak;\n> > -\t\t\t\t} else if (generation > max_generation) {\n> > -\t\t\t\t\tmax_generation = generation;\n> > +\t\t\t\t} else if (level > max_level) {\n> > +\t\t\t\t\tmax_level = level;\n> >  \t\t\t\t}\n> >  \t\t\t}\n> \n> This is the same case as for previous chunk; see the comment above.\n> \n> This code checks if parents have generation number / topological level\n> computed, and tracks maximum value of it among all parents.\n> \n> >\n> >  \t\t\tif (all_parents_computed) {\n> > -\t\t\t\tstruct commit_graph_data *data = commit_graph_data_at(current);\n> > -\n> > -\t\t\t\tdata->generation = max_generation + 1;\n> >  \t\t\t\tpop_commit(&list);\n> >\n> > -\t\t\t\tif (data->generation > GENERATION_NUMBER_MAX)\n> > -\t\t\t\t\tdata->generation = GENERATION_NUMBER_MAX;\n> > +\t\t\t\tif (max_level > GENERATION_NUMBER_MAX - 1)\n> > +\t\t\t\t\tmax_level = GENERATION_NUMBER_MAX - 1;\n> > +\t\t\t\t*topo_level_slab_at(ctx->topo_levels, current) = max_level + 1;\n> \n> OK, this is safer way of handling GENERATION_NUMBER*_MAX, especially if\n> this value can be maximum value that can be safely stored in a given\n> data type.  Previously GENERATION_NUMBER_MAX was smaller than maximum\n> value that can be safely stored in uint32_t, so generation+1 had no\n> chance to overflow.  This is no longer the case; the reorganization done\n> here leads to more defensive code (safer).\n> \n> All good.  However I think that we should clamp the value of topological\n> level to the maximum value that can be safely stored *on disk*, in the\n> 30 bits of the CDAT chunk reserved for generation number v1.  Otherwise\n> the code to write topological level would get more complicated.\n> \n> In my opinion the symbolic constant used here should be named\n> GENERATION_NUMBER_V1_MAX, and its value should be at most (2 ^ 30 - 1);\n> it should be the current value of GENERATION_NUMBER_MAX, that is\n> 0x3FFFFFFF.\n> \n> >  \t\t\t}\n> >  \t\t}\n> >  \t}\n> > @@ -2101,6 +2105,7 @@ int write_commit_graph(struct object_directory *odb,\n> >  \tuint32_t i, count_distinct = 0;\n> >  \tint res = 0;\n> >  \tint replace = 0;\n> > +\tstruct topo_level_slab topo_levels;\n> >\n> \n> All right, we will be using topo_level slab for writing the\n> commit-graph, and only for this purpose, so it is good to put it here.\n> \n> >  \tif (!commit_graph_compatible(the_repository))\n> >  \t\treturn 0;\n> > @@ -2179,6 +2184,18 @@ int write_commit_graph(struct object_directory *odb,\n> >  \t\t}\n> >  \t}\n> >\n> > +\tinit_topo_level_slab(&topo_levels);\n> > +\tctx->topo_levels = &topo_levels;\n> > +\n> > +\tif (ctx->r->objects->commit_graph) {\n> > +\t\tstruct commit_graph *g = ctx->r->objects->commit_graph;\n> > +\n> > +\t\twhile (g) {\n> > +\t\t\tg->topo_levels = &topo_levels;\n> > +\t\t\tg = g->base_graph;\n> > +\t\t}\n> > +\t}\n> \n> All right, now I see why we need `topo_levels` member both in the\n> `struct write_commit_graph_context` and in `struct commit_graph`.\n> The former is for functions that write the commit-graph, the latter for\n> fill_commit_graph_info() functions that is deep in the callstack, but it\n> needs to know whether to load topological level to commit-slab, or maybe\n> put it as generation number (and in the future -- discard it, if not\n> needed).\n> \n> \n> Sidenote: this fragment of code, that fills with a given value some\n> member of the `struct commit_graph` throughout the split commit-graph\n> chain, will be repeated as similar code in patches later in series.\n> However without resorting to preprocessor macros I have no idea how to\n> generalize it to avoid code duplication (well, almost).\n> \n\nThe pattern is: iterate over the commit-graph chain and assign a member\n(here, topo_level and in the other patch, read_generation_data) a value\n(the address of topo_level slab, 1/0 depending on whether it is a mixed\ngeneration chain).\n\nWe could generalize this in a future series but I don\'t think it is\nworthwhile.\n\n> > +\n> >  \tif (pack_indexes) {\n> >  \t\tctx->order_by_pack = 1;\n> >  \t\tif ((res = fill_oids_from_packs(ctx, pack_indexes)))\n> > diff --git a/commit-graph.h b/commit-graph.h\n> > index 430bc830bb..1152a9642e 100644\n> > --- a/commit-graph.h\n> > +++ b/commit-graph.h\n> > @@ -72,6 +72,7 @@ struct commit_graph {\n> >  \tconst unsigned char *chunk_bloom_indexes;\n> >  \tconst unsigned char *chunk_bloom_data;\n> >\n> > +\tstruct topo_level_slab *topo_levels;\n> >  \tstruct bloom_filter_settings *bloom_filter_settings;\n> >  };\n> \n> All right: `struct commit_graph` is public, `struct\n> write_commit_graph_context` is not.\n> \n> >\n> > diff --git a/commit.h b/commit.h\n> > index bc0732a4fe..bb846e0025 100644\n> > --- a/commit.h\n> > +++ b/commit.h\n> > @@ -15,6 +15,7 @@\n> >  #define GENERATION_NUMBER_V1_INFINITY 0xFFFFFFFF\n> >  #define GENERATION_NUMBER_MAX 0x3FFFFFFF\n> \n> The name GENERATION_NUMBER_MAX for 0x3FFFFFFF should be instead\n> GENERATION_NUMBER_V1_MAX, but that may be done in a later commit.\n> \n> >  #define GENERATION_NUMBER_ZERO 0\n> > +#define GENERATION_NUMBER_V2_OFFSET_MAX 0xFFFFFFFF\n> \n> This value is never used, so why it is defined in this commit.\n> \n\nMoved down to the patch actually uses it.\n\n> >\n> >  struct commit_list {\n> >  \tstruct commit *item;\n> \n> Best,\n> -- \n> Jakub Narębski\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 25, 6, 19, 19, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 476218018, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/20200825064954.GA645690@Abhishek-Arch), Abhishek Kumar wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Sat, Aug 22, 2020 at 02:05:41AM +0200, Jakub Narębski wrote:\n> ""Abhishek Kumar via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n> \n> > From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> >\n> > With most of preparations done, let\'s implement corrected commit date.\n> >\n> > The corrected commit date for a commit is defined as:\n> >\n> > * A commit with no parents (a root commit) has corrected commit date\n> >   equal to its committer date.\n> > * A commit with at least one parent has corrected commit date equal to\n> >   the maximum of its commit date and one more than the largest corrected\n> >   commit date among its parents.\n> \n> Good.\n> \n> >\n> > To minimize the space required to store corrected commit date, Git\n> > stores corrected commit date offsets into the commit-graph file. The\n> > corrected commit date offset for a commit is defined as the difference\n> > between its corrected commit date and actual commit date.\n> \n> Perhaps we should add more details about data type sizes in question.\n\nWill add.\n\n> \n> Storing corrected commit date requires sizeof(timestamp_t) bytes, which\n> in most cases is 64 bits (uintmax_t).  However corrected commit date\n> offsets can be safely stored^* using only 32 bits.  This halves the size\n> of GDAT chunk, reducing per-commit storage from 2*H + 16 + 8 bytes to\n> 2*H + 16 + 4 bytes, which is reduction of around 6%, not including\n> header, fanout table (OIDF) and extra edges list (EDGE).\n> \n> Which might mean that the extra complication is not worth it, and we\n> should store corrected commit date directly instead.\n> \n> *) unless for example one of commits is malformed but valid,\n>    and has committerdate of 0 Unix time, 1 January 1970.\n> \n> >\n> > While Git does not write out offsets at this stage, Git stores the\n> > corrected commit dates in member generation of struct commit_graph_data.\n> > It will begin writing commit date offsets with the introduction of\n> > generation data chunk.\n> \n> OK, so the agenda for introducing geeration number v2 is as follows:\n> - compute generation numbers v2, i.e. corrected commit date\n> - store corrected commit date [offsets] in new GDAT chunk,\n>   unless backward-compatibility concerns require us to not to\n> - load [and compute] corrected commit date from commit-graph\n>   storing it as \'generation\' field of `struct commit_graph_data`,\n>   unless backward-compatibility concerns require us to store\n>   topological levels (generation number v1) in there instead\n> \n\nThe last point is not correct. We always store topological levels into\nthe topo_levels slab introduced and always store corrected commit date\ninto data->generation, regardless of backward compatibility concerns.\n\nWe could avoid initializing topo_slab if we are not writing generation\ndata chunk (and thus don\'t need corrected commit dates) but that\nwouldn\'t have an impact on run time while writing commit-graph because\ncomputing corrected commit dates is cheap as the main cost is in walking\nthe graph and writing the file.\n\n> Because the reachability condition for corrected commit date and for\n> topological level is exactly the same, we don\'t need to do anything to\n> take advantage of generation number v2.\n> \n> Though we can use generation number v2 in more cases, where we turned\n> off use of generation numbers because v1 gave worse performance than\n> date heuristics.\n> \n> Did I got this right?\n> \n> >\n> > Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> > ---\n> >  commit-graph.c | 58 +++++++++++++++++++++++++++-----------------------\n> >  1 file changed, 31 insertions(+), 27 deletions(-)\n> >\n> > diff --git a/commit-graph.c b/commit-graph.c\n> > index a2f15b2825..fd69534dd5 100644\n> > --- a/commit-graph.c\n> > +++ b/commit-graph.c\n> > @@ -169,11 +169,6 @@ static int commit_gen_cmp(const void *va, const void *vb)\n> >  \telse if (generation_a > generation_b)\n> >  \t\treturn 1;\n> >\n> > -\t/* use date as a heuristic when generations are equal */\n> > -\tif (a->date < b->date)\n> > -\t\treturn -1;\n> > -\telse if (a->date > b->date)\n> > -\t\treturn 1;\n> \n> At first I was wondering why this tie-breaking is beig removed; wouldn\'t\n> be needed for backward-compatibility?  But then I remembered that this\n> comparison function is used _only_ for sorting commits when writing\n> Bloom filters, for `git commit-graph write --reachable --changed-paths ...`\n> \n> Assuming that when writing the commit graph we always compute geeration\n> number v2 and \'generation\' field stores corrected commit date, we don\'t\n> need to use date as a heuristic when generations are equal, and it would\n> not help in tie-breaking anyway.\n> \n> All right.\n> \n> >  \treturn 0;\n> >  }\n> >\n> > @@ -1342,10 +1337,14 @@ static void compute_generation_numbers(struct write_commit_graph_context *ctx)\n> >  \t\t\t\t\tctx->commits.nr);\n> >  \tfor (i = 0; i < ctx->commits.nr; i++) {\n> >  \t\tuint32_t level = *topo_level_slab_at(ctx->topo_levels, ctx->commits.list[i]);\n> > +\t\ttimestamp_t corrected_commit_date = commit_graph_data_at(ctx->commits.list[i])->generation;\n> \n> All right, so the pattern is to add \'corrected_commit_date\' stuff after\n> \'topological_level\' stuff.\n> \n> >\n> >  \t\tdisplay_progress(ctx->progress, i + 1);\n> >  \t\tif (level != GENERATION_NUMBER_V1_INFINITY &&\n> > -\t\t    level != GENERATION_NUMBER_ZERO)\n> > +\t\t    level != GENERATION_NUMBER_ZERO &&\n> > +\t\t    corrected_commit_date != GENERATION_NUMBER_INFINITY &&\n> > +\t\t    corrected_commit_date != GENERATION_NUMBER_ZERO\n> > +\t\t    )\n> >  \t\t\tcontinue;\n> >\n> >  \t\tcommit_list_insert(ctx->commits.list[i], &list);\n> > @@ -1354,17 +1353,26 @@ static void compute_generation_numbers(struct write_commit_graph_context *ctx)\n> >  \t\t\tstruct commit_list *parent;\n> >  \t\t\tint all_parents_computed = 1;\n> >  \t\t\tuint32_t max_level = 0;\n> > +\t\t\ttimestamp_t max_corrected_commit_date = 0;\n> >\n> >  \t\t\tfor (parent = current->parents; parent; parent = parent->next) {\n> >  \t\t\t\tlevel = *topo_level_slab_at(ctx->topo_levels, parent->item);\n> > +\t\t\t\tcorrected_commit_date = commit_graph_data_at(parent->item)->generation;\n> >\n> >  \t\t\t\tif (level == GENERATION_NUMBER_V1_INFINITY ||\n> > -\t\t\t\t    level == GENERATION_NUMBER_ZERO) {\n> > +\t\t\t\t    level == GENERATION_NUMBER_ZERO ||\n> > +\t\t\t\t    corrected_commit_date == GENERATION_NUMBER_INFINITY ||\n> > +\t\t\t\t    corrected_commit_date == GENERATION_NUMBER_ZERO\n> > +\t\t\t\t    ) {\n> >  \t\t\t\t\tall_parents_computed = 0;\n> >  \t\t\t\t\tcommit_list_insert(parent->item, &list);\n> >  \t\t\t\t\tbreak;\n> > -\t\t\t\t} else if (level > max_level) {\n> > -\t\t\t\t\tmax_level = level;\n> > +\t\t\t\t} else {\n> > +\t\t\t\t\tif (level > max_level)\n> > +\t\t\t\t\t\tmax_level = level;\n> > +\n> > +\t\t\t\t\tif (corrected_commit_date > max_corrected_commit_date)\n> > +\t\t\t\t\t\tmax_corrected_commit_date = corrected_commit_date;\n> >  \t\t\t\t}\n> >  \t\t\t}\n> >\n> > @@ -1374,6 +1382,10 @@ static void compute_generation_numbers(struct write_commit_graph_context *ctx)\n> >  \t\t\t\tif (max_level > GENERATION_NUMBER_MAX - 1)\n> >  \t\t\t\t\tmax_level = GENERATION_NUMBER_MAX - 1;\n> >  \t\t\t\t*topo_level_slab_at(ctx->topo_levels, current) = max_level + 1;\n> > +\n> > +\t\t\t\tif (current->date > max_corrected_commit_date)\n> > +\t\t\t\t\tmax_corrected_commit_date = current->date - 1;\n> > +\t\t\t\tcommit_graph_data_at(current)->generation = max_corrected_commit_date + 1;\n> >  \t\t\t}\n> >  \t\t}\n> >  \t}\n> \n> All right.  Looks good to me.\n> \n> > @@ -2372,8 +2384,8 @@ int verify_commit_graph(struct repository *r, struct commit_graph *g, int flags)\n> >  \tfor (i = 0; i < g->num_commits; i++) {\n> >  \t\tstruct commit *graph_commit, *odb_commit;\n> >  \t\tstruct commit_list *graph_parents, *odb_parents;\n> > -\t\ttimestamp_t max_generation = 0;\n> > -\t\ttimestamp_t generation;\n> > +\t\ttimestamp_t max_corrected_commit_date = 0;\n> > +\t\ttimestamp_t corrected_commit_date;\n> \n> This is simple, and perhaps unnecessary, rename of variables.\n> Shouldn\'t we however verify *both* topological level, and\n> (if exists) corrected commit date?\n\nThe problem with verifying both topological level and corrected commit\ndates is that we would have to re-fill commit_graph_data slab with commit\ndata chunk as we cannot modify data->generation otherwise, essentially\nrepeating the whole verification process.\n\nWhile it\'s okay for now, I might take this up in a future series [1].\n\n[1]: https://lore.kernel.org/git/4043ffbc-84df-0cd6-5c75-af80383a56cf@gmail.com/\n\n> \n> >\n> >  \t\tdisplay_progress(progress, i + 1);\n> >  \t\thashcpy(cur_oid.hash, g->chunk_oid_lookup + g->hash_len * i);\n> > @@ -2412,9 +2424,9 @@ int verify_commit_graph(struct repository *r, struct commit_graph *g, int flags)\n> >  \t\t\t\t\t     oid_to_hex(&graph_parents->item->object.oid),\n> >  \t\t\t\t\t     oid_to_hex(&odb_parents->item->object.oid));\n> >\n> > -\t\t\tgeneration = commit_graph_generation(graph_parents->item);\n> > -\t\t\tif (generation > max_generation)\n> > -\t\t\t\tmax_generation = generation;\n> > +\t\t\tcorrected_commit_date = commit_graph_generation(graph_parents->item);\n> > +\t\t\tif (corrected_commit_date > max_corrected_commit_date)\n> > +\t\t\t\tmax_corrected_commit_date = corrected_commit_date;\n> \n> Actually, commit_graph_generation(<commit>) can return either corrected\n> commit date, or topological level, the latter in backward-compatibility\n> case (if at least one commit-graph file is lacking GDAT chunk, because\n> [some of] it was created by the ""Old"" Git).\n> \n> >\n> >  \t\t\tgraph_parents = graph_parents->next;\n> >  \t\t\todb_parents = odb_parents->next;\n> > @@ -2436,20 +2448,12 @@ int verify_commit_graph(struct repository *r, struct commit_graph *g, int flags)\n> >  \t\tif (generation_zero == GENERATION_ZERO_EXISTS)\n> >  \t\t\tcontinue;\n> >\n> > -\t\t/*\n> > -\t\t * If one of our parents has generation GENERATION_NUMBER_MAX, then\n> > -\t\t * our generation is also GENERATION_NUMBER_MAX. Decrement to avoid\n> > -\t\t * extra logic in the following condition.\n> > -\t\t */\n> > -\t\tif (max_generation == GENERATION_NUMBER_MAX)\n> > -\t\t\tmax_generation--;\n> \n> All right, this was needed for checking the correctness of topological\n> levels (generation number v1) because we were checking not that it\n> fullfills the reachability condition, but more strict one: namely that\n> topological level of commit is equal to maximum of topological levels of\n> its parents plus one.\n> \n> The comment about checking both generation number v1 and v2 still\n> applies.\n> \n> > -\n> > -\t\tgeneration = commit_graph_generation(graph_commit);\n> > -\t\tif (generation != max_generation + 1)\n> > -\t\t\tgraph_report(_(""commit-graph generation for commit %s is %u != %u""),\n> > +\t\tcorrected_commit_date = commit_graph_generation(graph_commit);\n> > +\t\tif (corrected_commit_date < max_corrected_commit_date + 1)\n> > +\t\t\tgraph_report(_(""commit-graph generation for commit %s is %""PRItime"" < %""PRItime),\n> >  \t\t\t\t     oid_to_hex(&cur_oid),\n> > -\t\t\t\t     generation,\n> > -\t\t\t\t     max_generation + 1);\n> > +\t\t\t\t     corrected_commit_date,\n> > +\t\t\t\t     max_corrected_commit_date + 1);\n> \n> All right, we check less strict condition for corrected commit date.\n> \n> >\n> >  \t\tif (graph_commit->date != odb_commit->date)\n> >  \t\t\tgraph_report(_(""commit date for commit %s in commit-graph is %""PRItime"" != %""PRItime),\n> \n> Best,\n> -- \n> Jakub Narębski\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 25, 6, 55, 23, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 476239601, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/855z97dvsp.fsf@gmail.com), jnareb@gmail.com (Jakub Narębski) wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nHello,\n\nAbhishek Kumar <abhishekkumar8222@gmail.com> writes:\n> On Fri, Aug 21, 2020 at 08:43:38PM +0200, Jakub Narębski wrote:\n>> ""Abhishek Kumar via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n>>\n>>> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n[...]\n>>> @@ -1335,11 +1341,11 @@ static void compute_generation_numbers(struct write_commit_graph_context *ctx)\n>>>  \t\t\t\t\t_(""Computing commit graph generation numbers""),\n>>>  \t\t\t\t\tctx->commits.nr);\n>>>  \tfor (i = 0; i < ctx->commits.nr; i++) {\n>>> -\t\tuint32_t generation = commit_graph_data_at(ctx->commits.list[i])->generation;\n>>> +\t\tuint32_t level = *topo_level_slab_at(ctx->topo_levels, ctx->commits.list[i]);\n>>\n>> All right, so that is why this \'generation\' variable was not converted\n>> to timestamp_t type.\n>>\n>>>\n>>>  \t\tdisplay_progress(ctx->progress, i + 1);\n>>> -\t\tif (generation != GENERATION_NUMBER_V1_INFINITY &&\n>>> -\t\t    generation != GENERATION_NUMBER_ZERO)\n>>> +\t\tif (level != GENERATION_NUMBER_V1_INFINITY &&\n>>> +\t\t    level != GENERATION_NUMBER_ZERO)\n>>>  \t\t\tcontinue;\n>>\n>> Here we use GENERATION_NUMBER*_INFINITY to check if the commit is\n>> outside commit-graph files, and therefore we would need its topological\n>> level computed.\n>>\n>> However, I don\'t understand how it works.  We have had created the\n>> commit_graph_data_at() and use it instead of commit_graph_data_slab_at()\n>> to provide default values for `struct commit_graph`... but only for\n>> `graph_pos` member.  It is commit_graph_generation() that returns\n>> GENERATION_NUMBER_INFINITY for commits not in graph.\n>>\n>> But neither commit_graph_data_at()->generation nor topo_level_slab_at()\n>> handles this special case, so I don\'t see how \'generation\' variable can\n>> *ever* be GENERATION_NUMBER_INFINITY, and \'level\' variable can ever be\n>> GENERATION_NUMBER_V1_INFINITY for commits not in graph.\n>>\n>> Does it work *accidentally*, because the default value for uninitialized\n>> data on commit-slab is 0, which matches GENERATION_NUMBER_ZERO?  It\n>> certainly looks like it does.  And GENERATION_NUMBER_ZERO is an artifact\n>> of commit-graph feature development history, namely the short time where\n>> Git didn\'t use any generation numbers and stored 0 in the place set for\n>> it in the commit-graph format...  On the other hand this is not the case\n>> for corrected commit date (generation number v2), as it could\n>> ""legitimately"" be 0 if some root commit (without any parents) had\n>> committerdate of epoch 0, i.e. 1 January 1970 00:00:00 UTC, perhaps\n>> caused by malformed but valid commit object.\n>>\n>> Ugh...\n>\n> It works accidentally.\n>\n> Our decision to avoid the cost of initializing both\n> commit_graph_data->generation and commit_graph_data->graph_pos has\n> led to some unwieldy choices - the complexity of helper functions,\n> bypassing helper functions when writing a commit-graph file [1].\n>\n> I want to re-visit how commit_graph_data slab is defined in a future series.\n>\n> [1]: https://lore.kernel.org/git/be28ab7b-0ae4-2cc5-7f2b-92075de3723a@gmail.com/\n\nAll right, we might want to make use of the fact that the value of 0 for\ntopological level here always mean that its value for a commit needs to\nbe computed, that 0 is not a valid value for topological levels.\n- if the value 0 came from commit-graph file, it means that it came\n  from Git version that used commit-graph but didn\'t compute generation\n  numbers; the value is GENERATION_NUMBER_ZERO\n- the value 0 might came from the fact that commit is not in graph,\n  and that commit-slab zero-initializes the values stored; let\'s\n  call this value GENERATION_NUMBER_UNINITIALIZED\n\nIf we ensure that corrected commit date can never be zero (which is\nextremely unlikely, as one of root commits would have to be malformed or\nwritten on badly misconfigured computer, with value of 0 for committer\ntimestamp), then this ""happy accident"" can keep working.\n\n  As a special case, commit date with timestamp of zero (01.01.1970 00:00:00Z)\n  has corrected commit date of one, to be able to distinguish\n  uninitialized values.\n\nOr something like that.\n\nActually, it is not even necessary, as corrected commit date of 0 just\nmeans that this single value (well, for every root commit with commit\ndate of 0) would be unnecessary recomputed in compute_generation_numbers().\n\nAnyway, we would want to document this fact in the commit message.\n\nBest,\n-- \nJakub Narębski\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 25, 7, 37, 22, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 476251853, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/CANQwDwdsV0mSos7M_d7UP1CjT1rCyA_GfaYarMKUZaFdDZ0WRg@mail.gmail.com), Jakub Narębski wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Tue, 25 Aug 2020 at 09:33, Jakub Narębski <jnareb@gmail.com> wrote:\n> Abhishek Kumar <abhishekkumar8222@gmail.com> writes:\n> > On Fri, Aug 21, 2020 at 08:43:38PM +0200, Jakub Narębski wrote:\n> >> ""Abhishek Kumar via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n> >>\n> >>> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> [...]\n> >>> @@ -1335,11 +1341,11 @@ static void compute_generation_numbers(struct write_commit_graph_context *ctx)\n> >>>                                     _(""Computing commit graph generation numbers""),\n> >>>                                     ctx->commits.nr);\n> >>>     for (i = 0; i < ctx->commits.nr; i++) {\n> >>> -           uint32_t generation = commit_graph_data_at(ctx->commits.list[i])->generation;\n> >>> +           uint32_t level = *topo_level_slab_at(ctx->topo_levels, ctx->commits.list[i]);\n> >>\n> >> All right, so that is why this \'generation\' variable was not converted\n> >> to timestamp_t type.\n> >>\n> >>>\n> >>>             display_progress(ctx->progress, i + 1);\n> >>> -           if (generation != GENERATION_NUMBER_V1_INFINITY &&\n> >>> -               generation != GENERATION_NUMBER_ZERO)\n> >>> +           if (level != GENERATION_NUMBER_V1_INFINITY &&\n> >>> +               level != GENERATION_NUMBER_ZERO)\n> >>>                     continue;\n> >>\n> >> Here we use GENERATION_NUMBER*_INFINITY to check if the commit is\n> >> outside commit-graph files, and therefore we would need its topological\n> >> level computed.\n> >>\n> >> However, I don\'t understand how it works.  We have had created the\n> >> commit_graph_data_at() and use it instead of commit_graph_data_slab_at()\n> >> to provide default values for `struct commit_graph`... but only for\n> >> `graph_pos` member.  It is commit_graph_generation() that returns\n> >> GENERATION_NUMBER_INFINITY for commits not in graph.\n> >>\n> >> But neither commit_graph_data_at()->generation nor topo_level_slab_at()\n> >> handles this special case, so I don\'t see how \'generation\' variable can\n> >> *ever* be GENERATION_NUMBER_INFINITY, and \'level\' variable can ever be\n> >> GENERATION_NUMBER_V1_INFINITY for commits not in graph.\n> >>\n> >> Does it work *accidentally*, because the default value for uninitialized\n> >> data on commit-slab is 0, which matches GENERATION_NUMBER_ZERO?  It\n> >> certainly looks like it does.  And GENERATION_NUMBER_ZERO is an artifact\n> >> of commit-graph feature development history, namely the short time where\n> >> Git didn\'t use any generation numbers and stored 0 in the place set for\n> >> it in the commit-graph format...  On the other hand this is not the case\n> >> for corrected commit date (generation number v2), as it could\n> >> ""legitimately"" be 0 if some root commit (without any parents) had\n> >> committerdate of epoch 0, i.e. 1 January 1970 00:00:00 UTC, perhaps\n> >> caused by malformed but valid commit object.\n> >>\n> >> Ugh...\n> >\n> > It works accidentally.\n> >\n> > Our decision to avoid the cost of initializing both\n> > commit_graph_data->generation and commit_graph_data->graph_pos has\n> > led to some unwieldy choices - the complexity of helper functions,\n> > bypassing helper functions when writing a commit-graph file [1].\n> >\n> > I want to re-visit how commit_graph_data slab is defined in a future series.\n> >\n> > [1]: https://lore.kernel.org/git/be28ab7b-0ae4-2cc5-7f2b-92075de3723a@gmail.com/\n>\n> All right, we might want to make use of the fact that the value of 0 for\n> topological level here always mean that its value for a commit needs to\n> be computed, that 0 is not a valid value for topological levels.\n> - if the value 0 came from commit-graph file, it means that it came\n>   from Git version that used commit-graph but didn\'t compute generation\n>   numbers; the value is GENERATION_NUMBER_ZERO\n> - the value 0 might came from the fact that commit is not in graph,\n>   and that commit-slab zero-initializes the values stored; let\'s\n>   call this value GENERATION_NUMBER_UNINITIALIZED\n>\n> If we ensure that corrected commit date can never be zero (which is\n> extremely unlikely, as one of root commits would have to be malformed or\n> written on badly misconfigured computer, with value of 0 for committer\n> timestamp), then this ""happy accident"" can keep working.\n>\n>   As a special case, commit date with timestamp of zero (01.01.1970 00:00:00Z)\n>   has corrected commit date of one, to be able to distinguish\n>   uninitialized values.\n>\n> Or something like that.\n>\n> Actually, it is not even necessary, as corrected commit date of 0 just\n> means that this single value (well, for every root commit with commit\n> date of 0) would be unnecessary recomputed in compute_generation_numbers().\n>\n> Anyway, we would want to document this fact in the commit message.\n\nAlternatively, instead of comparing \'level\' (and later in series also\n\'corrected_commit_date\') against GENERATION_NUMBER_INFINITY,\nwe could load at no extra cost `graph_pos` value and compare it\nagainst COMMIT_NOT_FROM_GRAPH.\n\nBut with this solution we could never get rid of graph_pos, if we\nthink it is unnecessary. If we split commit_graph_data into separate\nslabs (as it was in early versions of respective patch series), we\nwould have to pay additional cost.\n\nBut it is an alternative.\n\nBest,\n-- \nJakub Narębski\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 25, 7, 58, 23, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 476335972, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/85wo1nca3u.fsf@gmail.com), jnareb@gmail.com (Jakub Narębski) wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nHello,\n\nAbhishek Kumar <abhishekkumar8222@gmail.com> writes:\n> On Sat, Aug 22, 2020 at 02:05:41AM +0200, Jakub Narębski wrote:\n>> ""Abhishek Kumar via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n>>\n>>> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n[...]\n>>> To minimize the space required to store corrected commit date, Git\n>>> stores corrected commit date offsets into the commit-graph file. The\n>>> corrected commit date offset for a commit is defined as the difference\n>>> between its corrected commit date and actual commit date.\n>>\n>> Perhaps we should add more details about data type sizes in question.\n>\n> Will add.\n\nNote however that we need to solve the problem of storing values which\nare not monotonic wrt. parent relation (partial order) in limited disk\nspace, that is GENERATION_NUMBER_V2_OFFSET_MAX vs GENERATION_NUMBER_MAX;\nsee comments in 11/11 and 00/11.\n\n>>\n>> Storing corrected commit date requires sizeof(timestamp_t) bytes, which\n>> in most cases is 64 bits (uintmax_t).  However corrected commit date\n>> offsets can be safely stored^* using only 32 bits.  This halves the size\n>> of GDAT chunk, reducing per-commit storage from 2*H + 16 + 8 bytes to\n>> 2*H + 16 + 4 bytes, which is reduction of around 6%, not including\n>> header, fanout table (OIDF) and extra edges list (EDGE).\n>>\n>> Which might mean that the extra complication is not worth it, and we\n>> should store corrected commit date directly instead.\n>>\n>> *) unless for example one of commits is malformed but valid,\n>>    and has committerdate of 0 Unix time, 1 January 1970.\n\nSee above.\n\n>>> While Git does not write out offsets at this stage, Git stores the\n>>> corrected commit dates in member generation of struct commit_graph_data.\n>>> It will begin writing commit date offsets with the introduction of\n>>> generation data chunk.\n>>\n>> OK, so the agenda for introducing geeration number v2 is as follows:\n>> - compute generation numbers v2, i.e. corrected commit date\n>> - store corrected commit date [offsets] in new GDAT chunk,\n>>   unless backward-compatibility concerns require us to not to\n>> - load [and compute] corrected commit date from commit-graph\n>>   storing it as \'generation\' field of `struct commit_graph_data`,\n>>   unless backward-compatibility concerns require us to store\n>>   topological levels (generation number v1) in there instead\n>>\n>\n> The last point is not correct. We always store topological levels into\n> the topo_levels slab introduced and always store corrected commit date\n> into data->generation, regardless of backward compatibility concerns.\n\nI think I was not clear enough (in trying to be brief).  I meant here\nloading available generation numbers for use in graph traversal,\ndone in later patches in this series.\n\nIn _next_ commit we store topological levels in `generation` field:\n\n  @@ -755,7 +763,11 @@ static void fill_commit_graph_info(struct commit *item, struct commit_graph *g,\n   \tdate_low = get_be32(commit_data + g->hash_len + 12);\n   \titem->date = (timestamp_t)((date_high << 32) | date_low);\n\n  -\tgraph_data->generation = get_be32(commit_data + g->hash_len + 8) >> 2;\n  +\tif (g->chunk_generation_data)\n  +\t\tgraph_data->generation = item->date +\n  +\t\t\t(timestamp_t) get_be32(g->chunk_generation_data + sizeof(uint32_t) * lex_index);\n  +\telse\n  +\t\tgraph_data->generation = get_be32(commit_data + g->hash_len + 8) >> 2;\n\n\nWe use topo_level slab only when writing the commit-graph file.\n\n> We could avoid initializing topo_slab if we are not writing generation\n> data chunk (and thus don\'t need corrected commit dates) but that\n> wouldn\'t have an impact on run time while writing commit-graph because\n> computing corrected commit dates is cheap as the main cost is in walking\n> the graph and writing the file.\n\nRight.\n\nThough you need to add the cost of allocation and managing extra\ncommit slab, I think that amortized cost is negligible.\n\nBut what would be better is showing benchmark data: does writing the\ncommit graph without GDAT take not insigificant more time than without\nthis patch?\n\n[...]\n>>> @@ -2372,8 +2384,8 @@ int verify_commit_graph(struct repository *r, struct commit_graph *g, int flags)\n>>>  \tfor (i = 0; i < g->num_commits; i++) {\n>>>  \t\tstruct commit *graph_commit, *odb_commit;\n>>>  \t\tstruct commit_list *graph_parents, *odb_parents;\n>>> -\t\ttimestamp_t max_generation = 0;\n>>> -\t\ttimestamp_t generation;\n>>> +\t\ttimestamp_t max_corrected_commit_date = 0;\n>>> +\t\ttimestamp_t corrected_commit_date;\n>>\n>> This is simple, and perhaps unnecessary, rename of variables.\n>> Shouldn\'t we however verify *both* topological level, and\n>> (if exists) corrected commit date?\n>\n> The problem with verifying both topological level and corrected commit\n> dates is that we would have to re-fill commit_graph_data slab with commit\n> data chunk as we cannot modify data->generation otherwise, essentially\n> repeating the whole verification process.\n>\n> While it\'s okay for now, I might take this up in a future series [1].\n>\n> [1]: https://lore.kernel.org/git/4043ffbc-84df-0cd6-5c75-af80383a56cf@gmail.com/\n\nAll right, I believe you that verifying both topological level and\ncorrected commit date would be more difficult.\n\nThat doesn\'t change the conclusion that this variable should remain to\nbe named `generation`, as when verifying GDAT-less commit-graph files it\nwould check topological levels (it uses commit_graph_generation(), which\nin turn uses `generation` field in commit graph info, which as I have\nshow above in later patch could be v1 or v2 generation number).\n\nBest,\n-- \nJakub Narębski\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 25, 10, 10, 37, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 476367748, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/85mu2jc75c.fsf@gmail.com), jnareb@gmail.com (Jakub Narębski) wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nHello,\n\nAbhishek Kumar <abhishekkumar8222@gmail.com> writes:\n> On Wed, Aug 19, 2020 at 07:54:20PM +0200, Jakub Narębski wrote:\n>> ""Abhishek Kumar via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n>>\n>>> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n>>>\n>>> Both fill_commit_graph_info() and fill_commit_in_graph() parse\n>>> information present in commit data chunk. Let\'s simplify the\n>>> implementation by calling fill_commit_graph_info() within\n>>> fill_commit_in_graph().\n>>>\n>>> The test \'generate tar with future mtime\' creates a commit with commit\n>>> time of (2 ^ 36 + 1) seconds since EPOCH. The commit time overflows into\n>>> generation number (within CDAT chunk) and has undefined behavior.\n>>>\n>>> The test used to pass\n>>\n>> Could you please tell us how does this test starts to fail without the\n>> change to the test described there?  What is the error message, etc.?\n>>\n>\n> Here\'s what I revised the commit message to:\n>\n> commit-graph: consolidate fill_commit_graph_info\n>\n> Both fill_commit_graph_info() and fill_commit_in_graph() parse\n> information present in commit data chunk. Let\'s simplify the\n> implementation by calling fill_commit_graph_info() within\n> fill_commit_in_graph().\n\nAll right.\n\nWe might want to add here the information that we also move loading the\ncommit date from the commit-graph file from fill_commit_in_graph() down\nthe [new] call chain into fill_commit_graph_info().  The commit date\nwould be needed in fill_commit_graph_info() in the next commit to\ncompute corrected commit date out of corrected commit date offset, and\nstore it as generation number.\n\n\nNOTE that this means that if we switch to storing 64-bit corrected\ncommit date directly in the commit-graph file, instead of storing 32-bit\noffsets, neither this Move Statement Into Function Out of Caller\nrefactoring nor change to the \'generate tar with future mtime\' test\nwould be necessary.\n\n>\n> The test \'generate tar with future mtime\' creates a commit with commit\n> time of (2 ^ 36 + 1) seconds since EPOCH. The CDAT chunk provides\n> 34-bits for storing commiter date, thus committer time overflows into\n> generation number (within CDAT chunk) and has undefined behavior.\n>\n> The test used to pass as fill_commit_graph_info() would not set struct\n> member `date` of struct commit and loads committer date from the object\n> database, generating a tar file with the expected mtime.\n\nI guess that in the case of generating a tar file we would read the\ncommit out of \'object database\', and then only add commit-graph specific\ninfo with fill_commit_graph_info().  Possibly because we need more\ninformation that commit-graph provides for a commit.\n\n>\n> However, with corrected commit date, we will load the committer date\n> from CDAT chunk (truncated to lower 34-bits) to populate the generation\n> number. Thus, fill_commit_graph_info() sets date and generates tar file\n> with the truncated mtime and the test fails.\n>\n> Let\'s fix the test by setting a timestamp of (2 ^ 34 - 1) seconds, which\n> will not be truncated.\n\nNow I got interested why the value of (2 ^ 36 + 1) seconds since EPOCH\nwas used.\n\nThe commit that introduced the \'generate tar with future mtime\' test,\nnamely e51217e15 (t5000: test tar files that overflow ustar headers,\n30-06-2016), says:\n\n\tThe ustar format only has room for 11 (or 12, depending on\n\tsome implementations) octal digits for the size and mtime of\n\teach file. For values larger than this, we have to add pax\n\textended headers to specify the real data, and git does not\n\tyet know how to do so.\n\n\tBefore fixing that, let\'s start off with some test\n\tinfrastructure [...]\n\nThe value of 2 ^ 36 equals 2 ^ 3*12 = (2 ^ 3) ^ 12 = 8 ^ 12.\nSo we need the value of (2 ^ 36 + 1) for this test do do its job.\nPossibly the value of 8 ^ 11 + 1 = 2 ^ 33 + 1 would be enough\n(if we skip testing ""some implementations"").\n\nSo I think to make this test more clear (for inquisitive minds) we\nshould set a timestamp of (2 ^ 33 + 1), not (2 ^ 34 - 1) seconds\nsince EPOCH.  Maybe even add a variant of this test that uses the\norigial value of (2 ^ 36 + 1) seconds since EPOCH, but turns off\nuse of serialized commit-graph.\n\nI\'m sorry for not checking this earlier.\n\nBest,\n-- \nJakub Narębski\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 25, 11, 13, 40, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 476406309, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/85ft8adilr.fsf@gmail.com), jnareb@gmail.com (Jakub Narębski) wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nAbhishek Kumar <abhishekkumar8222@gmail.com> writes:\n> On Fri, Aug 21, 2020 at 03:14:34PM +0200, Jakub Narębski wrote:\n>> ""Abhishek Kumar via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n>>\n>>> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n>>>\n>>> In a preparatory step, let\'s return timestamp_t values from\n>>> commit_graph_generation(), use timestamp_t for local variables\n>>\n>> All right, this is all good.\n>>\n>>> and define GENERATION_NUMBER_INFINITY as (2 ^ 63 - 1) instead.\n>>\n>> This needs more detailed examination.  There are two similar constants,\n>> GENERATION_NUMBER_INFINITY and GENERATION_NUMBER_MAX.  The former is\n>> used for newest commits outside the commit-graph, while the latter is\n>> maximum number that commits in the commit-graph can have (because of the\n>> storage limitations).  We therefore need GENERATION_NUMBER_INFINITY\n>> to be larger than GENERATION_NUMBER_MAX, and it is (and was).\n>>\n>> The GENERATION_NUMBER_INFINITY is because of the above requirement\n>> traditionally taken as maximum value that can be represented in the data\n>> type used to store commit\'s generation number _in memory_, but it can be\n>> less.  For timestamp_t the maximum value that can be represented\n>> is (2 ^ 63 - 1).\n>>\n>> All right then.\n>\n> Related to this, by the end of this series we are using\n> GENERATION_NUMBER_MAX in just one place - compute_generation_numbers()\n> to make sure the topological levels fit within 30 bits.\n>\n> Would it be more appropriate to rename GENERATION_NUMBER_MAX to\n> GENERATION_NUMBER_V1_MAX (along the lines of\n> GENERATION_NUMBER_V2_OFFSET_MAX)  to correctly describe that is a\n> limit on topological levels, rather than generation number value?\n\nYes, I think that at the end of this patch series we should be using\nGENERATION_NUMBER_V1_MAX and GENERATION_NUMBER_V2_OFFSET_MAX to describe\nstorage limits, and GENERATION_NUMBER_INFINITY (the latter as generation\nnumber value for commits not in graph).\n\nWe need to ensure that both GENERATION_NUMBER_V1_MAX and\nGENERATION_NUMBER_V2_OFFSET_MAX are smaller than\nGENERATION_NUMBER_INFINITY.\n\n\nHowever, as I wrote, handling GENERATION_NUMBER_V2_OFFSET_MAX is\ndifficult.  As far as I can see, we can choose one of the *three*\nsolutions (the third one is _new_):\n\na. store 64-bit corrected commit date in the GDAT chunk\n   all possible values are able to be stored, no need for\n   GENERATION_NUMBER_V2_MAX,\n\nb. store 32-bit corrected commit date offset in the GDAT chunk,\n   if its value is larger than GENERATION_NUMBER_V2_OFFSET_MAX,\n   do not write GDAT chunk at all (like for backward compatibility\n   with mixed-version chains of split commit-graph layers),\n\nc. store 32-bit corrected commit date offset in the GDAT chunk,\n   using some kind of overflow handling scheme; for example if\n   the most significant bit of 32-bit value is 1, then the\n   rest 31-bits are position in GDOV chunk, which uses 64-bit\n   to store those corrected commit date offsets that do not\n   fit in 32 bits.\n\nThis type of schema is used in other places in Git code, if I remember\nit correctly.\n\n>> The commit message says nothing about the new symbolic constant\n>> GENERATION_NUMBER_V1_INFINITY, though.\n>>\n>> I\'m not sure it is even needed (see comments below).\n>\n> Yes, you are correct. I tried it out with your suggestions and it wasn\'t\n> really needed.\n>\n> Thanks for catching this!\n\nMistakes can happen when changig how the series is split into commits.\n\nBest,\n-- \nJakub Narębski\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 25, 12, 23, 2, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 477087210, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/20200826071519.GA6805@Abhishek-Arch), Abhishek Kumar wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Sat, Aug 22, 2020 at 07:14:38PM +0200, Jakub Narębski wrote:\n> Hi Abhishek,\n> \n> ... \n> \n> However the commit message do not say anything about the *writing* side.\n> \n\nRevised the commit message to include the following at the end:\n\nWhen writing the new layer in split commit-graph, we write a GDAT chunk\nonly if the topmost layer has a GDAT chunk. This guarantees that if a\nlayer has GDAT chunk, all lower layers must have a GDAT chunk as well.\n\nRewriting layers follows similar approach: if the topmost layer below\nset of layers being rewritten (in the split commit-graph chain) exists,\nand it does not contain GDAT chunk, then the result of rewrite does not\nhave GDAT chunks either.\n\n> \n> ...\n> \n> To be more detailed, without \'--split=replace\' we would want the following\n> layer merging behavior:\n> \n>    [layer with GDAT][with GDAT][without GDAT][without GDAT][without GDAT]\n>            1              2           3             4            5\n> \n> In the split commit-graph chain above, merging two topmost layers\n> (layers 4 and 5) should create a layer without GDAT; merging three\n> topmost layers (and any other layers, e.g. two middle ones, i.e. 3 and\n> 4) should create a new layer with GDAT.\n> \n>    [layer with GDAT][with GDAT][without GDAT][-------without GDAT-------]\n>            1              2           3               merged\n> \n>    [layer with GDAT][with GDAT][-------------with GDAT------------------]\n>            1              2                    merged\n> \n> I hope those ASCII-art pictures help understanding it\n> \n\nThanks! There were helpful.\n\nWhile we work as expected in the first scenario i.e merging 4 and 5, we\nwould *still* write a layer without GDAT in the second scenario.\n\nI have tweaked split_graph_merge_strategy() to fix this:\n\n----------------------------------------------\n\ndiff --git a/commit-graph.c b/commit-graph.c\nindex 6d54d9a286..246fad030d 100644\n--- a/commit-graph.c\n+++ b/commit-graph.c\n@@ -1973,6 +1973,9 @@ static void split_graph_merge_strategy(struct write_commit_graph_context *ctx)\n \t\t}\n \t}\n \n+\tif (!ctx->write_generation_data && g->chunk_generation_data)\n+\t\tctx->write_generation_data = 1;\n+\n \tif (flags != COMMIT_GRAPH_SPLIT_REPLACE)\n \t\tctx->new_base_graph = g;\n \telse if (ctx->num_commit_graphs_after != 1)\n\n----------------------------------------------------\n\nThat is, if we were not writing generation data (because of mixed\ngeneration concerns) but the new topmost layer has a generation data\nchunk, we have merged all layers without GDAT chunk and can now write a\nGDAT chunk safely.\n\n> >\n> > It is difficult to expose this issue in a test. Since we _start_ with\n> > artificially low generation numbers, any commit walk that prioritizes\n> > generation numbers will walk all of the commits with high generation\n> > number before walking the commits with low generation number. In all the\n> > cases I tried, the commit-graph layers themselves ""protect"" any\n> > incorrect behavior since none of the commits in the lower layer can\n> > reach the commits in the upper layer.\n> >\n> > This issue would manifest itself as a performance problem in this case,\n> > especially with something like ""git log --graph"" since the low\n> > generation numbers would cause the in-degree queue to walk all of the\n> > commits in the lower layer before allowing the topo-order queue to write\n> > anything to output (depending on the size of the upper layer).\n> \n> Wouldn\'t breaking the reachability condition promise make some Git\n> commands to return *incorrect* results if they short-circuit, stop\n> walking if generation number shows that A cannot reach B?\n> \n> I am talking here about commands that return boolean, or select subset\n> from given set of revisions:\n> - git merge-base --is-ancestor <B> <A>\n> - git branch branch-A <A> && git branch --contains <B>\n> - git branch branch-B <B> && git branch --merged <A>\n> \n> Git assumes that generation numbers fulfill the following condition:\n> \n>   if A can reach B, then gen(A) > gen(B)\n> \n> Notably this includes commits not in commit-graph, and clamped values.\n> \n> However, in the following case\n> \n> * if commit A is from higher layer without GDAT\n>   and uses topological levels for \'generation\', e.g. 115 (in a small repo)\n> * and commit B is from lower layer with GDAT\n>   and uses corrected commit date as \'generation\', for example 1598112896,\n> \n> it may happen that A (later commit) can reach B (earlier commit), but\n> gen(B) > gen(A).  The reachability condition promise for generation\n> numbers is broken.\n> \n> >\n> > Signed-off-by: Derrick Stolee <dstolee@microsoft.com>\n> > Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> > ---\n> \n> I have reordered files in the patch itself to make it easier to review\n> the proposed changes.\n> \n> >  commit-graph.h                |  1 +\n> >  commit-graph.c                | 32 +++++++++++++++-\n> >  t/t5324-split-commit-graph.sh | 70 +++++++++++++++++++++++++++++++++++\n> >  3 files changed, 102 insertions(+), 1 deletion(-)\n> >\n> > diff --git a/commit-graph.h b/commit-graph.h\n> > index f78c892fc0..3cf89d895d 100644\n> > --- a/commit-graph.h\n> > +++ b/commit-graph.h\n> > @@ -63,6 +63,7 @@ struct commit_graph {\n> >  \tstruct object_directory *odb;\n> >\n> >  \tuint32_t num_commits_in_base;\n> > +\tuint32_t read_generation_data;\n> >  \tstruct commit_graph *base_graph;\n> >\n> \n> First, why `read_generation_data` is of uint32_t type, when it stores\n> (as far as I understand it), a ""boolean"" value of either 0 or 1?\n> \n\nYes, using unsigned int instead of uint32_t (although in most of cases\nit would be same).  If commit_graph had other flags as well, we could\nhave used a bit field.\n\n> Second, couldn\'t we simply set chunk_generation_data to NULL?  Or would\n> that interfere with the case of rewriting, where we want to use existing\n> GDAT data when writing new commit-graph with GDAT chunk?\n\nIt interferes with rewriting the split commit-graph, as you might have\nguessed from the above code snippet.\n\n> \n> ...\n>\n> > diff --git a/commit-graph.c b/commit-graph.c\n> \n> >  \t\tgraph_data->generation = item->date +\n> >  \t\t\t(timestamp_t) get_be32(g->chunk_generation_data + sizeof(uint32_t) * lex_index);\n> >  \telse\n> > @@ -885,6 +908,7 @@ void load_commit_graph_info(struct repository *r, struct commit *item)\n> >  \tuint32_t pos;\n> >  \tif (!prepare_commit_graph(r))\n> >  \t\treturn;\n> > +\n> >  \tif (find_commit_in_graph(item, r->objects->commit_graph, &pos))\n> >  \t\tfill_commit_graph_info(item, r->objects->commit_graph, pos);\n> >  }\n> \n> This is unrelated whitespace fix, a ""while at it"" in neighbourhood of\n> changes.  All right then.\n> \n\nReverted this change, as it\'s unimportant.\n\n> > @@ -2192,6 +2216,9 @@ int write_commit_graph(struct object_directory *odb,\n>\n> ...\n> \n> It would be nice to have an example with merging layers (whether we\n> would handle it in strict or relaxed way).\n> \n\nSure, will add.\n\n> > +\n> >  test_done\n> \n> Best,\n> -- \n> Jakub Narębski\n\nThanks\n- Abhishek\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 26, 7, 21, 33, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 477204718, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/857dtld75f.fsf@gmail.com), jnareb@gmail.com (Jakub Narębski) wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nHi Abhishek,\n\nAbhishek Kumar <abhishekkumar8222@gmail.com> writes:\n> On Sat, Aug 22, 2020 at 07:14:38PM +0200, Jakub Narębski wrote:\n>> Hi Abhishek,\n>>\n>> ...\n>>\n>> However the commit message do not say anything about the *writing* side.\n>>\n>\n> Revised the commit message to include the following at the end:\n>\n> When writing the new layer in split commit-graph, we write a GDAT chunk\n> only if the topmost layer has a GDAT chunk. This guarantees that if a\n> layer has GDAT chunk, all lower layers must have a GDAT chunk as well.\n>\n\nAll right.\n\n> Rewriting layers follows similar approach: if the topmost layer below\n> set of layers being rewritten (in the split commit-graph chain) exists,\n> and it does not contain GDAT chunk, then the result of rewrite does not\n> have GDAT chunks either.\n\nAll right.\n\nI see that you went with proposed more complex (but better) solution...\n\n>>\n>> ...\n>>\n>> To be more detailed, without \'--split=replace\' we would want the following\n>> layer merging behavior:\n>>\n>>    [layer with GDAT][with GDAT][without GDAT][without GDAT][without GDAT]\n>>            1              2           3             4            5\n>>\n>> In the split commit-graph chain above, merging two topmost layers\n>> (layers 4 and 5) should create a layer without GDAT; merging three\n>> topmost layers (and any other layers, e.g. two middle ones, i.e. 3 and\n>> 4) should create a new layer with GDAT.\n\nA simpler solution would be to create a new merged layer without GDAT if\nany of the layers being merged do not have GDAT.\n\nIn this solution merging 3+4+5, 3+4, and even 2+3 would result with\nlayer without GDAT, and only merging 1+2 would result in layer with GDAT.\n\n>>\n>>    [layer with GDAT][with GDAT][without GDAT][-------without GDAT-------]\n>>            1              2           3               merged\n>>\n>>    [layer with GDAT][with GDAT][-------------with GDAT------------------]\n>>            1              2                    merged\n>>\n>> I hope those ASCII-art pictures help understanding it\n>>\n>\n> Thanks! There were helpful.\n>\n> While we work as expected in the first scenario i.e merging 4 and 5, we\n> would *still* write a layer without GDAT in the second scenario.\n>\n> I have tweaked split_graph_merge_strategy() to fix this:\n>\n> ----------------------------------------------\n>\n> diff --git a/commit-graph.c b/commit-graph.c\n> index 6d54d9a286..246fad030d 100644\n> --- a/commit-graph.c\n> +++ b/commit-graph.c\n> @@ -1973,6 +1973,9 @@ static void split_graph_merge_strategy(struct write_commit_graph_context *ctx)\n>  \t\t}\n>  \t}\n>\n> +\tif (!ctx->write_generation_data && g->chunk_generation_data)\n> +\t\tctx->write_generation_data = 1;\n> +\n>  \tif (flags != COMMIT_GRAPH_SPLIT_REPLACE)\n>  \t\tctx->new_base_graph = g;\n>  \telse if (ctx->num_commit_graphs_after != 1)\n\n...which turned out to be not that complicated.  Nice work!\n\nThough this needs tests that if fulfills the stated condition (because I\nam not sure if it is entirely correct: we are not checking the layer\nbelow current one, isn\'t it?... ah, you explain it below).\n\nOne possible solution would be to grep `test-tool read-graph` output for\n""^chunks: "", then pass it through `uniq` (without `sort`!), check that\nthe number of lines is less or equal 2, and if there are two lines then\ncheck that we get the following contents:\n\n  chunks: oid_fanout oid_lookup commit_metadata generation_data\n  chunks: oid_fanout oid_lookup commit_metadata\n\n(assuming that information about layers is added in top-down order).\n\nThis test must be run with GIT_TEST_COMMIT_GRAPH_CHANGED_PATHS=0, which\nI think is the default.\n\n> ----------------------------------------------------\n>\n> That is, if we were not writing generation data (because of mixed\n> generation concerns) but the new topmost layer has a generation data\n> chunk, we have merged all layers without GDAT chunk and can now write a\n> GDAT chunk safely.\n\nAll right.\n\n[...]\n>>> diff --git a/commit-graph.h b/commit-graph.h\n>>> index f78c892fc0..3cf89d895d 100644\n>>> --- a/commit-graph.h\n>>> +++ b/commit-graph.h\n>>> @@ -63,6 +63,7 @@ struct commit_graph {\n>>>  \tstruct object_directory *odb;\n>>>\n>>>  \tuint32_t num_commits_in_base;\n>>> +\tuint32_t read_generation_data;\n>>>  \tstruct commit_graph *base_graph;\n>>>\n>>\n>> First, why `read_generation_data` is of uint32_t type, when it stores\n>> (as far as I understand it), a ""boolean"" value of either 0 or 1?\n>\n> Yes, using unsigned int instead of uint32_t (although in most of cases\n> it would be same).  If commit_graph had other flags as well, we could\n> have used a bit field.\n\nOK.\n\n>> Second, couldn\'t we simply set chunk_generation_data to NULL?  Or would\n>> that interfere with the case of rewriting, where we want to use existing\n>> GDAT data when writing new commit-graph with GDAT chunk?\n>\n> It interferes with rewriting the split commit-graph, as you might have\n> guessed from the above code snippet.\n\nAll right.\n\n[...]\n>>> @@ -885,6 +908,7 @@ void load_commit_graph_info(struct repository *r, struct commit *item)\n>>>  \tuint32_t pos;\n>>>  \tif (!prepare_commit_graph(r))\n>>>  \t\treturn;\n>>> +\n>>>  \tif (find_commit_in_graph(item, r->objects->commit_graph, &pos))\n>>>  \t\tfill_commit_graph_info(item, r->objects->commit_graph, pos);\n>>>  }\n>>\n>> This is unrelated whitespace fix, a ""while at it"" in neighbourhood of\n>> changes.  All right then.\n>>\n>\n> Reverted this change, as it\'s unimportant.\n\nActually I am not against fixing the whitespace in the neighbourhood of\nchanges, so you can keep it or revert it (discard).\n\n>>> @@ -2192,6 +2216,9 @@ int write_commit_graph(struct object_directory *odb,\n>>\n>> ...\n>>\n>> It would be nice to have an example with merging layers (whether we\n>> would handle it in strict or relaxed way).\n>>\n>\n> Sure, will add.\n\nThanks.\n\n\nBest,\n--\nJakub Narębski\n``````````\n', 'comment_created': datetime.datetime(2020, 8, 26, 10, 39, 43, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 481038897, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/20200901102624.GB10388@Abhishek-Arch), Abhishek Kumar wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Tue, Aug 25, 2020 at 09:56:44AM +0200, Jakub Narębski wrote:\n> On Tue, 25 Aug 2020 at 09:33, Jakub Narębski <jnareb@gmail.com> wrote:\n>\n> ...\n>\n> >\n> > All right, we might want to make use of the fact that the value of 0 for\n> > topological level here always mean that its value for a commit needs to\n> > be computed, that 0 is not a valid value for topological levels.\n> > - if the value 0 came from commit-graph file, it means that it came\n> >   from Git version that used commit-graph but didn\'t compute generation\n> >   numbers; the value is GENERATION_NUMBER_ZERO\n> > - the value 0 might came from the fact that commit is not in graph,\n> >   and that commit-slab zero-initializes the values stored; let\'s\n> >   call this value GENERATION_NUMBER_UNINITIALIZED\n> >\n> > If we ensure that corrected commit date can never be zero (which is\n> > extremely unlikely, as one of root commits would have to be malformed or\n> > written on badly misconfigured computer, with value of 0 for committer\n> > timestamp), then this ""happy accident"" can keep working.\n> >\n> >   As a special case, commit date with timestamp of zero (01.01.1970 00:00:00Z)\n> >   has corrected commit date of one, to be able to distinguish\n> >   uninitialized values.\n> >\n> > Or something like that.\n> >\n> > Actually, it is not even necessary, as corrected commit date of 0 just\n> > means that this single value (well, for every root commit with commit\n> > date of 0) would be unnecessary recomputed in compute_generation_numbers().\n> >\n> > Anyway, we would want to document this fact in the commit message.\n> \n> Alternatively, instead of comparing \'level\' (and later in series also\n> \'corrected_commit_date\') against GENERATION_NUMBER_INFINITY,\n> we could load at no extra cost `graph_pos` value and compare it\n> against COMMIT_NOT_FROM_GRAPH.\n> \n> But with this solution we could never get rid of graph_pos, if we\n> think it is unnecessary. If we split commit_graph_data into separate\n> slabs (as it was in early versions of respective patch series), we\n> would have to pay additional cost.\n> \n> But it is an alternative.\n> \n> Best,\n> -- \n> Jakub Narębski\n\nI think updating a commit date with timestampt of zero to use corrected\ncommit date of one would leave us more options down the line.\n\nChanging this is easy enough.\n\nFor a root commit with timestamp zero, current->date would be zero and \nmax_corrected_commit_date would be zero as well. So we can set \ncorrected commit date as `max_corrected_commit_date + 1`, instead of the\nearlier `(current->date - 1) + 1`.\n\n----\n\ndiff --git a/commit-graph.c b/commit-graph.c\nindex 7ed0a33ad6..e3c5e30405 100644\n--- a/commit-graph.c\n+++ b/commit-graph.c\n@@ -1389,7 +1389,7 @@ static void compute_generation_numbers(struct write_commit_graph_context *ctx)\n \t\t\t\t\tmax_level = GENERATION_NUMBER_V1_MAX - 1;\n \t\t\t\t*topo_level_slab_at(ctx->topo_levels, current) = max_level + 1;\n \n-\t\t\t\tif (current->date > max_corrected_commit_date)\n+\t\t\t\tif (current->date && current->date > max_corrected_commit_date)\n \t\t\t\t\tmax_corrected_commit_date = current->date - 1;\n \t\t\t\tcommit_graph_data_at(current)->generation = max_corrected_commit_date + 1;\n \t\t\t}\n``````````\n', 'comment_created': datetime.datetime(2020, 9, 1, 10, 30, 55, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 481061318, 'comment_body': ""[On the Git mailing list](https://lore.kernel.org/git/20200901110141.GC10388@Abhishek-Arch), Abhishek Kumar wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Tue, Aug 25, 2020 at 12:07:17PM +0200, Jakub Narębski wrote:\n> Hello,\n> \n> ...\n> \n> I think I was not clear enough (in trying to be brief).  I meant here\n> loading available generation numbers for use in graph traversal,\n> done in later patches in this series.\n> \n> In _next_ commit we store topological levels in `generation` field:\n> \n>   @@ -755,7 +763,11 @@ static void fill_commit_graph_info(struct commit *item, struct commit_graph *g,\n>    \tdate_low = get_be32(commit_data + g->hash_len + 12);\n>    \titem->date = (timestamp_t)((date_high << 32) | date_low);\n> \n>   -\tgraph_data->generation = get_be32(commit_data + g->hash_len + 8) >> 2;\n>   +\tif (g->chunk_generation_data)\n>   +\t\tgraph_data->generation = item->date +\n>   +\t\t\t(timestamp_t) get_be32(g->chunk_generation_data + sizeof(uint32_t) * lex_index);\n>   +\telse\n>   +\t\tgraph_data->generation = get_be32(commit_data + g->hash_len + 8) >> 2;\n> \n> \n> We use topo_level slab only when writing the commit-graph file.\n> \n\nRight, I thought the agenda outlined points in the process of writing\ncommit-graph file.\n\n>\n> > We could avoid initializing topo_slab if we are not writing generation\n> > data chunk (and thus don't need corrected commit dates) but that\n> > wouldn't have an impact on run time while writing commit-graph because\n> > computing corrected commit dates is cheap as the main cost is in walking\n> > the graph and writing the file.\n> \n> Right.\n> \n> Though you need to add the cost of allocation and managing extra\n> commit slab, I think that amortized cost is negligible.\n> \n> But what would be better is showing benchmark data: does writing the\n> commit graph without GDAT take not insigificant more time than without\n> this patch?\n\nRight, we could compare time taken by master and series until (but not\nincluding this patcth) to write a commit-graph file. Will add.\n\n> \n> [...]\n> >>> @@ -2372,8 +2384,8 @@ int verify_commit_graph(struct repository *r, struct commit_graph *g, int flags)\n> >>>  \tfor (i = 0; i < g->num_commits; i++) {\n> >>>  \t\tstruct commit *graph_commit, *odb_commit;\n> >>>  \t\tstruct commit_list *graph_parents, *odb_parents;\n> >>> -\t\ttimestamp_t max_generation = 0;\n> >>> -\t\ttimestamp_t generation;\n> >>> +\t\ttimestamp_t max_corrected_commit_date = 0;\n> >>> +\t\ttimestamp_t corrected_commit_date;\n> >>\n> >> This is simple, and perhaps unnecessary, rename of variables.\n> >> Shouldn't we however verify *both* topological level, and\n> >> (if exists) corrected commit date?\n> >\n> > The problem with verifying both topological level and corrected commit\n> > dates is that we would have to re-fill commit_graph_data slab with commit\n> > data chunk as we cannot modify data->generation otherwise, essentially\n> > repeating the whole verification process.\n> >\n> > While it's okay for now, I might take this up in a future series [1].\n> >\n> > [1]: https://lore.kernel.org/git/4043ffbc-84df-0cd6-5c75-af80383a56cf@gmail.com/\n> \n> All right, I believe you that verifying both topological level and\n> corrected commit date would be more difficult.\n> \n> That doesn't change the conclusion that this variable should remain to\n> be named `generation`, as when verifying GDAT-less commit-graph files it\n> would check topological levels (it uses commit_graph_generation(), which\n> in turn uses `generation` field in commit graph info, which as I have\n> show above in later patch could be v1 or v2 generation number).\n> \n\nRight, I completely misunderstood you initially. Reverted the variable\nname changes.\n\n> Best,\n> -- \n> Jakub Narębski\n``````````\n"", 'comment_created': datetime.datetime(2020, 9, 1, 11, 16, 2, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 481076449, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/20200901113524.GD10388@Abhishek-Arch), Abhishek Kumar wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Tue, Aug 25, 2020 at 01:11:11PM +0200, Jakub Narębski wrote:\n> Hello,\n> \n> ...\n> \n> All right.\n> \n> We might want to add here the information that we also move loading the\n> commit date from the commit-graph file from fill_commit_in_graph() down\n> the [new] call chain into fill_commit_graph_info().  The commit date\n> would be needed in fill_commit_graph_info() in the next commit to\n> compute corrected commit date out of corrected commit date offset, and\n> store it as generation number.\n> \n> \n> NOTE that this means that if we switch to storing 64-bit corrected\n> commit date directly in the commit-graph file, instead of storing 32-bit\n> offsets, neither this Move Statement Into Function Out of Caller\n> refactoring nor change to the \'generate tar with future mtime\' test\n> would be necessary.\n> \n> >\n> > The test \'generate tar with future mtime\' creates a commit with commit\n> > time of (2 ^ 36 + 1) seconds since EPOCH. The CDAT chunk provides\n> > 34-bits for storing commiter date, thus committer time overflows into\n> > generation number (within CDAT chunk) and has undefined behavior.\n> >\n> > The test used to pass as fill_commit_graph_info() would not set struct\n> > member `date` of struct commit and loads committer date from the object\n> > database, generating a tar file with the expected mtime.\n> \n> I guess that in the case of generating a tar file we would read the\n> commit out of \'object database\', and then only add commit-graph specific\n> info with fill_commit_graph_info().  Possibly because we need more\n> information that commit-graph provides for a commit.\n> \n> >\n> > However, with corrected commit date, we will load the committer date\n> > from CDAT chunk (truncated to lower 34-bits) to populate the generation\n> > number. Thus, fill_commit_graph_info() sets date and generates tar file\n> > with the truncated mtime and the test fails.\n> >\n> > Let\'s fix the test by setting a timestamp of (2 ^ 34 - 1) seconds, which\n> > will not be truncated.\n> \n> Now I got interested why the value of (2 ^ 36 + 1) seconds since EPOCH\n> was used.\n> \n> The commit that introduced the \'generate tar with future mtime\' test,\n> namely e51217e15 (t5000: test tar files that overflow ustar headers,\n> 30-06-2016), says:\n> \n> \tThe ustar format only has room for 11 (or 12, depending on\n> \tsome implementations) octal digits for the size and mtime of\n> \teach file. For values larger than this, we have to add pax\n> \textended headers to specify the real data, and git does not\n> \tyet know how to do so.\n> \n> \tBefore fixing that, let\'s start off with some test\n> \tinfrastructure [...]\n> \n> The value of 2 ^ 36 equals 2 ^ 3*12 = (2 ^ 3) ^ 12 = 8 ^ 12.\n> So we need the value of (2 ^ 36 + 1) for this test do do its job.\n> Possibly the value of 8 ^ 11 + 1 = 2 ^ 33 + 1 would be enough\n> (if we skip testing ""some implementations"").\n> \n> So I think to make this test more clear (for inquisitive minds) we\n> should set a timestamp of (2 ^ 33 + 1), not (2 ^ 34 - 1) seconds\n> since EPOCH.  Maybe even add a variant of this test that uses the\n> origial value of (2 ^ 36 + 1) seconds since EPOCH, but turns off\n> use of serialized commit-graph.\n\nThat\'s pretty interesting! I didn\'t look into this either, will modify\nthe existing test and add a new test for it.\n\nThanks for investigating this further.\n\n> \n> I\'m sorry for not checking this earlier.\n> \n> Best,\n> -- \n> Jakub Narębski\n\nThanks\n- Abhishek\n``````````\n', 'comment_created': datetime.datetime(2020, 9, 1, 11, 45, 59, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 481111567, 'comment_body': ""[On the Git mailing list](https://lore.kernel.org/git/20200901120653.GA59580@Abhishek-Arch), Abhishek Kumar wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Tue, Aug 25, 2020 at 02:18:24PM +0200, Jakub Narębski wrote:\n> Abhishek Kumar <abhishekkumar8222@gmail.com> writes:\n> \n> ...\n> \n> However, as I wrote, handling GENERATION_NUMBER_V2_OFFSET_MAX is\n> difficult.  As far as I can see, we can choose one of the *three*\n> solutions (the third one is _new_):\n> \n> a. store 64-bit corrected commit date in the GDAT chunk\n>    all possible values are able to be stored, no need for\n>    GENERATION_NUMBER_V2_MAX,\n> \n> b. store 32-bit corrected commit date offset in the GDAT chunk,\n>    if its value is larger than GENERATION_NUMBER_V2_OFFSET_MAX,\n>    do not write GDAT chunk at all (like for backward compatibility\n>    with mixed-version chains of split commit-graph layers),\n> \n> c. store 32-bit corrected commit date offset in the GDAT chunk,\n>    using some kind of overflow handling scheme; for example if\n>    the most significant bit of 32-bit value is 1, then the\n>    rest 31-bits are position in GDOV chunk, which uses 64-bit\n>    to store those corrected commit date offsets that do not\n>    fit in 32 bits.\n> \n\nAlright, so the third solution leverages the fact that in practice,\nvery few offsets would overflow the 32-bit limit. Using 64-bits for all\noffsets would be wasteful, we can trade off a miniscule amount of\ncomputation to save large amounts of disk space.\n\n>\n> This type of schema is used in other places in Git code, if I remember\n> it correctly.\n> \n\nYes, it's a similar idea to the extra edge list chunk, where the most\nsignificant bit of second parent indicates whether they are more than\ntwo parents.\n\nIt's definitely feasible, albeit a little complex.\n\nWhat's the overall consensus on the third solution?\n\n>\n> >> The commit message says nothing about the new symbolic constant\n> >> GENERATION_NUMBER_V1_INFINITY, though.\n> >>\n> >> I'm not sure it is even needed (see comments below).\n> >\n> > Yes, you are correct. I tried it out with your suggestions and it wasn't\n> > really needed.\n> >\n> > Thanks for catching this!\n> \n> Mistakes can happen when changig how the series is split into commits.\n> \n> Best,\n> -- \n> Jakub Narębski\n\nThanks\n- Abhishek\n``````````\n"", 'comment_created': datetime.datetime(2020, 9, 1, 12, 49, 3, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 482838246, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/85imcvb4ag.fsf@gmail.com), jnareb@gmail.com (Jakub Narębski) wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nAbhishek Kumar <abhishekkumar8222@gmail.com> writes:\n> On Tue, Aug 25, 2020 at 09:56:44AM +0200, Jakub Narębski wrote:\n>> On Tue, 25 Aug 2020 at 09:33, Jakub Narębski <jnareb@gmail.com> wrote:\n>>\n>> ...\n>>\n>>>\n>>> All right, we might want to make use of the fact that the value of 0 for\n>>> topological level here always mean that its value for a commit needs to\n>>> be computed, that 0 is not a valid value for topological levels.\n>>> - if the value 0 came from commit-graph file, it means that it came\n>>>   from Git version that used commit-graph but didn\'t compute generation\n>>>   numbers; the value is GENERATION_NUMBER_ZERO\n>>> - the value 0 might came from the fact that commit is not in graph,\n>>>   and that commit-slab zero-initializes the values stored; let\'s\n>>>   call this value GENERATION_NUMBER_UNINITIALIZED\n>>>\n>>> If we ensure that corrected commit date can never be zero (which is\n>>> extremely unlikely, as one of root commits would have to be malformed or\n>>> written on badly misconfigured computer, with value of 0 for committer\n>>> timestamp), then this ""happy accident"" can keep working.\n>>>\n>>>   As a special case, commit date with timestamp of zero (01.01.1970 00:00:00Z)\n>>>   has corrected commit date of one, to be able to distinguish\n>>>   uninitialized values.\n>>>\n>>> Or something like that.\n>>>\n>>> Actually, it is not even necessary, as corrected commit date of 0 just\n>>> means that this single value (well, for every root commit with commit\n>>> date of 0) would be unnecessary recomputed in compute_generation_numbers().\n>>>\n>>> Anyway, we would want to document this fact in the commit message.\n>> \n>> Alternatively, instead of comparing \'level\' (and later in series also\n>> \'corrected_commit_date\') against GENERATION_NUMBER_INFINITY,\n>> we could load at no extra cost `graph_pos` value and compare it\n>> against COMMIT_NOT_FROM_GRAPH.\n>> \n>> But with this solution we could never get rid of graph_pos, if we\n>> think it is unnecessary. If we split commit_graph_data into separate\n>> slabs (as it was in early versions of respective patch series), we\n>> would have to pay additional cost.\n>> \n>> But it is an alternative.\n>\n> I think updating a commit date with timestampt of zero to use corrected\n> commit date of one would leave us more options down the line.\n>\n> Changing this is easy enough.\n>\n> For a root commit with timestamp zero, current->date would be zero and \n> max_corrected_commit_date would be zero as well. So we can set \n> corrected commit date as `max_corrected_commit_date + 1`, instead of the\n> earlier `(current->date - 1) + 1`.\n>\n> ----\n>\n> diff --git a/commit-graph.c b/commit-graph.c\n> index 7ed0a33ad6..e3c5e30405 100644\n> --- a/commit-graph.c\n> +++ b/commit-graph.c\n> @@ -1389,7 +1389,7 @@ static void compute_generation_numbers(struct write_commit_graph_context *ctx)\n>  \t\t\t\t\tmax_level = GENERATION_NUMBER_V1_MAX - 1;\n>  \t\t\t\t*topo_level_slab_at(ctx->topo_levels, current) = max_level + 1;\n>  \n> -\t\t\t\tif (current->date > max_corrected_commit_date)\n> +\t\t\t\tif (current->date && current->date > max_corrected_commit_date)\n>  \t\t\t\t\tmax_corrected_commit_date = current->date - 1;\n>  \t\t\t\tcommit_graph_data_at(current)->generation = max_corrected_commit_date + 1;\n>  \t\t\t}\n\nIt turned out to be much easier than I have expected: a one-line change,\nadding simply a new condition.  Good work!\n\nPerhaps it would be better to write it as current->date == GENERATION_NUMBER_UNINITIALIZED\n(or *_ZERO, or *_NO_DATA,...), but current version is quite idiomatic\nand easy to read.\n\nWith this change we should, of course, also change the commit-graph\nformat docs.\n\n\nOn the other hand it is a bit unnecessary.  If `generation` is zero,\nusing it would still work, and it would just mean that it would be\nunnecessarily recomputed - but corrected commit date equal zero is\npossible only for root commits.\n\nBut the above solution is more consistent, using 0 to mark not\ninitialized values...  it is cleaner, at the cost of one more corner\ncase, single line change, and possibly an insignificant amount of\nperformance penalty due to adding unlikely true branch to the\nconditional.\n\nBest,\n-- \nJakub Narębski\n``````````\n', 'comment_created': datetime.datetime(2020, 9, 3, 9, 26, 39, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 483045837, 'comment_body': ""[On the Git mailing list](https://lore.kernel.org/git/851rjjasdo.fsf@gmail.com), jnareb@gmail.com (Jakub Narębski) wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nHi,\n\nAbhishek Kumar <abhishekkumar8222@gmail.com> writes:\n> On Tue, Aug 25, 2020 at 02:18:24PM +0200, Jakub Narębski wrote:\n>> Abhishek Kumar <abhishekkumar8222@gmail.com> writes:\n>> \n>> ...\n>> \n>> However, as I wrote, handling GENERATION_NUMBER_V2_OFFSET_MAX is\n>> difficult.  As far as I can see, we can choose one of the *three*\n>> solutions (the third one is _new_):\n>> \n>> a. store 64-bit corrected commit date in the GDAT chunk\n>>    all possible values are able to be stored, no need for\n>>    GENERATION_NUMBER_V2_MAX,\n>> \n>> b. store 32-bit corrected commit date offset in the GDAT chunk,\n>>    if its value is larger than GENERATION_NUMBER_V2_OFFSET_MAX,\n>>    do not write GDAT chunk at all (like for backward compatibility\n>>    with mixed-version chains of split commit-graph layers),\n>> \n>> c. store 32-bit corrected commit date offset in the GDAT chunk,\n>>    using some kind of overflow handling scheme; for example if\n>>    the most significant bit of 32-bit value is 1, then the\n>>    rest 31-bits are position in GDOV chunk, which uses 64-bit\n>>    to store those corrected commit date offsets that do not\n>>    fit in 32 bits.\n\nNote that I have posted more detailed analysis of advantages and\ndisadvantages of each of the above solutions in response to 11/11\nhttps://public-inbox.org/git/85o8mwb6nq.fsf@gmail.com/\n\nI can think of yet another solution, a variant of approach 'c' with\ndifferent overflow handling scheme:\n\nc'.  Store 32-bit corrected commit date offset in the GDAT chunk,\n     using the following overflow handling scheme: if the value\n     is 0xFFFFFFFF (all bits set to 1, the maximum possible value\n     for uint32_t), then the corrected commit date or corrected\n     commit date offset can be found in GDOV chunk (Generation\n     Data OVerflow handling).\n\n     The GDOV chunk is composed of:\n     - H bytes of commit OID, or 4 bytes (32 bits) of commit pos\n     - 8 bytes (64 bits) of corrected commit date or its offset\n     \n     Commits in GDOV chunk are sorted; as we expect for the number\n     of commits that require GDOV to be zero or a very small number\n     there is no need for GDO Fanout chunk.\n     \n   - advantages:\n     * commit-graph is smaller, increasing for abnormal repos\n     * overflow limit reduced only by 1 (a single value)\n   - disadvantages:\n     * most complex code of all proposed solutions\n       even more complicated than for solution 'c',\n       different from EDGE chunk handling\n     * tests would be needed to exercise the overflow code\n\nOr we can split overflow handling into two chunks: GDOI (Generation Data\nOverflow Index) and GDOV, where GDOI would be composed of H bytes of\ncommit OID or 4 bytes of commit graph position (sorted), and GDOV would\nbe composed oly of 8 bytes (64 bits) of corrected commit date data.\n\nThis c'') variant has the same advantages and disadvantages as c'), with\nnegligibly slightly larger disk size and possibly slightly better\nperformance because of better data locality.\n\n>\n> Alright, so the third solution leverages the fact that in practice,\n> very few offsets would overflow the 32-bit limit. Using 64-bits for all\n> offsets would be wasteful, we can trade off a miniscule amount of\n> computation to save large amounts of disk space.\n\nOn the other hand we can say that we can trade negligible increase of\ncommit-graph disk space size (less than 7% in worst case: no octopus\nmerges, no changed-path Bloom filter data, using SHA-1 for object ids,\nlarge repository so header size + OIFD is negligible) for simpler code\nwith no need for overflow handling at all (and a minuscule amount of\nless computations).\n\n>>\n>> This type of schema is used in other places in Git code, if I remember\n>> it correctly.\n>> \n>\n> Yes, it's a similar idea to the extra edge list chunk, where the most\n> significant bit of second parent indicates whether they are more than\n> two parents.\n\nYes and no.  Yes, the solution 'c' uses exactly the same mechanism as\nthe pointer from Commid Data chunk into Extra Edges List chunk:\n\n      [...]  If there are more than two parents, the second value\n      has its most-significant bit on and the other bits store an array\n      position into the Extra Edge List chunk.\n\nOn the other hand we need to have some kind of overflow handling for the\nlist of parents, as the number of parents is not limited in Git (there\nis no technical upper limit on the number of parents a commits can\nhave), as opposed to for example Mercurial.  This is not the case for\nstoring corrected commit date (or corrected commit date offset), as 64\nbits is all we would ever need.\n\n> It's definitely feasible, albeit a little complex.\n>\n> What's the overall consensus on the third solution?\n\nStill waiting for others to weight in.\n\nBest,\n-- \nJakub Narębski\n``````````\n"", 'comment_created': datetime.datetime(2020, 9, 3, 14, 59, 52, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 483970482, 'comment_body': ""[On the Git mailing list](https://lore.kernel.org/git/20200905172127.GA1382@Abhishek-Arch), Abhishek Kumar wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Thu, Sep 03, 2020 at 03:42:43PM +0200, Jakub Narębski wrote:\n> Hi,\n> \n> Abhishek Kumar <abhishekkumar8222@gmail.com> writes:\n> > On Tue, Aug 25, 2020 at 02:18:24PM +0200, Jakub Narębski wrote:\n> >> Abhishek Kumar <abhishekkumar8222@gmail.com> writes:\n> >> \n> >> ...\n> >> \n> >> However, as I wrote, handling GENERATION_NUMBER_V2_OFFSET_MAX is\n> >> difficult.  As far as I can see, we can choose one of the *three*\n> >> solutions (the third one is _new_):\n> >> \n> >> a. store 64-bit corrected commit date in the GDAT chunk\n> >>    all possible values are able to be stored, no need for\n> >>    GENERATION_NUMBER_V2_MAX,\n> >> \n> >> b. store 32-bit corrected commit date offset in the GDAT chunk,\n> >>    if its value is larger than GENERATION_NUMBER_V2_OFFSET_MAX,\n> >>    do not write GDAT chunk at all (like for backward compatibility\n> >>    with mixed-version chains of split commit-graph layers),\n> >> \n> >> c. store 32-bit corrected commit date offset in the GDAT chunk,\n> >>    using some kind of overflow handling scheme; for example if\n> >>    the most significant bit of 32-bit value is 1, then the\n> >>    rest 31-bits are position in GDOV chunk, which uses 64-bit\n> >>    to store those corrected commit date offsets that do not\n> >>    fit in 32 bits.\n> \n> Note that I have posted more detailed analysis of advantages and\n> disadvantages of each of the above solutions in response to 11/11\n> https://public-inbox.org/git/85o8mwb6nq.fsf@gmail.com/\n> \n> I can think of yet another solution, a variant of approach 'c' with\n> different overflow handling scheme:\n> \n> c'.  Store 32-bit corrected commit date offset in the GDAT chunk,\n>      using the following overflow handling scheme: if the value\n>      is 0xFFFFFFFF (all bits set to 1, the maximum possible value\n>      for uint32_t), then the corrected commit date or corrected\n>      commit date offset can be found in GDOV chunk (Generation\n>      Data OVerflow handling).\n> \n>      The GDOV chunk is composed of:\n>      - H bytes of commit OID, or 4 bytes (32 bits) of commit pos\n>      - 8 bytes (64 bits) of corrected commit date or its offset\n>      \n>      Commits in GDOV chunk are sorted; as we expect for the number\n>      of commits that require GDOV to be zero or a very small number\n>      there is no need for GDO Fanout chunk.\n>      \n>    - advantages:\n>      * commit-graph is smaller, increasing for abnormal repos\n>      * overflow limit reduced only by 1 (a single value)\n>    - disadvantages:\n>      * most complex code of all proposed solutions\n>        even more complicated than for solution 'c',\n>        different from EDGE chunk handling\n>      * tests would be needed to exercise the overflow code\n> \n> Or we can split overflow handling into two chunks: GDOI (Generation Data\n> Overflow Index) and GDOV, where GDOI would be composed of H bytes of\n> commit OID or 4 bytes of commit graph position (sorted), and GDOV would\n> be composed oly of 8 bytes (64 bits) of corrected commit date data.\n> \n> This c'') variant has the same advantages and disadvantages as c'), with\n> negligibly slightly larger disk size and possibly slightly better\n> performance because of better data locality.\n> \n\nThe primary benefit of c') over c) seems to the range of valid offsets -\nc') can range from [0, 0xFFFFFFFF) whereas offsets for c) can range\nbetwen [0, 0x7FFFFFF].\n\nIn other words, we should prefer c') over c) only if the offsets are\nusually in the range [0x7FFFFFFF + 1, 0xFFFFFFFF)\n\nCommits were overflowing corrected committer date offsets are rare, and\noffsets in that particular range are doubly rare. To be wrong within\nthe range would be have an offset of 68 to 136 years, so that's possible\nonly if the corrupted timestamp is in future (it's been 50.68 years since\nUnix epoch 0 so far).\n\nThikning back to the linux repository, the largest offset was around of\nthe order of 2 ^ 25 (offset of 1.06 years) and I would assume that holds\n\nOverall, I don't think the added complexity (compared to c) approach)\nmakes up for by greater versatility.\n\n[1]: https://lore.kernel.org/git/20200703082842.GA28027@Abhishek-Arch/\n\nThanks\n- Abhishek\n``````````\n"", 'comment_created': datetime.datetime(2020, 9, 5, 17, 24, 54, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 487544402, 'comment_body': ""[On the Git mailing list](https://lore.kernel.org/git/85v9gh1yaz.fsf@gmail.com), jnareb@gmail.com (Jakub Narębski) wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nHello,\n\nAbhishek Kumar <abhishekkumar8222@gmail.com> writes:\n> On Thu, Sep 03, 2020 at 03:42:43PM +0200, Jakub Narębski wrote:\n>> Abhishek Kumar <abhishekkumar8222@gmail.com> writes:\n>>> On Tue, Aug 25, 2020 at 02:18:24PM +0200, Jakub Narębski wrote:\n>>>> Abhishek Kumar <abhishekkumar8222@gmail.com> writes:\n>>>>\n>>>> ...\n>>>>\n>>>> However, as I wrote, handling GENERATION_NUMBER_V2_OFFSET_MAX is\n>>>> difficult.  As far as I can see, we can choose one of the *three*\n>>>> solutions (the third one is _new_):\n>>>>\n>>>> a. store 64-bit corrected commit date in the GDAT chunk\n>>>>    all possible values are able to be stored, no need for\n>>>>    GENERATION_NUMBER_V2_MAX,\n>>>>\n>>>> b. store 32-bit corrected commit date offset in the GDAT chunk,\n>>>>    if its value is larger than GENERATION_NUMBER_V2_OFFSET_MAX,\n>>>>    do not write GDAT chunk at all (like for backward compatibility\n>>>>    with mixed-version chains of split commit-graph layers),\n>>>>\n>>>> c. store 32-bit corrected commit date offset in the GDAT chunk,\n>>>>    using some kind of overflow handling scheme; for example if\n>>>>    the most significant bit of 32-bit value is 1, then the\n>>>>    rest 31-bits are position in GDOV chunk, which uses 64-bit\n>>>>    to store those corrected commit date offsets that do not\n>>>>    fit in 32 bits.\n>>\n>> Note that I have posted more detailed analysis of advantages and\n>> disadvantages of each of the above solutions in response to 11/11\n>> https://public-inbox.org/git/85o8mwb6nq.fsf@gmail.com/\n>>\n>> I can think of yet another solution, a variant of approach 'c' with\n>> different overflow handling scheme:\n>>\n>> c'.  Store 32-bit corrected commit date offset in the GDAT chunk,\n>>      using the following overflow handling scheme: if the value\n>>      is 0xFFFFFFFF (all bits set to 1, the maximum possible value\n>>      for uint32_t), then the corrected commit date or corrected\n>>      commit date offset can be found in GDOV chunk (Generation\n>>      Data OVerflow handling).\n>>\n>>      The GDOV chunk is composed of:\n>>      - H bytes of commit OID, or 4 bytes (32 bits) of commit pos\n>>      - 8 bytes (64 bits) of corrected commit date or its offset\n>>\n>>      Commits in GDOV chunk are sorted; as we expect for the number\n>>      of commits that require GDOV to be zero or a very small number\n>>      there is no need for GDO Fanout chunk.\n>>\n>>    - advantages:\n>>      * commit-graph is smaller, increasing for abnormal repos\n>>      * overflow limit reduced only by 1 (a single value)\n>>    - disadvantages:\n>>      * most complex code of all proposed solutions\n>>        even more complicated than for solution 'c',\n>>        different from EDGE chunk handling\n>>      * tests would be needed to exercise the overflow code\n>>\n>> Or we can split overflow handling into two chunks: GDOI (Generation Data\n>> Overflow Index) and GDOV, where GDOI would be composed of H bytes of\n>> commit OID or 4 bytes of commit graph position (sorted), and GDOV would\n>> be composed oly of 8 bytes (64 bits) of corrected commit date data.\n>>\n>> This c'') variant has the same advantages and disadvantages as c'), with\n>> negligibly slightly larger disk size and possibly slightly better\n>> performance because of better data locality.\n>>\n>\n> The primary benefit of c') over c) seems to the range of valid offsets -\n> c') can range from [0, 0xFFFFFFFF) whereas offsets for c) can range\n> betwen [0, 0x7FFFFFF].\n>\n> In other words, we should prefer c') over c) only if the offsets are\n> usually in the range [0x7FFFFFFF + 1, 0xFFFFFFFF)\n>\n> Commits were overflowing corrected committer date offsets are rare, and\n> offsets in that particular range are doubly rare. To be wrong within\n> the range would be have an offset of 68 to 136 years, so that's possible\n> only if the corrupted timestamp is in future (it's been 50.68 years since\n> Unix epoch 0 so far).\n\nRight, the c) variant has the same limitation as if corrected commit\ndate offsets were stored as signed 32-bit integer (int32_t), so to have\noverflow we would have date post Y2k38 followed by date of Unix epoch 0.\nVery unlikely.\n\n>\n> Thinking back to the linux repository, the largest offset was around of\n> the order of 2 ^ 25 (offset of 1.06 years) and I would assume that holds\n>\n> Overall, I don't think the added complexity (compared to c) approach)\n> makes up for by greater versatility.\n>\n> [1]: https://lore.kernel.org/git/20200703082842.GA28027@Abhishek-Arch/\n\nAll right.\n\nWith variant c) we have additional advantage in that we can pattern the\ncode on the code for EDGE chunk handling, as you said.\n\nI wanted to warn about the need for sanity checking, like ensuring that\nwe have GDOV chunk and that it is large enough -- but it turns out that\nwe skip this bounds checking for extra edges / EDGE chunk:\n\n\tif (!(edge_value & GRAPH_EXTRA_EDGES_NEEDED)) {\n\t\tpptr = insert_parent_or_die(r, g, edge_value, pptr);\n\t\treturn 1;\n\t}\n\n\tparent_data_ptr = (uint32_t*)(g->chunk_extra_edges +\n\t\t\t  4 * (uint64_t)(edge_value & GRAPH_EDGE_LAST_MASK));\n\tdo {\n\t\tedge_value = get_be32(parent_data_ptr);\n\t\tpptr = insert_parent_or_die(r, g,\n\t\t\t\t\t    edge_value & GRAPH_EDGE_LAST_MASK,\n\t\t\t\t\t    pptr);\n\t\tparent_data_ptr++;\n\t} while (!(edge_value & GRAPH_LAST_EDGE));\n\nBest,\n-- \nJakub Narębski\n``````````\n"", 'comment_created': datetime.datetime(2020, 9, 13, 15, 40, 47, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 496303693, 'comment_body': ""[On the Git mailing list](https://lore.kernel.org/git/857dsdvai2.fsf@gmail.com), Jakub Narębski wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nHello,\n\nJakub Narębski <jnareb@gmail.com> writes:\n> Abhishek Kumar <abhishekkumar8222@gmail.com> writes:\n>> On Thu, Sep 03, 2020 at 03:42:43PM +0200, Jakub Narębski wrote:\n>>> Abhishek Kumar <abhishekkumar8222@gmail.com> writes:\n>>>> On Tue, Aug 25, 2020 at 02:18:24PM +0200, Jakub Narębski wrote:\n>>>>> Abhishek Kumar <abhishekkumar8222@gmail.com> writes:\n>>>>>\n>>>>> ...\n>>>>>\n>>>>> However, as I wrote, handling GENERATION_NUMBER_V2_OFFSET_MAX is\n>>>>> difficult.  As far as I can see, we can choose one of the *three*\n>>>>> solutions (the third one is _new_):\n>>>>>\n>>>>> a. store 64-bit corrected commit date in the GDAT chunk\n>>>>>    all possible values are able to be stored, no need for\n>>>>>    GENERATION_NUMBER_V2_MAX,\n>>>>>\n>>>>> b. store 32-bit corrected commit date offset in the GDAT chunk,\n>>>>>    if its value is larger than GENERATION_NUMBER_V2_OFFSET_MAX,\n>>>>>    do not write GDAT chunk at all (like for backward compatibility\n>>>>>    with mixed-version chains of split commit-graph layers),\n>>>>>\n>>>>> c. store 32-bit corrected commit date offset in the GDAT chunk,\n>>>>>    using some kind of overflow handling scheme; for example if\n>>>>>    the most significant bit of 32-bit value is 1, then the\n>>>>>    rest 31-bits are position in GDOV chunk, which uses 64-bit\n>>>>>    to store those corrected commit date offsets that do not\n>>>>>    fit in 32 bits.\n>>>\n>>> Note that I have posted more detailed analysis of advantages and\n>>> disadvantages of each of the above solutions in response to 11/11\n>>> https://public-inbox.org/git/85o8mwb6nq.fsf@gmail.com/\n>>>\n>>> I can think of yet another solution, a variant of approach 'c'\n[...]\n>>\n>> The primary benefit of c') over c) seems to the range of valid offsets -\n>> c') can range from [0, 0xFFFFFFFF) whereas offsets for c) can range\n>> betwen [0, 0x7FFFFFF].\n>>\n>> In other words, we should prefer c') over c) only if the offsets are\n>> usually in the range [0x7FFFFFFF + 1, 0xFFFFFFFF)\n>>\n>> Commits were overflowing corrected committer date offsets are rare, and\n>> offsets in that particular range are doubly rare. To be wrong within\n>> the range would be have an offset of 68 to 136 years, so that's possible\n>> only if the corrupted timestamp is in future (it's been 50.68 years since\n>> Unix epoch 0 so far).\n>\n> Right, the c) variant has the same limitation as if corrected commit\n> date offsets were stored as signed 32-bit integer (int32_t), so to have\n> overflow we would have date post Y2k38 followed by date of Unix epoch 0.\n> Very unlikely.\n>\n>> Thinking back to the linux repository, the largest offset was around of\n>> the order of 2 ^ 25 (offset of 1.06 years) and I would assume that holds\n>>\n>> Overall, I don't think the added complexity (compared to c) approach)\n>> makes up for by greater versatility.\n>>\n>> [1]: https://lore.kernel.org/git/20200703082842.GA28027@Abhishek-Arch/\n>\n> All right.\n>\n> With variant c) we have additional advantage in that we can pattern the\n> code on the code for EDGE chunk handling, as you said.\n>\n> I wanted to warn about the need for sanity checking, like ensuring that\n> we have GDOV chunk and that it is large enough -- but it turns out that\n> we skip this bounds checking for extra edges / EDGE chunk:\n>\n> \tif (!(edge_value & GRAPH_EXTRA_EDGES_NEEDED)) {\n> \t\tpptr = insert_parent_or_die(r, g, edge_value, pptr);\n> \t\treturn 1;\n> \t}\n>\n> \tparent_data_ptr = (uint32_t*)(g->chunk_extra_edges +\n> \t\t\t  4 * (uint64_t)(edge_value & GRAPH_EDGE_LAST_MASK));\n> \tdo {\n> \t\tedge_value = get_be32(parent_data_ptr);\n> \t\tpptr = insert_parent_or_die(r, g,\n> \t\t\t\t\t    edge_value & GRAPH_EDGE_LAST_MASK,\n> \t\t\t\t\t    pptr);\n> \t\tparent_data_ptr++;\n> \t} while (!(edge_value & GRAPH_LAST_EDGE));\n\nBoth Taylor Blau and Junio C Hamano agree that it is better to store\ncorrected commit date offsets and have overload handling to halve (to\nreduce by 50%) the size of the GDAT chunk.  I have not heard from\nDerrick Stolee.\n\nIt looks then that it is the way to go; as I said that you have\nconvinced me that variant 'c' (EDGE-like) is the best solution for\noverflow handling.\n\nBest,\n-- \nJakub Narębski\n``````````\n"", 'comment_created': datetime.datetime(2020, 9, 29, 0, 14, 54, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 499352582, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/20201005052500.GA7276@Abhishek-Arch), Abhishek Kumar wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Mon, Sep 28, 2020 at 11:48:05PM +0200, Jakub Narębski wrote:\n> Hello,\n> \n> \n> Both Taylor Blau and Junio C Hamano agree that it is better to store\n> corrected commit date offsets and have overload handling to halve (to\n> reduce by 50%) the size of the GDAT chunk.  I have not heard from\n> Derrick Stolee.\n> \n> It looks then that it is the way to go; as I said that you have\n> convinced me that variant \'c\' (EDGE-like) is the best solution for\n> overflow handling.\n> \n\nGreat!\n\nSo I have implemented the variant \'c\' and I am unsure whether my tests\nare exhaustive enough. Can you preview the commit ""commit-graph:\nimplement generation data chunk"" [1] on the pull request?.\n\nApart from that, I am ready to publish the v4 to the mailing list.\n\n[1]: https://github.com/gitgitgadget/git/pull/676/commits/390973da1d744cbb8a08a3b99c991f6d04ae9baf\n\n> Best,\n> -- \n> Jakub Narębski\n``````````\n', 'comment_created': datetime.datetime(2020, 10, 5, 5, 29, 58, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 499567879, 'comment_body': '(Commenting on the commit message here)\r\n\r\n> We test the overflow-related code with the following repo history:\r\n> \r\n>            F - N - U\r\n>           /         \\\r\n> U - N - U            N\r\n>          \\          /\r\n> \t  N - F - N\r\n> \r\n> Where U is a commit with committer date of zero seconds since Unix\r\n> epoch, N is a commit with committer date of 1112354055 (default\r\n> committer date for the test suite) seconds since Unix epoch and F is\r\n> a commit with committer date of (2 ^ 31 - 2) seconds since Unix epoch.\r\n\r\nMy nitpick here is that you use `F`, `N`, and `U` to indicate a property of the commits, but they are not ""a commit"". Instead, I would reword this as ""The commits denoted by \'U\' have committer date of zero seconds..."".', 'comment_created': datetime.datetime(2020, 10, 5, 12, 41, 16, tzinfo=datetime.timezone.utc), 'commenter': 'derrickstolee', 'type': 'User'}, {'comment_id': 499568488, 'comment_body': 'I wonder if this would be clearer using bitwise XOR instead of subtraction:\r\n\r\n`offset_pos = offset ^ CORRECTED_COMMIT_DATE_OFFSET_OVERFLOW;`', 'comment_created': datetime.datetime(2020, 10, 5, 12, 42, 17, tzinfo=datetime.timezone.utc), 'commenter': 'derrickstolee', 'type': 'User'}, {'comment_id': 499568733, 'comment_body': 'Is `timestamp_t` always 64-bits? Perhaps we should use a constant or `sizeof(uint64_t)` here?', 'comment_created': datetime.datetime(2020, 10, 5, 12, 42, 44, tzinfo=datetime.timezone.utc), 'commenter': 'derrickstolee', 'type': 'User'}, {'comment_id': 499569081, 'comment_body': '```\r\n} else\r\n```', 'comment_created': datetime.datetime(2020, 10, 5, 12, 43, 19, tzinfo=datetime.timezone.utc), 'commenter': 'derrickstolee', 'type': 'User'}, {'comment_id': 499569174, 'comment_body': 'for the `else` above, too.', 'comment_created': datetime.datetime(2020, 10, 5, 12, 43, 31, tzinfo=datetime.timezone.utc), 'commenter': 'derrickstolee', 'type': 'User'}, {'comment_id': 499569340, 'comment_body': '`if (...) {`', 'comment_created': datetime.datetime(2020, 10, 5, 12, 43, 50, tzinfo=datetime.timezone.utc), 'commenter': 'derrickstolee', 'type': 'User'}, {'comment_id': 499569701, 'comment_body': '`if (..) {`', 'comment_created': datetime.datetime(2020, 10, 5, 12, 44, 25, tzinfo=datetime.timezone.utc), 'commenter': 'derrickstolee', 'type': 'User'}, {'comment_id': 499570712, 'comment_body': 'I believe @ttaylorr has a `hashwrite_be64()` in the works for a related issue, but here I would consider instead (while that is in-progress):\r\n\r\n```\r\nhashwrite_be32(f, offset >> 32);\r\nhashwrite_be32(f, (uint32_t)offset);\r\n```', 'comment_created': datetime.datetime(2020, 10, 5, 12, 46, 5, tzinfo=datetime.timezone.utc), 'commenter': 'derrickstolee', 'type': 'User'}, {'comment_id': 499571033, 'comment_body': ""Let's keep this out of this patch, as we have enough going on."", 'comment_created': datetime.datetime(2020, 10, 5, 12, 46, 37, tzinfo=datetime.timezone.utc), 'commenter': 'derrickstolee', 'type': 'User'}, {'comment_id': 500476005, 'comment_body': ""`timestamp_t` is not always 64-bits, it's implementation specific. Since the neighbouring code prefers to use constant (for example: `date_high = get_be32(commit_data + g->hash_len + 8) 0x3)`, I will move ahead with using constant."", 'comment_created': datetime.datetime(2020, 10, 6, 17, 33, 15, tzinfo=datetime.timezone.utc), 'commenter': 'abhishekkumar2718', 'type': 'User'}, {'comment_id': 511524639, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/85wnzf43kv.fsf@gmail.com), Jakub Narębski wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\n""Abhishek Kumar via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n\n> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n>\n> commit_gen_cmp is used when writing a commit-graph to sort commits in\n> generation order before computing Bloom filters. Since c49c82aa (commit:\n> move members graph_pos, generation to a slab, 2020-06-17) made it so\n> that \'commit_graph_generation()\' returns \'GENERATION_NUMBER_INFINITY\'\n> during writing, we cannot call it within this function. Instead, access\n> the generation number directly through the slab (i.e., by calling\n> \'commit_graph_data_at(c)->generation\') in order to access it while\n> writing.\n\nThis description is all right, but I think it can be made more clear:\n\n  When running `git commit-graph write --reachable --changed-paths` to\n  compute Bloom filters for changed paths, commits are first sorted by\n  generation number using \'commit_gen_cmp()\'.  Commits with similar\n  generation are more likely to have many trees in common, making the\n  diff faster, see 3d112755.\n\n  However, since c49c82aa (commit: move members graph_pos, generation to\n  a slab, 2020-06-17) made it so that \'commit_graph_generation()\'\n  returns \'GENERATION_NUMBER_INFINITY\' during writing, we cannot call it\n  within this function.  Instead, access the generation number directly\n  through the slab (i.e., by calling \'commit_graph_data_at(c)->generation\')\n  in order to access it while writing.\n\nOr something like that.\n\nWe should also add an explanation why avoiding getter is safe here,\nperhaps adding the following line to the second paragraph:\n\n  It is safe to do because \'commit_gen_cmp()\' from commit-graph.c is\n  static and used only when writing Bloom filters, and because writing\n  changed-paths filters is done after computing generation numbers (if\n  necessary).\n\nOr something like that.\n\n>\n> While measuring performance with `git commit-graph write --reachable\n> --changed-paths` on the linux repository led to around 1m40s for both\n> HEAD and master (and could be due to fault in my measurements), it is\n> still the ""right"" thing to do.\n\nI had to read the above paragraph several times to understand it,\npossibly because I have expected here to be a fix for a performance\nregression.  The commit message for 3d112755 (commit-graph: examine\ncommits by generation number) describes reduction of computation time\nfrom 3m00s to 1m37s.  So I would expect performance with HEAD (i.e.\nbefore those changes) to be around 3m, not the same before and after\nchanges being around 1m40s.\n\nCan anyone recheck this before-and-after benchmark, please?\n\nAnyway, it might be more clear to write it as the following:\n\n  On the Linux kernel repository, this patch didn\'t reduce the\n  computation time for \'git commit-graph write --reachable\n  --changed-paths\', which is around 1m40s both before and after this\n  change.  This could be a fault in my measurements; it is still the\n  ""right"" thing to do.\n\nOr something like that.\n\n> Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> ---\n\nAnyway, it is nice and clear change.\n\n>  commit-graph.c | 4 ++--\n>  1 file changed, 2 insertions(+), 2 deletions(-)\n>\n> diff --git a/commit-graph.c b/commit-graph.c\n> index cb042bdba8..94503e584b 100644\n> --- a/commit-graph.c\n> +++ b/commit-graph.c\n> @@ -144,8 +144,8 @@ static int commit_gen_cmp(const void *va, const void *vb)\n>  \tconst struct commit *a = *(const struct commit **)va;\n>  \tconst struct commit *b = *(const struct commit **)vb;\n>  \n> -\tuint32_t generation_a = commit_graph_generation(a);\n> -\tuint32_t generation_b = commit_graph_generation(b);\n> +\tuint32_t generation_a = commit_graph_data_at(a)->generation;\n> +\tuint32_t generation_b = commit_graph_data_at(b)->generation;\n>  \t/* lower generation commits first */\n>  \tif (generation_a < generation_b)\n>  \t\treturn -1;\n\nBest,\n-- \nJakub Narębski\n``````````\n', 'comment_created': datetime.datetime(2020, 10, 24, 23, 20, 50, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 511526602, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/85o8kr42g0.fsf@gmail.com), Jakub Narębski wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\n""Abhishek Kumar via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n\n> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n>\n> In indegree_walk_step(), we add unvisited parents to the indegree queue.\n> However, parents are not guaranteed to be parsed. As the indegree queue\n> sorts by generation number, let\'s parse parents before inserting them to\n> ensure the correct priority order.\n\nAll right, we need to ensure the parent commit is parsed to know its\ngeneration number, to insert in into priority queue in a correct order.\n\n>\n> Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n\nLooks good.\n\n> ---\n>  revision.c | 3 +++\n>  1 file changed, 3 insertions(+)\n>\n> diff --git a/revision.c b/revision.c\n> index aa62212040..c97abcdde1 100644\n> --- a/revision.c\n> +++ b/revision.c\n> @@ -3381,6 +3381,9 @@ static void indegree_walk_step(struct rev_info *revs)\n>  \t\tstruct commit *parent = p->item;\n>  \t\tint *pi = indegree_slab_at(&info->indegree, parent);\n>  \n> +\t\tif (repo_parse_commit_gently(revs->repo, parent, 1) < 0)\n> +\t\t\treturn;\n> +\n>  \t\tif (*pi)\n>  \t\t\t(*pi)++;\n>  \t\telse\n\nBest,\n-- \nJakub Narębski\n``````````\n', 'comment_created': datetime.datetime(2020, 10, 24, 23, 47, 43, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 511580005, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/85blgq4lxh.fsf@gmail.com), jnareb@gmail.com (Jakub Narębski) wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nHi Abhishek,\n\nIn short: everything is all right, except for the now duplicated test\nnames in t5000 after this commit.\n\n""Abhishek Kumar via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n\n> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n>\n> Both fill_commit_graph_info() and fill_commit_in_graph() parse\n> information present in commit data chunk. Let\'s simplify the\n> implementation by calling fill_commit_graph_info() within\n> fill_commit_in_graph().\n>\n> fill_commit_graph_info() used to not load committer data from commit data\n> chunk. However, with the corrected committer date, we have to load\n> committer date to calculate generation number value.\n\nNice writeup, however the last sentence would in my opinion read better\nin the future tense: we don\'t use generation number v2 yet.  For\nexample:\n\n  However, with upcoming switch to using corrected committer date as\n  generation number v2, we will have to load committer date to compute\n  generation number value anyway.\n\nOr something like that - notice the minor addition and changes.\n\nThe following is slightly unrelated change, but we agreed that it would\nbe better to not separate them; the need for change to the t5000 test is\ncaused by the change described above.\n\n>\n> e51217e15 (t5000: test tar files that overflow ustar headers,\n> 30-06-2016) introduced a test \'generate tar with future mtime\' that\n> creates a commit with committer date of (2 ^ 36 + 1) seconds since\n> EPOCH. The CDAT chunk provides 34-bits for storing committer date, thus\n> committer time overflows into generation number (within CDAT chunk) and\n> has undefined behavior.\n>\n> The test used to pass as fill_commit_graph_info() would not set struct\n> member `date` of struct commit and loads committer date from the object\n> database, generating a tar file with the expected mtime.\n\nI think it should be s/loads/load/, as in ""would load"", but I am not a\nnative English speaker.\n\n>\n> However, with corrected commit date, we will load the committer date\n> from CDAT chunk (truncated to lower 34-bits to populate the generation\n> number. Thus, Git sets date and generates tar file with the truncated\n> mtime.\n>\n> The ustar format (the header format used by most modern tar programs)\n> only has room for 11 (or 12, depending om some implementations) octal\n> digits for the size and mtime of each files.\n>\n> Thus, setting a timestamp of 2 ^ 33 + 1 would overflow the 11-octal\n> digit implementations while still fitting into commit data chunk.\n>\n> Since we want to test 12-octal digit implementations of ustar as well,\n> let\'s modify the existing test to no longer use commit-graph file.\n\nThe description above is for me does not make it entirely clear that we\nadd new test for handling possible 11-octal digit overflow nearly\nidentical to the existing one, and turn off use of commit-graph file for\ntest that checks handling 12-octal digit overflow.\n\n> Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> ---\n>  commit-graph.c      | 27 ++++++++++-----------------\n>  t/t5000-tar-tree.sh | 20 +++++++++++++++++++-\n>  2 files changed, 29 insertions(+), 18 deletions(-)\n>\n> diff --git a/commit-graph.c b/commit-graph.c\n> index 94503e584b..e8362e144e 100644\n> --- a/commit-graph.c\n> +++ b/commit-graph.c\n> @@ -749,15 +749,24 @@ static void fill_commit_graph_info(struct commit *item, struct commit_graph *g,\n>  \tconst unsigned char *commit_data;\n>  \tstruct commit_graph_data *graph_data;\n>  \tuint32_t lex_index;\n> +\tuint64_t date_high, date_low;\n>  \n>  \twhile (pos < g->num_commits_in_base)\n>  \t\tg = g->base_graph;\n>  \n> +\tif (pos >= g->num_commits + g->num_commits_in_base)\n> +\t\tdie(_(""invalid commit position. commit-graph is likely corrupt""));\n> +\n>  \tlex_index = pos - g->num_commits_in_base;\n>  \tcommit_data = g->chunk_commit_data + GRAPH_DATA_WIDTH * lex_index;\n>  \n>  \tgraph_data = commit_graph_data_at(item);\n>  \tgraph_data->graph_pos = pos;\n> +\n> +\tdate_high = get_be32(commit_data + g->hash_len + 8) & 0x3;\n> +\tdate_low = get_be32(commit_data + g->hash_len + 12);\n> +\titem->date = (timestamp_t)((date_high << 32) | date_low);\n> +\n>  \tgraph_data->generation = get_be32(commit_data + g->hash_len + 8) >> 2;\n>  }\n>  \n> @@ -772,38 +781,22 @@ static int fill_commit_in_graph(struct repository *r,\n>  {\n>  \tuint32_t edge_value;\n>  \tuint32_t *parent_data_ptr;\n> -\tuint64_t date_low, date_high;\n>  \tstruct commit_list **pptr;\n> -\tstruct commit_graph_data *graph_data;\n>  \tconst unsigned char *commit_data;\n>  \tuint32_t lex_index;\n>  \n>  \twhile (pos < g->num_commits_in_base)\n>  \t\tg = g->base_graph;\n>  \n> -\tif (pos >= g->num_commits + g->num_commits_in_base)\n> -\t\tdie(_(""invalid commit position. commit-graph is likely corrupt""));\n> +\tfill_commit_graph_info(item, g, pos);\n>  \n> -\t/*\n> -\t * Store the ""full"" position, but then use the\n> -\t * ""local"" position for the rest of the calculation.\n> -\t */\n> -\tgraph_data = commit_graph_data_at(item);\n> -\tgraph_data->graph_pos = pos;\n>  \tlex_index = pos - g->num_commits_in_base;\n> -\n>  \tcommit_data = g->chunk_commit_data + (g->hash_len + 16) * lex_index;\n>  \n>  \titem->object.parsed = 1;\n>  \n>  \tset_commit_tree(item, NULL);\n>  \n> -\tdate_high = get_be32(commit_data + g->hash_len + 8) & 0x3;\n> -\tdate_low = get_be32(commit_data + g->hash_len + 12);\n> -\titem->date = (timestamp_t)((date_high << 32) | date_low);\n> -\n> -\tgraph_data->generation = get_be32(commit_data + g->hash_len + 8) >> 2;\n> -\n>  \tpptr = &item->parents;\n>  \n>  \tedge_value = get_be32(commit_data + g->hash_len);\n\nAll right, looks good for me.\n\nHere second change begins.\n\n> diff --git a/t/t5000-tar-tree.sh b/t/t5000-tar-tree.sh\n> index 3ebb0d3b65..8f41cdc509 100755\n> --- a/t/t5000-tar-tree.sh\n> +++ b/t/t5000-tar-tree.sh\n> @@ -431,11 +431,29 @@ test_expect_success TAR_HUGE,LONG_IS_64BIT \'system tar can read our huge size\' \'\n>  \ttest_cmp expect actual\n>  \'\n>  \n> +test_expect_success TIME_IS_64BIT \'set up repository with far-future commit\' \'\n> +\trm -f .git/index &&\n> +\techo foo >file &&\n> +\tgit add file &&\n> +\tGIT_COMMITTER_DATE=""@17179869183 +0000"" \\\n> +\t\tgit commit -m ""tempori parendum""\n> +\'\n> +\n> +test_expect_success TIME_IS_64BIT \'generate tar with future mtime\' \'\n> +\tgit archive HEAD >future.tar\n> +\'\n> +\n> +test_expect_success TAR_HUGE,TIME_IS_64BIT,TIME_T_IS_64BIT \'system tar can read our future mtime\' \'\n> +\techo 2514 >expect &&\n> +\ttar_info future.tar | cut -d"" "" -f2 >actual &&\n> +\ttest_cmp expect actual\n> +\'\n> +\n\nEverything is all right, except we now have duplicated test names.\n\nPerhaps in the three following tests we should use \'far-far-future\ncommit\' and \'far future mtime\' in place of current \'far-future commit\'\nand \'future mtime\' for tests checking handling 12-digital ditgits\noverflow, or add description how far the future is, for example\n\'far-future commit (2^11 + 1)\', etc.\n\n>  test_expect_success TIME_IS_64BIT \'set up repository with far-future commit\' \'\n>  \trm -f .git/index &&\n>  \techo content >file &&\n>  \tgit add file &&\n> -\tGIT_COMMITTER_DATE=""@68719476737 +0000"" \\\n> +\tGIT_TEST_COMMIT_GRAPH=0 GIT_COMMITTER_DATE=""@68719476737 +0000"" \\\n>  \t\tgit commit -m ""tempori parendum""\n>  \'\n\nBest,\n-- \nJakub Narębski\n``````````\n', 'comment_created': datetime.datetime(2020, 10, 25, 10, 53, 55, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 511599904, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/85imay2z84.fsf@gmail.com), jnareb@gmail.com (Jakub Narębski) wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nHi Abhishek,\n\n""Abhishek Kumar via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n\n> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n>\n> In a preparatory step, let\'s return timestamp_t values from\n> commit_graph_generation(), use timestamp_t for local variables and\n> define GENERATION_NUMBER_INFINITY as (2 ^ 63 - 1) instead.\n\nI think it would be easier to understand if it was explicitely said what\nthis preparatory step prepares for, e.g.:\n\n  In a preparatory step for introducing corrected commit dates as\n  generation number, let\'s return timestamp_t values from...\n\nOr even\n\n  generation number, let\'s change the return type of\n  commit_graph_generation() to timestamp_t, and use ...\n\nOtherwise it looks good.\n\n>\n> We rename GENERATION_NUMBER_MAX to GENERATION_NUMBER_V1_MAX to\n> represent the largest topological level we can store in the commit data\n> chunk.\n>\n> With corrected commit dates implemented, we will have two such *_MAX\n> variables to denote the largest offset and largest topological level\n> that can be stored.\n\nAll right, nice explanation.\n\n>\n> Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n\nNote that there are two changes that are not mentioned in the commit\nmessage, namely adding \'const\'-ness to generation_a/b local variables in\ncommit_gen_cmp() from commit-graph.c, and switching from\nGENERATION_NUMBER_ZERO to GENERATION_NUMBER_INFINITY as the default\n(initial) value for \'max_generation\' in repo_in_merge_bases_many().\n\nWhile the former is a simple ""while-at-it"" change that shouldn\'t affect\ncorrectness, the latter needs an explanation (or fixing if it is wrong).\n\n> ---\n>  commit-graph.c | 22 +++++++++++-----------\n>  commit-graph.h |  4 ++--\n>  commit-reach.c | 36 ++++++++++++++++++------------------\n>  commit-reach.h |  2 +-\n>  commit.c       |  4 ++--\n>  commit.h       |  4 ++--\n>  revision.c     | 10 +++++-----\n>  upload-pack.c  |  2 +-\n>  8 files changed, 42 insertions(+), 42 deletions(-)\n>\n> diff --git a/commit-graph.c b/commit-graph.c\n> index e8362e144e..bfc532de6f 100644\n> --- a/commit-graph.c\n> +++ b/commit-graph.c\n> @@ -99,7 +99,7 @@ uint32_t commit_graph_position(const struct commit *c)\n>  \treturn data ? data->graph_pos : COMMIT_NOT_FROM_GRAPH;\n>  }\n>  \n> -uint32_t commit_graph_generation(const struct commit *c)\n> +timestamp_t commit_graph_generation(const struct commit *c)\n\nAll right.\n\n>  {\n>  \tstruct commit_graph_data *data =\n>  \t\tcommit_graph_data_slab_peek(&commit_graph_data_slab, c);\n> @@ -144,8 +144,8 @@ static int commit_gen_cmp(const void *va, const void *vb)\n>  \tconst struct commit *a = *(const struct commit **)va;\n>  \tconst struct commit *b = *(const struct commit **)vb;\n>  \n> -\tuint32_t generation_a = commit_graph_data_at(a)->generation;\n> -\tuint32_t generation_b = commit_graph_data_at(b)->generation;\n> +\tconst timestamp_t generation_a = commit_graph_data_at(a)->generation;\n> +\tconst timestamp_t generation_b = commit_graph_data_at(b)->generation;\n\nAll right... but this also adds \'const\' qualifier.  I understand that\nyou don\'t want to create separate commit for this ""while at it""\nchange...\n\n>  \t/* lower generation commits first */\n>  \tif (generation_a < generation_b)\n>  \t\treturn -1;\n> @@ -1350,7 +1350,7 @@ static void compute_generation_numbers(struct write_commit_graph_context *ctx)\n>  \t\t\t\t\t_(""Computing commit graph generation numbers""),\n>  \t\t\t\t\tctx->commits.nr);\n>  \tfor (i = 0; i < ctx->commits.nr; i++) {\n> -\t\tuint32_t generation = commit_graph_data_at(ctx->commits.list[i])->generation;\n> +\t\ttimestamp_t generation = commit_graph_data_at(ctx->commits.list[i])->generation;\n\nAll right.\n\n>  \n>  \t\tdisplay_progress(ctx->progress, i + 1);\n>  \t\tif (generation != GENERATION_NUMBER_INFINITY &&\n> @@ -1383,8 +1383,8 @@ static void compute_generation_numbers(struct write_commit_graph_context *ctx)\n>  \t\t\t\tdata->generation = max_generation + 1;\n>  \t\t\t\tpop_commit(&list);\n>  \n> -\t\t\t\tif (data->generation > GENERATION_NUMBER_MAX)\n> -\t\t\t\t\tdata->generation = GENERATION_NUMBER_MAX;\n> +\t\t\t\tif (data->generation > GENERATION_NUMBER_V1_MAX)\n> +\t\t\t\t\tdata->generation = GENERATION_NUMBER_V1_MAX;\n\nAll right, this is the other mentioned change.\n\n>  \t\t\t}\n>  \t\t}\n>  \t}\n> @@ -2404,8 +2404,8 @@ int verify_commit_graph(struct repository *r, struct commit_graph *g, int flags)\n>  \tfor (i = 0; i < g->num_commits; i++) {\n>  \t\tstruct commit *graph_commit, *odb_commit;\n>  \t\tstruct commit_list *graph_parents, *odb_parents;\n> -\t\tuint32_t max_generation = 0;\n> -\t\tuint32_t generation;\n> +\t\ttimestamp_t max_generation = 0;\n> +\t\ttimestamp_t generation;\n\nAll right.\n\n>  \n>  \t\tdisplay_progress(progress, i + 1);\n>  \t\thashcpy(cur_oid.hash, g->chunk_oid_lookup + g->hash_len * i);\n> @@ -2469,11 +2469,11 @@ int verify_commit_graph(struct repository *r, struct commit_graph *g, int flags)\n>  \t\t\tcontinue;\n>  \n>  \t\t/*\n> -\t\t * If one of our parents has generation GENERATION_NUMBER_MAX, then\n> -\t\t * our generation is also GENERATION_NUMBER_MAX. Decrement to avoid\n> +\t\t * If one of our parents has generation GENERATION_NUMBER_V1_MAX, then\n> +\t\t * our generation is also GENERATION_NUMBER_V1_MAX. Decrement to avoid\n>  \t\t * extra logic in the following condition.\n>  \t\t */\n> -\t\tif (max_generation == GENERATION_NUMBER_MAX)\n> +\t\tif (max_generation == GENERATION_NUMBER_V1_MAX)\n>  \t\t\tmax_generation--;\n\nAll right.  Nice fixing a comment too.\n\n>  \n>  \t\tgeneration = commit_graph_generation(graph_commit);\n> diff --git a/commit-graph.h b/commit-graph.h\n> index f8e92500c6..8be247fa35 100644\n> --- a/commit-graph.h\n> +++ b/commit-graph.h\n> @@ -144,12 +144,12 @@ void disable_commit_graph(struct repository *r);\n>  \n>  struct commit_graph_data {\n>  \tuint32_t graph_pos;\n> -\tuint32_t generation;\n> +\ttimestamp_t generation;\n>  };\n\nAll right.\n\n>  \n>  /*\n>   * Commits should be parsed before accessing generation, graph positions.\n>   */\n> -uint32_t commit_graph_generation(const struct commit *);\n> +timestamp_t commit_graph_generation(const struct commit *);\n>  uint32_t commit_graph_position(const struct commit *);\n>  #endif\n\nAll right.\n\n> diff --git a/commit-reach.c b/commit-reach.c\n> index 50175b159e..20b48b872b 100644\n> --- a/commit-reach.c\n> +++ b/commit-reach.c\n> @@ -32,12 +32,12 @@ static int queue_has_nonstale(struct prio_queue *queue)\n>  static struct commit_list *paint_down_to_common(struct repository *r,\n>  \t\t\t\t\t\tstruct commit *one, int n,\n>  \t\t\t\t\t\tstruct commit **twos,\n> -\t\t\t\t\t\tint min_generation)\n> +\t\t\t\t\t\ttimestamp_t min_generation)\n>  {\n>  \tstruct prio_queue queue = { compare_commits_by_gen_then_commit_date };\n>  \tstruct commit_list *result = NULL;\n>  \tint i;\n> -\tuint32_t last_gen = GENERATION_NUMBER_INFINITY;\n> +\ttimestamp_t last_gen = GENERATION_NUMBER_INFINITY;\n\nAll right.\n\n>  \n>  \tif (!min_generation)\n>  \t\tqueue.compare = compare_commits_by_commit_date;\n> @@ -58,10 +58,10 @@ static struct commit_list *paint_down_to_common(struct repository *r,\n>  \t\tstruct commit *commit = prio_queue_get(&queue);\n>  \t\tstruct commit_list *parents;\n>  \t\tint flags;\n> -\t\tuint32_t generation = commit_graph_generation(commit);\n> +\t\ttimestamp_t generation = commit_graph_generation(commit);\n\nAll right.\n\n>  \n>  \t\tif (min_generation && generation > last_gen)\n> -\t\t\tBUG(""bad generation skip %8x > %8x at %s"",\n> +\t\t\tBUG(""bad generation skip %""PRItime"" > %""PRItime"" at %s"",\n\nAll right; nice of you noticing this issue.\n\n>  \t\t\t    generation, last_gen,\n>  \t\t\t    oid_to_hex(&commit->object.oid));\n>  \t\tlast_gen = generation;\n> @@ -177,12 +177,12 @@ static int remove_redundant(struct repository *r, struct commit **array, int cnt\n>  \t\trepo_parse_commit(r, array[i]);\n>  \tfor (i = 0; i < cnt; i++) {\n>  \t\tstruct commit_list *common;\n> -\t\tuint32_t min_generation = commit_graph_generation(array[i]);\n> +\t\ttimestamp_t min_generation = commit_graph_generation(array[i]);\n>  \n>  \t\tif (redundant[i])\n>  \t\t\tcontinue;\n>  \t\tfor (j = filled = 0; j < cnt; j++) {\n> -\t\t\tuint32_t curr_generation;\n> +\t\t\ttimestamp_t curr_generation;\n>  \t\t\tif (i == j || redundant[j])\n>  \t\t\t\tcontinue;\n>  \t\t\tfilled_index[filled] = j;\n\nAll right.\n\n> @@ -321,7 +321,7 @@ int repo_in_merge_bases_many(struct repository *r, struct commit *commit,\n>  {\n>  \tstruct commit_list *bases;\n>  \tint ret = 0, i;\n> -\tuint32_t generation, max_generation = GENERATION_NUMBER_ZERO;\n> +\ttimestamp_t generation, max_generation = GENERATION_NUMBER_INFINITY;\n\nThe change of type from uint32_t to timestamp_t is expected, but the\nchange from GENERATION_NUMBER_ZERO to GENERATION_NUMBER_INFINITY is not.\n\nThis might be caused by the fact that repo_in_merge_bases_many()\nswitched from using min_generation and GENERATION_NUMBER_INFINITY to\nusing max_generation and GENERATION_NUMBER_ZERO. Or the reverse: I see\none version on https://github.com/git/git, and other version in \'master\'\npulled from https://github.com/git-for-windows/git\n\nCertainly max_generation should be paired with GENERATION_NUMBER_ZERO,\nand min_generation with GENERATION_NUMBER_INFINITY.\n\n>  \n>  \tif (repo_parse_commit(r, commit))\n>  \t\treturn ret;\n> @@ -470,7 +470,7 @@ static int in_commit_list(const struct commit_list *want, struct commit *c)\n>  static enum contains_result contains_test(struct commit *candidate,\n>  \t\t\t\t\t  const struct commit_list *want,\n>  \t\t\t\t\t  struct contains_cache *cache,\n> -\t\t\t\t\t  uint32_t cutoff)\n> +\t\t\t\t\t  timestamp_t cutoff)\n\nAll right.\n\nSidenote: this parameter should probably be named gen_cutoff, for\nconsistency and better readability (but that was the existing state),\nbut this would also mean more changes.\n\n\n>  {\n>  \tenum contains_result *cached = contains_cache_at(cache, candidate);\n>  \n> @@ -506,11 +506,11 @@ static enum contains_result contains_tag_algo(struct commit *candidate,\n>  {\n>  \tstruct contains_stack contains_stack = { 0, 0, NULL };\n>  \tenum contains_result result;\n> -\tuint32_t cutoff = GENERATION_NUMBER_INFINITY;\n> +\ttimestamp_t cutoff = GENERATION_NUMBER_INFINITY;\n\nSidenote: this variable should probably be named gen_cutoff, for\nconsistency and better readability (but that was the existing state).\nHowever changing it would pollute this commit with unrelated changes;\nit is not that big of an isseu that it *requires* fixing.\n\n>  \tconst struct commit_list *p;\n>  \n>  \tfor (p = want; p; p = p->next) {\n> -\t\tuint32_t generation;\n> +\t\ttimestamp_t generation;\n>  \t\tstruct commit *c = p->item;\n>  \t\tload_commit_graph_info(the_repository, c);\n>  \t\tgeneration = commit_graph_generation(c);\n\nAll right.\n\n> @@ -566,8 +566,8 @@ static int compare_commits_by_gen(const void *_a, const void *_b)\n>  \tconst struct commit *a = *(const struct commit * const *)_a;\n>  \tconst struct commit *b = *(const struct commit * const *)_b;\n>  \n> -\tuint32_t generation_a = commit_graph_generation(a);\n> -\tuint32_t generation_b = commit_graph_generation(b);\n> +\ttimestamp_t generation_a = commit_graph_generation(a);\n> +\ttimestamp_t generation_b = commit_graph_generation(b);\n\nAll right.\n\n>  \n>  \tif (generation_a < generation_b)\n>  \t\treturn -1;\n> @@ -580,7 +580,7 @@ int can_all_from_reach_with_flag(struct object_array *from,\n>  \t\t\t\t unsigned int with_flag,\n>  \t\t\t\t unsigned int assign_flag,\n>  \t\t\t\t time_t min_commit_date,\n> -\t\t\t\t uint32_t min_generation)\n> +\t\t\t\t timestamp_t min_generation)\n>  {\n>  \tstruct commit **list = NULL;\n>  \tint i;\n\nAll right.\n\n> @@ -681,13 +681,13 @@ int can_all_from_reach(struct commit_list *from, struct commit_list *to,\n>  \ttime_t min_commit_date = cutoff_by_min_date ? from->item->date : 0;\n>  \tstruct commit_list *from_iter = from, *to_iter = to;\n>  \tint result;\n> -\tuint32_t min_generation = GENERATION_NUMBER_INFINITY;\n> +\ttimestamp_t min_generation = GENERATION_NUMBER_INFINITY;\n>  \n>  \twhile (from_iter) {\n>  \t\tadd_object_array(&from_iter->item->object, NULL, &from_objs);\n>  \n>  \t\tif (!parse_commit(from_iter->item)) {\n> -\t\t\tuint32_t generation;\n> +\t\t\ttimestamp_t generation;\n>  \t\t\tif (from_iter->item->date < min_commit_date)\n>  \t\t\t\tmin_commit_date = from_iter->item->date;\n>\n\nAll right.\n\n> @@ -701,7 +701,7 @@ int can_all_from_reach(struct commit_list *from, struct commit_list *to,\n>  \n>  \twhile (to_iter) {\n>  \t\tif (!parse_commit(to_iter->item)) {\n> -\t\t\tuint32_t generation;\n> +\t\t\ttimestamp_t generation;\n>  \t\t\tif (to_iter->item->date < min_commit_date)\n>  \t\t\t\tmin_commit_date = to_iter->item->date;\n>\n\nAll right.\n\n> @@ -741,13 +741,13 @@ struct commit_list *get_reachable_subset(struct commit **from, int nr_from,\n>  \tstruct commit_list *found_commits = NULL;\n>  \tstruct commit **to_last = to + nr_to;\n>  \tstruct commit **from_last = from + nr_from;\n> -\tuint32_t min_generation = GENERATION_NUMBER_INFINITY;\n> +\ttimestamp_t min_generation = GENERATION_NUMBER_INFINITY;\n>  \tint num_to_find = 0;\n>  \n>  \tstruct prio_queue queue = { compare_commits_by_gen_then_commit_date };\n>  \n>  \tfor (item = to; item < to_last; item++) {\n> -\t\tuint32_t generation;\n> +\t\ttimestamp_t generation;\n>  \t\tstruct commit *c = *item;\n>  \n>  \t\tparse_commit(c);\n\nAll right.\n\n> diff --git a/commit-reach.h b/commit-reach.h\n> index b49ad71a31..148b56fea5 100644\n> --- a/commit-reach.h\n> +++ b/commit-reach.h\n> @@ -87,7 +87,7 @@ int can_all_from_reach_with_flag(struct object_array *from,\n>  \t\t\t\t unsigned int with_flag,\n>  \t\t\t\t unsigned int assign_flag,\n>  \t\t\t\t time_t min_commit_date,\n> -\t\t\t\t uint32_t min_generation);\n> +\t\t\t\t timestamp_t min_generation);\n>  int can_all_from_reach(struct commit_list *from, struct commit_list *to,\n>  \t\t       int commit_date_cutoff);\n>\n\nAll right.\n\n> diff --git a/commit.c b/commit.c\n> index f53429c0ac..3b488381d5 100644\n> --- a/commit.c\n> +++ b/commit.c\n> @@ -731,8 +731,8 @@ int compare_commits_by_author_date(const void *a_, const void *b_,\n>  int compare_commits_by_gen_then_commit_date(const void *a_, const void *b_, void *unused)\n>  {\n>  \tconst struct commit *a = a_, *b = b_;\n> -\tconst uint32_t generation_a = commit_graph_generation(a),\n> -\t\t       generation_b = commit_graph_generation(b);\n> +\tconst timestamp_t generation_a = commit_graph_generation(a),\n> +\t\t\t  generation_b = commit_graph_generation(b);\n>\n\nAll right (assuming that the indent after change looks all right; but\neven if it doesn\'t t would be a very minor issue).\n\n>  \t/* newer commits first */\n>  \tif (generation_a < generation_b)\n> diff --git a/commit.h b/commit.h\n> index 5467786c7b..33c66b2177 100644\n> --- a/commit.h\n> +++ b/commit.h\n> @@ -11,8 +11,8 @@\n>  #include ""commit-slab.h""\n>  \n>  #define COMMIT_NOT_FROM_GRAPH 0xFFFFFFFF\n> -#define GENERATION_NUMBER_INFINITY 0xFFFFFFFF\n> -#define GENERATION_NUMBER_MAX 0x3FFFFFFF\n> +#define GENERATION_NUMBER_INFINITY ((1ULL << 63) - 1)\n> +#define GENERATION_NUMBER_V1_MAX 0x3FFFFFFF\n>  #define GENERATION_NUMBER_ZERO 0\n>\n\nAll right, we redefine GENERATION_NUMBER_INFINITY and rename\nGENERATION_NUMBER_MAX.\n\n>  struct commit_list {\n> diff --git a/revision.c b/revision.c\n> index c97abcdde1..2861f1c45c 100644\n> --- a/revision.c\n> +++ b/revision.c\n> @@ -3308,7 +3308,7 @@ define_commit_slab(indegree_slab, int);\n>  define_commit_slab(author_date_slab, timestamp_t);\n>  \n>  struct topo_walk_info {\n> -\tuint32_t min_generation;\n> +\ttimestamp_t min_generation;\n>  \tstruct prio_queue explore_queue;\n>  \tstruct prio_queue indegree_queue;\n>  \tstruct prio_queue topo_queue;\n\nAll right.\n\n> @@ -3354,7 +3354,7 @@ static void explore_walk_step(struct rev_info *revs)\n>  }\n>  \n>  static void explore_to_depth(struct rev_info *revs,\n> -\t\t\t     uint32_t gen_cutoff)\n> +\t\t\t     timestamp_t gen_cutoff)\n>  {\n>  \tstruct topo_walk_info *info = revs->topo_walk_info;\n>  \tstruct commit *c;\n\nAll right.\n\n> @@ -3397,7 +3397,7 @@ static void indegree_walk_step(struct rev_info *revs)\n>  }\n>  \n>  static void compute_indegrees_to_depth(struct rev_info *revs,\n> -\t\t\t\t       uint32_t gen_cutoff)\n> +\t\t\t\t       timestamp_t gen_cutoff)\n>  {\n>  \tstruct topo_walk_info *info = revs->topo_walk_info;\n>  \tstruct commit *c;\n\nAll right.\n\n> @@ -3455,7 +3455,7 @@ static void init_topo_walk(struct rev_info *revs)\n>  \tinfo->min_generation = GENERATION_NUMBER_INFINITY;\n>  \tfor (list = revs->commits; list; list = list->next) {\n>  \t\tstruct commit *c = list->item;\n> -\t\tuint32_t generation;\n> +\t\ttimestamp_t generation;\n>  \n>  \t\tif (repo_parse_commit_gently(revs->repo, c, 1))\n>  \t\t\tcontinue;\n\nAll right.\n\n> @@ -3516,7 +3516,7 @@ static void expand_topo_walk(struct rev_info *revs, struct commit *commit)\n>  \tfor (p = commit->parents; p; p = p->next) {\n>  \t\tstruct commit *parent = p->item;\n>  \t\tint *pi;\n> -\t\tuint32_t generation;\n> +\t\ttimestamp_t generation;\n>  \n>  \t\tif (parent->object.flags & UNINTERESTING)\n>  \t\t\tcontinue;\n\nAll right.\n\n> diff --git a/upload-pack.c b/upload-pack.c\n> index 3b858eb457..fdb82885b6 100644\n> --- a/upload-pack.c\n> +++ b/upload-pack.c\n> @@ -497,7 +497,7 @@ static int got_oid(struct upload_pack_data *data,\n>  \n>  static int ok_to_give_up(struct upload_pack_data *data)\n>  {\n> -\tuint32_t min_generation = GENERATION_NUMBER_ZERO;\n> +\ttimestamp_t min_generation = GENERATION_NUMBER_ZERO;\n>  \n>  \tif (!data->have_obj.nr)\n>  \t\treturn 0;\n\nAll right.\n\nThe only thing to check is if you have changed the type in all the\nplaces that need it. My cursory examination shows that those are all\nplaces than need fixing.\n\nNote that the \'generation\' variable in git-name-rev, git-fsck and in\ngit-show-branch (snd sha1-name.c) means something different.\n\nAlso, \'first_generation\' variable in generation_numbers_enabled() (part\nof commit-graph.c) examines and will examine generation number v1 i.e.\ntopological levels, and do not need type change... though it may require\nname change in some time in the future; the generation number\ncomputation path also does not require change type, though variables\nwould be renamed in the future commit.\n\nBest,\n-- \nJakub Narębski\n``````````\n', 'comment_created': datetime.datetime(2020, 10, 25, 13, 50, 59, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 511647819, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/X5Xm5nlFK39o0rkJ@nand.local), Taylor Blau wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Sun, Oct 25, 2020 at 01:16:48AM +0200, Jakub Narębski wrote:\n> ""Abhishek Kumar via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n>\n> > While measuring performance with `git commit-graph write --reachable\n> > --changed-paths` on the linux repository led to around 1m40s for both\n> > HEAD and master (and could be due to fault in my measurements), it is\n> > still the ""right"" thing to do.\n>\n> I had to read the above paragraph several times to understand it,\n> possibly because I have expected here to be a fix for a performance\n> regression.  The commit message for 3d112755 (commit-graph: examine\n> commits by generation number) describes reduction of computation time\n> from 3m00s to 1m37s.  So I would expect performance with HEAD (i.e.\n> before those changes) to be around 3m, not the same before and after\n> changes being around 1m40s.\n>\n> Can anyone recheck this before-and-after benchmark, please?\n\nMy hunch is that our heuristic to fall back to the commits \'date\'\nvalue is saving us here. commit_gen_cmp() first compares the generation\nnumbers, breaking ties by \'date\' as a heuristic. But since all\ngeneration number queries return GENERATION_NUMBER_INFINITY during\nwriting, we\'re relying on our heuristic entirely.\n\nI haven\'t looked much further than that, other than to see that I could\nget about a ~4sec speed-up with this patch as compared to v2.29.1 in the\ncomputing Bloom filters region on the kernel.\n\n> Anyway, it might be more clear to write it as the following:\n>\n>   On the Linux kernel repository, this patch didn\'t reduce the\n>   computation time for \'git commit-graph write --reachable\n>   --changed-paths\', which is around 1m40s both before and after this\n>   change.  This could be a fault in my measurements; it is still the\n>   ""right"" thing to do.\n>\n> Or something like that.\n\nAssuming that we are in fact being saved by the ""date"" heuristic, I\'d\nprobably write the following commit message instead:\n\n  Before computing Bloom filters, the commit-graph machinery uses\n  commit_gen_cmp to sort commits by generation order for improved diff\n  performance. 3d11275505 (commit-graph: examine commits by generation\n  number, 2020-03-30) claims that this sort can reduce the time spent to\n  compute Bloom filters by nearly half.\n\n  But since c49c82aa4c (commit: move members graph_pos, generation to a\n  slab, 2020-06-17), this optimization is broken, since asking for\n  \'commit_graph_generation()\' directly returns GENERATION_NUMBER_INFINITY\n  while writing.\n\n  Not all hope is lost, though: \'commit_graph_generation()\' falls\n  back to comparing commits by their date when they have equal generation\n  number, and so since c49c82aa4c is purely a date comparison function.\n  This heuristic is good enough that we don\'t seem to loose appreciable\n  performance while computing Bloom filters. [Benchmark that we loose\n  about ~4sec before/after c49c82aa4c9...]\n\n  So, avoid the uesless \'commit_graph_generation()\' while writing by\n  instead accessing the slab directly. This returns the newly-computed\n  generation numbers, and allows us to avoid the heuristic by directly\n  comparing generation numbers.\n\nThanks,\nTaylor\n``````````\n', 'comment_created': datetime.datetime(2020, 10, 25, 21, 3, 4, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 511656131, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/85tuui0x3m.fsf@gmail.com), jnareb@gmail.com (Jakub Narębski) wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\n""Abhishek Kumar via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n\n> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n>\n> In a later commit we will introduce corrected commit date as the\n> generation number v2. This value will be stored in the new seperate\n> Generation Data chunk. However, to ensure backwards compatibility with\n> ""Old"" Git we need to continue to write generation number v1, which is\n> topological level, to the commit data chunk. This means that we need to\n> compute both versions of generation numbers when writing the\n> commit-graph file. Therefore, let\'s introduce a commit-slab to store\n> topological levels; corrected commit date will be stored in the member\n> `generation` of struct commit_graph_data.\n>\n> When Git creates a split commit-graph, it takes advantage of the\n> generation values that have been computed already and present in\n> existing commit-graph files.\n>\n> So, let\'s add a pointer to struct commit_graph as well as struct\n> write_commit_graph_context to the topological level commit-slab\n> and populate it with topological levels while writing a commit-graph\n> file.\n\nI think you meant here ""add a pointer in `struct commit_graph` as well\nas in `struct write_commit_graph_context`..."".\n\nPerhaps we should add the information that it is done that way to be\nable to allocate topo_level_slab only when needed, in the\nwrite_commit_graph(), and adding new member to those struct is required\nto pass it through the call chain (modifying `struct commit_graph` is\nneeded for fill_commit_graph_info()).  But that might be too much detail\nto put in the commit message.\n\n>\n> Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> ---\n>  commit-graph.c | 47 ++++++++++++++++++++++++++++++++---------------\n>  commit-graph.h |  1 +\n>  2 files changed, 33 insertions(+), 15 deletions(-)\n>\n\nLet me reorder those files for easier review.\n\n> diff --git a/commit-graph.h b/commit-graph.h\n> index 8be247fa35..2e9aa7824e 100644\n> --- a/commit-graph.h\n> +++ b/commit-graph.h\n> @@ -73,6 +73,7 @@ struct commit_graph {\n>  \tconst unsigned char *chunk_bloom_indexes;\n>  \tconst unsigned char *chunk_bloom_data;\n>  \n> +\tstruct topo_level_slab *topo_levels;\n>  \tstruct bloom_filter_settings *bloom_filter_settings;\n>  };\n\nAll right, here we add new member to `struct commit_graph` type.\n\n> diff --git a/commit-graph.c b/commit-graph.c\n> index bfc532de6f..cedd311024 100644\n> --- a/commit-graph.c\n> +++ b/commit-graph.c\n> @@ -962,6 +967,7 @@ struct write_commit_graph_context {\n>  \t\t changed_paths:1,\n>  \t\t order_by_pack:1;\n>  \n> +\tstruct topo_level_slab *topo_levels;\n>  \tconst struct commit_graph_opts *opts;\n>  \tsize_t total_bloom_filter_data_size;\n>  \tconst struct bloom_filter_settings *bloom_settings;\n\nAll right, here we add new member to `struct write_commit_graph_context`\ntype, which is local to commit-graph.c.\n\n> @@ -64,6 +64,8 @@ void git_test_write_commit_graph_or_die(void)\n>  /* Remember to update object flag allocation in object.h */\n>  #define REACHABLE       (1u<<15)\n>  \n> +define_commit_slab(topo_level_slab, uint32_t);\n> +\n\nAll right, here we define new slab for storing topological levels; this\njust defines new type. Note that we do not define any setters and\ngetters to handle non-zero initialization, like we have for\ncommit_graph_data_slab.\n\n>  /* Keep track of the order in which commits are added to our list. */\n>  define_commit_slab(commit_pos, int);\n>  static struct commit_pos commit_pos = COMMIT_SLAB_INIT(1, commit_pos);\n> @@ -768,6 +770,9 @@ static void fill_commit_graph_info(struct commit *item, struct commit_graph *g,\n>  \titem->date = (timestamp_t)((date_high << 32) | date_low);\n>  \n>  \tgraph_data->generation = get_be32(commit_data + g->hash_len + 8) >> 2;\n> +\n> +\tif (g->topo_levels)\n> +\t\t*topo_level_slab_at(g->topo_levels, item) = get_be32(commit_data + g->hash_len + 8) >> 2;\n\nI guess using get_be32() is repeated in this newly added part of code\nbecause previous part would be changed to read in generation number v2,\nif available, and we won\'t be then able to use\n\n\t\t*topo_level_slab_at(g->topo_levels, item) = graph_data->generation;\n\nAll right, that\'s smart.\n\n\nI guess that in fill_commit_graph_info() we don\'t know if we are reading\ncommit-graph, when topo levels slab is not present, or whether we are\nextending and writing the commit-graph file, when we need to fill it\nwith current commit-graph data.\n\nThe fact that fill_commit_graph_info() takes \'struct commit_graph\' also\nexplains why we need to add pointer to a topo_levels slab to both\nstructs.\n\n>  }\n>  \n>  static inline void set_commit_tree(struct commit *c, struct tree *t)\n[...]\n> @@ -2142,6 +2146,7 @@ int write_commit_graph(struct object_directory *odb,\n>  \tint res = 0;\n>  \tint replace = 0;\n>  \tstruct bloom_filter_settings bloom_settings = DEFAULT_BLOOM_FILTER_SETTINGS;\n> +\tstruct topo_level_slab topo_levels;\n>  \n>  \tif (!commit_graph_compatible(the_repository))\n>  \t\treturn 0;\n> @@ -2163,6 +2168,18 @@ int write_commit_graph(struct object_directory *odb,\n>  \t\t\t\t\t\t\t bloom_settings.max_changed_paths);\n>  \tctx->bloom_settings = &bloom_settings;\n>  \n> +\tinit_topo_level_slab(&topo_levels);\n> +\tctx->topo_levels = &topo_levels;\n> +\n> +\tif (ctx->r->objects->commit_graph) {\n> +\t\tstruct commit_graph *g = ctx->r->objects->commit_graph;\n> +\n> +\t\twhile (g) {\n> +\t\t\tg->topo_levels = &topo_levels;\n> +\t\t\tg = g->base_graph;\n> +\t\t}\n> +\t}\n> +\n>  \tif (flags & COMMIT_GRAPH_WRITE_BLOOM_FILTERS)\n>  \t\tctx->changed_paths = 1;\n>  \tif (!(flags & COMMIT_GRAPH_NO_WRITE_BLOOM_FILTERS)) {\n\nAll right, we need topo_level_slab only for writing the commit-graph, so\nwe allocate it with init_*_slab() in write_commit_graph(), and set\npointers to it in `struct write_commit_graph_context *ctx` and in\n`struct commit_graph` for each layer in the commit graph.  This is\nneeded to pass it down the call-chain.\n\nLooks good to me.\n\n> @@ -1108,7 +1114,7 @@ static int write_graph_chunk_data(struct hashfile *f,\n>  \t\telse\n>  \t\t\tpackedDate[0] = 0;\n>  \n> -\t\tpackedDate[0] |= htonl(commit_graph_data_at(*list)->generation << 2);\n> +\t\tpackedDate[0] |= htonl(*topo_level_slab_at(ctx->topo_levels, *list) << 2);\n>\n\nAll right, write_graph_chunk_data() is called from write_commit_graph(),\nso we know that cxt->topo_levels is not NULL.\n\n>  \t\tpackedDate[1] = htonl((*list)->date);\n>  \t\thashwrite(f, packedDate, 8);\n> @@ -1350,11 +1356,11 @@ static void compute_generation_numbers(struct write_commit_graph_context *ctx)\n>  \t\t\t\t\t_(""Computing commit graph generation numbers""),\n>  \t\t\t\t\tctx->commits.nr);\n>  \tfor (i = 0; i < ctx->commits.nr; i++) {\n> -\t\ttimestamp_t generation = commit_graph_data_at(ctx->commits.list[i])->generation;\n> +\t\ttimestamp_t level = *topo_level_slab_at(ctx->topo_levels, ctx->commits.list[i]);\n>\n\nAll right, we know that compute_generation_numbers() is called by the\nwrite_commit_graph(), so we know that cxt->topo_levels is not NULL.\n\nAlso, we rename \'generation\' to \'level\' in preparation for the time when\nwe would be computing *both* topological level (for backward\ncompatibility) and corrected committer date (to be used as generation\nnumber v2).  All right.\n\n>  \t\tdisplay_progress(ctx->progress, i + 1);\n> -\t\tif (generation != GENERATION_NUMBER_INFINITY &&\n> -\t\t    generation != GENERATION_NUMBER_ZERO)\n> +\t\tif (level != GENERATION_NUMBER_INFINITY &&\n> +\t\t    level != GENERATION_NUMBER_ZERO)\n>  \t\t\tcontinue;\n\nSame here, the results of renaming of \'generation\' local variable to\n\'level\'.\n\n>  \n>  \t\tcommit_list_insert(ctx->commits.list[i], &list);\n> @@ -1362,29 +1368,27 @@ static void compute_generation_numbers(struct write_commit_graph_context *ctx)\n>  \t\t\tstruct commit *current = list->item;\n>  \t\t\tstruct commit_list *parent;\n>  \t\t\tint all_parents_computed = 1;\n> -\t\t\tuint32_t max_generation = 0;\n> +\t\t\tuint32_t max_level = 0;\n\nSimilarly, we rename \'max_generation\' to \'max_level\'.\n\n>  \n>  \t\t\tfor (parent = current->parents; parent; parent = parent->next) {\n> -\t\t\t\tgeneration = commit_graph_data_at(parent->item)->generation;\n> +\t\t\t\tlevel = *topo_level_slab_at(ctx->topo_levels, parent->item);\n>  \n> -\t\t\t\tif (generation == GENERATION_NUMBER_INFINITY ||\n> -\t\t\t\t    generation == GENERATION_NUMBER_ZERO) {\n> +\t\t\t\tif (level == GENERATION_NUMBER_INFINITY ||\n> +\t\t\t\t    level == GENERATION_NUMBER_ZERO) {\n>  \t\t\t\t\tall_parents_computed = 0;\n>  \t\t\t\t\tcommit_list_insert(parent->item, &list);\n>  \t\t\t\t\tbreak;\n> -\t\t\t\t} else if (generation > max_generation) {\n> -\t\t\t\t\tmax_generation = generation;\n> +\t\t\t\t} else if (level > max_level) {\n> +\t\t\t\t\tmax_level = level;\n>  \t\t\t\t}\n>  \t\t\t}\n\nContinuation of those renames.\n\n>  \n>  \t\t\tif (all_parents_computed) {\n> -\t\t\t\tstruct commit_graph_data *data = commit_graph_data_at(current);\n> -\n> -\t\t\t\tdata->generation = max_generation + 1;\n>  \t\t\t\tpop_commit(&list);\n>  \n> -\t\t\t\tif (data->generation > GENERATION_NUMBER_V1_MAX)\n> -\t\t\t\t\tdata->generation = GENERATION_NUMBER_V1_MAX;\n> +\t\t\t\tif (max_level > GENERATION_NUMBER_V1_MAX - 1)\n> +\t\t\t\t\tmax_level = GENERATION_NUMBER_V1_MAX - 1;\n> +\t\t\t\t*topo_level_slab_at(ctx->topo_levels, current) = max_level + 1;\n\nThis is a bit safer way to handle possible overflow: instead of\n\n  final = max_found + 1;            /* set to maximum plus 1 */\n  if (final > MAX_POSSIBLE_VALUE)   /* handle overflow */\n      final = MAX_POSSIBLE_VALUE;\n\nwhere we can have problems if MAX_POSSIBLE_VALUE overflows, we use the\nfollowing pattern:\n\n  if (max_found > MAX_POSSIBLE_VALUE - 1)  /* handle overflow */\n      max_found > MAX_POSSIBLE_VALUE - 1;\n  final = max_found + 1;                   /* set to maximum plus 1 */\n\nIt is just a bit obscured by renaming variable and switch to using\ncommit slab.\n\nIt is not that important for topological level, where\nGENERATION_NUMBER_V1_MAX is smaller than maximum possible value, but it\nwould be important for generation number v2.\n\n>  \t\t\t}\n>  \t\t}\n>  \t}\n\nBest,\n--\nJakub Narębski\n``````````\n', 'comment_created': datetime.datetime(2020, 10, 25, 22, 18, 18, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 512446816, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/20201027063306.GA15674@Abhishek-Arch), Abhishek Kumar wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nHello Dr. Narębski,\n\nOn Sun, Oct 25, 2020 at 11:52:42AM +0100, Jakub Narębski wrote:\n> Hi Abhishek,\n> \n> In short: everything is all right, except for the now duplicated test\n> names in t5000 after this commit.\n> \n> ""Abhishek Kumar via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n> \n> > From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> >\n> > Both fill_commit_graph_info() and fill_commit_in_graph() parse\n> > information present in commit data chunk. Let\'s simplify the\n> > implementation by calling fill_commit_graph_info() within\n> > fill_commit_in_graph().\n> >\n> > fill_commit_graph_info() used to not load committer data from commit data\n> > chunk. However, with the corrected committer date, we have to load\n> > committer date to calculate generation number value.\n> \n> Nice writeup, however the last sentence would in my opinion read better\n> in the future tense: we don\'t use generation number v2 yet.  For\n> example:\n> \n>   However, with upcoming switch to using corrected committer date as\n>   generation number v2, we will have to load committer date to compute\n>   generation number value anyway.\n> \n> Or something like that - notice the minor addition and changes.\n> \n\nThanks for the change, it looks better!\n\n> The following is slightly unrelated change, but we agreed that it would\n> be better to not separate them; the need for change to the t5000 test is\n> caused by the change described above.\n\n> \n> >\n> > e51217e15 (t5000: test tar files that overflow ustar headers,\n> > 30-06-2016) introduced a test \'generate tar with future mtime\' that\n> > creates a commit with committer date of (2 ^ 36 + 1) seconds since\n> > EPOCH. The CDAT chunk provides 34-bits for storing committer date, thus\n> > committer time overflows into generation number (within CDAT chunk) and\n> > has undefined behavior.\n> >\n> > The test used to pass as fill_commit_graph_info() would not set struct\n> > member `date` of struct commit and loads committer date from the object\n> > database, generating a tar file with the expected mtime.\n> \n> I think it should be s/loads/load/, as in ""would load"", but I am not a\n> native English speaker.\n> \n\nThat\'s correct - since I have used ""would not set"" in the first half of\nsentence, the later half should follow suit too.\n\n> >\n> > However, with corrected commit date, we will load the committer date\n> > from CDAT chunk (truncated to lower 34-bits to populate the generation\n> > number. Thus, Git sets date and generates tar file with the truncated\n> > mtime.\n> >\n> > The ustar format (the header format used by most modern tar programs)\n> > only has room for 11 (or 12, depending om some implementations) octal\n> > digits for the size and mtime of each files.\n> >\n> > Thus, setting a timestamp of 2 ^ 33 + 1 would overflow the 11-octal\n> > digit implementations while still fitting into commit data chunk.\n> >\n> > Since we want to test 12-octal digit implementations of ustar as well,\n> > let\'s modify the existing test to no longer use commit-graph file.\n> \n> The description above is for me does not make it entirely clear that we\n> add new test for handling possible 11-octal digit overflow nearly\n> identical to the existing one, and turn off use of commit-graph file for\n> test that checks handling 12-octal digit overflow.\n> \n\nRevised the last paragraphs to:\n\n  The ustar format (the header format used by most modern tar programs)\n  only has room for 11 (or 12, depending on some implementations) octal\n  digits for the size and mtime of each file.\n\n  To test the 11-octal digit implementation, we create a future commit\n  with committer date of 2^34 - 1, which overflows 11-octal digits\n  without overflowing 34-bits of the Commit Data chunk.\n\n  To test the 12-octal digit implementation, the smallest committer date\n  possible is 2^36, which overflows the Commit Data chunk and thus\n  commit-graph must be disabled for the test.\n\n> > Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> > ---\n> >  commit-graph.c      | 27 ++++++++++-----------------\n> >  t/t5000-tar-tree.sh | 20 +++++++++++++++++++-\n> >  2 files changed, 29 insertions(+), 18 deletions(-)\n> >\n> > diff --git a/commit-graph.c b/commit-graph.c\n> > index 94503e584b..e8362e144e 100644\n> > --- a/commit-graph.c\n> > +++ b/commit-graph.c\n> > @@ -749,15 +749,24 @@ static void fill_commit_graph_info(struct commit *item, struct commit_graph *g,\n> >  \tconst unsigned char *commit_data;\n> >  \tstruct commit_graph_data *graph_data;\n> >  \tuint32_t lex_index;\n> > +\tuint64_t date_high, date_low;\n> >  \n> >  \twhile (pos < g->num_commits_in_base)\n> >  \t\tg = g->base_graph;\n> >  \n> > +\tif (pos >= g->num_commits + g->num_commits_in_base)\n> > +\t\tdie(_(""invalid commit position. commit-graph is likely corrupt""));\n> > +\n> >  \tlex_index = pos - g->num_commits_in_base;\n> >  \tcommit_data = g->chunk_commit_data + GRAPH_DATA_WIDTH * lex_index;\n> >  \n> >  \tgraph_data = commit_graph_data_at(item);\n> >  \tgraph_data->graph_pos = pos;\n> > +\n> > +\tdate_high = get_be32(commit_data + g->hash_len + 8) & 0x3;\n> > +\tdate_low = get_be32(commit_data + g->hash_len + 12);\n> > +\titem->date = (timestamp_t)((date_high << 32) | date_low);\n> > +\n> >  \tgraph_data->generation = get_be32(commit_data + g->hash_len + 8) >> 2;\n> >  }\n> >  \n> > @@ -772,38 +781,22 @@ static int fill_commit_in_graph(struct repository *r,\n> >  {\n> >  \tuint32_t edge_value;\n> >  \tuint32_t *parent_data_ptr;\n> > -\tuint64_t date_low, date_high;\n> >  \tstruct commit_list **pptr;\n> > -\tstruct commit_graph_data *graph_data;\n> >  \tconst unsigned char *commit_data;\n> >  \tuint32_t lex_index;\n> >  \n> >  \twhile (pos < g->num_commits_in_base)\n> >  \t\tg = g->base_graph;\n> >  \n> > -\tif (pos >= g->num_commits + g->num_commits_in_base)\n> > -\t\tdie(_(""invalid commit position. commit-graph is likely corrupt""));\n> > +\tfill_commit_graph_info(item, g, pos);\n> >  \n> > -\t/*\n> > -\t * Store the ""full"" position, but then use the\n> > -\t * ""local"" position for the rest of the calculation.\n> > -\t */\n> > -\tgraph_data = commit_graph_data_at(item);\n> > -\tgraph_data->graph_pos = pos;\n> >  \tlex_index = pos - g->num_commits_in_base;\n> > -\n> >  \tcommit_data = g->chunk_commit_data + (g->hash_len + 16) * lex_index;\n> >  \n> >  \titem->object.parsed = 1;\n> >  \n> >  \tset_commit_tree(item, NULL);\n> >  \n> > -\tdate_high = get_be32(commit_data + g->hash_len + 8) & 0x3;\n> > -\tdate_low = get_be32(commit_data + g->hash_len + 12);\n> > -\titem->date = (timestamp_t)((date_high << 32) | date_low);\n> > -\n> > -\tgraph_data->generation = get_be32(commit_data + g->hash_len + 8) >> 2;\n> > -\n> >  \tpptr = &item->parents;\n> >  \n> >  \tedge_value = get_be32(commit_data + g->hash_len);\n> \n> All right, looks good for me.\n> \n> Here second change begins.\n> \n> > diff --git a/t/t5000-tar-tree.sh b/t/t5000-tar-tree.sh\n> > index 3ebb0d3b65..8f41cdc509 100755\n> > --- a/t/t5000-tar-tree.sh\n> > +++ b/t/t5000-tar-tree.sh\n> > @@ -431,11 +431,29 @@ test_expect_success TAR_HUGE,LONG_IS_64BIT \'system tar can read our huge size\' \'\n> >  \ttest_cmp expect actual\n> >  \'\n> >  \n> > +test_expect_success TIME_IS_64BIT \'set up repository with far-future commit\' \'\n> > +\trm -f .git/index &&\n> > +\techo foo >file &&\n> > +\tgit add file &&\n> > +\tGIT_COMMITTER_DATE=""@17179869183 +0000"" \\\n> > +\t\tgit commit -m ""tempori parendum""\n> > +\'\n> > +\n> > +test_expect_success TIME_IS_64BIT \'generate tar with future mtime\' \'\n> > +\tgit archive HEAD >future.tar\n> > +\'\n> > +\n> > +test_expect_success TAR_HUGE,TIME_IS_64BIT,TIME_T_IS_64BIT \'system tar can read our future mtime\' \'\n> > +\techo 2514 >expect &&\n> > +\ttar_info future.tar | cut -d"" "" -f2 >actual &&\n> > +\ttest_cmp expect actual\n> > +\'\n> > +\n> \n> Everything is all right, except we now have duplicated test names.\n> \n> Perhaps in the three following tests we should use \'far-far-future\n> commit\' and \'far future mtime\' in place of current \'far-future commit\'\n> and \'future mtime\' for tests checking handling 12-digital ditgits\n> overflow, or add description how far the future is, for example\n> \'far-future commit (2^11 + 1)\', etc.\n> \n\nChanged, thanks for pointing this out.\n\n> >  test_expect_success TIME_IS_64BIT \'set up repository with far-future commit\' \'\n> >  \trm -f .git/index &&\n> >  \techo content >file &&\n> >  \tgit add file &&\n> > -\tGIT_COMMITTER_DATE=""@68719476737 +0000"" \\\n> > +\tGIT_TEST_COMMIT_GRAPH=0 GIT_COMMITTER_DATE=""@68719476737 +0000"" \\\n> >  \t\tgit commit -m ""tempori parendum""\n> >  \'\n> \n> Best,\n> -- \n> Jakub Narębski\n\nThanks\n- Abhishek\n``````````\n', 'comment_created': datetime.datetime(2020, 10, 27, 6, 39, 41, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 516437250, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/20201103053629.GA13228@Abhishek-Arch), Abhishek Kumar wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Sun, Oct 25, 2020 at 04:58:14PM -0400, Taylor Blau wrote:\n> On Sun, Oct 25, 2020 at 01:16:48AM +0200, Jakub Narębski wrote:\n> > ""Abhishek Kumar via GitGitGadget"" <gitgitgadget@gmail.com> writes:\n> >\n> > > While measuring performance with `git commit-graph write --reachable\n> > > --changed-paths` on the linux repository led to around 1m40s for both\n> > > HEAD and master (and could be due to fault in my measurements), it is\n> > > still the ""right"" thing to do.\n> >\n> > I had to read the above paragraph several times to understand it,\n> > possibly because I have expected here to be a fix for a performance\n> > regression.  The commit message for 3d112755 (commit-graph: examine\n> > commits by generation number) describes reduction of computation time\n> > from 3m00s to 1m37s.  So I would expect performance with HEAD (i.e.\n> > before those changes) to be around 3m, not the same before and after\n> > changes being around 1m40s.\n> >\n> > Can anyone recheck this before-and-after benchmark, please?\n> \n> My hunch is that our heuristic to fall back to the commits \'date\'\n> value is saving us here. commit_gen_cmp() first compares the generation\n> numbers, breaking ties by \'date\' as a heuristic. But since all\n> generation number queries return GENERATION_NUMBER_INFINITY during\n> writing, we\'re relying on our heuristic entirely.\n> \n> I haven\'t looked much further than that, other than to see that I could\n> get about a ~4sec speed-up with this patch as compared to v2.29.1 in the\n> computing Bloom filters region on the kernel.\n> \n\nThanks for benchmarking it. I wasn\'t sure if I am testing it correctly\nor the patch made no difference.\n\n> > Anyway, it might be more clear to write it as the following:\n> >\n> >   On the Linux kernel repository, this patch didn\'t reduce the\n> >   computation time for \'git commit-graph write --reachable\n> >   --changed-paths\', which is around 1m40s both before and after this\n> >   change.  This could be a fault in my measurements; it is still the\n> >   ""right"" thing to do.\n> >\n> > Or something like that.\n> \n> Assuming that we are in fact being saved by the ""date"" heuristic, I\'d\n> probably write the following commit message instead:\n> \n>   Before computing Bloom filters, the commit-graph machinery uses\n>   commit_gen_cmp to sort commits by generation order for improved diff\n>   performance. 3d11275505 (commit-graph: examine commits by generation\n>   number, 2020-03-30) claims that this sort can reduce the time spent to\n>   compute Bloom filters by nearly half.\n> \n>   But since c49c82aa4c (commit: move members graph_pos, generation to a\n>   slab, 2020-06-17), this optimization is broken, since asking for\n>   \'commit_graph_generation()\' directly returns GENERATION_NUMBER_INFINITY\n>   while writing.\n> \n>   Not all hope is lost, though: \'commit_graph_generation()\' falls\n>   back to comparing commits by their date when they have equal generation\n>   number, and so since c49c82aa4c is purely a date comparison function.\n>   This heuristic is good enough that we don\'t seem to loose appreciable\n>   performance while computing Bloom filters. [Benchmark that we loose\n>   about ~4sec before/after c49c82aa4c9...]\n> \n>   So, avoid the uesless \'commit_graph_generation()\' while writing by\n>   instead accessing the slab directly. This returns the newly-computed\n>   generation numbers, and allows us to avoid the heuristic by directly\n>   comparing generation numbers.\n> \n\nThat\'s a lot better, will change.\n\n> Thanks,\n> Taylor\n``````````\n', 'comment_created': datetime.datetime(2020, 11, 3, 5, 41, 31, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 516453100, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/20201103064058.GB13228@Abhishek-Arch), Abhishek Kumar wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Sun, Oct 25, 2020 at 02:48:27PM +0100, Jakub Narębski wrote:\n> Hi Abhishek,\n> \n> Note that there are two changes that are not mentioned in the commit\n> message, namely adding \'const\'-ness to generation_a/b local variables in\n> commit_gen_cmp() from commit-graph.c, and switching from\n> GENERATION_NUMBER_ZERO to GENERATION_NUMBER_INFINITY as the default\n> (initial) value for \'max_generation\' in repo_in_merge_bases_many().\n> \n> While the former is a simple ""while-at-it"" change that shouldn\'t affect\n> correctness, the latter needs an explanation (or fixing if it is wrong).\n> \n\nThe change from GENERATION_NUMBER_ZERO to GENERATION_NUMBER_INFINITY was\nincorrect. While fixing merge conflicts on rebasing to master again, I\ndidn\'t notice that repo_in_merge_bases_many() switched from using\nmin_generation and GENERATION_NUMBER_ZERO to max_generation and\nGENERATION_NUMBER_ZERO.\n\nThanks for noticing!\n\n> ...\n> \n> Best,\n> -- \n> Jakub Narębski\n``````````\n', 'comment_created': datetime.datetime(2020, 11, 3, 6, 46, 45, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 549907475, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/1694688e-0253-9d67-1982-8ce483183162@gmail.com), Derrick Stolee wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn 12/28/2020 6:15 AM, Abhishek Kumar via GitGitGadget wrote:\n> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> \n> Before computing Bloom fitlers, the commit-graph machinery uses\n\ns/fitlers/filters/\n\n> commit_gen_cmp to sort commits by generation order for improved diff\n> performance. 3d11275505 (commit-graph: examine commits by generation\n> number, 2020-03-30) claims that this sort can reduce the time spent to\n> compute Bloom filters by nearly half.\n> \n> But since c49c82aa4c (commit: move members graph_pos, generation to a\n> slab, 2020-06-17), this optimization is broken, since asking for a\n> \'commit_graph_generation()\' directly returns GENERATION_NUMBER_INFINITY\n> while writing.\n> \n> Not all hope is lost, though: \'commit_graph_generation()\' falls back to\n> comparing commits by their date when they have equal generation number,\n> and so since c49c82aa4c is purely a date comparision function. This\n\ns/comparision/comparison/\n\n> heuristic is good enough that we don\'t seem to loose appreciable\n> performance while computing Bloom filters. Applying this patch (compared\n> with v2.29.1) speeds up computing Bloom filters by around ~4\n> seconds.\n\nUsing ""~4 seconds"" here is odd since there is no baseline. Which\nrepository did you use?\n\nPrevious discussion used relative terms. Something like ""speeds up by\na factor of 1.25"" or something might be interesting.\n\n> So, avoid the useless \'commit_graph_generation()\' while writing by\n> instead accessing the slab directly. This returns the newly-computed\n> generation numbers, and allows us to avoid the heuristic by directly\n> comparing generation numbers.\n\nThis introduces some timing restrictions to the ability for this\ncomparison function. It would be dangerous if someone extracted\nthe method for another purpose. A comment above these lines could\nwarn future developers from making that mistake, but they would\nprobably use the comparison functions in commit.c instead.\n\n> Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> ---\n>  commit-graph.c | 4 ++--\n>  1 file changed, 2 insertions(+), 2 deletions(-)\n> \n> diff --git a/commit-graph.c b/commit-graph.c\n> index 06f8dc1d896..caf823295f4 100644\n> --- a/commit-graph.c\n> +++ b/commit-graph.c\n> @@ -144,8 +144,8 @@ static int commit_gen_cmp(const void *va, const void *vb)\n>  \tconst struct commit *a = *(const struct commit **)va;\n>  \tconst struct commit *b = *(const struct commit **)vb;\n>  \n> -\tuint32_t generation_a = commit_graph_generation(a);\n> -\tuint32_t generation_b = commit_graph_generation(b);\n> +\tuint32_t generation_a = commit_graph_data_at(a)->generation;\n> +\tuint32_t generation_b = commit_graph_data_at(b)->generation;\n>  \t/* lower generation commits first */\n>  \tif (generation_a < generation_b)\n>  \t\treturn -1;\n> \n\n``````````\n', 'comment_created': datetime.datetime(2020, 12, 30, 1, 39, 36, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 549910071, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/7a0eaa06-131f-ce2d-a335-b624d64ec7e4@gmail.com), Derrick Stolee wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn 12/28/2020 6:16 AM, Abhishek Kumar via GitGitGadget wrote:\n> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> \n> With most of preparations done, let\'s implement corrected commit date.\n> \n> The corrected commit date for a commit is defined as:\n> \n> * A commit with no parents (a root commit) has corrected commit date\n>   equal to its committer date.\n> * A commit with at least one parent has corrected commit date equal to\n>   the maximum of its commit date and one more than the largest corrected\n>   commit date among its parents.\n> \n> As a special case, a root commit with timestamp of zero (01.01.1970\n> 00:00:00Z) has corrected commit date of one, to be able to distinguish\n> from GENERATION_NUMBER_ZERO (that is, an uncomputed corrected commit\n> date).\n> \n> To minimize the space required to store corrected commit date, Git\n> stores corrected commit date offsets into the commit-graph file. The\n> corrected commit date offset for a commit is defined as the difference\n> between its corrected commit date and actual commit date.\n> \n> Storing corrected commit date requires sizeof(timestamp_t) bytes, which\n> in most cases is 64 bits (uintmax_t). However, corrected commit date\n> offsets can be safely stored using only 32-bits. This halves the size\n> of GDAT chunk, which is a reduction of around 6% in the size of\n> commit-graph file.\n> \n> However, using offsets be problematic if one of commits is malformed but\n\nHowever, using 32-bit offsets is problematic if a commit is malformed...\n\n> valid and has committerdate of 0 Unix time, as the offset would be the\n\ns/committerdate/committer date/\n\n> same as corrected commit date and thus require 64-bits to be stored\n> properly.\n> \n> While Git does not write out offsets at this stage, Git stores the\n> corrected commit dates in member generation of struct commit_graph_data.\n> It will begin writing commit date offsets with the introduction of\n> generation data chunk.\n> \n> Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> ---\n>  commit-graph.c | 21 +++++++++++++++++----\n>  1 file changed, 17 insertions(+), 4 deletions(-)\n> \n> diff --git a/commit-graph.c b/commit-graph.c\n> index 1b2a015f92f..bfc3aae5f93 100644\n> --- a/commit-graph.c\n> +++ b/commit-graph.c\n> @@ -1339,9 +1339,11 @@ static void compute_generation_numbers(struct write_commit_graph_context *ctx)\n>  \t\t\t\t\tctx->commits.nr);\n>  \tfor (i = 0; i < ctx->commits.nr; i++) {\n>  \t\tuint32_t level = *topo_level_slab_at(ctx->topo_levels, ctx->commits.list[i]);\n> +\t\ttimestamp_t corrected_commit_date = commit_graph_data_at(ctx->commits.list[i])->generation;\n>  \n>  \t\tdisplay_progress(ctx->progress, i + 1);\n> -\t\tif (level != GENERATION_NUMBER_ZERO)\n> +\t\tif (level != GENERATION_NUMBER_ZERO &&\n> +\t\t    corrected_commit_date != GENERATION_NUMBER_ZERO)\n>  \t\t\tcontinue;\n>  \n>  \t\tcommit_list_insert(ctx->commits.list[i], &list);\n> @@ -1350,16 +1352,23 @@ static void compute_generation_numbers(struct write_commit_graph_context *ctx)\n>  \t\t\tstruct commit_list *parent;\n>  \t\t\tint all_parents_computed = 1;\n>  \t\t\tuint32_t max_level = 0;\n> +\t\t\ttimestamp_t max_corrected_commit_date = 0;\n>  \n>  \t\t\tfor (parent = current->parents; parent; parent = parent->next) {\n>  \t\t\t\tlevel = *topo_level_slab_at(ctx->topo_levels, parent->item);\n> +\t\t\t\tcorrected_commit_date = commit_graph_data_at(parent->item)->generation;\n>  \n> -\t\t\t\tif (level == GENERATION_NUMBER_ZERO) {\n> +\t\t\t\tif (level == GENERATION_NUMBER_ZERO ||\n> +\t\t\t\t    corrected_commit_date == GENERATION_NUMBER_ZERO) {\n>  \t\t\t\t\tall_parents_computed = 0;\n>  \t\t\t\t\tcommit_list_insert(parent->item, &list);\n>  \t\t\t\t\tbreak;\n> -\t\t\t\t} else if (level > max_level) {\n> -\t\t\t\t\tmax_level = level;\n> +\t\t\t\t} else {\n> +\t\t\t\t\tif (level > max_level)\n> +\t\t\t\t\t\tmax_level = level;\n> +\n> +\t\t\t\t\tif (corrected_commit_date > max_corrected_commit_date)\n> +\t\t\t\t\t\tmax_corrected_commit_date = corrected_commit_date;\n\nnit: the ""break"" in the first case makes it so this large else block\nis unnecessary. \n\n-\t\t\t\tif (level == GENERATION_NUMBER_ZERO) {\n+\t\t\t\tif (level == GENERATION_NUMBER_ZERO ||\n+\t\t\t\t    corrected_commit_date == GENERATION_NUMBER_ZERO) {\n \t\t\t\t\tall_parents_computed = 0;\n \t\t\t\t\tcommit_list_insert(parent->item, &list);\n \t\t\t\t\tbreak;\n-\t\t\t\t} else if (level > max_level) {\n-\t\t\t\t\tmax_level = level;\n+\t\t\t\t\n+\t\t\t\tif (level > max_level)\n+\t\t\t\t\tmax_level = level;\n+\n+\t\t\t\tif (corrected_commit_date > max_corrected_commit_date)\n+\t\t\t\t\tmax_corrected_commit_date = corrected_commit_date;\n-\t\t\t\t}\n \t\t\t}\n\nThanks,\n-Stolee\n\n``````````\n', 'comment_created': datetime.datetime(2020, 12, 30, 1, 57, 33, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 549922850, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/2e89c6e1-e8e8-0d51-5670-038b4e296d93@gmail.com), Derrick Stolee wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn 12/28/2020 6:16 AM, Abhishek Kumar via GitGitGadget wrote:\n> From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n\n...\n\n> +static void validate_mixed_generation_chain(struct commit_graph *g)\n> +{\n> +\tint read_generation_data;\n> +\n> +\tif (!g)\n> +\t\treturn;\n> +\n> +\tread_generation_data = !!g->chunk_generation_data;\n> +\n> +\twhile (g) {\n> +\t\tg->read_generation_data = read_generation_data;\n> +\t\tg = g->base_graph;\n> +\t}\n> +}\n> +\n\nThis method exists to say ""use generation v2 if the top layer has it""\nand that helps with the future layer checks.\n\n> @@ -2239,6 +2263,7 @@ int write_commit_graph(struct object_directory *odb,\n>  \t\tstruct commit_graph *g = ctx->r->objects->commit_graph;\n>  \n>  \t\twhile (g) {\n> +\t\t\tg->read_generation_data = 1;\n>  \t\t\tg->topo_levels = &topo_levels;\n>  \t\t\tg = g->base_graph;\n>  \t\t}\n\nHowever, here you just turn them on automatically.\n\nI think the diff you want is here:\n\n \t\tstruct commit_graph *g = ctx->r->objects->commit_graph;\n \n+ \t\tvalidate_mixed_generation_chain(g);\n+ \n \t\twhile (g) {\n \t\t\tg->topo_levels = &topo_levels;\n \t\t\tg = g->base_graph;\n \t\t}\n\nBut maybe you have a good reason for what you already have.\n\nI paid attention to this because I hit a problem in my local testing.\nAfter trying to reproduce it, I think the root cause is that I had a\ncommit-graph that was written by an older version of your series, so\nit caused an unexpected pairing of an ""offset required"" bit but no\noffset chunk.\n\nPerhaps this diff is required in the proper place to avoid the\nsegfault I hit, in the case of a malformed commit-graph file:\n\ndiff --git a/commit-graph.c b/commit-graph.c\nindex c8d7ed1330..d264c90868 100644\n--- a/commit-graph.c\n+++ b/commit-graph.c\n@@ -822,6 +822,9 @@ static void fill_commit_graph_info(struct commit *item, struct commit_graph *g,\n \t\toffset = (timestamp_t)get_be32(g->chunk_generation_data + sizeof(uint32_t) * lex_index);\n \n \t\tif (offset & CORRECTED_COMMIT_DATE_OFFSET_OVERFLOW) {\n+\t\t\tif (!g->chunk_generation_data_overflow)\n+\t\t\t\tdie(_(""commit-graph requires overflow generation data but has none""));\n+\n \t\t\toffset_pos = offset ^ CORRECTED_COMMIT_DATE_OFFSET_OVERFLOW;\n \t\t\tgraph_data->generation = get_be64(g->chunk_generation_data_overflow + 8 * offset_pos);\n \t\t} else\n\nYour tests in this patch seem very thorough, covering all the cases\nI could think to create this strange situation. I even tried creating\ncases where the overflow would be necessary. The following test actually\nfails on the ""graph_read_expect 6"" due to the extra chunk, not the \'write\'\nprocess I was trying to trick into failure.\n\ndiff --git a/t/t5324-split-commit-graph.sh b/t/t5324-split-commit-graph.sh\nindex 8e90f3423b..cfef8e52b9 100755\n--- a/t/t5324-split-commit-graph.sh\n+++ b/t/t5324-split-commit-graph.sh\n@@ -453,6 +453,20 @@ test_expect_success \'prevent regression for duplicate commits across layers\' \'\n        git -C dup commit-graph verify\n \'\n \n+test_expect_success \'upgrade to generation data succeeds when there was none\' \'\n+\t(\n+\t\tcd dup &&\n+\t\trm -rf .git/objects/info/commit-graph* &&\n+\t\tGIT_TEST_COMMIT_GRAPH_NO_GDAT=1 git commit-graph \\\n+\t\t\twrite --reachable &&\n+\t\tGIT_COMMITTER_DATE=""1980-01-01 00:00"" git commit --allow-empty -m one &&\n+\t\tGIT_COMMITTER_DATE=""2090-01-01 00:00"" git commit --allow-empty -m two &&\n+\t\tGIT_COMMITTER_DATE=""2000-01-01 00:00"" git commit --allow-empty -m three &&\n+\t\tgit commit-graph write --reachable &&\n+\t\tgraph_read_expect 6\n+\t)\n+\'\n+\n NUM_FIRST_LAYER_COMMITS=64\n NUM_SECOND_LAYER_COMMITS=16\n NUM_THIRD_LAYER_COMMITS=7\n\nThanks,\n-Stolee\n``````````\n', 'comment_created': datetime.datetime(2020, 12, 30, 3, 27, 45, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 551823649, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/20210105094535.GN8396@szeder.dev), SZEDER Gábor wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Mon, Dec 28, 2020 at 11:15:58AM +0000, Abhishek Kumar via GitGitGadget wrote:\n> Before computing Bloom fitlers, the commit-graph machinery uses\n> commit_gen_cmp to sort commits by generation order for improved diff\n> performance. 3d11275505 (commit-graph: examine commits by generation\n> number, 2020-03-30) claims that this sort can reduce the time spent to\n> compute Bloom filters by nearly half.\n\nThat\'s true, though there are repositories where it has basically no\neffect.  Alas we can\'t directly test it, because in 3d11275505 there\nis no \'--changed-paths\' option yet... one has to revert 3d11275505 on\ntop of d38e07b8c4 (commit-graph: add --changed-paths option to write\nsubcommand, 2020-04-06) to make any runtime comparisons (\'git\ncommit-graph write --reachable --changed-paths\', best of five):\n\n                   Sorting by\n               pack    | generation\n             position  |\n    -------------------+------------\n    gcc      114.821s  |    38.963s \n    git        8.896s  |     5.620s\n    linux    209.984s  |   104.900s\n    webkit    35.193s  |    35.482s\n\nNote the almost 3x speedup in the gcc repository, and the basically\nnegligible slowdown in the webkit repo.\n\n> But since c49c82aa4c (commit: move members graph_pos, generation to a\n> slab, 2020-06-17), this optimization is broken, since asking for a\n> \'commit_graph_generation()\' directly returns GENERATION_NUMBER_INFINITY\n> while writing.\n\nI wouldn\'t say that c49c82aa4c broke this optimisation, because:\n\ndid not break that optimization.  Though, sadly, it\'s not\nmentioned in 3d11275505\'s commit message, when commit_gen_cmp()\ncompares two commits with identical generation numbers, then it\ndoesn\'t leave them unsorted, but falls back to use their committer\ndate as a tie-braker.  This means that after c49c82aa4c the commits\nare sorted by committer date, which appears to be so good a heuristic\nfor Bloom filter computation that there is barely any slowdown\ncompared to sorting by generation numbers:\n\n> Not all hope is lost, though: \'commit_graph_generation()\' falls back to\n\nYou mean commit_gen_cmp() here.\n\n> comparing commits by their date when they have equal generation number,\n> and so since c49c82aa4c is purely a date comparision function. This\n> heuristic is good enough that we don\'t seem to loose appreciable\n> performance while computing Bloom filters.\n\nIndeed, c49c82aa4c barely caused any runtime difference in the\nrepositories I usually use to test modified path Bloom filter\nperformance:\n\n                 c49c82aa4c^  c49c82aa4c\n  ---------------------------------------------\n  android-base     43.057s     43.091s   0.07%\n  cmssw            21.781s     21.856s   0.34%\n  cpython           9.626s      9.724s   1.01%\n  elasticsearch    18.049s     18.224s   0.96%\n  gcc              40.312s     40.255s  -0.14%\n  gecko-dev       104.515s    104.740s   0.21%\n  git               5.559s      5.570s   0.19%\n  glibc             4.455s      4.468s   0.29%\n  go                4.009s      4.016s   0.17%\n  homebrew-cask    30.759s     30.523s  -0.76%\n  homebrew-core    57.122s     56.553s  -0.99%\n  jdk              18.297s     18.364s   0.36%\n  linux           104.499s    105.302s   0.76%\n  llvm-project     34.074s     34.446s   1.09%\n  rails             6.472s      6.486s   0.21%\n  rust             14.943s     14.947s   0.02%\n  tensorflow       13.362s     13.477s   0.86%\n  webkit           34.583s     34.601s   0.05%\n\n> Applying this patch (compared\n> with v2.29.1) speeds up computing Bloom filters by around ~4\n> seconds.\n\nWithout a baseline and knowing which repo, this ""~4 seconds"" is\nmeaningless.\n\nHere are my results comparing this fix to v2.30.0, best of five:\n\n                              v2.30.0 +\n                   v2.30.0    this fix\n  ---------------------------------------------\n  android-base     42.786s     42.933s   0.34%\n  cmssw            20.229s     20.160s  -0.34%\n  cpython           9.616s      9.647s   0.32%\n  elasticsearch    16.859s     16.936s   0.45%\n  gcc              38.909s     36.889s  -5.19%\n  gecko-dev        99.417s     98.558s  -0.86%\n  git               5.620s      5.509s  -1.97%\n  glibc             4.307s      4.301s  -0.13%\n  go                3.971s      3.938s  -0.83%\n  homebrew-cask    31.262s     30.283s  -3.13%\n  homebrew-core    57.842s     55.663s  -3.76%\n  jdk              12.557s     12.251s  -2.43%\n  linux            94.335s     94.760s   0.45%\n  llvm-project     34.432s     33.988s  -1.28%\n  rails             6.481s      6.454s  -0.41%\n  rust             14.772s     14.601s  -1.15%\n  tensorflow       11.759s     11.711s  -0.40%\n  webkit           33.917s     33.759s  -0.46%\n\n> So, avoid the useless \'commit_graph_generation()\' while writing by\n> instead accessing the slab directly. This returns the newly-computed\n> generation numbers, and allows us to avoid the heuristic by directly\n> comparing generation numbers.\n> \n> Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> ---\n>  commit-graph.c | 4 ++--\n>  1 file changed, 2 insertions(+), 2 deletions(-)\n> \n> diff --git a/commit-graph.c b/commit-graph.c\n> index 06f8dc1d896..caf823295f4 100644\n> --- a/commit-graph.c\n> +++ b/commit-graph.c\n> @@ -144,8 +144,8 @@ static int commit_gen_cmp(const void *va, const void *vb)\n>  \tconst struct commit *a = *(const struct commit **)va;\n>  \tconst struct commit *b = *(const struct commit **)vb;\n>  \n> -\tuint32_t generation_a = commit_graph_generation(a);\n> -\tuint32_t generation_b = commit_graph_generation(b);\n> +\tuint32_t generation_a = commit_graph_data_at(a)->generation;\n> +\tuint32_t generation_b = commit_graph_data_at(b)->generation;\n>  \t/* lower generation commits first */\n>  \tif (generation_a < generation_b)\n>  \t\treturn -1;\n> -- \n> gitgitgadget\n> \n``````````\n', 'comment_created': datetime.datetime(2021, 1, 5, 9, 48, 39, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 551825224, 'comment_body': ""[On the Git mailing list](https://lore.kernel.org/git/20210105094740.GO8396@szeder.dev), SZEDER Gábor wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Tue, Jan 05, 2021 at 10:45:35AM +0100, SZEDER Gábor wrote:\n> > But since c49c82aa4c (commit: move members graph_pos, generation to a\n> > slab, 2020-06-17), this optimization is broken, since asking for a\n> > 'commit_graph_generation()' directly returns GENERATION_NUMBER_INFINITY\n> > while writing.\n> \n> I wouldn't say that c49c82aa4c broke this optimisation, because:\n> \n> did not break that optimization.  Though, sadly, it's not\n> mentioned in 3d11275505's commit message, when commit_gen_cmp()\n> compares two commits with identical generation numbers, then it\n> doesn't leave them unsorted, but falls back to use their committer\n> date as a tie-braker.  This means that after c49c82aa4c the commits\n> are sorted by committer date, which appears to be so good a heuristic\n> for Bloom filter computation that there is barely any slowdown\n> compared to sorting by generation numbers:\n\nGaah, scratch this paragraph; I first misunderstood what you wrote in\nthe paragraph below, but then forgot to remove it.\n\n> > Not all hope is lost, though: 'commit_graph_generation()' falls back to\n> \n> You mean commit_gen_cmp() here.\n> \n> > comparing commits by their date when they have equal generation number,\n> > and so since c49c82aa4c is purely a date comparision function. This\n> > heuristic is good enough that we don't seem to loose appreciable\n> > performance while computing Bloom filters.\n``````````\n"", 'comment_created': datetime.datetime(2021, 1, 5, 9, 51, 35, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 553754505, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/X/fxlVc8UK7FQRpP@Abhishek-Arch), Abhishek Kumar wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Tue, Dec 29, 2020 at 08:35:56PM -0500, Derrick Stolee wrote:\n> On 12/28/2020 6:15 AM, Abhishek Kumar via GitGitGadget wrote:\n> > From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> > \n> > Before computing Bloom fitlers, the commit-graph machinery uses\n> \n> s/fitlers/filters/\n> \n> > commit_gen_cmp to sort commits by generation order for improved diff\n> > performance. 3d11275505 (commit-graph: examine commits by generation\n> > number, 2020-03-30) claims that this sort can reduce the time spent to\n> > compute Bloom filters by nearly half.\n> > \n> > But since c49c82aa4c (commit: move members graph_pos, generation to a\n> > slab, 2020-06-17), this optimization is broken, since asking for a\n> > \'commit_graph_generation()\' directly returns GENERATION_NUMBER_INFINITY\n> > while writing.\n> > \n> > Not all hope is lost, though: \'commit_graph_generation()\' falls back to\n> > comparing commits by their date when they have equal generation number,\n> > and so since c49c82aa4c is purely a date comparision function. This\n> \n> s/comparision/comparison/\n> \n> > heuristic is good enough that we don\'t seem to loose appreciable\n> > performance while computing Bloom filters. Applying this patch (compared\n> > with v2.29.1) speeds up computing Bloom filters by around ~4\n> > seconds.\n> \n> Using ""~4 seconds"" here is odd since there is no baseline. Which\n> repository did you use?\n> \n\nI used the linux repository, will mention that.\n\n> Previous discussion used relative terms. Something like ""speeds up by\n> a factor of 1.25"" or something might be interesting.\n> \n\nAs SZEDER G�bor found, the improvements are rather minor - ranging from\n0.40% to 5.19% [1]. I want to make sure this is the correct way to word\nin the commit message:\n\nApplying this patch (compared with v2.30.0) speeds up computing Bloom\nfilters by factors ranging from 0.40% to 5.19% on various\nrepositories. \n\nhttps://lore.kernel.org/git/20210105094535.GN8396@szeder.dev/\n\n> > So, avoid the useless \'commit_graph_generation()\' while writing by\n> > instead accessing the slab directly. This returns the newly-computed\n> > generation numbers, and allows us to avoid the heuristic by directly\n> > comparing generation numbers.\n> \n> This introduces some timing restrictions to the ability for this\n> comparison function. It would be dangerous if someone extracted\n> the method for another purpose. A comment above these lines could\n> warn future developers from making that mistake, but they would\n> probably use the comparison functions in commit.c instead.\n> \n\nSure, will add a comment above.\n\n> > Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> > ---\n> >  commit-graph.c | 4 ++--\n> >  1 file changed, 2 insertions(+), 2 deletions(-)\n> > \n> > diff --git a/commit-graph.c b/commit-graph.c\n> > index 06f8dc1d896..caf823295f4 100644\n> > --- a/commit-graph.c\n> > +++ b/commit-graph.c\n> > @@ -144,8 +144,8 @@ static int commit_gen_cmp(const void *va, const void *vb)\n> >  \tconst struct commit *a = *(const struct commit **)va;\n> >  \tconst struct commit *b = *(const struct commit **)vb;\n> >  \n> > -\tuint32_t generation_a = commit_graph_generation(a);\n> > -\tuint32_t generation_b = commit_graph_generation(b);\n> > +\tuint32_t generation_a = commit_graph_data_at(a)->generation;\n> > +\tuint32_t generation_b = commit_graph_data_at(b)->generation;\n> >  \t/* lower generation commits first */\n> >  \tif (generation_a < generation_b)\n> >  \t\treturn -1;\n> > \n> \n``````````\n', 'comment_created': datetime.datetime(2021, 1, 8, 5, 48, 34, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 553756191, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/X/fy6vWfCCVuApTE@Abhishek-Arch), Abhishek Kumar wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Tue, Jan 05, 2021 at 10:45:35AM +0100, SZEDER G�bor wrote:\n> On Mon, Dec 28, 2020 at 11:15:58AM +0000, Abhishek Kumar via GitGitGadget wrote:\n> > Before computing Bloom fitlers, the commit-graph machinery uses\n> > commit_gen_cmp to sort commits by generation order for improved diff\n> > performance. 3d11275505 (commit-graph: examine commits by generation\n> > number, 2020-03-30) claims that this sort can reduce the time spent to\n> > compute Bloom filters by nearly half.\n> \n> That\'s true, though there are repositories where it has basically no\n> effect.  Alas we can\'t directly test it, because in 3d11275505 there\n> is no \'--changed-paths\' option yet... one has to revert 3d11275505 on\n> top of d38e07b8c4 (commit-graph: add --changed-paths option to write\n> subcommand, 2020-04-06) to make any runtime comparisons (\'git\n> commit-graph write --reachable --changed-paths\', best of five):\n> \n>                    Sorting by\n>                pack    | generation\n>              position  |\n>     -------------------+------------\n>     gcc      114.821s  |    38.963s \n>     git        8.896s  |     5.620s\n>     linux    209.984s  |   104.900s\n>     webkit    35.193s  |    35.482s\n> \n> Note the almost 3x speedup in the gcc repository, and the basically\n> negligible slowdown in the webkit repo.\n> \n> > But since c49c82aa4c (commit: move members graph_pos, generation to a\n> > slab, 2020-06-17), this optimization is broken, since asking for a\n> > \'commit_graph_generation()\' directly returns GENERATION_NUMBER_INFINITY\n> > while writing.\n> \n> I wouldn\'t say that c49c82aa4c broke this optimisation, because:\n> \n> did not break that optimization.  Though, sadly, it\'s not\n> mentioned in 3d11275505\'s commit message, when commit_gen_cmp()\n> compares two commits with identical generation numbers, then it\n> doesn\'t leave them unsorted, but falls back to use their committer\n> date as a tie-braker.  This means that after c49c82aa4c the commits\n> are sorted by committer date, which appears to be so good a heuristic\n> for Bloom filter computation that there is barely any slowdown\n> compared to sorting by generation numbers:\n> \n> > Not all hope is lost, though: \'commit_graph_generation()\' falls back to\n> \n> You mean commit_gen_cmp() here.\n> \n\nYes, fixed.\n\n> > comparing commits by their date when they have equal generation number,\n> > and so since c49c82aa4c is purely a date comparision function. This\n> > heuristic is good enough that we don\'t seem to loose appreciable\n> > performance while computing Bloom filters.\n> \n> Indeed, c49c82aa4c barely caused any runtime difference in the\n> repositories I usually use to test modified path Bloom filter\n> performance:\n> \n>                  c49c82aa4c^  c49c82aa4c\n>   ---------------------------------------------\n>   android-base     43.057s     43.091s   0.07%\n>   cmssw            21.781s     21.856s   0.34%\n>   cpython           9.626s      9.724s   1.01%\n>   elasticsearch    18.049s     18.224s   0.96%\n>   gcc              40.312s     40.255s  -0.14%\n>   gecko-dev       104.515s    104.740s   0.21%\n>   git               5.559s      5.570s   0.19%\n>   glibc             4.455s      4.468s   0.29%\n>   go                4.009s      4.016s   0.17%\n>   homebrew-cask    30.759s     30.523s  -0.76%\n>   homebrew-core    57.122s     56.553s  -0.99%\n>   jdk              18.297s     18.364s   0.36%\n>   linux           104.499s    105.302s   0.76%\n>   llvm-project     34.074s     34.446s   1.09%\n>   rails             6.472s      6.486s   0.21%\n>   rust             14.943s     14.947s   0.02%\n>   tensorflow       13.362s     13.477s   0.86%\n>   webkit           34.583s     34.601s   0.05%\n> \n> > Applying this patch (compared\n> > with v2.29.1) speeds up computing Bloom filters by around ~4\n> > seconds.\n> \n> Without a baseline and knowing which repo, this ""~4 seconds"" is\n> meaningless.\n> \n> Here are my results comparing this fix to v2.30.0, best of five:\n> \n>                               v2.30.0 +\n>                    v2.30.0    this fix\n>   ---------------------------------------------\n>   android-base     42.786s     42.933s   0.34%\n>   cmssw            20.229s     20.160s  -0.34%\n>   cpython           9.616s      9.647s   0.32%\n>   elasticsearch    16.859s     16.936s   0.45%\n>   gcc              38.909s     36.889s  -5.19%\n>   gecko-dev        99.417s     98.558s  -0.86%\n>   git               5.620s      5.509s  -1.97%\n>   glibc             4.307s      4.301s  -0.13%\n>   go                3.971s      3.938s  -0.83%\n>   homebrew-cask    31.262s     30.283s  -3.13%\n>   homebrew-core    57.842s     55.663s  -3.76%\n>   jdk              12.557s     12.251s  -2.43%\n>   linux            94.335s     94.760s   0.45%\n>   llvm-project     34.432s     33.988s  -1.28%\n>   rails             6.481s      6.454s  -0.41%\n>   rust             14.772s     14.601s  -1.15%\n>   tensorflow       11.759s     11.711s  -0.40%\n>   webkit           33.917s     33.759s  -0.46%\n>\n\nThank you for the detailed performance benchmarking.\n\n> \n> > So, avoid the useless \'commit_graph_generation()\' while writing by\n> > instead accessing the slab directly. This returns the newly-computed\n> > generation numbers, and allows us to avoid the heuristic by directly\n> > comparing generation numbers.\n> > \n> > Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> > ---\n> >  commit-graph.c | 4 ++--\n> >  1 file changed, 2 insertions(+), 2 deletions(-)\n> > \n> > diff --git a/commit-graph.c b/commit-graph.c\n> > index 06f8dc1d896..caf823295f4 100644\n> > --- a/commit-graph.c\n> > +++ b/commit-graph.c\n> > @@ -144,8 +144,8 @@ static int commit_gen_cmp(const void *va, const void *vb)\n> >  \tconst struct commit *a = *(const struct commit **)va;\n> >  \tconst struct commit *b = *(const struct commit **)vb;\n> >  \n> > -\tuint32_t generation_a = commit_graph_generation(a);\n> > -\tuint32_t generation_b = commit_graph_generation(b);\n> > +\tuint32_t generation_a = commit_graph_data_at(a)->generation;\n> > +\tuint32_t generation_b = commit_graph_data_at(b)->generation;\n> >  \t/* lower generation commits first */\n> >  \tif (generation_a < generation_b)\n> >  \t\treturn -1;\n> > -- \n> > gitgitgadget\n> > \n\nThanks\n- Abhishek\n``````````\n', 'comment_created': datetime.datetime(2021, 1, 8, 5, 55, 19, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 554559858, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/X/rxL+ofMI4LNSYw@Abhishek-Arch), Abhishek Kumar wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Tue, Dec 29, 2020 at 08:53:11PM -0500, Derrick Stolee wrote:\n> On 12/28/2020 6:16 AM, Abhishek Kumar via GitGitGadget wrote:\n> > From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> > \n> > With most of preparations done, let\'s implement corrected commit date.\n> > \n> > The corrected commit date for a commit is defined as:\n> > \n> > * A commit with no parents (a root commit) has corrected commit date\n> >   equal to its committer date.\n> > * A commit with at least one parent has corrected commit date equal to\n> >   the maximum of its commit date and one more than the largest corrected\n> >   commit date among its parents.\n> > \n> > As a special case, a root commit with timestamp of zero (01.01.1970\n> > 00:00:00Z) has corrected commit date of one, to be able to distinguish\n> > from GENERATION_NUMBER_ZERO (that is, an uncomputed corrected commit\n> > date).\n> > \n> > To minimize the space required to store corrected commit date, Git\n> > stores corrected commit date offsets into the commit-graph file. The\n> > corrected commit date offset for a commit is defined as the difference\n> > between its corrected commit date and actual commit date.\n> > \n> > Storing corrected commit date requires sizeof(timestamp_t) bytes, which\n> > in most cases is 64 bits (uintmax_t). However, corrected commit date\n> > offsets can be safely stored using only 32-bits. This halves the size\n> > of GDAT chunk, which is a reduction of around 6% in the size of\n> > commit-graph file.\n> > \n> > However, using offsets be problematic if one of commits is malformed but\n> \n> However, using 32-bit offsets is problematic if a commit is malformed...\n> \n> > valid and has committerdate of 0 Unix time, as the offset would be the\n> \n> s/committerdate/committer date/\n> \n> > same as corrected commit date and thus require 64-bits to be stored\n> > properly.\n> > \n> > While Git does not write out offsets at this stage, Git stores the\n> > corrected commit dates in member generation of struct commit_graph_data.\n> > It will begin writing commit date offsets with the introduction of\n> > generation data chunk.\n> > \n> > Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> > ---\n> >  commit-graph.c | 21 +++++++++++++++++----\n> >  1 file changed, 17 insertions(+), 4 deletions(-)\n> > \n> > diff --git a/commit-graph.c b/commit-graph.c\n> > index 1b2a015f92f..bfc3aae5f93 100644\n> > --- a/commit-graph.c\n> > +++ b/commit-graph.c\n> > @@ -1339,9 +1339,11 @@ static void compute_generation_numbers(struct write_commit_graph_context *ctx)\n> >  \t\t\t\t\tctx->commits.nr);\n> >  \tfor (i = 0; i < ctx->commits.nr; i++) {\n> >  \t\tuint32_t level = *topo_level_slab_at(ctx->topo_levels, ctx->commits.list[i]);\n> > +\t\ttimestamp_t corrected_commit_date = commit_graph_data_at(ctx->commits.list[i])->generation;\n> >  \n> >  \t\tdisplay_progress(ctx->progress, i + 1);\n> > -\t\tif (level != GENERATION_NUMBER_ZERO)\n> > +\t\tif (level != GENERATION_NUMBER_ZERO &&\n> > +\t\t    corrected_commit_date != GENERATION_NUMBER_ZERO)\n> >  \t\t\tcontinue;\n> >  \n> >  \t\tcommit_list_insert(ctx->commits.list[i], &list);\n> > @@ -1350,16 +1352,23 @@ static void compute_generation_numbers(struct write_commit_graph_context *ctx)\n> >  \t\t\tstruct commit_list *parent;\n> >  \t\t\tint all_parents_computed = 1;\n> >  \t\t\tuint32_t max_level = 0;\n> > +\t\t\ttimestamp_t max_corrected_commit_date = 0;\n> >  \n> >  \t\t\tfor (parent = current->parents; parent; parent = parent->next) {\n> >  \t\t\t\tlevel = *topo_level_slab_at(ctx->topo_levels, parent->item);\n> > +\t\t\t\tcorrected_commit_date = commit_graph_data_at(parent->item)->generation;\n> >  \n> > -\t\t\t\tif (level == GENERATION_NUMBER_ZERO) {\n> > +\t\t\t\tif (level == GENERATION_NUMBER_ZERO ||\n> > +\t\t\t\t    corrected_commit_date == GENERATION_NUMBER_ZERO) {\n> >  \t\t\t\t\tall_parents_computed = 0;\n> >  \t\t\t\t\tcommit_list_insert(parent->item, &list);\n> >  \t\t\t\t\tbreak;\n> > -\t\t\t\t} else if (level > max_level) {\n> > -\t\t\t\t\tmax_level = level;\n> > +\t\t\t\t} else {\n> > +\t\t\t\t\tif (level > max_level)\n> > +\t\t\t\t\t\tmax_level = level;\n> > +\n> > +\t\t\t\t\tif (corrected_commit_date > max_corrected_commit_date)\n> > +\t\t\t\t\t\tmax_corrected_commit_date = corrected_commit_date;\n> \n> nit: the ""break"" in the first case makes it so this large else block\n> is unnecessary. \n\nThanks, removed.\n\n> \n> -\t\t\t\tif (level == GENERATION_NUMBER_ZERO) {\n> +\t\t\t\tif (level == GENERATION_NUMBER_ZERO ||\n> +\t\t\t\t    corrected_commit_date == GENERATION_NUMBER_ZERO) {\n>  \t\t\t\t\tall_parents_computed = 0;\n>  \t\t\t\t\tcommit_list_insert(parent->item, &list);\n>  \t\t\t\t\tbreak;\n> -\t\t\t\t} else if (level > max_level) {\n> -\t\t\t\t\tmax_level = level;\n> +\t\t\t\t\n> +\t\t\t\tif (level > max_level)\n> +\t\t\t\t\tmax_level = level;\n> +\n> +\t\t\t\tif (corrected_commit_date > max_corrected_commit_date)\n> +\t\t\t\t\tmax_corrected_commit_date = corrected_commit_date;\n> -\t\t\t\t}\n>  \t\t\t}\n> \n> Thanks,\n> -Stolee\n> \n\nThanks\n- Abhishek\n``````````\n', 'comment_created': datetime.datetime(2021, 1, 10, 12, 23, 48, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 554566447, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/X/r9i0HJFEGxuyW/@Abhishek-Arch), Abhishek Kumar wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Tue, Dec 29, 2020 at 10:23:54PM -0500, Derrick Stolee wrote:\n> On 12/28/2020 6:16 AM, Abhishek Kumar via GitGitGadget wrote:\n> > From: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> \n> ...\n> \n> > +static void validate_mixed_generation_chain(struct commit_graph *g)\n> > +{\n> > +\tint read_generation_data;\n> > +\n> > +\tif (!g)\n> > +\t\treturn;\n> > +\n> > +\tread_generation_data = !!g->chunk_generation_data;\n> > +\n> > +\twhile (g) {\n> > +\t\tg->read_generation_data = read_generation_data;\n> > +\t\tg = g->base_graph;\n> > +\t}\n> > +}\n> > +\n> \n> This method exists to say ""use generation v2 if the top layer has it""\n> and that helps with the future layer checks.\n> \n> > @@ -2239,6 +2263,7 @@ int write_commit_graph(struct object_directory *odb,\n> >  \t\tstruct commit_graph *g = ctx->r->objects->commit_graph;\n> >  \n> >  \t\twhile (g) {\n> > +\t\t\tg->read_generation_data = 1;\n> >  \t\t\tg->topo_levels = &topo_levels;\n> >  \t\t\tg = g->base_graph;\n> >  \t\t}\n> \n> However, here you just turn them on automatically.\n> \n> I think the diff you want is here:\n> \n>  \t\tstruct commit_graph *g = ctx->r->objects->commit_graph;\n>  \n> + \t\tvalidate_mixed_generation_chain(g);\n> + \n>  \t\twhile (g) {\n>  \t\t\tg->topo_levels = &topo_levels;\n>  \t\t\tg = g->base_graph;\n>  \t\t}\n> \n> But maybe you have a good reason for what you already have.\n> \n\nThanks, that was an oversight.\n\nMy (incorrect) reasoning at the time was:\n\nSince we are computing both topological levels and corrected commit\ndates, we can read corrected commit dates from layers with a GDAT chunk\nhidden below non-GDAT layer.\n\nBut we end up storing both corrected commit date offsets (for a layers with\nGDAT chunk) and topological level (for layers without GDAT chunk) in the\nsame slab with no way to distinguish between the two!\n\n> I paid attention to this because I hit a problem in my local testing.\n> After trying to reproduce it, I think the root cause is that I had a\n> commit-graph that was written by an older version of your series, so\n> it caused an unexpected pairing of an ""offset required"" bit but no\n> offset chunk.\n> \n> Perhaps this diff is required in the proper place to avoid the\n> segfault I hit, in the case of a malformed commit-graph file:\n> \n> diff --git a/commit-graph.c b/commit-graph.c\n> index c8d7ed1330..d264c90868 100644\n> --- a/commit-graph.c\n> +++ b/commit-graph.c\n> @@ -822,6 +822,9 @@ static void fill_commit_graph_info(struct commit *item, struct commit_graph *g,\n>  \t\toffset = (timestamp_t)get_be32(g->chunk_generation_data + sizeof(uint32_t) * lex_index);\n>  \n>  \t\tif (offset & CORRECTED_COMMIT_DATE_OFFSET_OVERFLOW) {\n> +\t\t\tif (!g->chunk_generation_data_overflow)\n> +\t\t\t\tdie(_(""commit-graph requires overflow generation data but has none""));\n> +\n>  \t\t\toffset_pos = offset ^ CORRECTED_COMMIT_DATE_OFFSET_OVERFLOW;\n>  \t\t\tgraph_data->generation = get_be64(g->chunk_generation_data_overflow + 8 * offset_pos);\n>  \t\t} else\n> \n> Your tests in this patch seem very thorough, covering all the cases\n> I could think to create this strange situation. I even tried creating\n> cases where the overflow would be necessary. The following test actually\n> fails on the ""graph_read_expect 6"" due to the extra chunk, not the \'write\'\n> process I was trying to trick into failure.\n> \n> diff --git a/t/t5324-split-commit-graph.sh b/t/t5324-split-commit-graph.sh\n> index 8e90f3423b..cfef8e52b9 100755\n> --- a/t/t5324-split-commit-graph.sh\n> +++ b/t/t5324-split-commit-graph.sh\n> @@ -453,6 +453,20 @@ test_expect_success \'prevent regression for duplicate commits across layers\' \'\n>         git -C dup commit-graph verify\n>  \'\n>  \n> +test_expect_success \'upgrade to generation data succeeds when there was none\' \'\n> +\t(\n> +\t\tcd dup &&\n> +\t\trm -rf .git/objects/info/commit-graph* &&\n> +\t\tGIT_TEST_COMMIT_GRAPH_NO_GDAT=1 git commit-graph \\\n> +\t\t\twrite --reachable &&\n> +\t\tGIT_COMMITTER_DATE=""1980-01-01 00:00"" git commit --allow-empty -m one &&\n> +\t\tGIT_COMMITTER_DATE=""2090-01-01 00:00"" git commit --allow-empty -m two &&\n> +\t\tGIT_COMMITTER_DATE=""2000-01-01 00:00"" git commit --allow-empty -m three &&\n> +\t\tgit commit-graph write --reachable &&\n> +\t\tgraph_read_expect 6\n> +\t)\n> +\'\n\nI am not sure what this test adds over the existing generation data\noverflow related tests added in t5318-commit-graph.sh\n\n> +\n>  NUM_FIRST_LAYER_COMMITS=64\n>  NUM_SECOND_LAYER_COMMITS=16\n>  NUM_THIRD_LAYER_COMMITS=7\n> \n> Thanks,\n> -Stolee\n\nThanks\n- Abhishek\n``````````\n', 'comment_created': datetime.datetime(2021, 1, 10, 13, 17, 54, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 555022574, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/003c1892-cbfe-7437-f8ce-fbae58f0cb83@gmail.com), Derrick Stolee wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn 1/10/2021 8:13 AM, Abhishek Kumar wrote:\n> On Tue, Dec 29, 2020 at 10:23:54PM -0500, Derrick Stolee wrote:\n>> Your tests in this patch seem very thorough, covering all the cases\n>> I could think to create this strange situation. I even tried creating\n>> cases where the overflow would be necessary. The following test actually\n>> fails on the ""graph_read_expect 6"" due to the extra chunk, not the \'write\'\n>> process I was trying to trick into failure.\n>>\n>> diff --git a/t/t5324-split-commit-graph.sh b/t/t5324-split-commit-graph.sh\n>> index 8e90f3423b..cfef8e52b9 100755\n>> --- a/t/t5324-split-commit-graph.sh\n>> +++ b/t/t5324-split-commit-graph.sh\n>> @@ -453,6 +453,20 @@ test_expect_success \'prevent regression for duplicate commits across layers\' \'\n>>         git -C dup commit-graph verify\n>>  \'\n>>  \n>> +test_expect_success \'upgrade to generation data succeeds when there was none\' \'\n>> +\t(\n>> +\t\tcd dup &&\n>> +\t\trm -rf .git/objects/info/commit-graph* &&\n>> +\t\tGIT_TEST_COMMIT_GRAPH_NO_GDAT=1 git commit-graph \\\n>> +\t\t\twrite --reachable &&\n>> +\t\tGIT_COMMITTER_DATE=""1980-01-01 00:00"" git commit --allow-empty -m one &&\n>> +\t\tGIT_COMMITTER_DATE=""2090-01-01 00:00"" git commit --allow-empty -m two &&\n>> +\t\tGIT_COMMITTER_DATE=""2000-01-01 00:00"" git commit --allow-empty -m three &&\n>> +\t\tgit commit-graph write --reachable &&\n>> +\t\tgraph_read_expect 6\n>> +\t)\n>> +\'\n> \n> I am not sure what this test adds over the existing generation data\n> overflow related tests added in t5318-commit-graph.sh\n\nGood point.\n\n-Stolee\n``````````\n', 'comment_created': datetime.datetime(2021, 1, 11, 12, 47, 1, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 565010515, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/20210127000454.GA1440011@szeder.dev), SZEDER Gábor wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Sat, Jan 16, 2021 at 06:11:18PM +0000, Abhishek Kumar via GitGitGadget wrote:\n> With generation data chunk and corrected commit dates implemented, let\'s\n> update the technical documentation for commit-graph.\n\nThis patch should come much earlier in this series, before patch 07/11\n(commit-graph: implement corrected commit date), or perhaps even\nearlier.  That way if someone were to investigate an issue in this\nseries and checks out one of its commits, then the specification and\nthe will be right there under \'Documentation/technical/\'.\n\nFurthermore, a patch introducing a new chunk format is the right place\nto justify the introduction of said new chunk.  What problems does a\nchunk of corrected commit dates solve?  Why does it solve them?  Why\ndo we need corrected commit dates instead of simple commit dates?\nWhat alternatives were considered [1]?  Any other design considerations\nworth mentioning for the benefit of future readers?\n\nNone of the patches\' log messages properly explain these, and while\nmuch of these is indeed explained in the cover letter, the cover\nletter will not be part of the history.  Requiring to look up mailing\nlist archives for the justification puts unnecessary burden on other\ndevelopers who might get interested in this feature in the future.\n\nYou might want to take\nhttps://public-inbox.org/git/20200529085038.26008-16-szeder.dev@gmail.com/\nas an inspiration.\n\n\n[1] Please remember the following snippet from SubmittingPatches:\n    ""Try to make sure your explanation can be understood without\n    external resources. Instead of giving a URL to a mailing list\n    archive, summarize the relevant points of the discussion.""\n\n> Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> ---\n>  .../technical/commit-graph-format.txt         | 28 +++++--\n>  Documentation/technical/commit-graph.txt      | 77 +++++++++++++++----\n>  2 files changed, 86 insertions(+), 19 deletions(-)\n> \n> diff --git a/Documentation/technical/commit-graph-format.txt b/Documentation/technical/commit-graph-format.txt\n> index b3b58880b92..b6658eff188 100644\n> --- a/Documentation/technical/commit-graph-format.txt\n> +++ b/Documentation/technical/commit-graph-format.txt\n> @@ -4,11 +4,7 @@ Git commit graph format\n>  The Git commit graph stores a list of commit OIDs and some associated\n>  metadata, including:\n>  \n> -- The generation number of the commit. Commits with no parents have\n> -  generation number 1; commits with parents have generation number\n> -  one more than the maximum generation number of its parents. We\n> -  reserve zero as special, and can be used to mark a generation\n> -  number invalid or as ""not computed"".\n> +- The generation number of the commit.\n>  \n>  - The root tree OID.\n>  \n> @@ -86,13 +82,33 @@ CHUNK DATA:\n>        position. If there are more than two parents, the second value\n>        has its most-significant bit on and the other bits store an array\n>        position into the Extra Edge List chunk.\n> -    * The next 8 bytes store the generation number of the commit and\n> +    * The next 8 bytes store the topological level (generation number v1)\n> +      of the commit and\n>        the commit time in seconds since EPOCH. The generation number\n>        uses the higher 30 bits of the first 4 bytes, while the commit\n>        time uses the 32 bits of the second 4 bytes, along with the lowest\n>        2 bits of the lowest byte, storing the 33rd and 34th bit of the\n>        commit time.\n>  \n> +  Generation Data (ID: {\'G\', \'D\', \'A\', \'T\' }) (N * 4 bytes) [Optional]\n> +    * This list of 4-byte values store corrected commit date offsets for the\n> +      commits, arranged in the same order as commit data chunk.\n> +    * If the corrected commit date offset cannot be stored within 31 bits,\n> +      the value has its most-significant bit on and the other bits store\n> +      the position of corrected commit date into the Generation Data Overflow\n> +      chunk.\n> +    * Generation Data chunk is present only when commit-graph file is written\n> +      by compatible versions of Git and in case of split commit-graph chains,\n> +      the topmost layer also has Generation Data chunk.\n> +\n> +  Generation Data Overflow (ID: {\'G\', \'D\', \'O\', \'V\' }) [Optional]\n> +    * This list of 8-byte values stores the corrected commit date offsets\n> +      for commits with corrected commit date offsets that cannot be\n> +      stored within 31 bits.\n> +    * Generation Data Overflow chunk is present only when Generation Data\n> +      chunk is present and atleast one corrected commit date offset cannot\n> +      be stored within 31 bits.\n> +\n>    Extra Edge List (ID: {\'E\', \'D\', \'G\', \'E\'}) [Optional]\n>        This list of 4-byte values store the second through nth parents for\n>        all octopus merges. The second parent value in the commit data stores\n> diff --git a/Documentation/technical/commit-graph.txt b/Documentation/technical/commit-graph.txt\n> index f14a7659aa8..f05e7bda1a9 100644\n> --- a/Documentation/technical/commit-graph.txt\n> +++ b/Documentation/technical/commit-graph.txt\n> @@ -38,14 +38,31 @@ A consumer may load the following info for a commit from the graph:\n>  \n>  Values 1-4 satisfy the requirements of parse_commit_gently().\n>  \n> -Define the ""generation number"" of a commit recursively as follows:\n> +There are two definitions of generation number:\n> +1. Corrected committer dates (generation number v2)\n> +2. Topological levels (generation nummber v1)\n>  \n> - * A commit with no parents (a root commit) has generation number one.\n> +Define ""corrected committer date"" of a commit recursively as follows:\n>  \n> - * A commit with at least one parent has generation number one more than\n> -   the largest generation number among its parents.\n> + * A commit with no parents (a root commit) has corrected committer date\n> +    equal to its committer date.\n>  \n> -Equivalently, the generation number of a commit A is one more than the\n> + * A commit with at least one parent has corrected committer date equal to\n> +    the maximum of its commiter date and one more than the largest corrected\n> +    committer date among its parents.\n> +\n> + * As a special case, a root commit with timestamp zero has corrected commit\n> +    date of 1, to be able to distinguish it from GENERATION_NUMBER_ZERO\n> +    (that is, an uncomputed corrected commit date).\n> +\n> +Define the ""topological level"" of a commit recursively as follows:\n> +\n> + * A commit with no parents (a root commit) has topological level of one.\n> +\n> + * A commit with at least one parent has topological level one more than\n> +   the largest topological level among its parents.\n> +\n> +Equivalently, the topological level of a commit A is one more than the\n>  length of a longest path from A to a root commit. The recursive definition\n>  is easier to use for computation and observing the following property:\n>  \n> @@ -60,6 +77,9 @@ is easier to use for computation and observing the following property:\n>      generation numbers, then we always expand the boundary commit with highest\n>      generation number and can easily detect the stopping condition.\n>  \n> +The property applies to both versions of generation number, that is both\n> +corrected committer dates and topological levels.\n> +\n>  This property can be used to significantly reduce the time it takes to\n>  walk commits and determine topological relationships. Without generation\n>  numbers, the general heuristic is the following:\n> @@ -67,7 +87,9 @@ numbers, the general heuristic is the following:\n>      If A and B are commits with commit time X and Y, respectively, and\n>      X < Y, then A _probably_ cannot reach B.\n>  \n> -This heuristic is currently used whenever the computation is allowed to\n> +In absence of corrected commit dates (for example, old versions of Git or\n> +mixed generation graph chains),\n> +this heuristic is currently used whenever the computation is allowed to\n>  violate topological relationships due to clock skew (such as ""git log""\n>  with default order), but is not used when the topological order is\n>  required (such as merge base calculations, ""git log --graph"").\n> @@ -77,7 +99,7 @@ in the commit graph. We can treat these commits as having ""infinite""\n>  generation number and walk until reaching commits with known generation\n>  number.\n>  \n> -We use the macro GENERATION_NUMBER_INFINITY = 0xFFFFFFFF to mark commits not\n> +We use the macro GENERATION_NUMBER_INFINITY to mark commits not\n>  in the commit-graph file. If a commit-graph file was written by a version\n>  of Git that did not compute generation numbers, then those commits will\n>  have generation number represented by the macro GENERATION_NUMBER_ZERO = 0.\n> @@ -93,12 +115,12 @@ fully-computed generation numbers. Using strict inequality may result in\n>  walking a few extra commits, but the simplicity in dealing with commits\n>  with generation number *_INFINITY or *_ZERO is valuable.\n>  \n> -We use the macro GENERATION_NUMBER_MAX = 0x3FFFFFFF to for commits whose\n> -generation numbers are computed to be at least this value. We limit at\n> -this value since it is the largest value that can be stored in the\n> -commit-graph file using the 30 bits available to generation numbers. This\n> -presents another case where a commit can have generation number equal to\n> -that of a parent.\n> +We use the macro GENERATION_NUMBER_V1_MAX = 0x3FFFFFFF for commits whose\n> +topological levels (generation number v1) are computed to be at least\n> +this value. We limit at this value since it is the largest value that\n> +can be stored in the commit-graph file using the 30 bits available\n> +to topological levels. This presents another case where a commit can\n> +have generation number equal to that of a parent.\n>  \n>  Design Details\n>  --------------\n> @@ -267,6 +289,35 @@ The merge strategy values (2 for the size multiple, 64,000 for the maximum\n>  number of commits) could be extracted into config settings for full\n>  flexibility.\n>  \n> +## Handling Mixed Generation Number Chains\n> +\n> +With the introduction of generation number v2 and generation data chunk, the\n> +following scenario is possible:\n> +\n> +1. ""New"" Git writes a commit-graph with the corrected commit dates.\n> +2. ""Old"" Git writes a split commit-graph on top without corrected commit dates.\n> +\n> +A naive approach of using the newest available generation number from\n> +each layer would lead to violated expectations: the lower layer would\n> +use corrected commit dates which are much larger than the topological\n> +levels of the higher layer. For this reason, Git inspects the topmost\n> +layer to see if the layer is missing corrected commit dates. In such a case\n> +Git only uses topological level for generation numbers.\n> +\n> +When writing a new layer in split commit-graph, we write corrected commit\n> +dates if the topmost layer has corrected commit dates written. This\n> +guarantees that if a layer has corrected commit dates, all lower layers\n> +must have corrected commit dates as well.\n> +\n> +When merging layers, we do not consider whether the merged layers had corrected\n> +commit dates. Instead, the new layer will have corrected commit dates if the\n> +layer below the new layer has corrected commit dates.\n> +\n> +While writing or merging layers, if the new layer is the only layer, it will\n> +have corrected commit dates when written by compatible versions of Git. Thus,\n> +rewriting split commit-graph as a single file (`--split=replace`) creates a\n> +single layer with corrected commit dates.\n> +\n>  ## Deleting graph-{hash} files\n>  \n>  After a new tip file is written, some `graph-{hash}` files may no longer\n> -- \n> gitgitgadget\n``````````\n', 'comment_created': datetime.datetime(2021, 1, 27, 4, 0, 12, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 567201607, 'comment_body': '[On the Git mailing list](https://lore.kernel.org/git/YBTuoTsrnbzLtX0j@Abhishek-Arch), Abhishek Kumar wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Wed, Jan 27, 2021 at 01:04:54AM +0100, SZEDER G�bor wrote:\n> On Sat, Jan 16, 2021 at 06:11:18PM +0000, Abhishek Kumar via GitGitGadget wrote:\n> > With generation data chunk and corrected commit dates implemented, let\'s\n> > update the technical documentation for commit-graph.\n> \n> This patch should come much earlier in this series, before patch 07/11\n> (commit-graph: implement corrected commit date), or perhaps even\n> earlier.  That way if someone were to investigate an issue in this\n> series and checks out one of its commits, then the specification and\n> the will be right there under \'Documentation/technical/\'.\n> \n> Furthermore, a patch introducing a new chunk format is the right place\n> to justify the introduction of said new chunk.  What problems does a\n> chunk of corrected commit dates solve?  Why does it solve them?  Why\n> do we need corrected commit dates instead of simple commit dates?\n> What alternatives were considered [1]?  Any other design considerations\n> worth mentioning for the benefit of future readers?\n> \n> None of the patches\' log messages properly explain these, and while\n> much of these is indeed explained in the cover letter, the cover\n> letter will not be part of the history.  Requiring to look up mailing\n> list archives for the justification puts unnecessary burden on other\n> developers who might get interested in this feature in the future.\n> \n> You might want to take\n> https://public-inbox.org/git/20200529085038.26008-16-szeder.dev@gmail.com/\n> as an inspiration.\n> \n\nAlright, the suggestion makes a lot of sense and the patch introducing\ndocumentation is the perfect place to justify the introduction of new\nchunk format.\n\n> \n> [1] Please remember the following snippet from SubmittingPatches:\n>     ""Try to make sure your explanation can be understood without\n>     external resources. Instead of giving a URL to a mailing list\n>     archive, summarize the relevant points of the discussion.""\n> \n> > Signed-off-by: Abhishek Kumar <abhishekkumar8222@gmail.com>\n> > ---\n> >  .../technical/commit-graph-format.txt         | 28 +++++--\n> >  Documentation/technical/commit-graph.txt      | 77 +++++++++++++++----\n> >  2 files changed, 86 insertions(+), 19 deletions(-)\n> > \n> > diff --git a/Documentation/technical/commit-graph-format.txt b/Documentation/technical/commit-graph-format.txt\n> > index b3b58880b92..b6658eff188 100644\n> > --- a/Documentation/technical/commit-graph-format.txt\n> > +++ b/Documentation/technical/commit-graph-format.txt\n> > @@ -4,11 +4,7 @@ Git commit graph format\n> >  The Git commit graph stores a list of commit OIDs and some associated\n> >  metadata, including:\n> >  \n> > -- The generation number of the commit. Commits with no parents have\n> > -  generation number 1; commits with parents have generation number\n> > -  one more than the maximum generation number of its parents. We\n> > -  reserve zero as special, and can be used to mark a generation\n> > -  number invalid or as ""not computed"".\n> > +- The generation number of the commit.\n> >  \n> >  - The root tree OID.\n> >  \n> > @@ -86,13 +82,33 @@ CHUNK DATA:\n> >        position. If there are more than two parents, the second value\n> >        has its most-significant bit on and the other bits store an array\n> >        position into the Extra Edge List chunk.\n> > -    * The next 8 bytes store the generation number of the commit and\n> > +    * The next 8 bytes store the topological level (generation number v1)\n> > +      of the commit and\n> >        the commit time in seconds since EPOCH. The generation number\n> >        uses the higher 30 bits of the first 4 bytes, while the commit\n> >        time uses the 32 bits of the second 4 bytes, along with the lowest\n> >        2 bits of the lowest byte, storing the 33rd and 34th bit of the\n> >        commit time.\n> >  \n> > +  Generation Data (ID: {\'G\', \'D\', \'A\', \'T\' }) (N * 4 bytes) [Optional]\n> > +    * This list of 4-byte values store corrected commit date offsets for the\n> > +      commits, arranged in the same order as commit data chunk.\n> > +    * If the corrected commit date offset cannot be stored within 31 bits,\n> > +      the value has its most-significant bit on and the other bits store\n> > +      the position of corrected commit date into the Generation Data Overflow\n> > +      chunk.\n> > +    * Generation Data chunk is present only when commit-graph file is written\n> > +      by compatible versions of Git and in case of split commit-graph chains,\n> > +      the topmost layer also has Generation Data chunk.\n> > +\n> > +  Generation Data Overflow (ID: {\'G\', \'D\', \'O\', \'V\' }) [Optional]\n> > +    * This list of 8-byte values stores the corrected commit date offsets\n> > +      for commits with corrected commit date offsets that cannot be\n> > +      stored within 31 bits.\n> > +    * Generation Data Overflow chunk is present only when Generation Data\n> > +      chunk is present and atleast one corrected commit date offset cannot\n> > +      be stored within 31 bits.\n> > +\n> >    Extra Edge List (ID: {\'E\', \'D\', \'G\', \'E\'}) [Optional]\n> >        This list of 4-byte values store the second through nth parents for\n> >        all octopus merges. The second parent value in the commit data stores\n> > diff --git a/Documentation/technical/commit-graph.txt b/Documentation/technical/commit-graph.txt\n> > index f14a7659aa8..f05e7bda1a9 100644\n> > --- a/Documentation/technical/commit-graph.txt\n> > +++ b/Documentation/technical/commit-graph.txt\n> > @@ -38,14 +38,31 @@ A consumer may load the following info for a commit from the graph:\n> >  \n> >  Values 1-4 satisfy the requirements of parse_commit_gently().\n> >  \n> > -Define the ""generation number"" of a commit recursively as follows:\n> > +There are two definitions of generation number:\n> > +1. Corrected committer dates (generation number v2)\n> > +2. Topological levels (generation nummber v1)\n> >  \n> > - * A commit with no parents (a root commit) has generation number one.\n> > +Define ""corrected committer date"" of a commit recursively as follows:\n> >  \n> > - * A commit with at least one parent has generation number one more than\n> > -   the largest generation number among its parents.\n> > + * A commit with no parents (a root commit) has corrected committer date\n> > +    equal to its committer date.\n> >  \n> > -Equivalently, the generation number of a commit A is one more than the\n> > + * A commit with at least one parent has corrected committer date equal to\n> > +    the maximum of its commiter date and one more than the largest corrected\n> > +    committer date among its parents.\n> > +\n> > + * As a special case, a root commit with timestamp zero has corrected commit\n> > +    date of 1, to be able to distinguish it from GENERATION_NUMBER_ZERO\n> > +    (that is, an uncomputed corrected commit date).\n> > +\n> > +Define the ""topological level"" of a commit recursively as follows:\n> > +\n> > + * A commit with no parents (a root commit) has topological level of one.\n> > +\n> > + * A commit with at least one parent has topological level one more than\n> > +   the largest topological level among its parents.\n> > +\n> > +Equivalently, the topological level of a commit A is one more than the\n> >  length of a longest path from A to a root commit. The recursive definition\n> >  is easier to use for computation and observing the following property:\n> >  \n> > @@ -60,6 +77,9 @@ is easier to use for computation and observing the following property:\n> >      generation numbers, then we always expand the boundary commit with highest\n> >      generation number and can easily detect the stopping condition.\n> >  \n> > +The property applies to both versions of generation number, that is both\n> > +corrected committer dates and topological levels.\n> > +\n> >  This property can be used to significantly reduce the time it takes to\n> >  walk commits and determine topological relationships. Without generation\n> >  numbers, the general heuristic is the following:\n> > @@ -67,7 +87,9 @@ numbers, the general heuristic is the following:\n> >      If A and B are commits with commit time X and Y, respectively, and\n> >      X < Y, then A _probably_ cannot reach B.\n> >  \n> > -This heuristic is currently used whenever the computation is allowed to\n> > +In absence of corrected commit dates (for example, old versions of Git or\n> > +mixed generation graph chains),\n> > +this heuristic is currently used whenever the computation is allowed to\n> >  violate topological relationships due to clock skew (such as ""git log""\n> >  with default order), but is not used when the topological order is\n> >  required (such as merge base calculations, ""git log --graph"").\n> > @@ -77,7 +99,7 @@ in the commit graph. We can treat these commits as having ""infinite""\n> >  generation number and walk until reaching commits with known generation\n> >  number.\n> >  \n> > -We use the macro GENERATION_NUMBER_INFINITY = 0xFFFFFFFF to mark commits not\n> > +We use the macro GENERATION_NUMBER_INFINITY to mark commits not\n> >  in the commit-graph file. If a commit-graph file was written by a version\n> >  of Git that did not compute generation numbers, then those commits will\n> >  have generation number represented by the macro GENERATION_NUMBER_ZERO = 0.\n> > @@ -93,12 +115,12 @@ fully-computed generation numbers. Using strict inequality may result in\n> >  walking a few extra commits, but the simplicity in dealing with commits\n> >  with generation number *_INFINITY or *_ZERO is valuable.\n> >  \n> > -We use the macro GENERATION_NUMBER_MAX = 0x3FFFFFFF to for commits whose\n> > -generation numbers are computed to be at least this value. We limit at\n> > -this value since it is the largest value that can be stored in the\n> > -commit-graph file using the 30 bits available to generation numbers. This\n> > -presents another case where a commit can have generation number equal to\n> > -that of a parent.\n> > +We use the macro GENERATION_NUMBER_V1_MAX = 0x3FFFFFFF for commits whose\n> > +topological levels (generation number v1) are computed to be at least\n> > +this value. We limit at this value since it is the largest value that\n> > +can be stored in the commit-graph file using the 30 bits available\n> > +to topological levels. This presents another case where a commit can\n> > +have generation number equal to that of a parent.\n> >  \n> >  Design Details\n> >  --------------\n> > @@ -267,6 +289,35 @@ The merge strategy values (2 for the size multiple, 64,000 for the maximum\n> >  number of commits) could be extracted into config settings for full\n> >  flexibility.\n> >  \n> > +## Handling Mixed Generation Number Chains\n> > +\n> > +With the introduction of generation number v2 and generation data chunk, the\n> > +following scenario is possible:\n> > +\n> > +1. ""New"" Git writes a commit-graph with the corrected commit dates.\n> > +2. ""Old"" Git writes a split commit-graph on top without corrected commit dates.\n> > +\n> > +A naive approach of using the newest available generation number from\n> > +each layer would lead to violated expectations: the lower layer would\n> > +use corrected commit dates which are much larger than the topological\n> > +levels of the higher layer. For this reason, Git inspects the topmost\n> > +layer to see if the layer is missing corrected commit dates. In such a case\n> > +Git only uses topological level for generation numbers.\n> > +\n> > +When writing a new layer in split commit-graph, we write corrected commit\n> > +dates if the topmost layer has corrected commit dates written. This\n> > +guarantees that if a layer has corrected commit dates, all lower layers\n> > +must have corrected commit dates as well.\n> > +\n> > +When merging layers, we do not consider whether the merged layers had corrected\n> > +commit dates. Instead, the new layer will have corrected commit dates if the\n> > +layer below the new layer has corrected commit dates.\n> > +\n> > +While writing or merging layers, if the new layer is the only layer, it will\n> > +have corrected commit dates when written by compatible versions of Git. Thus,\n> > +rewriting split commit-graph as a single file (`--split=replace`) creates a\n> > +single layer with corrected commit dates.\n> > +\n> >  ## Deleting graph-{hash} files\n> >  \n> >  After a new tip file is written, some `graph-{hash}` files may no longer\n> > -- \n> > gitgitgadget\n\nThanks\n- Abhishek\n``````````\n', 'comment_created': datetime.datetime(2021, 1, 30, 5, 36, 1, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}, {'comment_id': 567350137, 'comment_body': ""[On the Git mailing list](https://lore.kernel.org/git/YBYLwpKdUfxCNwaz@nand.local), Taylor Blau wrote ([reply to this](https://github.com/gitgitgadget/gitgitgadget/wiki/ReplyToThis)):\n\n``````````\nOn Sat, Jan 30, 2021 at 10:59:05AM +0530, Abhishek Kumar wrote:\n> > You might want to take\n> > https://public-inbox.org/git/20200529085038.26008-16-szeder.dev@gmail.com/\n> > as an inspiration.\n> >\n> Alright, the suggestion makes a lot of sense and the patch introducing\n> documentation is the perfect place to justify the introduction of new\n> chunk format.\n\nI don't have any strong feelings about Gábor's suggestion itself, but\nnote that there isn't any work for you to do in this series, since the\npatches are on track to be merged to master.\n\nThanks,\nTaylor\n``````````\n"", 'comment_created': datetime.datetime(2021, 1, 31, 1, 49, 3, tzinfo=datetime.timezone.utc), 'commenter': 'gitgitgadget[bot]', 'type': 'Bot'}]","[{'commit_sha': '9ac331b63ee609f5380649d3b395f420e57e56f8', 'committer_username': 'abhishekkumar2718', 'committer_name': 'Abhishek Kumar', 'committer_email': 'abhishekkumar8222@gmail.com', 'commit_date': datetime.datetime(2017, 8, 22, 3, 2, 51, tzinfo=datetime.timezone.utc)}, {'commit_sha': '90ca0a1fd697b91180a01d82eeaed54511c9719f', 'committer_username': 'abhishekkumar2718', 'committer_name': 'Abhishek Kumar', 'committer_email': 'abhishekkumar8222@gmail.com', 'commit_date': datetime.datetime(2017, 8, 22, 3, 2, 51, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'b3040696d43f1abb6d7a50590b4e181cd2eb74aa', 'committer_username': 'abhishekkumar2718', 'committer_name': 'Abhishek Kumar', 'committer_email': 'abhishekkumar8222@gmail.com', 'commit_date': datetime.datetime(2017, 8, 22, 3, 2, 51, tzinfo=datetime.timezone.utc)}, {'commit_sha': '085085a433072076ffa45d149cdf4e0b6b55d918', 'committer_username': 'abhishekkumar2718', 'committer_name': 'Abhishek Kumar', 'committer_email': 'abhishekkumar8222@gmail.com', 'commit_date': datetime.datetime(2017, 8, 22, 3, 2, 51, tzinfo=datetime.timezone.utc)}, {'commit_sha': '3b1aae4106a409cf4652e07295683f92d7bf1fb2', 'committer_username': 'abhishekkumar2718', 'committer_name': 'Abhishek Kumar', 'committer_email': 'abhishekkumar8222@gmail.com', 'commit_date': datetime.datetime(2017, 8, 22, 3, 2, 51, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ea32cba16ef8533117d583aea46cd5a254ef4e24', 'committer_username': 'abhishekkumar2718', 'committer_name': 'Abhishek Kumar', 'committer_email': 'abhishekkumar8222@gmail.com', 'commit_date': datetime.datetime(2017, 8, 22, 3, 2, 51, tzinfo=datetime.timezone.utc)}, {'commit_sha': '8647b5d2e38d7c00b4b189b5cba27cc4f61b778c', 'committer_username': 'abhishekkumar2718', 'committer_name': 'Abhishek Kumar', 'committer_email': 'abhishekkumar8222@gmail.com', 'commit_date': datetime.datetime(2017, 8, 22, 3, 2, 51, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ec598f1d500b542953e8786f67f35115c2b29fec', 'committer_username': 'abhishekkumar2718', 'committer_name': 'Abhishek Kumar', 'committer_email': 'abhishekkumar8222@gmail.com', 'commit_date': datetime.datetime(2017, 8, 22, 3, 2, 51, tzinfo=datetime.timezone.utc)}, {'commit_sha': '71d815188571c3ea421244918b73f762cd7963e3', 'committer_username': 'abhishekkumar2718', 'committer_name': 'Abhishek Kumar', 'committer_email': 'abhishekkumar8222@gmail.com', 'commit_date': datetime.datetime(2017, 8, 22, 3, 2, 51, tzinfo=datetime.timezone.utc)}, {'commit_sha': '07a88f1aae6f7f7812ab7a5937eac73131c2139e', 'committer_username': 'abhishekkumar2718', 'committer_name': 'Abhishek Kumar', 'committer_email': 'abhishekkumar8222@gmail.com', 'commit_date': datetime.datetime(2017, 8, 22, 3, 2, 51, tzinfo=datetime.timezone.utc)}, {'commit_sha': '523e2d4a902b22fb7e0234bf9c207f7b071b7187', 'committer_username': 'abhishekkumar2718', 'committer_name': 'Abhishek Kumar', 'committer_email': 'abhishekkumar8222@gmail.com', 'commit_date': datetime.datetime(2017, 8, 22, 3, 2, 51, tzinfo=datetime.timezone.utc)}]",Abhishek Kumar,31231064,abhishekkumar8222@gmail.com,User,,18,,17,40

Project_ID,Name,Full_name,Language,Forks,Stars,Watchers,contributors,commits,issues,branches,PRs_count,contributor pullrequests
135437869,git,gitgitgadget/git,C,132,205,28,2235,74374,264,536,188,"[{'id': 585297654, 'number': 894, 'closed': None, 'created': datetime.datetime(2021, 3, 5, 3, 55, 52, tzinfo=datetime.timezone.utc), 'time_taken': 0.0, 'time_delta': '', 'additions': 67, 'deletions': 93, 'state': 'open'}, {'id': 448615340, 'number': 676, 'closed': datetime.datetime(2021, 2, 19, 0, 12, 26, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2020, 7, 14, 3, 10, 29, tzinfo=datetime.timezone.utc), 'time_taken': 18997317.0, 'time_delta': '219 days, 21:01:57', 'additions': 667, 'deletions': 154, 'state': 'closed'}]"
