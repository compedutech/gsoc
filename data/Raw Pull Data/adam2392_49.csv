pr_id,pr_title,pr_body,is_merged,pr_number,pr_url,pr_html_url,pr_state,additions,deletions,pr_changed_files,pr_commits_count,pr_comments_count,pr_review_comments_count,pr_labels_count,pr_assignees_count,pr_labels,pr_created_at,pr_closed_at,time_taken,time_delta,pr_review_comments,pr_commits,contributor,contributor_id,contributor_email,contributor_type,contributions,contributor_public_repos,contributor_private_repos,contributor_followings,contributor_followers
1485043105,[ENH] Fix coiteration algorithm to handle nested levels,"The current coiteration algorithm works when we define levels that are not stacked. Therefore, when we initialize `coiter_helper`, we just pass in an empty tuple and a `ZERO` marker for the IKs and PK. 

This is fine and works now, but it will not work when we want to use coiteration on levels that are nested in other levels. For example, say we have a dense pointing to a compressed level. Then we need to pass in the IK and PK of the dense, so we know where to start iterating in the compressed level. This is not currently supported because there is only one PK that is passed in. We need to pass in a tuple of PKs and tuple of IKs, not just a tuple of IKs and a PK.

### Sketch of plan

1. Define the unit-test that this must pass: Define a set of nested levels. Define two co-iterators.
2. Implement change in `co_iteration.hpp`


### Some difficulties

1. The changing of the PK to a tuple of PKs will change the design of the coiterator. It remains tbd how this will affect everything else",True,31,https://api.github.com/repos/hameerabbasi/xsparse/pulls/31,https://github.com/hameerabbasi/xsparse/pull/31,closed,235,32,5,19,5,22,0,0,[],2023-08-22 16:08:10+00:00,2023-08-31 19:24:14+00:00,789364.0,"9 days, 3:16:04","[{'comment_id': 1306110298, 'comment_body': ""This is the only part that's giving me trouble now. \r\n\r\nNote: Each `iter_helper` for each level takes a pair of elements for `IK` and `PKm1`, not a tuple.\r\n\r\n**Before:** The way it worked before was that `pkm1` was always a single element, so it would not need to get unpacked. On the other hand, `i` is either an empty tuple, or a tuple with the first element corresponding to the index we need to pass through. \r\n\r\n**Now:** For the `iter_helper`'s IK argument, we want to pass in an empty tuple, or the first index of `i` if `i` is not empty. This corresponds to the min_ik from the above level. We then want to expand the `pkm1` to each level's iter_helper. \r\n\r\nIs this thought correct? If so any idea how to go about doing this?\r\n\r\ncc: @hameerabbasi @bharath2438 "", 'comment_created': datetime.datetime(2023, 8, 25, 20, 9, 54, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1310613785, 'comment_body': 'This is the new change that leverages a templated `unfold_and_apply_helper` function to define the iter_helpers for each `coiterate.m_levelsTuple`.', 'comment_created': datetime.datetime(2023, 8, 30, 17, 34, 32, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1310616431, 'comment_body': 'When these LOC get uncommented, there is a segfault error during compilation time that I cannot parse.\r\n\r\n```\r\n(base) adam2392@Adams-MBP-3 xsparse % cmake --build build/test\r\n[ 25%] Built target fmt\r\n[ 25%] Built target XSparse\r\n[ 33%] Building CXX object CMakeFiles/XSparseTests.dir/source/coiteration_test.cpp.o\r\nclang: error: unable to execute command: Segmentation fault: 11\r\nclang: error: clang frontend command failed due to signal (use -v to see invocation)\r\nApple clang version 14.0.3 (clang-1403.0.22.14.1)\r\nTarget: arm64-apple-darwin22.6.0\r\nThread model: posix\r\nInstalledDir: /Library/Developer/CommandLineTools/usr/bin\r\nclang: note: diagnostic msg: \r\n********************\r\n\r\nPLEASE ATTACH THE FOLLOWING FILES TO THE BUG REPORT:\r\nPreprocessed source(s) and associated run script(s) are located at:\r\nclang: note: diagnostic msg: /var/folders/6_/sl83qtkd68x3_mvfys07_6qm0000gn/T/coiteration_test-d19547.cpp\r\nclang: note: diagnostic msg: /var/folders/6_/sl83qtkd68x3_mvfys07_6qm0000gn/T/coiteration_test-d19547.sh\r\nclang: note: diagnostic msg: Crash backtrace is located in\r\nclang: note: diagnostic msg: /Users/adam2392/Library/Logs/DiagnosticReports/clang_<YYYY-MM-DD-HHMMSS>_<hostname>.crash\r\nclang: note: diagnostic msg: (choose the .crash file that corresponds to your crash)\r\nclang: note: diagnostic msg: \r\n\r\n********************\r\nmake[2]: *** [CMakeFiles/XSparseTests.dir/source/coiteration_test.cpp.o] Error 254\r\nmake[1]: *** [CMakeFiles/XSparseTests.dir/all] Error 2\r\nmake: *** [all] Error 2\r\n```', 'comment_created': datetime.datetime(2023, 8, 30, 17, 36, 54, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1310625905, 'comment_body': ""This seems to be a bug on clang/Apple's side."", 'comment_created': datetime.datetime(2023, 8, 30, 17, 46, 22, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1310630867, 'comment_body': ""If we're always getting the first element, why have a tuple at all?"", 'comment_created': datetime.datetime(2023, 8, 30, 17, 51, 30, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1310637482, 'comment_body': ""I wanted to limit the scope of the change to just the `pkm1`, since that is forsure necessary to coiterate over nested levels. I don't know if the change to the passing of `min_ik`'s from above levels will affect other parts of the code(?)"", 'comment_created': datetime.datetime(2023, 8, 30, 17, 58, 28, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1310639342, 'comment_body': ""Hmm, for completeness I'd make those changes."", 'comment_created': datetime.datetime(2023, 8, 30, 18, 0, 25, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1310642834, 'comment_body': ""Oh sorry you're right. This was actually an unintended change. I reverted it back and it still has the same issues as highlighted in https://github.com/hameerabbasi/xsparse/pull/31#issuecomment-1699602394"", 'comment_created': datetime.datetime(2023, 8, 30, 18, 3, 57, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1310644816, 'comment_body': ""I'd debug on CI, or install g++ using homebrew and use that instead, or use a Linux VM."", 'comment_created': datetime.datetime(2023, 8, 30, 18, 6, 5, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1310664663, 'comment_body': ""Ah okay that helped. It seems the issue is that when we dereference `coiterate`, it returns a `std::optional<long unsigned int>`, but the iter_helper is expecting `BaseTraits::PKM1` type, which is defined as \r\n\r\n```\r\nusing PKM1 = std::tuple_element_t<\r\n            // First element of P\r\n            0,\r\n            // Except that the type list has uint8_t appended to it.\r\n            // This has the effect of choosing uint8_t instead of the\r\n            // first element if `sizeof...(LowerLevels) == 0`.\r\n            // is in place.\r\n            std::tuple<position_t<LowerLevels>..., bool>>;\r\n```\r\n\r\nComplete error message:\r\n```\r\nIn file included from /Users/adam2392/Documents/xsparse/test/source/coiteration_test.cpp:19:\r\n/Users/adam2392/Documents/xsparse/include/xsparse/level_capabilities/co_iteration.hpp: In instantiation of 'auto unfold_and_apply_helper(const std::tuple<_UTypes ...>&, const ITuple&, const Pkm1Tuple&, std::index_sequence<Indices ...>) [with Args = {xsparse::levels::compressed<std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >&, xsparse::levels::compressed<std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >&}; ITuple = std::tuple<long unsigned int>; Pkm1Tuple = std::tuple<std::optional<long unsigned int>, std::optional<long unsigned int> >; long unsigned int ...Indices = {0, 1}; std::index_sequence<Indices ...> = std::integer_sequence<long unsigned int, 0, 1>]':\r\n/Users/adam2392/Documents/xsparse/include/xsparse/level_capabilities/co_iteration.hpp:188:56:   required from 'xsparse::level_capabilities::Coiterate<F, Ffunc, IK, PK, std::tuple<Levels ...>, std::tuple<Is ...>, std::tuple<Ps ...> >::coiteration_helper::coiteration_helper(const xsparse::level_capabilities::Coiterate<F, Ffunc, IK, PK, std::tuple<Levels ...>, std::tuple<Is ...>, std::tuple<Ps ...> >&, std::tuple<Is ...>, std::tuple<Ps ...>) [with F = xsparse::util::LambdaWrapper<DOCTEST_ANON_FUNC_10()::<lambda(std::tuple<bool, bool>)> >::apply; Ffunc = DOCTEST_ANON_FUNC_10()::<lambda(std::tuple<bool, bool>)>; IK = long unsigned int; PK = long unsigned int; Levels = {xsparse::levels::compressed<std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >, xsparse::levels::compressed<std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >}; Is = {long unsigned int}; Ps = {std::optional<long unsigned int>, std::optional<long unsigned int>}]'\r\n/Users/adam2392/Documents/xsparse/include/xsparse/level_capabilities/co_iteration.hpp:441:55:   required from 'xsparse::level_capabilities::Coiterate<F, Ffunc, IK, PK, std::tuple<Levels ...>, std::tuple<Is ...>, std::tuple<Ps ...> >::coiteration_helper xsparse::level_capabilities::Coiterate<F, Ffunc, IK, PK, std::tuple<Levels ...>, std::tuple<Is ...>, std::tuple<Ps ...> >::coiter_helper(std::tuple<Is ...>, std::tuple<Ps ...>) [with F = xsparse::util::LambdaWrapper<DOCTEST_ANON_FUNC_10()::<lambda(std::tuple<bool, bool>)> >::apply; Ffunc = DOCTEST_ANON_FUNC_10()::<lambda(std::tuple<bool, bool>)>; IK = long unsigned int; PK = long unsigned int; Levels = {xsparse::levels::compressed<std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >, xsparse::levels::compressed<std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >}; Is = {long unsigned int}; Ps = {std::optional<long unsigned int>, std::optional<long unsigned int>}]'\r\n/Users/adam2392/Documents/xsparse/test/source/coiteration_test.cpp:404:45:   required from here\r\n/Users/adam2392/Documents/xsparse/include/xsparse/level_capabilities/co_iteration.hpp:45:63: error: cannot convert 'std::__tuple_element_t<0, std::tuple<std::optional<long unsigned int>, std::optional<long unsigned int> > >' {aka 'const std::optional<long unsigned int>'} to 'xsparse::util::base_traits<xsparse::levels::compressed, std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >::PKM1' {aka 'long unsigned int'}\r\n   45 |     return std::make_tuple(std::get<Indices>(args).iter_helper(m_i, std::get<Indices>(pkm1))...);\r\n      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\nIn file included from /Users/adam2392/Documents/xsparse/include/xsparse/levels/compressed.hpp:10,\r\n                 from /Users/adam2392/Documents/xsparse/test/source/coiteration_test.cpp:11:\r\n/Users/adam2392/Documents/xsparse/include/xsparse/level_capabilities/coordinate_iterate.hpp:271:90: note:   initializing argument 2 of 'xsparse::level_capabilities::coordinate_position_iterate<T, IK, PK, LowerLevels>::iteration_helper xsparse::level_capabilities::coordinate_position_iterate<T, IK, PK, LowerLevels>::iter_helper(typename BaseTraits::I, typename BaseTraits::PKM1) [with T = xsparse::levels::compressed; IK = std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >; PK = long unsigned int; LowerLevels = {long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true>}; typename BaseTraits::I = std::tuple<long unsigned int>; BaseTraits = xsparse::util::base_traits<xsparse::levels::compressed, std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >; typename BaseTraits::PKM1 = long unsigned int]'\r\n  271 |         iteration_helper iter_helper(typename BaseTraits::I i, typename BaseTraits::PKM1 pkm1)\r\n      |                                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\r\n```\r\n\r\nWould it be:\r\n\r\n1. good to change the PKM1 type to allow this?\r\n2. somehow cast the type?"", 'comment_created': datetime.datetime(2023, 8, 30, 18, 26, 31, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1310677572, 'comment_body': ""It's just wrapped in an extra `optional`, I think it should be safe to get the value."", 'comment_created': datetime.datetime(2023, 8, 30, 18, 38, 56, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1310697392, 'comment_body': 'Possibly stupid question. Where would you suggest making the change then? Perhaps in \r\n\r\n```\r\ntemplate <typename... Args, typename ITuple, typename Pkm1Tuple, size_t... Indices>\r\nauto\r\nunfold_and_apply_helper(const std::tuple<Args...>& args,\r\n                        const ITuple& m_i,\r\n                        const Pkm1Tuple& pkm1,\r\n                        std::index_sequence<Indices...>)\r\n{\r\n    return std::make_tuple(std::get<Indices>(args).iter_helper(m_i, std::get<Indices>(pkm1))...);\r\n}\r\n```\r\n? But not every element of `pkm1` is `std::optional` ', 'comment_created': datetime.datetime(2023, 8, 30, 18, 58, 29, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1310712716, 'comment_body': 'I think `pkm1` should never be `optional` in the first place, something is going wrong up the chain.', 'comment_created': datetime.datetime(2023, 8, 30, 19, 14, 20, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1310755814, 'comment_body': 'The issue is that dereferencing either calls: `deref_PKs(i)`, or `std::get<I>(this->m_coiterHelper.m_coiterate.m_levelsTuple)\r\n                            .locate(std::get<I>(m_coiterHelper.m_pkm1), min_ik)` depending on whether the level is ordered or not.\r\n\r\nDeref_PKS (https://github.com/hameerabbasi/xsparse/blob/bd482c099b3089fe512cccd60331ddf24ba84b91/include/xsparse/level_capabilities/co_iteration.hpp#L321):\r\n\r\n```\r\ntemplate <class iter>\r\n                inline auto deref_PKs(iter i) const noexcept\r\n                {\r\n                    return (std::get<0>(*i) == min_ik);\r\n                               ? std::optional<std::tuple_element_t<1, decltype(*i)>>(\r\n                                   std::get<1>(*i))\r\n                               : std::nullopt;\r\n                }\r\n```\r\n\r\nSimilarly locate is defined as (https://github.com/hameerabbasi/xsparse/blob/bd482c099b3089fe512cccd60331ddf24ba84b91/include/xsparse/levels/hashed.hpp#L157):\r\n\r\n```\r\ninline auto locate(typename BaseTraits::PKM1 pkm1, IK ik) const noexcept\r\n            {\r\n                auto it = m_crd[pkm1].find(ik);\r\n                return it != m_crd[pkm1].end() ? std::optional<PK>(it->second) : std::nullopt;\r\n            }\r\n```\r\n\r\nSo both routes return std::optional. ', 'comment_created': datetime.datetime(2023, 8, 30, 19, 58, 39, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1311115739, 'comment_body': ""If the algorithm is written correctly we should be able to de reference both without issue, otherwise there's something wrong with the algorithm; not the code."", 'comment_created': datetime.datetime(2023, 8, 31, 5, 37, 57, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1311738862, 'comment_body': ""We can dereference both though as evidenced by the existing unit-tests that test both of these dereferences of the `Coiterate`. That is not the issue I believe. The issue is that the compiler cannot handle the following:\r\n\r\n```\r\n'std::__tuple_element_t<0, std::tuple<std::optional<long unsigned int>, std::optional<long unsigned int> > >' {aka 'const std::optional<long unsigned int>'} to \r\n\r\n'xsparse::util::base_traits<xsparse::levels::compressed, std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >::PKM1' {aka 'long unsigned int'}\r\n```"", 'comment_created': datetime.datetime(2023, 8, 31, 14, 39, 35, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1311755520, 'comment_body': 'Ah I now see the issue -- we are missing const in one of them.', 'comment_created': datetime.datetime(2023, 8, 31, 14, 50, 51, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1311842837, 'comment_body': ""Google const correctness; something should be const but isn't or the other way around."", 'comment_created': datetime.datetime(2023, 8, 31, 15, 49, 59, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1311944032, 'comment_body': 'Ah okay it compiles! I needed to change one of the template arguments defined the `Ps` template type in `Coiterate`. It was incorrectly adding a `std::optional`, which I think gave it an issue because the returned type during dereferencing is ""there"".\r\n\r\nHowever, now the unit-test is the main issue. It is possible there is either an error in my unit-test, or in the actual Coiterate implementation for a nested level.', 'comment_created': datetime.datetime(2023, 8, 31, 17, 8, 6, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1311963862, 'comment_body': 'Moved to make the reading of code more sequential', 'comment_created': datetime.datetime(2023, 8, 31, 17, 25, 22, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1311964031, 'comment_body': 'I could place this in utils if we want?', 'comment_created': datetime.datetime(2023, 8, 31, 17, 25, 34, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1312121968, 'comment_body': 'If we need it elsewhere we can move it.', 'comment_created': datetime.datetime(2023, 8, 31, 19, 23, 19, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}]","[{'commit_sha': 'b0b788ddc0b87ed069642228e444883938ffa10d', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '1615f0f1f6d421bac106735dfa0916737c0b4cf9', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '80a6699d07e0c02980bbc77a0988fc703fcb89d0', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '44da584e77aa4642025d27d69f93cb1449d48fc7', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '49d3399ddbdf361573c07a3158971e203937c4ce', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '72d21ef12d4ce217d39ec10d2340a5537f2e9735', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'fce0e9a3ffddcde8c3b880d4cb8c3700aba0933a', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '93cb542f1062006a519eb5b8a350c0e41be6ec45', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '65e0dedde4bf2a8d0b078dcfd4cadc9fac3de9bc', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '849f3c6b2f69dd0287e2f82eb407bbea194335e8', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'aab47a4aaa029564b05c8ac93e3dd3a775879574', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'a5d6d8b183d72d7b5360f8ac769e22fdc1b7d981', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '74b58765336ff232d68bdd4867e8c88b51b74154', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '0818ce96675594eff2a0eb1962c5b5a12a60db4f', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'f9052aeb9bca3b309c388b135d96a19a6cc4bb75', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '54b881629a17526596a9f7959e77aa16eb110b19', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'deda62484efb6a7b5e3f8f17cfc4cbe18c239cbe', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'c7bcb3c061582d04575519b63dbd78734968dd1f', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '080493bcfda8981f369bcadcd1a5f441577c00ce', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}]",Adam Li,3460267,,User,,119,,30,93
1367118599,Merge upstream changes from template.,,True,21,https://api.github.com/repos/hameerabbasi/xsparse/pulls/21,https://github.com/hameerabbasi/xsparse/pull/21,closed,47,30,10,1,0,0,0,0,[],2023-05-27 06:45:51+00:00,2023-05-27 07:01:51+00:00,960.0,0:16:00,[],"[{'commit_sha': 'd4df3e9abb0d02484259bd147c6dd029168db05a', 'committer_username': 'hameerabbasi', 'committer_name': 'Hameer Abbasi', 'committer_email': None, 'commit_date': datetime.datetime(2012, 8, 21, 15, 48, 12, tzinfo=datetime.timezone.utc)}]",Hameer Abbasi,2190658,,User,,59,,2,69
1367118599,Merge upstream changes from template.,,True,21,https://api.github.com/repos/hameerabbasi/xsparse/pulls/21,https://github.com/hameerabbasi/xsparse/pull/21,closed,47,30,10,1,0,0,0,0,[],2023-05-27 06:45:51+00:00,2023-05-27 07:01:51+00:00,960.0,0:16:00,[],"[{'commit_sha': 'd4df3e9abb0d02484259bd147c6dd029168db05a', 'committer_username': 'hameerabbasi', 'committer_name': 'Hameer Abbasi', 'committer_email': None, 'commit_date': datetime.datetime(2012, 8, 21, 15, 48, 12, tzinfo=datetime.timezone.utc)}]",Hameer Abbasi,2190658,,User,,59,,2,69
1367118599,Merge upstream changes from template.,,True,21,https://api.github.com/repos/hameerabbasi/xsparse/pulls/21,https://github.com/hameerabbasi/xsparse/pull/21,closed,47,30,10,1,0,0,0,0,[],2023-05-27 06:45:51+00:00,2023-05-27 07:01:51+00:00,960.0,0:16:00,[],"[{'commit_sha': 'd4df3e9abb0d02484259bd147c6dd029168db05a', 'committer_username': 'hameerabbasi', 'committer_name': 'Hameer Abbasi', 'committer_email': None, 'commit_date': datetime.datetime(2012, 8, 21, 15, 48, 12, tzinfo=datetime.timezone.utc)}]",Hameer Abbasi,2190658,,User,,59,,2,69
1367118599,Merge upstream changes from template.,,True,21,https://api.github.com/repos/hameerabbasi/xsparse/pulls/21,https://github.com/hameerabbasi/xsparse/pull/21,closed,47,30,10,1,0,0,0,0,[],2023-05-27 06:45:51+00:00,2023-05-27 07:01:51+00:00,960.0,0:16:00,[],"[{'commit_sha': 'd4df3e9abb0d02484259bd147c6dd029168db05a', 'committer_username': 'hameerabbasi', 'committer_name': 'Hameer Abbasi', 'committer_email': None, 'commit_date': datetime.datetime(2012, 8, 21, 15, 48, 12, tzinfo=datetime.timezone.utc)}]",Hameer Abbasi,2190658,,User,,59,,2,69
1485043105,[ENH] Fix coiteration algorithm to handle nested levels,"The current coiteration algorithm works when we define levels that are not stacked. Therefore, when we initialize `coiter_helper`, we just pass in an empty tuple and a `ZERO` marker for the IKs and PK. 

This is fine and works now, but it will not work when we want to use coiteration on levels that are nested in other levels. For example, say we have a dense pointing to a compressed level. Then we need to pass in the IK and PK of the dense, so we know where to start iterating in the compressed level. This is not currently supported because there is only one PK that is passed in. We need to pass in a tuple of PKs and tuple of IKs, not just a tuple of IKs and a PK.

### Sketch of plan

1. Define the unit-test that this must pass: Define a set of nested levels. Define two co-iterators.
2. Implement change in `co_iteration.hpp`


### Some difficulties

1. The changing of the PK to a tuple of PKs will change the design of the coiterator. It remains tbd how this will affect everything else",True,31,https://api.github.com/repos/hameerabbasi/xsparse/pulls/31,https://github.com/hameerabbasi/xsparse/pull/31,closed,235,32,5,19,5,22,0,0,[],2023-08-22 16:08:10+00:00,2023-08-31 19:24:14+00:00,789364.0,"9 days, 3:16:04","[{'comment_id': 1306110298, 'comment_body': ""This is the only part that's giving me trouble now. \r\n\r\nNote: Each `iter_helper` for each level takes a pair of elements for `IK` and `PKm1`, not a tuple.\r\n\r\n**Before:** The way it worked before was that `pkm1` was always a single element, so it would not need to get unpacked. On the other hand, `i` is either an empty tuple, or a tuple with the first element corresponding to the index we need to pass through. \r\n\r\n**Now:** For the `iter_helper`'s IK argument, we want to pass in an empty tuple, or the first index of `i` if `i` is not empty. This corresponds to the min_ik from the above level. We then want to expand the `pkm1` to each level's iter_helper. \r\n\r\nIs this thought correct? If so any idea how to go about doing this?\r\n\r\ncc: @hameerabbasi @bharath2438 "", 'comment_created': datetime.datetime(2023, 8, 25, 20, 9, 54, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1310613785, 'comment_body': 'This is the new change that leverages a templated `unfold_and_apply_helper` function to define the iter_helpers for each `coiterate.m_levelsTuple`.', 'comment_created': datetime.datetime(2023, 8, 30, 17, 34, 32, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1310616431, 'comment_body': 'When these LOC get uncommented, there is a segfault error during compilation time that I cannot parse.\r\n\r\n```\r\n(base) adam2392@Adams-MBP-3 xsparse % cmake --build build/test\r\n[ 25%] Built target fmt\r\n[ 25%] Built target XSparse\r\n[ 33%] Building CXX object CMakeFiles/XSparseTests.dir/source/coiteration_test.cpp.o\r\nclang: error: unable to execute command: Segmentation fault: 11\r\nclang: error: clang frontend command failed due to signal (use -v to see invocation)\r\nApple clang version 14.0.3 (clang-1403.0.22.14.1)\r\nTarget: arm64-apple-darwin22.6.0\r\nThread model: posix\r\nInstalledDir: /Library/Developer/CommandLineTools/usr/bin\r\nclang: note: diagnostic msg: \r\n********************\r\n\r\nPLEASE ATTACH THE FOLLOWING FILES TO THE BUG REPORT:\r\nPreprocessed source(s) and associated run script(s) are located at:\r\nclang: note: diagnostic msg: /var/folders/6_/sl83qtkd68x3_mvfys07_6qm0000gn/T/coiteration_test-d19547.cpp\r\nclang: note: diagnostic msg: /var/folders/6_/sl83qtkd68x3_mvfys07_6qm0000gn/T/coiteration_test-d19547.sh\r\nclang: note: diagnostic msg: Crash backtrace is located in\r\nclang: note: diagnostic msg: /Users/adam2392/Library/Logs/DiagnosticReports/clang_<YYYY-MM-DD-HHMMSS>_<hostname>.crash\r\nclang: note: diagnostic msg: (choose the .crash file that corresponds to your crash)\r\nclang: note: diagnostic msg: \r\n\r\n********************\r\nmake[2]: *** [CMakeFiles/XSparseTests.dir/source/coiteration_test.cpp.o] Error 254\r\nmake[1]: *** [CMakeFiles/XSparseTests.dir/all] Error 2\r\nmake: *** [all] Error 2\r\n```', 'comment_created': datetime.datetime(2023, 8, 30, 17, 36, 54, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1310625905, 'comment_body': ""This seems to be a bug on clang/Apple's side."", 'comment_created': datetime.datetime(2023, 8, 30, 17, 46, 22, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1310630867, 'comment_body': ""If we're always getting the first element, why have a tuple at all?"", 'comment_created': datetime.datetime(2023, 8, 30, 17, 51, 30, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1310637482, 'comment_body': ""I wanted to limit the scope of the change to just the `pkm1`, since that is forsure necessary to coiterate over nested levels. I don't know if the change to the passing of `min_ik`'s from above levels will affect other parts of the code(?)"", 'comment_created': datetime.datetime(2023, 8, 30, 17, 58, 28, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1310639342, 'comment_body': ""Hmm, for completeness I'd make those changes."", 'comment_created': datetime.datetime(2023, 8, 30, 18, 0, 25, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1310642834, 'comment_body': ""Oh sorry you're right. This was actually an unintended change. I reverted it back and it still has the same issues as highlighted in https://github.com/hameerabbasi/xsparse/pull/31#issuecomment-1699602394"", 'comment_created': datetime.datetime(2023, 8, 30, 18, 3, 57, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1310644816, 'comment_body': ""I'd debug on CI, or install g++ using homebrew and use that instead, or use a Linux VM."", 'comment_created': datetime.datetime(2023, 8, 30, 18, 6, 5, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1310664663, 'comment_body': ""Ah okay that helped. It seems the issue is that when we dereference `coiterate`, it returns a `std::optional<long unsigned int>`, but the iter_helper is expecting `BaseTraits::PKM1` type, which is defined as \r\n\r\n```\r\nusing PKM1 = std::tuple_element_t<\r\n            // First element of P\r\n            0,\r\n            // Except that the type list has uint8_t appended to it.\r\n            // This has the effect of choosing uint8_t instead of the\r\n            // first element if `sizeof...(LowerLevels) == 0`.\r\n            // is in place.\r\n            std::tuple<position_t<LowerLevels>..., bool>>;\r\n```\r\n\r\nComplete error message:\r\n```\r\nIn file included from /Users/adam2392/Documents/xsparse/test/source/coiteration_test.cpp:19:\r\n/Users/adam2392/Documents/xsparse/include/xsparse/level_capabilities/co_iteration.hpp: In instantiation of 'auto unfold_and_apply_helper(const std::tuple<_UTypes ...>&, const ITuple&, const Pkm1Tuple&, std::index_sequence<Indices ...>) [with Args = {xsparse::levels::compressed<std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >&, xsparse::levels::compressed<std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >&}; ITuple = std::tuple<long unsigned int>; Pkm1Tuple = std::tuple<std::optional<long unsigned int>, std::optional<long unsigned int> >; long unsigned int ...Indices = {0, 1}; std::index_sequence<Indices ...> = std::integer_sequence<long unsigned int, 0, 1>]':\r\n/Users/adam2392/Documents/xsparse/include/xsparse/level_capabilities/co_iteration.hpp:188:56:   required from 'xsparse::level_capabilities::Coiterate<F, Ffunc, IK, PK, std::tuple<Levels ...>, std::tuple<Is ...>, std::tuple<Ps ...> >::coiteration_helper::coiteration_helper(const xsparse::level_capabilities::Coiterate<F, Ffunc, IK, PK, std::tuple<Levels ...>, std::tuple<Is ...>, std::tuple<Ps ...> >&, std::tuple<Is ...>, std::tuple<Ps ...>) [with F = xsparse::util::LambdaWrapper<DOCTEST_ANON_FUNC_10()::<lambda(std::tuple<bool, bool>)> >::apply; Ffunc = DOCTEST_ANON_FUNC_10()::<lambda(std::tuple<bool, bool>)>; IK = long unsigned int; PK = long unsigned int; Levels = {xsparse::levels::compressed<std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >, xsparse::levels::compressed<std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >}; Is = {long unsigned int}; Ps = {std::optional<long unsigned int>, std::optional<long unsigned int>}]'\r\n/Users/adam2392/Documents/xsparse/include/xsparse/level_capabilities/co_iteration.hpp:441:55:   required from 'xsparse::level_capabilities::Coiterate<F, Ffunc, IK, PK, std::tuple<Levels ...>, std::tuple<Is ...>, std::tuple<Ps ...> >::coiteration_helper xsparse::level_capabilities::Coiterate<F, Ffunc, IK, PK, std::tuple<Levels ...>, std::tuple<Is ...>, std::tuple<Ps ...> >::coiter_helper(std::tuple<Is ...>, std::tuple<Ps ...>) [with F = xsparse::util::LambdaWrapper<DOCTEST_ANON_FUNC_10()::<lambda(std::tuple<bool, bool>)> >::apply; Ffunc = DOCTEST_ANON_FUNC_10()::<lambda(std::tuple<bool, bool>)>; IK = long unsigned int; PK = long unsigned int; Levels = {xsparse::levels::compressed<std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >, xsparse::levels::compressed<std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >}; Is = {long unsigned int}; Ps = {std::optional<long unsigned int>, std::optional<long unsigned int>}]'\r\n/Users/adam2392/Documents/xsparse/test/source/coiteration_test.cpp:404:45:   required from here\r\n/Users/adam2392/Documents/xsparse/include/xsparse/level_capabilities/co_iteration.hpp:45:63: error: cannot convert 'std::__tuple_element_t<0, std::tuple<std::optional<long unsigned int>, std::optional<long unsigned int> > >' {aka 'const std::optional<long unsigned int>'} to 'xsparse::util::base_traits<xsparse::levels::compressed, std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >::PKM1' {aka 'long unsigned int'}\r\n   45 |     return std::make_tuple(std::get<Indices>(args).iter_helper(m_i, std::get<Indices>(pkm1))...);\r\n      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\nIn file included from /Users/adam2392/Documents/xsparse/include/xsparse/levels/compressed.hpp:10,\r\n                 from /Users/adam2392/Documents/xsparse/test/source/coiteration_test.cpp:11:\r\n/Users/adam2392/Documents/xsparse/include/xsparse/level_capabilities/coordinate_iterate.hpp:271:90: note:   initializing argument 2 of 'xsparse::level_capabilities::coordinate_position_iterate<T, IK, PK, LowerLevels>::iteration_helper xsparse::level_capabilities::coordinate_position_iterate<T, IK, PK, LowerLevels>::iter_helper(typename BaseTraits::I, typename BaseTraits::PKM1) [with T = xsparse::levels::compressed; IK = std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >; PK = long unsigned int; LowerLevels = {long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true>}; typename BaseTraits::I = std::tuple<long unsigned int>; BaseTraits = xsparse::util::base_traits<xsparse::levels::compressed, std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >; typename BaseTraits::PKM1 = long unsigned int]'\r\n  271 |         iteration_helper iter_helper(typename BaseTraits::I i, typename BaseTraits::PKM1 pkm1)\r\n      |                                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\r\n```\r\n\r\nWould it be:\r\n\r\n1. good to change the PKM1 type to allow this?\r\n2. somehow cast the type?"", 'comment_created': datetime.datetime(2023, 8, 30, 18, 26, 31, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1310677572, 'comment_body': ""It's just wrapped in an extra `optional`, I think it should be safe to get the value."", 'comment_created': datetime.datetime(2023, 8, 30, 18, 38, 56, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1310697392, 'comment_body': 'Possibly stupid question. Where would you suggest making the change then? Perhaps in \r\n\r\n```\r\ntemplate <typename... Args, typename ITuple, typename Pkm1Tuple, size_t... Indices>\r\nauto\r\nunfold_and_apply_helper(const std::tuple<Args...>& args,\r\n                        const ITuple& m_i,\r\n                        const Pkm1Tuple& pkm1,\r\n                        std::index_sequence<Indices...>)\r\n{\r\n    return std::make_tuple(std::get<Indices>(args).iter_helper(m_i, std::get<Indices>(pkm1))...);\r\n}\r\n```\r\n? But not every element of `pkm1` is `std::optional` ', 'comment_created': datetime.datetime(2023, 8, 30, 18, 58, 29, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1310712716, 'comment_body': 'I think `pkm1` should never be `optional` in the first place, something is going wrong up the chain.', 'comment_created': datetime.datetime(2023, 8, 30, 19, 14, 20, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1310755814, 'comment_body': 'The issue is that dereferencing either calls: `deref_PKs(i)`, or `std::get<I>(this->m_coiterHelper.m_coiterate.m_levelsTuple)\r\n                            .locate(std::get<I>(m_coiterHelper.m_pkm1), min_ik)` depending on whether the level is ordered or not.\r\n\r\nDeref_PKS (https://github.com/hameerabbasi/xsparse/blob/bd482c099b3089fe512cccd60331ddf24ba84b91/include/xsparse/level_capabilities/co_iteration.hpp#L321):\r\n\r\n```\r\ntemplate <class iter>\r\n                inline auto deref_PKs(iter i) const noexcept\r\n                {\r\n                    return (std::get<0>(*i) == min_ik);\r\n                               ? std::optional<std::tuple_element_t<1, decltype(*i)>>(\r\n                                   std::get<1>(*i))\r\n                               : std::nullopt;\r\n                }\r\n```\r\n\r\nSimilarly locate is defined as (https://github.com/hameerabbasi/xsparse/blob/bd482c099b3089fe512cccd60331ddf24ba84b91/include/xsparse/levels/hashed.hpp#L157):\r\n\r\n```\r\ninline auto locate(typename BaseTraits::PKM1 pkm1, IK ik) const noexcept\r\n            {\r\n                auto it = m_crd[pkm1].find(ik);\r\n                return it != m_crd[pkm1].end() ? std::optional<PK>(it->second) : std::nullopt;\r\n            }\r\n```\r\n\r\nSo both routes return std::optional. ', 'comment_created': datetime.datetime(2023, 8, 30, 19, 58, 39, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1311115739, 'comment_body': ""If the algorithm is written correctly we should be able to de reference both without issue, otherwise there's something wrong with the algorithm; not the code."", 'comment_created': datetime.datetime(2023, 8, 31, 5, 37, 57, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1311738862, 'comment_body': ""We can dereference both though as evidenced by the existing unit-tests that test both of these dereferences of the `Coiterate`. That is not the issue I believe. The issue is that the compiler cannot handle the following:\r\n\r\n```\r\n'std::__tuple_element_t<0, std::tuple<std::optional<long unsigned int>, std::optional<long unsigned int> > >' {aka 'const std::optional<long unsigned int>'} to \r\n\r\n'xsparse::util::base_traits<xsparse::levels::compressed, std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >::PKM1' {aka 'long unsigned int'}\r\n```"", 'comment_created': datetime.datetime(2023, 8, 31, 14, 39, 35, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1311755520, 'comment_body': 'Ah I now see the issue -- we are missing const in one of them.', 'comment_created': datetime.datetime(2023, 8, 31, 14, 50, 51, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1311842837, 'comment_body': ""Google const correctness; something should be const but isn't or the other way around."", 'comment_created': datetime.datetime(2023, 8, 31, 15, 49, 59, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1311944032, 'comment_body': 'Ah okay it compiles! I needed to change one of the template arguments defined the `Ps` template type in `Coiterate`. It was incorrectly adding a `std::optional`, which I think gave it an issue because the returned type during dereferencing is ""there"".\r\n\r\nHowever, now the unit-test is the main issue. It is possible there is either an error in my unit-test, or in the actual Coiterate implementation for a nested level.', 'comment_created': datetime.datetime(2023, 8, 31, 17, 8, 6, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1311963862, 'comment_body': 'Moved to make the reading of code more sequential', 'comment_created': datetime.datetime(2023, 8, 31, 17, 25, 22, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1311964031, 'comment_body': 'I could place this in utils if we want?', 'comment_created': datetime.datetime(2023, 8, 31, 17, 25, 34, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1312121968, 'comment_body': 'If we need it elsewhere we can move it.', 'comment_created': datetime.datetime(2023, 8, 31, 19, 23, 19, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}]","[{'commit_sha': 'b0b788ddc0b87ed069642228e444883938ffa10d', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '1615f0f1f6d421bac106735dfa0916737c0b4cf9', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '80a6699d07e0c02980bbc77a0988fc703fcb89d0', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '44da584e77aa4642025d27d69f93cb1449d48fc7', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '49d3399ddbdf361573c07a3158971e203937c4ce', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '72d21ef12d4ce217d39ec10d2340a5537f2e9735', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'fce0e9a3ffddcde8c3b880d4cb8c3700aba0933a', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '93cb542f1062006a519eb5b8a350c0e41be6ec45', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '65e0dedde4bf2a8d0b078dcfd4cadc9fac3de9bc', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '849f3c6b2f69dd0287e2f82eb407bbea194335e8', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'aab47a4aaa029564b05c8ac93e3dd3a775879574', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'a5d6d8b183d72d7b5360f8ac769e22fdc1b7d981', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '74b58765336ff232d68bdd4867e8c88b51b74154', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '0818ce96675594eff2a0eb1962c5b5a12a60db4f', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'f9052aeb9bca3b309c388b135d96a19a6cc4bb75', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '54b881629a17526596a9f7959e77aa16eb110b19', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'deda62484efb6a7b5e3f8f17cfc4cbe18c239cbe', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'c7bcb3c061582d04575519b63dbd78734968dd1f', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '080493bcfda8981f369bcadcd1a5f441577c00ce', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}]",Adam Li,3460267,,User,,119,,30,93
1485043105,[ENH] Fix coiteration algorithm to handle nested levels,"The current coiteration algorithm works when we define levels that are not stacked. Therefore, when we initialize `coiter_helper`, we just pass in an empty tuple and a `ZERO` marker for the IKs and PK. 

This is fine and works now, but it will not work when we want to use coiteration on levels that are nested in other levels. For example, say we have a dense pointing to a compressed level. Then we need to pass in the IK and PK of the dense, so we know where to start iterating in the compressed level. This is not currently supported because there is only one PK that is passed in. We need to pass in a tuple of PKs and tuple of IKs, not just a tuple of IKs and a PK.

### Sketch of plan

1. Define the unit-test that this must pass: Define a set of nested levels. Define two co-iterators.
2. Implement change in `co_iteration.hpp`


### Some difficulties

1. The changing of the PK to a tuple of PKs will change the design of the coiterator. It remains tbd how this will affect everything else",True,31,https://api.github.com/repos/hameerabbasi/xsparse/pulls/31,https://github.com/hameerabbasi/xsparse/pull/31,closed,235,32,5,19,5,22,0,0,[],2023-08-22 16:08:10+00:00,2023-08-31 19:24:14+00:00,789364.0,"9 days, 3:16:04","[{'comment_id': 1306110298, 'comment_body': ""This is the only part that's giving me trouble now. \r\n\r\nNote: Each `iter_helper` for each level takes a pair of elements for `IK` and `PKm1`, not a tuple.\r\n\r\n**Before:** The way it worked before was that `pkm1` was always a single element, so it would not need to get unpacked. On the other hand, `i` is either an empty tuple, or a tuple with the first element corresponding to the index we need to pass through. \r\n\r\n**Now:** For the `iter_helper`'s IK argument, we want to pass in an empty tuple, or the first index of `i` if `i` is not empty. This corresponds to the min_ik from the above level. We then want to expand the `pkm1` to each level's iter_helper. \r\n\r\nIs this thought correct? If so any idea how to go about doing this?\r\n\r\ncc: @hameerabbasi @bharath2438 "", 'comment_created': datetime.datetime(2023, 8, 25, 20, 9, 54, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1310613785, 'comment_body': 'This is the new change that leverages a templated `unfold_and_apply_helper` function to define the iter_helpers for each `coiterate.m_levelsTuple`.', 'comment_created': datetime.datetime(2023, 8, 30, 17, 34, 32, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1310616431, 'comment_body': 'When these LOC get uncommented, there is a segfault error during compilation time that I cannot parse.\r\n\r\n```\r\n(base) adam2392@Adams-MBP-3 xsparse % cmake --build build/test\r\n[ 25%] Built target fmt\r\n[ 25%] Built target XSparse\r\n[ 33%] Building CXX object CMakeFiles/XSparseTests.dir/source/coiteration_test.cpp.o\r\nclang: error: unable to execute command: Segmentation fault: 11\r\nclang: error: clang frontend command failed due to signal (use -v to see invocation)\r\nApple clang version 14.0.3 (clang-1403.0.22.14.1)\r\nTarget: arm64-apple-darwin22.6.0\r\nThread model: posix\r\nInstalledDir: /Library/Developer/CommandLineTools/usr/bin\r\nclang: note: diagnostic msg: \r\n********************\r\n\r\nPLEASE ATTACH THE FOLLOWING FILES TO THE BUG REPORT:\r\nPreprocessed source(s) and associated run script(s) are located at:\r\nclang: note: diagnostic msg: /var/folders/6_/sl83qtkd68x3_mvfys07_6qm0000gn/T/coiteration_test-d19547.cpp\r\nclang: note: diagnostic msg: /var/folders/6_/sl83qtkd68x3_mvfys07_6qm0000gn/T/coiteration_test-d19547.sh\r\nclang: note: diagnostic msg: Crash backtrace is located in\r\nclang: note: diagnostic msg: /Users/adam2392/Library/Logs/DiagnosticReports/clang_<YYYY-MM-DD-HHMMSS>_<hostname>.crash\r\nclang: note: diagnostic msg: (choose the .crash file that corresponds to your crash)\r\nclang: note: diagnostic msg: \r\n\r\n********************\r\nmake[2]: *** [CMakeFiles/XSparseTests.dir/source/coiteration_test.cpp.o] Error 254\r\nmake[1]: *** [CMakeFiles/XSparseTests.dir/all] Error 2\r\nmake: *** [all] Error 2\r\n```', 'comment_created': datetime.datetime(2023, 8, 30, 17, 36, 54, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1310625905, 'comment_body': ""This seems to be a bug on clang/Apple's side."", 'comment_created': datetime.datetime(2023, 8, 30, 17, 46, 22, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1310630867, 'comment_body': ""If we're always getting the first element, why have a tuple at all?"", 'comment_created': datetime.datetime(2023, 8, 30, 17, 51, 30, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1310637482, 'comment_body': ""I wanted to limit the scope of the change to just the `pkm1`, since that is forsure necessary to coiterate over nested levels. I don't know if the change to the passing of `min_ik`'s from above levels will affect other parts of the code(?)"", 'comment_created': datetime.datetime(2023, 8, 30, 17, 58, 28, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1310639342, 'comment_body': ""Hmm, for completeness I'd make those changes."", 'comment_created': datetime.datetime(2023, 8, 30, 18, 0, 25, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1310642834, 'comment_body': ""Oh sorry you're right. This was actually an unintended change. I reverted it back and it still has the same issues as highlighted in https://github.com/hameerabbasi/xsparse/pull/31#issuecomment-1699602394"", 'comment_created': datetime.datetime(2023, 8, 30, 18, 3, 57, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1310644816, 'comment_body': ""I'd debug on CI, or install g++ using homebrew and use that instead, or use a Linux VM."", 'comment_created': datetime.datetime(2023, 8, 30, 18, 6, 5, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1310664663, 'comment_body': ""Ah okay that helped. It seems the issue is that when we dereference `coiterate`, it returns a `std::optional<long unsigned int>`, but the iter_helper is expecting `BaseTraits::PKM1` type, which is defined as \r\n\r\n```\r\nusing PKM1 = std::tuple_element_t<\r\n            // First element of P\r\n            0,\r\n            // Except that the type list has uint8_t appended to it.\r\n            // This has the effect of choosing uint8_t instead of the\r\n            // first element if `sizeof...(LowerLevels) == 0`.\r\n            // is in place.\r\n            std::tuple<position_t<LowerLevels>..., bool>>;\r\n```\r\n\r\nComplete error message:\r\n```\r\nIn file included from /Users/adam2392/Documents/xsparse/test/source/coiteration_test.cpp:19:\r\n/Users/adam2392/Documents/xsparse/include/xsparse/level_capabilities/co_iteration.hpp: In instantiation of 'auto unfold_and_apply_helper(const std::tuple<_UTypes ...>&, const ITuple&, const Pkm1Tuple&, std::index_sequence<Indices ...>) [with Args = {xsparse::levels::compressed<std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >&, xsparse::levels::compressed<std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >&}; ITuple = std::tuple<long unsigned int>; Pkm1Tuple = std::tuple<std::optional<long unsigned int>, std::optional<long unsigned int> >; long unsigned int ...Indices = {0, 1}; std::index_sequence<Indices ...> = std::integer_sequence<long unsigned int, 0, 1>]':\r\n/Users/adam2392/Documents/xsparse/include/xsparse/level_capabilities/co_iteration.hpp:188:56:   required from 'xsparse::level_capabilities::Coiterate<F, Ffunc, IK, PK, std::tuple<Levels ...>, std::tuple<Is ...>, std::tuple<Ps ...> >::coiteration_helper::coiteration_helper(const xsparse::level_capabilities::Coiterate<F, Ffunc, IK, PK, std::tuple<Levels ...>, std::tuple<Is ...>, std::tuple<Ps ...> >&, std::tuple<Is ...>, std::tuple<Ps ...>) [with F = xsparse::util::LambdaWrapper<DOCTEST_ANON_FUNC_10()::<lambda(std::tuple<bool, bool>)> >::apply; Ffunc = DOCTEST_ANON_FUNC_10()::<lambda(std::tuple<bool, bool>)>; IK = long unsigned int; PK = long unsigned int; Levels = {xsparse::levels::compressed<std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >, xsparse::levels::compressed<std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >}; Is = {long unsigned int}; Ps = {std::optional<long unsigned int>, std::optional<long unsigned int>}]'\r\n/Users/adam2392/Documents/xsparse/include/xsparse/level_capabilities/co_iteration.hpp:441:55:   required from 'xsparse::level_capabilities::Coiterate<F, Ffunc, IK, PK, std::tuple<Levels ...>, std::tuple<Is ...>, std::tuple<Ps ...> >::coiteration_helper xsparse::level_capabilities::Coiterate<F, Ffunc, IK, PK, std::tuple<Levels ...>, std::tuple<Is ...>, std::tuple<Ps ...> >::coiter_helper(std::tuple<Is ...>, std::tuple<Ps ...>) [with F = xsparse::util::LambdaWrapper<DOCTEST_ANON_FUNC_10()::<lambda(std::tuple<bool, bool>)> >::apply; Ffunc = DOCTEST_ANON_FUNC_10()::<lambda(std::tuple<bool, bool>)>; IK = long unsigned int; PK = long unsigned int; Levels = {xsparse::levels::compressed<std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >, xsparse::levels::compressed<std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >}; Is = {long unsigned int}; Ps = {std::optional<long unsigned int>, std::optional<long unsigned int>}]'\r\n/Users/adam2392/Documents/xsparse/test/source/coiteration_test.cpp:404:45:   required from here\r\n/Users/adam2392/Documents/xsparse/include/xsparse/level_capabilities/co_iteration.hpp:45:63: error: cannot convert 'std::__tuple_element_t<0, std::tuple<std::optional<long unsigned int>, std::optional<long unsigned int> > >' {aka 'const std::optional<long unsigned int>'} to 'xsparse::util::base_traits<xsparse::levels::compressed, std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >::PKM1' {aka 'long unsigned int'}\r\n   45 |     return std::make_tuple(std::get<Indices>(args).iter_helper(m_i, std::get<Indices>(pkm1))...);\r\n      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\nIn file included from /Users/adam2392/Documents/xsparse/include/xsparse/levels/compressed.hpp:10,\r\n                 from /Users/adam2392/Documents/xsparse/test/source/coiteration_test.cpp:11:\r\n/Users/adam2392/Documents/xsparse/include/xsparse/level_capabilities/coordinate_iterate.hpp:271:90: note:   initializing argument 2 of 'xsparse::level_capabilities::coordinate_position_iterate<T, IK, PK, LowerLevels>::iteration_helper xsparse::level_capabilities::coordinate_position_iterate<T, IK, PK, LowerLevels>::iter_helper(typename BaseTraits::I, typename BaseTraits::PKM1) [with T = xsparse::levels::compressed; IK = std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >; PK = long unsigned int; LowerLevels = {long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true>}; typename BaseTraits::I = std::tuple<long unsigned int>; BaseTraits = xsparse::util::base_traits<xsparse::levels::compressed, std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >; typename BaseTraits::PKM1 = long unsigned int]'\r\n  271 |         iteration_helper iter_helper(typename BaseTraits::I i, typename BaseTraits::PKM1 pkm1)\r\n      |                                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\r\n```\r\n\r\nWould it be:\r\n\r\n1. good to change the PKM1 type to allow this?\r\n2. somehow cast the type?"", 'comment_created': datetime.datetime(2023, 8, 30, 18, 26, 31, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1310677572, 'comment_body': ""It's just wrapped in an extra `optional`, I think it should be safe to get the value."", 'comment_created': datetime.datetime(2023, 8, 30, 18, 38, 56, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1310697392, 'comment_body': 'Possibly stupid question. Where would you suggest making the change then? Perhaps in \r\n\r\n```\r\ntemplate <typename... Args, typename ITuple, typename Pkm1Tuple, size_t... Indices>\r\nauto\r\nunfold_and_apply_helper(const std::tuple<Args...>& args,\r\n                        const ITuple& m_i,\r\n                        const Pkm1Tuple& pkm1,\r\n                        std::index_sequence<Indices...>)\r\n{\r\n    return std::make_tuple(std::get<Indices>(args).iter_helper(m_i, std::get<Indices>(pkm1))...);\r\n}\r\n```\r\n? But not every element of `pkm1` is `std::optional` ', 'comment_created': datetime.datetime(2023, 8, 30, 18, 58, 29, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1310712716, 'comment_body': 'I think `pkm1` should never be `optional` in the first place, something is going wrong up the chain.', 'comment_created': datetime.datetime(2023, 8, 30, 19, 14, 20, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1310755814, 'comment_body': 'The issue is that dereferencing either calls: `deref_PKs(i)`, or `std::get<I>(this->m_coiterHelper.m_coiterate.m_levelsTuple)\r\n                            .locate(std::get<I>(m_coiterHelper.m_pkm1), min_ik)` depending on whether the level is ordered or not.\r\n\r\nDeref_PKS (https://github.com/hameerabbasi/xsparse/blob/bd482c099b3089fe512cccd60331ddf24ba84b91/include/xsparse/level_capabilities/co_iteration.hpp#L321):\r\n\r\n```\r\ntemplate <class iter>\r\n                inline auto deref_PKs(iter i) const noexcept\r\n                {\r\n                    return (std::get<0>(*i) == min_ik);\r\n                               ? std::optional<std::tuple_element_t<1, decltype(*i)>>(\r\n                                   std::get<1>(*i))\r\n                               : std::nullopt;\r\n                }\r\n```\r\n\r\nSimilarly locate is defined as (https://github.com/hameerabbasi/xsparse/blob/bd482c099b3089fe512cccd60331ddf24ba84b91/include/xsparse/levels/hashed.hpp#L157):\r\n\r\n```\r\ninline auto locate(typename BaseTraits::PKM1 pkm1, IK ik) const noexcept\r\n            {\r\n                auto it = m_crd[pkm1].find(ik);\r\n                return it != m_crd[pkm1].end() ? std::optional<PK>(it->second) : std::nullopt;\r\n            }\r\n```\r\n\r\nSo both routes return std::optional. ', 'comment_created': datetime.datetime(2023, 8, 30, 19, 58, 39, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1311115739, 'comment_body': ""If the algorithm is written correctly we should be able to de reference both without issue, otherwise there's something wrong with the algorithm; not the code."", 'comment_created': datetime.datetime(2023, 8, 31, 5, 37, 57, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1311738862, 'comment_body': ""We can dereference both though as evidenced by the existing unit-tests that test both of these dereferences of the `Coiterate`. That is not the issue I believe. The issue is that the compiler cannot handle the following:\r\n\r\n```\r\n'std::__tuple_element_t<0, std::tuple<std::optional<long unsigned int>, std::optional<long unsigned int> > >' {aka 'const std::optional<long unsigned int>'} to \r\n\r\n'xsparse::util::base_traits<xsparse::levels::compressed, std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >::PKM1' {aka 'long unsigned int'}\r\n```"", 'comment_created': datetime.datetime(2023, 8, 31, 14, 39, 35, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1311755520, 'comment_body': 'Ah I now see the issue -- we are missing const in one of them.', 'comment_created': datetime.datetime(2023, 8, 31, 14, 50, 51, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1311842837, 'comment_body': ""Google const correctness; something should be const but isn't or the other way around."", 'comment_created': datetime.datetime(2023, 8, 31, 15, 49, 59, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1311944032, 'comment_body': 'Ah okay it compiles! I needed to change one of the template arguments defined the `Ps` template type in `Coiterate`. It was incorrectly adding a `std::optional`, which I think gave it an issue because the returned type during dereferencing is ""there"".\r\n\r\nHowever, now the unit-test is the main issue. It is possible there is either an error in my unit-test, or in the actual Coiterate implementation for a nested level.', 'comment_created': datetime.datetime(2023, 8, 31, 17, 8, 6, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1311963862, 'comment_body': 'Moved to make the reading of code more sequential', 'comment_created': datetime.datetime(2023, 8, 31, 17, 25, 22, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1311964031, 'comment_body': 'I could place this in utils if we want?', 'comment_created': datetime.datetime(2023, 8, 31, 17, 25, 34, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1312121968, 'comment_body': 'If we need it elsewhere we can move it.', 'comment_created': datetime.datetime(2023, 8, 31, 19, 23, 19, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}]","[{'commit_sha': 'b0b788ddc0b87ed069642228e444883938ffa10d', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '1615f0f1f6d421bac106735dfa0916737c0b4cf9', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '80a6699d07e0c02980bbc77a0988fc703fcb89d0', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '44da584e77aa4642025d27d69f93cb1449d48fc7', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '49d3399ddbdf361573c07a3158971e203937c4ce', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '72d21ef12d4ce217d39ec10d2340a5537f2e9735', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'fce0e9a3ffddcde8c3b880d4cb8c3700aba0933a', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '93cb542f1062006a519eb5b8a350c0e41be6ec45', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '65e0dedde4bf2a8d0b078dcfd4cadc9fac3de9bc', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '849f3c6b2f69dd0287e2f82eb407bbea194335e8', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'aab47a4aaa029564b05c8ac93e3dd3a775879574', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'a5d6d8b183d72d7b5360f8ac769e22fdc1b7d981', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '74b58765336ff232d68bdd4867e8c88b51b74154', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '0818ce96675594eff2a0eb1962c5b5a12a60db4f', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'f9052aeb9bca3b309c388b135d96a19a6cc4bb75', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '54b881629a17526596a9f7959e77aa16eb110b19', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'deda62484efb6a7b5e3f8f17cfc4cbe18c239cbe', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'c7bcb3c061582d04575519b63dbd78734968dd1f', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '080493bcfda8981f369bcadcd1a5f441577c00ce', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}]",Adam Li,3460267,,User,,119,,30,93
1367118599,Merge upstream changes from template.,,True,21,https://api.github.com/repos/hameerabbasi/xsparse/pulls/21,https://github.com/hameerabbasi/xsparse/pull/21,closed,47,30,10,1,0,0,0,0,[],2023-05-27 06:45:51+00:00,2023-05-27 07:01:51+00:00,960.0,0:16:00,[],"[{'commit_sha': 'd4df3e9abb0d02484259bd147c6dd029168db05a', 'committer_username': 'hameerabbasi', 'committer_name': 'Hameer Abbasi', 'committer_email': None, 'commit_date': datetime.datetime(2012, 8, 21, 15, 48, 12, tzinfo=datetime.timezone.utc)}]",Hameer Abbasi,2190658,,User,,59,,2,69
1485043105,[ENH] Fix coiteration algorithm to handle nested levels,"The current coiteration algorithm works when we define levels that are not stacked. Therefore, when we initialize `coiter_helper`, we just pass in an empty tuple and a `ZERO` marker for the IKs and PK. 

This is fine and works now, but it will not work when we want to use coiteration on levels that are nested in other levels. For example, say we have a dense pointing to a compressed level. Then we need to pass in the IK and PK of the dense, so we know where to start iterating in the compressed level. This is not currently supported because there is only one PK that is passed in. We need to pass in a tuple of PKs and tuple of IKs, not just a tuple of IKs and a PK.

### Sketch of plan

1. Define the unit-test that this must pass: Define a set of nested levels. Define two co-iterators.
2. Implement change in `co_iteration.hpp`


### Some difficulties

1. The changing of the PK to a tuple of PKs will change the design of the coiterator. It remains tbd how this will affect everything else",True,31,https://api.github.com/repos/hameerabbasi/xsparse/pulls/31,https://github.com/hameerabbasi/xsparse/pull/31,closed,235,32,5,19,5,22,0,0,[],2023-08-22 16:08:10+00:00,2023-08-31 19:24:14+00:00,789364.0,"9 days, 3:16:04","[{'comment_id': 1306110298, 'comment_body': ""This is the only part that's giving me trouble now. \r\n\r\nNote: Each `iter_helper` for each level takes a pair of elements for `IK` and `PKm1`, not a tuple.\r\n\r\n**Before:** The way it worked before was that `pkm1` was always a single element, so it would not need to get unpacked. On the other hand, `i` is either an empty tuple, or a tuple with the first element corresponding to the index we need to pass through. \r\n\r\n**Now:** For the `iter_helper`'s IK argument, we want to pass in an empty tuple, or the first index of `i` if `i` is not empty. This corresponds to the min_ik from the above level. We then want to expand the `pkm1` to each level's iter_helper. \r\n\r\nIs this thought correct? If so any idea how to go about doing this?\r\n\r\ncc: @hameerabbasi @bharath2438 "", 'comment_created': datetime.datetime(2023, 8, 25, 20, 9, 54, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1310613785, 'comment_body': 'This is the new change that leverages a templated `unfold_and_apply_helper` function to define the iter_helpers for each `coiterate.m_levelsTuple`.', 'comment_created': datetime.datetime(2023, 8, 30, 17, 34, 32, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1310616431, 'comment_body': 'When these LOC get uncommented, there is a segfault error during compilation time that I cannot parse.\r\n\r\n```\r\n(base) adam2392@Adams-MBP-3 xsparse % cmake --build build/test\r\n[ 25%] Built target fmt\r\n[ 25%] Built target XSparse\r\n[ 33%] Building CXX object CMakeFiles/XSparseTests.dir/source/coiteration_test.cpp.o\r\nclang: error: unable to execute command: Segmentation fault: 11\r\nclang: error: clang frontend command failed due to signal (use -v to see invocation)\r\nApple clang version 14.0.3 (clang-1403.0.22.14.1)\r\nTarget: arm64-apple-darwin22.6.0\r\nThread model: posix\r\nInstalledDir: /Library/Developer/CommandLineTools/usr/bin\r\nclang: note: diagnostic msg: \r\n********************\r\n\r\nPLEASE ATTACH THE FOLLOWING FILES TO THE BUG REPORT:\r\nPreprocessed source(s) and associated run script(s) are located at:\r\nclang: note: diagnostic msg: /var/folders/6_/sl83qtkd68x3_mvfys07_6qm0000gn/T/coiteration_test-d19547.cpp\r\nclang: note: diagnostic msg: /var/folders/6_/sl83qtkd68x3_mvfys07_6qm0000gn/T/coiteration_test-d19547.sh\r\nclang: note: diagnostic msg: Crash backtrace is located in\r\nclang: note: diagnostic msg: /Users/adam2392/Library/Logs/DiagnosticReports/clang_<YYYY-MM-DD-HHMMSS>_<hostname>.crash\r\nclang: note: diagnostic msg: (choose the .crash file that corresponds to your crash)\r\nclang: note: diagnostic msg: \r\n\r\n********************\r\nmake[2]: *** [CMakeFiles/XSparseTests.dir/source/coiteration_test.cpp.o] Error 254\r\nmake[1]: *** [CMakeFiles/XSparseTests.dir/all] Error 2\r\nmake: *** [all] Error 2\r\n```', 'comment_created': datetime.datetime(2023, 8, 30, 17, 36, 54, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1310625905, 'comment_body': ""This seems to be a bug on clang/Apple's side."", 'comment_created': datetime.datetime(2023, 8, 30, 17, 46, 22, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1310630867, 'comment_body': ""If we're always getting the first element, why have a tuple at all?"", 'comment_created': datetime.datetime(2023, 8, 30, 17, 51, 30, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1310637482, 'comment_body': ""I wanted to limit the scope of the change to just the `pkm1`, since that is forsure necessary to coiterate over nested levels. I don't know if the change to the passing of `min_ik`'s from above levels will affect other parts of the code(?)"", 'comment_created': datetime.datetime(2023, 8, 30, 17, 58, 28, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1310639342, 'comment_body': ""Hmm, for completeness I'd make those changes."", 'comment_created': datetime.datetime(2023, 8, 30, 18, 0, 25, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1310642834, 'comment_body': ""Oh sorry you're right. This was actually an unintended change. I reverted it back and it still has the same issues as highlighted in https://github.com/hameerabbasi/xsparse/pull/31#issuecomment-1699602394"", 'comment_created': datetime.datetime(2023, 8, 30, 18, 3, 57, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1310644816, 'comment_body': ""I'd debug on CI, or install g++ using homebrew and use that instead, or use a Linux VM."", 'comment_created': datetime.datetime(2023, 8, 30, 18, 6, 5, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1310664663, 'comment_body': ""Ah okay that helped. It seems the issue is that when we dereference `coiterate`, it returns a `std::optional<long unsigned int>`, but the iter_helper is expecting `BaseTraits::PKM1` type, which is defined as \r\n\r\n```\r\nusing PKM1 = std::tuple_element_t<\r\n            // First element of P\r\n            0,\r\n            // Except that the type list has uint8_t appended to it.\r\n            // This has the effect of choosing uint8_t instead of the\r\n            // first element if `sizeof...(LowerLevels) == 0`.\r\n            // is in place.\r\n            std::tuple<position_t<LowerLevels>..., bool>>;\r\n```\r\n\r\nComplete error message:\r\n```\r\nIn file included from /Users/adam2392/Documents/xsparse/test/source/coiteration_test.cpp:19:\r\n/Users/adam2392/Documents/xsparse/include/xsparse/level_capabilities/co_iteration.hpp: In instantiation of 'auto unfold_and_apply_helper(const std::tuple<_UTypes ...>&, const ITuple&, const Pkm1Tuple&, std::index_sequence<Indices ...>) [with Args = {xsparse::levels::compressed<std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >&, xsparse::levels::compressed<std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >&}; ITuple = std::tuple<long unsigned int>; Pkm1Tuple = std::tuple<std::optional<long unsigned int>, std::optional<long unsigned int> >; long unsigned int ...Indices = {0, 1}; std::index_sequence<Indices ...> = std::integer_sequence<long unsigned int, 0, 1>]':\r\n/Users/adam2392/Documents/xsparse/include/xsparse/level_capabilities/co_iteration.hpp:188:56:   required from 'xsparse::level_capabilities::Coiterate<F, Ffunc, IK, PK, std::tuple<Levels ...>, std::tuple<Is ...>, std::tuple<Ps ...> >::coiteration_helper::coiteration_helper(const xsparse::level_capabilities::Coiterate<F, Ffunc, IK, PK, std::tuple<Levels ...>, std::tuple<Is ...>, std::tuple<Ps ...> >&, std::tuple<Is ...>, std::tuple<Ps ...>) [with F = xsparse::util::LambdaWrapper<DOCTEST_ANON_FUNC_10()::<lambda(std::tuple<bool, bool>)> >::apply; Ffunc = DOCTEST_ANON_FUNC_10()::<lambda(std::tuple<bool, bool>)>; IK = long unsigned int; PK = long unsigned int; Levels = {xsparse::levels::compressed<std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >, xsparse::levels::compressed<std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >}; Is = {long unsigned int}; Ps = {std::optional<long unsigned int>, std::optional<long unsigned int>}]'\r\n/Users/adam2392/Documents/xsparse/include/xsparse/level_capabilities/co_iteration.hpp:441:55:   required from 'xsparse::level_capabilities::Coiterate<F, Ffunc, IK, PK, std::tuple<Levels ...>, std::tuple<Is ...>, std::tuple<Ps ...> >::coiteration_helper xsparse::level_capabilities::Coiterate<F, Ffunc, IK, PK, std::tuple<Levels ...>, std::tuple<Is ...>, std::tuple<Ps ...> >::coiter_helper(std::tuple<Is ...>, std::tuple<Ps ...>) [with F = xsparse::util::LambdaWrapper<DOCTEST_ANON_FUNC_10()::<lambda(std::tuple<bool, bool>)> >::apply; Ffunc = DOCTEST_ANON_FUNC_10()::<lambda(std::tuple<bool, bool>)>; IK = long unsigned int; PK = long unsigned int; Levels = {xsparse::levels::compressed<std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >, xsparse::levels::compressed<std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >}; Is = {long unsigned int}; Ps = {std::optional<long unsigned int>, std::optional<long unsigned int>}]'\r\n/Users/adam2392/Documents/xsparse/test/source/coiteration_test.cpp:404:45:   required from here\r\n/Users/adam2392/Documents/xsparse/include/xsparse/level_capabilities/co_iteration.hpp:45:63: error: cannot convert 'std::__tuple_element_t<0, std::tuple<std::optional<long unsigned int>, std::optional<long unsigned int> > >' {aka 'const std::optional<long unsigned int>'} to 'xsparse::util::base_traits<xsparse::levels::compressed, std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >::PKM1' {aka 'long unsigned int'}\r\n   45 |     return std::make_tuple(std::get<Indices>(args).iter_helper(m_i, std::get<Indices>(pkm1))...);\r\n      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\nIn file included from /Users/adam2392/Documents/xsparse/include/xsparse/levels/compressed.hpp:10,\r\n                 from /Users/adam2392/Documents/xsparse/test/source/coiteration_test.cpp:11:\r\n/Users/adam2392/Documents/xsparse/include/xsparse/level_capabilities/coordinate_iterate.hpp:271:90: note:   initializing argument 2 of 'xsparse::level_capabilities::coordinate_position_iterate<T, IK, PK, LowerLevels>::iteration_helper xsparse::level_capabilities::coordinate_position_iterate<T, IK, PK, LowerLevels>::iter_helper(typename BaseTraits::I, typename BaseTraits::PKM1) [with T = xsparse::levels::compressed; IK = std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >; PK = long unsigned int; LowerLevels = {long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true>}; typename BaseTraits::I = std::tuple<long unsigned int>; BaseTraits = xsparse::util::base_traits<xsparse::levels::compressed, std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >; typename BaseTraits::PKM1 = long unsigned int]'\r\n  271 |         iteration_helper iter_helper(typename BaseTraits::I i, typename BaseTraits::PKM1 pkm1)\r\n      |                                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\r\n```\r\n\r\nWould it be:\r\n\r\n1. good to change the PKM1 type to allow this?\r\n2. somehow cast the type?"", 'comment_created': datetime.datetime(2023, 8, 30, 18, 26, 31, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1310677572, 'comment_body': ""It's just wrapped in an extra `optional`, I think it should be safe to get the value."", 'comment_created': datetime.datetime(2023, 8, 30, 18, 38, 56, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1310697392, 'comment_body': 'Possibly stupid question. Where would you suggest making the change then? Perhaps in \r\n\r\n```\r\ntemplate <typename... Args, typename ITuple, typename Pkm1Tuple, size_t... Indices>\r\nauto\r\nunfold_and_apply_helper(const std::tuple<Args...>& args,\r\n                        const ITuple& m_i,\r\n                        const Pkm1Tuple& pkm1,\r\n                        std::index_sequence<Indices...>)\r\n{\r\n    return std::make_tuple(std::get<Indices>(args).iter_helper(m_i, std::get<Indices>(pkm1))...);\r\n}\r\n```\r\n? But not every element of `pkm1` is `std::optional` ', 'comment_created': datetime.datetime(2023, 8, 30, 18, 58, 29, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1310712716, 'comment_body': 'I think `pkm1` should never be `optional` in the first place, something is going wrong up the chain.', 'comment_created': datetime.datetime(2023, 8, 30, 19, 14, 20, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1310755814, 'comment_body': 'The issue is that dereferencing either calls: `deref_PKs(i)`, or `std::get<I>(this->m_coiterHelper.m_coiterate.m_levelsTuple)\r\n                            .locate(std::get<I>(m_coiterHelper.m_pkm1), min_ik)` depending on whether the level is ordered or not.\r\n\r\nDeref_PKS (https://github.com/hameerabbasi/xsparse/blob/bd482c099b3089fe512cccd60331ddf24ba84b91/include/xsparse/level_capabilities/co_iteration.hpp#L321):\r\n\r\n```\r\ntemplate <class iter>\r\n                inline auto deref_PKs(iter i) const noexcept\r\n                {\r\n                    return (std::get<0>(*i) == min_ik);\r\n                               ? std::optional<std::tuple_element_t<1, decltype(*i)>>(\r\n                                   std::get<1>(*i))\r\n                               : std::nullopt;\r\n                }\r\n```\r\n\r\nSimilarly locate is defined as (https://github.com/hameerabbasi/xsparse/blob/bd482c099b3089fe512cccd60331ddf24ba84b91/include/xsparse/levels/hashed.hpp#L157):\r\n\r\n```\r\ninline auto locate(typename BaseTraits::PKM1 pkm1, IK ik) const noexcept\r\n            {\r\n                auto it = m_crd[pkm1].find(ik);\r\n                return it != m_crd[pkm1].end() ? std::optional<PK>(it->second) : std::nullopt;\r\n            }\r\n```\r\n\r\nSo both routes return std::optional. ', 'comment_created': datetime.datetime(2023, 8, 30, 19, 58, 39, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1311115739, 'comment_body': ""If the algorithm is written correctly we should be able to de reference both without issue, otherwise there's something wrong with the algorithm; not the code."", 'comment_created': datetime.datetime(2023, 8, 31, 5, 37, 57, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1311738862, 'comment_body': ""We can dereference both though as evidenced by the existing unit-tests that test both of these dereferences of the `Coiterate`. That is not the issue I believe. The issue is that the compiler cannot handle the following:\r\n\r\n```\r\n'std::__tuple_element_t<0, std::tuple<std::optional<long unsigned int>, std::optional<long unsigned int> > >' {aka 'const std::optional<long unsigned int>'} to \r\n\r\n'xsparse::util::base_traits<xsparse::levels::compressed, std::tuple<xsparse::levels::dense<std::tuple<>, long unsigned int, long unsigned int, xsparse::level_properties<true, true, true, false, true> > >, long unsigned int, long unsigned int, xsparse::util::container_traits<std::vector, std::set, std::map>, xsparse::level_properties<true, true, false, false, true> >::PKM1' {aka 'long unsigned int'}\r\n```"", 'comment_created': datetime.datetime(2023, 8, 31, 14, 39, 35, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1311755520, 'comment_body': 'Ah I now see the issue -- we are missing const in one of them.', 'comment_created': datetime.datetime(2023, 8, 31, 14, 50, 51, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1311842837, 'comment_body': ""Google const correctness; something should be const but isn't or the other way around."", 'comment_created': datetime.datetime(2023, 8, 31, 15, 49, 59, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}, {'comment_id': 1311944032, 'comment_body': 'Ah okay it compiles! I needed to change one of the template arguments defined the `Ps` template type in `Coiterate`. It was incorrectly adding a `std::optional`, which I think gave it an issue because the returned type during dereferencing is ""there"".\r\n\r\nHowever, now the unit-test is the main issue. It is possible there is either an error in my unit-test, or in the actual Coiterate implementation for a nested level.', 'comment_created': datetime.datetime(2023, 8, 31, 17, 8, 6, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1311963862, 'comment_body': 'Moved to make the reading of code more sequential', 'comment_created': datetime.datetime(2023, 8, 31, 17, 25, 22, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1311964031, 'comment_body': 'I could place this in utils if we want?', 'comment_created': datetime.datetime(2023, 8, 31, 17, 25, 34, tzinfo=datetime.timezone.utc), 'commenter': 'adam2392', 'type': 'User'}, {'comment_id': 1312121968, 'comment_body': 'If we need it elsewhere we can move it.', 'comment_created': datetime.datetime(2023, 8, 31, 19, 23, 19, tzinfo=datetime.timezone.utc), 'commenter': 'hameerabbasi', 'type': 'User'}]","[{'commit_sha': 'b0b788ddc0b87ed069642228e444883938ffa10d', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '1615f0f1f6d421bac106735dfa0916737c0b4cf9', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '80a6699d07e0c02980bbc77a0988fc703fcb89d0', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '44da584e77aa4642025d27d69f93cb1449d48fc7', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '49d3399ddbdf361573c07a3158971e203937c4ce', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '72d21ef12d4ce217d39ec10d2340a5537f2e9735', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'fce0e9a3ffddcde8c3b880d4cb8c3700aba0933a', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '93cb542f1062006a519eb5b8a350c0e41be6ec45', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '65e0dedde4bf2a8d0b078dcfd4cadc9fac3de9bc', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '849f3c6b2f69dd0287e2f82eb407bbea194335e8', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'aab47a4aaa029564b05c8ac93e3dd3a775879574', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'a5d6d8b183d72d7b5360f8ac769e22fdc1b7d981', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '74b58765336ff232d68bdd4867e8c88b51b74154', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '0818ce96675594eff2a0eb1962c5b5a12a60db4f', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'f9052aeb9bca3b309c388b135d96a19a6cc4bb75', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '54b881629a17526596a9f7959e77aa16eb110b19', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'deda62484efb6a7b5e3f8f17cfc4cbe18c239cbe', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'c7bcb3c061582d04575519b63dbd78734968dd1f', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '080493bcfda8981f369bcadcd1a5f441577c00ce', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}]",Adam Li,3460267,,User,,119,,30,93
1423901625,[ENH] Check validity of coiteration,"Follow-up to #25 

Closes: #25 as completed",True,26,https://api.github.com/repos/hameerabbasi/xsparse/pulls/26,https://github.com/hameerabbasi/xsparse/pull/26,closed,176,36,3,44,12,0,0,0,[],2023-07-07 03:32:02+00:00,2023-07-31 20:09:52+00:00,2133470.0,"24 days, 16:37:50",[],"[{'commit_sha': '276773cc89491d181797a6f41440ae6c78ea51a5', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '84e147148b15b3b3302ef2969cf754be9c343a5b', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '7a852aef74971d16c388df50581610410d9aa5e7', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '3633a6798a4661fb87cf070cc5399b5b2489c684', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '78d5cbcf2b92edcbe75bd5e60c3f9907f8cebb29', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '5fc8476f3d061a1472572d7a8699bf4250c72db9', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '2508e94c492aa004064c0c3bfecf68009c554542', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'f1e6b626c233fa233e09fa65707b8d2584c6e1a9', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '8269a9975932df3beb7f3354a14ecafdfa05cd83', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '83997fdb22ff46273401e1cec77adf5c73f86d89', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '117baff8563e0bda57ffa18c3628cddefa66fe62', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'b5d0960e08974eca7fe379172aa4520f4a8ed9f6', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '02144235004e18f22f307acbc6cb6d8ce249ce78', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '0473b6445e76c4a708f78e915d3b87d769bb1fff', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '5f56d714783f6d3744e3d5cbf59da88a0e8c0117', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'd5c2d9ba66f10f77d92c2cb13feebd6633c7484e', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'db6454960cb85795d5e67f9f6b29269cf563a512', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'dc1b2360420b614adea3d63296bf163e48d385ca', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '625aec40745a7a78a61c27316ac20327f07abee1', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '69febebabd0510f75a8c53d9639acc68a1962b9f', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'e8c7bdb27dd71bdbbe4a43867138d8d18de3b422', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '7794317db7c5eac3cb02dd25d5dba0490b241308', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'e7a1ba47c91257053c8256aeac2900fa17d3a830', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'f591cc445bf1d4d0475d5bb292024baf94479ecc', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'f3c1ccb06834957fd0884ed5aac13318abb66fb7', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '295f4fb3810a8626006d393673e660b83d25ebe7', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'e012900315130a216d6fecac90ecf605a04473fb', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'b459b615472523ceecf489864e985d7aab169416', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '9701dca518b35267d22f28cde9be517de6f050af', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '8adc693e5763849c7f2089d31d3897d1150d5b77', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '3e8b91549c1ccf1aa2e6b72f47c98c57bbe616a7', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '5a105d88fdbd435d3ad9f2017267a210e0eab7fe', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '4f085dbdc34018296d0c44f070e4089bf47f9a06', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '27ccce62c1171c9ad1c7c29b971c6385929d20cc', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '9bfe79f5079167f6c720acd34753be0ea17381ab', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'abcd5d9b6bfb4873be508d27e5d1447fdc2483fc', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '696d09f899d4cdd94dde6379270600f6f719c44b', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'c8057a1cf2bbdf4f9ba1faf56ad28788ec30db05', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'a246549a650683117675b722d24e00c0a774ed3a', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'd5c31caa4eaefc6f15b3d40c3b01b7a5891dd855', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '55e5a5bcdbd1b34d80160c1ef92db15f48e58b7b', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '83efe09599a718297d04afd0b755fd3c07512b24', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '39b8d856199375551bcc65a24497b7e6c5fa462b', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}, {'commit_sha': '091b5688b96f1b2d4ad0877d55c40b9d98aa760d', 'committer_username': 'adam2392', 'committer_name': 'Adam Li', 'committer_email': None, 'commit_date': datetime.datetime(2013, 2, 3, 0, 44, 49, tzinfo=datetime.timezone.utc)}]",Adam Li,3460267,,User,,119,,30,93

Project_ID,Name,Full_name,Language,Forks,Stars,Watchers,contributors,commits,issues,branches,PRs_count,contributor pullrequests
365144269,xsparse,hameerabbasi/xsparse,C++,6,9,5,17,143,4,4,1,"[{'id': 1485043105, 'number': 31, 'closed': datetime.datetime(2023, 8, 31, 19, 24, 14, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 8, 22, 16, 8, 10, tzinfo=datetime.timezone.utc), 'time_taken': 789364.0, 'time_delta': '9 days, 3:16:04', 'additions': 235, 'deletions': 32, 'state': 'closed'}, {'id': 1454253821, 'number': 30, 'closed': datetime.datetime(2023, 8, 13, 14, 9, 47, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 7, 28, 18, 31, tzinfo=datetime.timezone.utc), 'time_taken': 1366727.0, 'time_delta': '15 days, 19:38:47', 'additions': 170, 'deletions': 14, 'state': 'closed'}, {'id': 1454233003, 'number': 29, 'closed': datetime.datetime(2023, 8, 6, 20, 24, 47, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 7, 28, 18, 19, 3, tzinfo=datetime.timezone.utc), 'time_taken': 785144.0, 'time_delta': '9 days, 2:05:44', 'additions': 28, 'deletions': 1, 'state': 'closed'}, {'id': 1438132846, 'number': 28, 'closed': None, 'created': datetime.datetime(2023, 7, 17, 21, 51, 57, tzinfo=datetime.timezone.utc), 'time_taken': 0.0, 'time_delta': '', 'additions': 531, 'deletions': 0, 'state': 'open'}, {'id': 1423901625, 'number': 26, 'closed': datetime.datetime(2023, 7, 31, 20, 9, 52, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 7, 7, 3, 32, 2, tzinfo=datetime.timezone.utc), 'time_taken': 2133470.0, 'time_delta': '24 days, 16:37:50', 'additions': 176, 'deletions': 36, 'state': 'closed'}, {'id': 1387591845, 'number': 25, 'closed': datetime.datetime(2023, 7, 8, 20, 30, 45, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 6, 11, 16, 0, 11, tzinfo=datetime.timezone.utc), 'time_taken': 2349034.0, 'time_delta': '27 days, 4:30:34', 'additions': 313, 'deletions': 65, 'state': 'closed'}, {'id': 1383343437, 'number': 24, 'closed': datetime.datetime(2023, 6, 12, 14, 16, 22, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 6, 7, 20, 39, 47, tzinfo=datetime.timezone.utc), 'time_taken': 408995.0, 'time_delta': '4 days, 17:36:35', 'additions': 110, 'deletions': 87, 'state': 'closed'}, {'id': 1372224253, 'number': 22, 'closed': datetime.datetime(2023, 6, 6, 13, 36, 6, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 5, 31, 13, 31, 22, tzinfo=datetime.timezone.utc), 'time_taken': 518684.0, 'time_delta': '6 days, 0:04:44', 'additions': 145, 'deletions': 65, 'state': 'closed'}, {'id': 1287930153, 'number': 19, 'closed': datetime.datetime(2023, 8, 31, 19, 26, 7, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 3, 23, 18, 55, 40, tzinfo=datetime.timezone.utc), 'time_taken': 13912227.0, 'time_delta': '161 days, 0:30:27', 'additions': 311, 'deletions': 90, 'state': 'closed'}, {'id': 1249174581, 'number': 16, 'closed': datetime.datetime(2023, 2, 22, 21, 30, 9, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 2, 21, 19, 32, 21, tzinfo=datetime.timezone.utc), 'time_taken': 93468.0, 'time_delta': '1 day, 1:57:48', 'additions': 5, 'deletions': 11, 'state': 'closed'}]"
