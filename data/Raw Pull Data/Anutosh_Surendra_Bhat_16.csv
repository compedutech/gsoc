pr_id,pr_title,pr_body,is_merged,pr_number,pr_url,pr_html_url,pr_state,additions,deletions,pr_changed_files,pr_commits_count,pr_comments_count,pr_review_comments_count,pr_labels_count,pr_assignees_count,pr_labels,pr_created_at,pr_closed_at,time_taken,time_delta,pr_review_comments,pr_commits,contributor,contributor_id,contributor_email,contributor_type,contributions,contributor_public_repos,contributor_private_repos,contributor_followings,contributor_followers
959935796,[GSoC Pr1] Refactored leading term method for log Function,"<!-- Your title above should be a short description of what
was changed. Do not include the issue number in the title. -->

#### References to other Issues or PRs
<!-- If this pull request fixes an issue, write ""Fixes #NNNN"" in that exact
format, e.g. ""Fixes #1234"" (see
https://tinyurl.com/auto-closing for more information). Also, please
write a comment on that issue linking back to this pull request once it is
open. -->
Fixes #21721
Fixes #21227
Fixes #22220
Fixes #23596 
Fixes #6682 
#### Brief description of what is fixed or changed
This PR introduces a new algorithm/logic to compute leading terms of expressions of type `log` which has been broken down into 5 step explained below.
1) In leading term methods the parameter `x` is expected to tend to `0` along the half-ray `x = cdir*t` where `t` is `real` and `positive`. Hence we define a positive dummy variable `t` and substitute `cdir*t` for `x` in the argument of `log: z = arg0.subs(x, cdir*t)`. 
2) In the next step we calculate coefficient and exponent of the leading term of `z` through `c, e = z.leadterm(t)` to take decisions based on `c` and `e` for the incoming steps.
3) In this step we handle the standard case of  `c, e == 1, 0`
4) Next, we expand `log(c*t**e)` using `log(t) = log(x) - log(cdir)` or `logx - log(cdir)`.
5) Finally we append `-2*I*pi` if `c` is `negative` and the imaginary part of `z` is `negative` for small `t > 0`

#### Other comments


#### Release Notes

<!-- Write the release notes for this release below between the BEGIN and END
statements. The basic format is a bulleted list with the name of the subpackage
and the release note for this PR. For example:

* solvers
  * Added a new solver for logarithmic equations.

* functions
  * Fixed a bug with log of integers.

or if no release note(s) should be included use:

NO ENTRY

See https://github.com/sympy/sympy/wiki/Writing-Release-Notes for more
information on how to write release notes. The bot will check your release
notes automatically to see if they are formatted correctly. -->

<!-- BEGIN RELEASE NOTES -->
* series
  * Refactored leading term method for log Function.
  * Added logx parameter to leading term methods of type add and power.
  * Introduced arg_flag in Limit.doit.set_signs.
  * Fixed leading term method for Ei, Chi and bessely functions.
  * Implemented branch cut handling for leading term methods of inverse trigonometric functions.
  * Fixed nseries for nested logarithms where logx parameter passed is not None.
  * Fixes integral for probability distribution function of cauchy distribution
<!-- END RELEASE NOTES -->
",True,23592,https://api.github.com/repos/sympy/sympy/pulls/23592,https://github.com/sympy/sympy/pull/23592,closed,286,76,16,5,14,37,2,0,"[{'name': 'series'}, {'name': 'GSoC'}]",2022-06-07 06:20:19+00:00,2022-07-01 15:02:36+00:00,2104937.0,"24 days, 8:42:17","[{'comment_id': 892281612, 'comment_body': 'Why two substitutions that look like doing the same?', 'comment_created': datetime.datetime(2022, 6, 8, 12, 13, 4, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 892305391, 'comment_body': ""Ahh didn't really plan on doing that .... but for certain cases like the following without that check we would have \r\n```\r\n>>> f = log(-log(x))\r\n>>> f.nseries(x, logx=-x)\r\nlog(x) + O(x**5) \r\n```\r\n```\r\n            res = log(a) + b*logx\r\n            if (res.subs(logx, log(x)) == self\r\n                or res.subs(-logx, -log(x)) == self):\r\n```\r\nHere `res` is `log(x)` and `logx` is `-x` and self is `log(-log(x))` but something like `log(x).subs(-x, log(x))` won't give `log(-log(x))` just because of the same reason as `(2*x).subs(-x, log(x))` wouldn't give `-2*log(x)` and returns back `2*x`.\r\n\r\nI will change this as soon as I can see any improvement here , yeah looks a bit odd !\r\n\r\n"", 'comment_created': datetime.datetime(2022, 6, 8, 12, 37, 18, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 894393313, 'comment_body': ""Actually another test from `test1_latest` which fails , is due to this sort of handling but in `mul.py` actually lands up on this \r\n```\r\n>>> expr = x**2*_eis(-2*log(1/x))/2\r\n>>> expr._eval_nseries(x, n = 6, logx = -p)\r\nx**2*_eis(-2*p)/2 + O(x**6)\r\n```\r\nBut the order term shouldn't be there \r\nNow this is because I've added a simple case like \r\n```\r\n        if res != self:\r\n            if res.subs(logx, log(x)) == self:\r\n                return res\r\n```\r\nBut here `res  = x**2*_eis(-2*p)/2` and `logx = -p` so we get the substituted expression as `x**2*_eis(2*log(x))/2` which is correct but not in the form of self (uses log(1/x) so yeah here the case gets more weird , we would need to have something like \r\n```\r\n         if res != self:\r\n+            if (res.subs(logx, log(x)) == self\r\n+                or res.subs(-logx, -log(x)) == self\r\n+                or res.subs(-logx, log(1/x)) == self):\r\n                         return res;\r\n```\r\nThen we get the correct result"", 'comment_created': datetime.datetime(2022, 6, 10, 10, 40, 43, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 894484336, 'comment_body': 'We cannot possibly have substitutions for many different expressions like `log(1/x)`. Instead, we should probably first try to force `self` into a more canonical form by something like `expand_log` and then substitute for `logx` (or `-logx` if `logx` is negative).\r\n```\r\nIn [11]: res = x**2*_eis(-2*p)/2  \r\n\r\nIn [12]: logx = -p\r\n\r\nIn [13]: res.subs(-logx, -log(x))\r\nOut[13]: \r\n 2               \r\nx ⋅_eis(2⋅log(x))\r\n─────────────────\r\n        2        \r\n\r\nIn [14]: expr = x**2*_eis(-2*log(1/x))/2\r\n\r\nIn [17]: expand_log(expr, force=True)\r\nOut[17]: \r\n 2               \r\nx ⋅_eis(2⋅log(x))\r\n─────────────────\r\n        2\r\n```', 'comment_created': datetime.datetime(2022, 6, 10, 12, 46, 58, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 895003715, 'comment_body': ""Thanks for this, wasn't aware of `expand_log`, I was just about to commit using the following , then saw your message\r\n```\r\n            expr = expr.expand(**dict(deep=True, log=True, mul=False, power_exp=False,\r\n                  power_base=False, multinomial=False, basic=False, force=False,\r\n                  factor=False)\r\n\r\n```"", 'comment_created': datetime.datetime(2022, 6, 11, 9, 55, 17, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 895130880, 'comment_body': 'Should there be logx instead of log(x)? ', 'comment_created': datetime.datetime(2022, 6, 12, 8, 15, 28, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 895132284, 'comment_body': 'Yeah correct , will make the change in the upcoming commits today !', 'comment_created': datetime.datetime(2022, 6, 12, 8, 26, 24, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 896332084, 'comment_body': 'Is there any reason for using `expand_log`? The above comment should be removed if such a case is there.', 'comment_created': datetime.datetime(2022, 6, 14, 3, 8, 21, tzinfo=datetime.timezone.utc), 'commenter': '0sidharth', 'type': 'User'}, {'comment_id': 896333163, 'comment_body': 'Why should the `logx` parameter not be passed? Is it not required, or giving a wrong result?', 'comment_created': datetime.datetime(2022, 6, 14, 3, 11, 8, tzinfo=datetime.timezone.utc), 'commenter': '0sidharth', 'type': 'User'}, {'comment_id': 896333900, 'comment_body': 'Is the `and` clause really required? When is `logx` = `log(x)`?', 'comment_created': datetime.datetime(2022, 6, 14, 3, 13, 3, tzinfo=datetime.timezone.utc), 'commenter': '0sidharth', 'type': 'User'}, {'comment_id': 896334586, 'comment_body': 'I think, we can try with the above snippet anutosh posted, with `force=True`, and see if that works. `expand_log` can be more expensive.', 'comment_created': datetime.datetime(2022, 6, 14, 3, 14, 56, tzinfo=datetime.timezone.utc), 'commenter': '0sidharth', 'type': 'User'}, {'comment_id': 896337787, 'comment_body': ""There should be no spaces around '=' in function argument acc to PEP8"", 'comment_created': datetime.datetime(2022, 6, 14, 3, 24, 1, tzinfo=datetime.timezone.utc), 'commenter': '0sidharth', 'type': 'User'}, {'comment_id': 896340594, 'comment_body': ""Is this supposed to be missing a '-' sign in front of 2*x?"", 'comment_created': datetime.datetime(2022, 6, 14, 3, 31, 44, tzinfo=datetime.timezone.utc), 'commenter': '0sidharth', 'type': 'User'}, {'comment_id': 896824599, 'comment_body': ""No ,the real essence of STEP 5 comes into picture for `log(2*x + (3 - I)*x**2)` through any negative `cdir`. Yeah it might look weird because I've added both tests(the upper one and this) which would go through STEP 5 and neglected the counterparts which would skip the step . I guess I'll add them in the next commit to make more sense , as those tests would then act as controls and would showcase cases which won't need STEP 5"", 'comment_created': datetime.datetime(2022, 6, 14, 13, 32, 14, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 900687897, 'comment_body': 'No not really , had introduced that change to see if it helps in fixing bugs in `add._eval_as_leading_term()`, had planned to change it back after I get some clarity( done in latest commit) ', 'comment_created': datetime.datetime(2022, 6, 18, 2, 53, 12, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 900688355, 'comment_body': ""Yeah it is not required and also would give many wrong result . It went unnoticed as we weren't exactly dealing with the `logx` parameter, but now that the PR introduces the real essence of `logx`, having a `logx = logx` there changes the path/execution of calls involving expressions of type `Mul` where `logx` is not `None`"", 'comment_created': datetime.datetime(2022, 6, 18, 2, 58, 38, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 900694101, 'comment_body': ""Not really , I would say no , actually that shoudn't be there , put it just by choice . From what I understand the parameter `logx` should be replacing all instances of `log(x)` in the series/leading term. For eg\r\n```\r\n>>> (log(x) + log(1+x)).nseries(x,n=3, logx = p)\r\nx - x**2/2 + p + O(x**3)\r\n```\r\n**But quite some times we encounter `log(x)` as the `logx` parameter, which I guess means there shouldn't be any change in the expression correct ?( like replacing log(x) by log(x) )**\r\n```\r\n >>> (log(x) + log(1+x)).nseries(x,n=3, logx = log(x))\r\nlog(x) + x - x**2/2 + O(x**3)\r\n```\r\nSo yeah few tests like the following involve such a change and I had put that check by choice so that the output looks somewhat better\r\n```\r\n>>> log(1 + 1/x).nseries(x, n=5) # calls for log(1 + 1/x)._eval_nseries(x, n=5 , logx=log(x))\r\nlog(1/x) + x - x**2/2 + x**3/3 - x**4/4 + O(x**5)    # without the check\r\n\r\nx - log(x) - x**2/2 + x**3/3 - x**4/4 + O(x**5)      # with the check \r\n```\r\nif log(x) replaces log(x) it means there shouldn't be any change from the normal series expansion so the answer should be \r\n```\r\n>>> log(1 + 1/x).series(x, 0, 5)\r\nlog(1/x) + x - x**2/2 + x**3/3 - x**4/4 + O(x**5)\r\n```\r\nAlso another case being\r\n```\r\n>>> e = -log(x) + x*(-log(x) + log(sin(2*x))) + log(sin(2*x))\r\n>>> e.series(x, n=5)\r\nlog(2*x) - log(x) + x*log(2) - 2*x**2/3 - 2*x**3/3 - 4*x**4/45 + O(x**5)\r\n>>> # The first -log(x) doesn't really take part in the expansion but with the check we get\r\nlog(2) + log(2)*x - 2*x**2/3 - 2*x**3/3 - 4*x**4/45 + O(x**5)\r\n```\r\nSo yeah , we could do with or without the check !\r\n\r\n\r\n"", 'comment_created': datetime.datetime(2022, 6, 18, 4, 7, 53, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 900736349, 'comment_body': ""The check looks counterintuitive to me, so I think it can be removed. I meant to ask if there are any example cases where we don't explicitly pass `logx=log(x)`, but it gets passed during the run of the code."", 'comment_created': datetime.datetime(2022, 6, 18, 8, 32, 58, tzinfo=datetime.timezone.utc), 'commenter': '0sidharth', 'type': 'User'}, {'comment_id': 900751789, 'comment_body': ""Ahh ok got your point , will look into this . If I remember correctly , there are cases in `test_aseries.py` and `test_nseries.py`, where somehow a `log(x)` is being passed as the parameter. Not sure of its usecase and like where is it happening but I'll look into this soon"", 'comment_created': datetime.datetime(2022, 6, 18, 8, 56, 51, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 901637049, 'comment_body': ""The only case which we would be missing out here would be the ones having `log(1/x)`.For eg As of now we have the following \r\n```\r\n>>> log(log(1/x))._eval_nseries(x, n= 3, logx=-p)  \r\nlog(p) + O(x**3)    # order term is unwanted\r\n ```\r\nAnd let's say we stick to something like \r\n```\r\n        if not d.is_positive:\r\n            res = log(a) + b*logx\r\n            expr = self.expand(**dict(deep=True, log=True, mul=False,\r\n                    power_exp=False, power_base=False, multinomial=False,\r\n                    basic=False, force=True, factor=False))\r\n            if (res.subs(logx, log(x)) == expr\r\n                or res.subs(-logx, -log(x)) == expr):\r\n                return res\r\n```\r\nwhere `res = log(p)`, `logx= -p` . We would miss out on cases having log(1/x) as shown below \r\n```\r\n>>> expand_log(log(log(1/x)), force=True)\r\nlog(log(x)) + I*pi\r\n```\r\nThis sort of implementation would have liked the answer as `log(-log(x))` rather than `log(log(x)) + I*pi` "", 'comment_created': datetime.datetime(2022, 6, 20, 13, 0, 47, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 902614400, 'comment_body': '> The check looks counterintuitive to me, so I think it can be removed. I meant to ask if there are any example cases where we don\'t explicitly pass logx=log(x), but it gets passed during the run of the code.\r\n\r\nActually I realize we would need some kind of check here like `logx != log(x)`. This is because , I had overlooked line `976-977` . \r\n```\r\n    def _eval_nseries(self, x, n, logx, cdir=0):\r\n        from sympy.series.order import Order\r\n        from sympy.simplify.simplify import logcombine\r\n        if not logx:\r\n            logx = log(x)\r\n```\r\nSo whenever we pass `logx` as `None` originally , it is changed to `log(x)` and the check I\'ve added is for addressing a corner case as follows\r\n```\r\ndef test_issue_21227():\r\n    f = log(x)\r\n    assert f.nseries(x, logx=-x) == -x\r\n\r\n    f = log(-log(x))\r\n    assert f.nseries(x, logx=-x) == log(x)\r\n\r\n    f = log(log(x))\r\n    assert f.nseries(x, logx=-x) == log(-x)\r\n    assert f.nseries(x, logx=x) == log(x)\r\n```\r\nHere `logx` contains an argument based on `x` which is the variable in consideration for the expansion for which there is no handling in the code currently ! The original code is capable to address all other cases through `a, b = s.removeO().leadterm(x)` . We should have the following diff I believe\r\n```\r\n--- a/sympy/functions/elementary/exponential.py\r\n+++ b/sympy/functions/elementary/exponential.py\r\n@@ -973,6 +973,7 @@ def _eval_nseries(self, x, n, logx, cdir=0):\r\n         #      IMPORTANT.\r\n         from sympy.series.order import Order\r\n         from sympy.simplify.simplify import logcombine\r\n+        _logx = logx\r\n         if not logx:\r\n             logx = log(x)\r\n         if self.args[0] == x:\r\n@@ -1009,10 +1010,13 @@ def coeff_exp(term, x):\r\n             while s.is_Order:\r\n                 n += 1\r\n                 s = arg.nseries(x, n=n, logx=logx)\r\n-        if logx.has(x):\r\n+        if _logx and logx.has(x):\r\n             a, b = arg.subs(log(x), logx).as_leading_term(x), S.Zero\r\n         else:\r\n-            a, b = s.removeO().leadterm(x)\r\n+            try:\r\n+                a, b = s.removeO().leadterm(x)\r\n+            except:\r\n+                a, b = s.removeO().as_leading_term(x), S.Zero\r\n```\r\nThe last try except block would be for something like this\r\n```\r\n>>> log(sqrt(-x**2 -2*x))._eval_nseries(x, 3, None)\r\nlog(sqrt(2)*sqrt(-x)) + x/4 - x**2/16 + O(x**3)\r\n>>> \r\n>>> # Without the block \r\n>>> log(sqrt(-x**2 -2*x))._eval_nseries(x, 3, None)""\r\nValueError:\r\ncannot compute leadterm(-sqrt(2)*x**2*sqrt(-x)/32 +\r\nsqrt(2)*x*sqrt(-x)/4 + sqrt(2)*sqrt(-x), x). The coefficient should\r\nhave been free of x but got sqrt(2)*sqrt(-x)\r\n```', 'comment_created': datetime.datetime(2022, 6, 21, 13, 23, 19, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 903596562, 'comment_body': ""I've addressed this now , everything works fine now . Hence resolving (failing tests not due to the latest commit , due to some other warnings I see)"", 'comment_created': datetime.datetime(2022, 6, 22, 11, 1, 43, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 903961809, 'comment_body': 'if we put `integrate(1/(pi*(1+(x-a)**2)),(x,-oo,oo)).expand()` on the left hand side, them `expr` would look more readable.', 'comment_created': datetime.datetime(2022, 6, 22, 16, 6, 53, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 904119691, 'comment_body': 'These tests are not needed when the integral with parameter `a` is given above.', 'comment_created': datetime.datetime(2022, 6, 22, 18, 45, 37, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 904764595, 'comment_body': ""Sure , will change them . It's just that all other cases were working on master except this one which is `-1< im(a) < 1` . This case used to give `0` on master, so what we really addressed here was this case. But we anyways have the integral in the form of parameter `a`, so we can get rid of this ."", 'comment_created': datetime.datetime(2022, 6, 23, 8, 58, 16, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 907090369, 'comment_body': 'Why should logx not be included? A comment would be helpful. ', 'comment_created': datetime.datetime(2022, 6, 27, 8, 2, 35, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 907144209, 'comment_body': ""Yeah , this might be confusing sometimes . I had also explained it to Sidharth on the gitter channel few days back . It's just that the `logx=logx` argument was being passed since quite some time in `mul._eval_nseries()` unknowingly and it worked as the `logx` parameter wasn't really functioning before this Pr. \r\n```\r\n>>> log(x).as_leading_term(x, logx=x)  # On master\r\nlog(x)\r\n>>> log(x).as_leading_term(x, logx=x)\r\nx\r\n```\r\nSo as now that the `logx` parameter is functioning for log function... the path taken by the nseries call for any `f(x) = g(x) * log(h(x))` would change and the output won't we returned from where it be should be . For all other `f(x)` nothing changes . Th block `1921 - 1933` is mainly responsible for returning result for nseries for mul expression involving log but this would change to the return statement from the end of the file if we keep the logx.\r\n\r\nWe can replicate this in any nseries method having such a try except block as of now .For eg if we take `log._eval_nseries` which has a block like this \r\n```\r\n        try:\r\n            a, b = arg.leadterm(x)\r\n            s = arg.nseries(x, n=n+b, logx=logx)\r\n        except (ValueError, NotImplementedError, PoleError):\r\n            s = arg.nseries(x, n=n, logx=logx)\r\n```\r\nIf we now change `a, b = arg.leadterm(x)` to `a, b = arg.leadterm(x, logx= logx)` , this would give us errors while running tests.\r\n\r\nI'll try to think of a comment if we want to make a note of this change in the code ."", 'comment_created': datetime.datetime(2022, 6, 27, 8, 57, 26, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 907147503, 'comment_body': ""Let me know if you want me to explain any other changes I've made or would like to see some more changes from my side ,otherwise the change look decent to me ."", 'comment_created': datetime.datetime(2022, 6, 27, 9, 0, 36, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 907263248, 'comment_body': 'It looks like the limit should be `oo`. (It will suffice to define `x` with `positive=True` as that implies `real=True`.)', 'comment_created': datetime.datetime(2022, 6, 27, 11, 9, 2, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 907274268, 'comment_body': 'Oops ...Yeah correct , not sure how I missed this . Will look into it !', 'comment_created': datetime.datetime(2022, 6, 27, 11, 22, 53, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 909439956, 'comment_body': 'It is probably better to add `expand` to `asin._eval_as_leading_term` (and to other similar methods where `rewrite(log)` will introduce nontrivial factors).', 'comment_created': datetime.datetime(2022, 6, 29, 9, 58, 16, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 911687242, 'comment_body': 'It looks like there should be `-pi/2` instead of `-3*pi/2`:\r\n```\r\nIn [49]: asin(-2).n()\r\nOut[49]: -1.5707963267949 + 1.31695789692482⋅ⅈ\r\nIn [50]: asin(-10).n()\r\nOut[50]: -1.5707963267949 + 2.99322284612638⋅ⅈ\r\nIn [51]: asin(-100).n()         \r\nOut[51]: -1.5707963267949 + 5.29829236561048⋅ⅈ\r\n```\r\nIt is probably best to comment this out now and fix in a later PR. Something like this can also be expected in case of other inverse functions.', 'comment_created': datetime.datetime(2022, 7, 1, 7, 24, 1, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 911690452, 'comment_body': 'This can probably be fixed later in order.py.', 'comment_created': datetime.datetime(2022, 7, 1, 7, 28, 19, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 911767969, 'comment_body': ""I guess it is correct , atleast that's what the graph and wolfram shows ( I hope you didn't forget the negative cdir here ) \r\n![image](https://user-images.githubusercontent.com/87052487/176861725-ea4be5de-d81d-49a8-a402-3a7426ba37d0.png)\r\n\r\nAlso we can achieve this on master through gruntz \r\n```\r\n>>> x = Symbol('x')\r\n>>> asin(1/x).rewrite(log)\r\n-I*log(sqrt(1 - 1/x**2) + I/x)\r\n>>> expand_log(_, force=True)\r\n-I*log(sqrt(1 - 1/x**2) + I/x)\r\n>>> gruntz(-I*log(sqrt(1 - 1/x**2) + I/x) + I*log(x), x, 0, '-')\r\nI*(log(2) + 3*I*pi/2)\r\n```\r\n"", 'comment_created': datetime.datetime(2022, 7, 1, 9, 1, 27, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 911769742, 'comment_body': ""Yeah I remember asking this on the gitter channel , if we could do with this ans . Not sure if I got any suggestion on that . Would this do ? or we should stick to `log(x)` as before . In any case I'll give it a quick try regarding how this can be fixed , otherwise make a TODO for that !"", 'comment_created': datetime.datetime(2022, 7, 1, 9, 3, 35, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 911780267, 'comment_body': ""Ahh yeah I remember , this comes out of this line we had added\r\n```\r\n        _logx = Dummy('logx') if logx is None else logx\r\n        leading_terms = [t.as_leading_term(x, logx=_logx, cdir=cdir) for t in expr.args]\r\n```\r\nTreating log as constants means log(x) and 1/log(x) both are rather treated as constants/symbols , hence the second log(x) term isn't eliminated !"", 'comment_created': datetime.datetime(2022, 7, 1, 9, 16, 47, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 911819119, 'comment_body': 'The difference between `-pi/2` and `-3*pi/2` is accounted for by the imaginary part of `log(x)` for negative `x`. So there is no problem after all..', 'comment_created': datetime.datetime(2022, 7, 1, 10, 2, 50, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}]","[{'commit_sha': 'f97263344cd1b3296c17da395928bb7894f76ac0', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}, {'commit_sha': '5d4b0ed2246ea7ac028ae1df49e70049c0ba54a5', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'a95ec1e62c99e38346ddd2b4dbe6f8e12f0d91fc', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}, {'commit_sha': '4f49fe2fbf8c7a3778aea4a2fa800cfac922381c', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}, {'commit_sha': '94dd9276b63a2f27209d5e9c3156bec968be116c', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}]",Anutosh Bhat,87052487,,User,,45,,25,34

985431714,[GSoC Pr2] Implemented/Fixed a few series methods for inverse trig/hyperbolic functions,"<!-- Your title above should be a short description of what
was changed. Do not include the issue number in the title. -->

#### References to other Issues or PRs
<!-- If this pull request fixes an issue, write ""Fixes #NNNN"" in that exact
format, e.g. ""Fixes #1234"" (see
https://tinyurl.com/auto-closing for more information). Also, please
write a comment on that issue linking back to this pull request once it is
open. -->
Fixes #10868
Fixes #22986
Fixes #3663
Fixes #23727 
Fixes #23752 
Closes #22521 
Closes #22995

#### Brief description of what is fixed or changed

1) Changes through first commit - Implemented taylor_term method for asec, acsc, asech, acsch functions.

On master
```
>>> asec(x).series(x)
nan
>>> acsc(x).series(x)
nan
>>> asech(x).series(x)
nan
>>> acsch(x).series(x)
nan
```
On branch
```
>>> asec(x).series(x)
I*log(2) - I*log(x) - I*x**2/4 - 3*I*x**4/32 + O(x**6)
>>> acsc(x).series(x)
-I*log(2) + pi/2 + I*log(x) + I*x**2/4 + 3*I*x**4/32 + O(x**6)
>>> asech(x).series(x)
log(2) - log(x) - x**2/4 - 3*x**4/32 + O(x**6)
>>> acsch(x).series(x)
log(2) - log(x) + x**2/4 - 3*x**4/32 + O(x**6)
```

2) Changes through second commit - Implemented series for functions( `atan`, `acot`) having branch cuts along the imaginary axis.

On Master
```
>>> atan(x + I).series(x)
Traceback (most recent call last):
....................
sympy.core.function.PoleError: Cannot expand atan(_x + I) around 0
>>> atan(x - I).series(x)
Traceback (most recent call last):
..............
sympy.core.function.PoleError: Cannot expand atan(_x - I) around 0
```
On branch
```
>>> atan(x + I).series(x)
I*log(2)/2 + pi/4 - I*log(x)/2 + x/4 + I*x**2/16 - x**3/48 - I*x**4/128 + x**5/320 + O(x**6)
>>> atan(x - I).series(x)
-I*log(2)/2 + pi/4 + I*log(x)/2 + x/4 - I*x**2/16 - x**3/48 + I*x**4/128 + x**5/320 + O(x**6)
```
#### Other comments


#### Release Notes

<!-- Write the release notes for this release below between the BEGIN and END
statements. The basic format is a bulleted list with the name of the subpackage
and the release note for this PR. For example:

* solvers
  * Added a new solver for logarithmic equations.

* functions
  * Fixed a bug with log of integers.

or if no release note(s) should be included use:

NO ENTRY

See https://github.com/sympy/sympy/wiki/Writing-Release-Notes for more
information on how to write release notes. The bot will check your release
notes automatically to see if they are formatted correctly. -->

<!-- BEGIN RELEASE NOTES -->
* series
  * Implemented taylor_term method for asec, acsc, asech, acsch functions.
  * Refactored leading term methods for all inverse hyperbolic functions.
  * Fixes bi-directional limits for acot, asec, acsc, acoth, asech, acsch.
  * Fixes Float handling for pow._eval_nseries.
  * Fixes branch cut handling for pow._eval_as_leading_term and pow._eval_nseries method where new direction (ndir) being calculated with respect to base of the pow expression is real.
<!-- END RELEASE NOTES -->
",True,23715,https://api.github.com/repos/sympy/sympy/pulls/23715,https://github.com/sympy/sympy/pull/23715,closed,662,218,10,8,13,42,2,0,"[{'name': 'series'}, {'name': 'GSoC'}]",2022-07-02 01:41:15+00:00,2022-07-16 16:00:18+00:00,1261143.0,"14 days, 14:19:03","[{'comment_id': 912311828, 'comment_body': 'There are many tests like these , that have been commented out in `test_trigonometric.py` from lines 1870 - 1980 . But now that we have proper `_eval_nseries` methods for all inv trig functions , I guess all of these would work (will try it out) so not sure why they have been commented out or do we need all of these ! @jksuom \r\n\r\nI guess we could also restructure these tests better creating separate tests per each inverse function , rather than creating a single 110 line test function', 'comment_created': datetime.datetime(2022, 7, 2, 3, 0, 33, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 912318058, 'comment_body': 'I ran a check , all the commented tests seem to work properly !', 'comment_created': datetime.datetime(2022, 7, 2, 4, 23, 15, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 913460920, 'comment_body': ""Conditions like `im(x0) < S.NegativeOne` do not necessarily return a boolean value.\r\n```\r\nIn [6]: r = symbols('r', real=True)                                            \r\n\r\nIn [7]: e = asinh(I*r + x)                                                     \r\n\r\nIn [8]: e._eval_as_leading_term(x, None, 1)                                    \r\n---------------------------------------------------------------------------\r\n...\r\nTypeError: cannot determine truth value of Relational\r\n```\r\n"", 'comment_created': datetime.datetime(2022, 7, 5, 7, 15, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 913782499, 'comment_body': 'Yeah, we have such cases throughout all inverse functions and ..... maybe also other trig/hyperbolic functions too if we search for \r\n```\r\n>>> asin(r + I*x)\r\nasin(r + I*x)\r\n>>> _._eval_as_leading_term(x, None, 1)\r\nTraceback (most recent call last):\r\n  File ""<stdin>"", line 1, in <module>\r\n  File ""C:\\Users\\anuto\\sympy\\sympy\\sympy\\functions\\elementary\\trigonometric.py"", line 2329, in _eval_as_leading_term\r\n    elif im(cdir) > 0 and x0.is_real and x0 > S.One:\r\nTypeError: cannot determine truth value of Relational\r\n```\r\nI guess we could have used log rewrites here if we wanted to have a generic result , then substitute value of `r` to get the correct answer. For eg\r\n```\r\n>>> asin(r + I*x).as_leading_term(x, cdir=1)\r\n-I*log(I*r + sqrt(1 - r**2))\r\n>>> _.subs(r, 1)\r\npi/2\r\n>>>\r\n>>> asin(1 + I*x).as_leading_term(x, cdir=1)\r\npi/2\r\n```\r\nBut not sure if a general result could be returned for all cases (would depend on range of `r` so would require a Piecewise ans). For eg\r\n```\r\n>>> asin(r + I*x).as_leading_term(x, cdir=1)\r\n-I*log(I*r + sqrt(1 - r**2))\r\n>>> _.subs(r, 2)\r\n-I*(log(sqrt(3) + 2) + I*pi/2)\r\n>>> _.n()\r\n1.5707963267949 - 1.31695789692482*I\r\n>>>\r\n>>> asin(2 + I*x).as_leading_term(x, cdir=1)\r\npi - asin(2)\r\n>>> _.n()\r\n1.5707963267949 + 1.31695789692482*I\r\n```\r\nThe answers are different here . This is because something like leading term of something like `sqrt(1 - g(x)**2)` would be be depending on `cdir` and `g(x)` eventually\r\n```\r\n>>> sqrt(1 - (I*x + r)**2).as_leading_term(x)\r\nsqrt(1 - r**2)\r\n>>> sqrt(1 - (I*x + r)**2).as_leading_term(x, cdir = 1)\r\nsqrt(1 - r**2)\r\n>>> sqrt(1 - (I*x + r)**2).as_leading_term(x, cdir = -1)\r\nsqrt(1 - r**2)\r\n```\r\nBut for r = 2\r\n```\r\n>>> sqrt(1 - (I*x + 2)**2).as_leading_term(x, cdir = 1)\r\n-sqrt(3)*I\r\n>>> sqrt(1 - (I*x + 2)**2).as_leading_term(x, cdir = -1)\r\nsqrt(3)*I\r\n```\r\n\r\nSo it may require a Piecewise implementation based on range of `r` or something if we plan to do something like that . I look into this and ways how we can do better in this case ! \r\n\r\nCan catching the `TypeError` and then working forward (and maybe returning `self` if nothing concrete can be done) be an approach here ?\r\n\r\n\r\n', 'comment_created': datetime.datetime(2022, 7, 5, 13, 13, 17, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 913809585, 'comment_body': 'It will be better to use a condition that will not raise an error. There are several possibilities, e.g., `(im(x0) -1).is_negative`, or there could be something like `-I*pi*Heaviside(1 - im(x0), 0)` in the return value. \r\nIt seems that some experimentation is necessary. ', 'comment_created': datetime.datetime(2022, 7, 5, 13, 38, 29, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 914396943, 'comment_body': 'Yeah , even I was thinking about `Heaviside` , will look into this and explore the options we have .', 'comment_created': datetime.datetime(2022, 7, 6, 4, 11, 32, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 914421236, 'comment_body': ""If we plan to use Heaviside though for all generic cases including the one above which you've pointed out involving `r` , we would still need to differentiate based on `cdir` and use `Piecewise` . This is because we would end up using            \r\n `-self(x0)` whenever the Heaviside term comes into picture or else we would use `self(x0)` as shown in the code which has already been implemented.\r\n```\r\n        if re(cdir) > 0 and re(x0).is_zero and im(x0) < S.NegativeOne:\r\n            return -self.func(x0) - I*pi\r\n        elif re(cdir) < 0 and re(x0).is_zero and im(x0) > S.One:\r\n            return -self.func(x0) + I*pi\r\n        return self.func(x0)\r\n```\r\nObviously everything would work as expected \r\n```\r\n>>> x = Symbol('x')\r\n>>> r = symbols('r', real=True)\r\n>>> asinh(2*I + x)._eval_as_leading_term(x, cdir = 1)\r\nI*asin(2)\r\n>>> asinh(-2*I + x)._eval_as_leading_term(x, cdir = 1)\r\n-I*pi + I*asin(2)\r\n>>> asinh(r*I + x)._eval_as_leading_term(x, cdir = 1)\r\n⎧         ⅈ⋅asin(r)            for θ(1 - r, 0) = 0\r\n⎨\r\n⎩-ⅈ⋅π⋅θ(1 - r, 0) - ⅈ⋅asin(r)       otherwise\r\n>>> expr = _\r\n>>> expr.subs(r, 2)\r\nI*asin(2)\r\n>>> expr.subs(r, -2)\r\n-I*pi + I*asin(2)\r\n>>>\r\n>>>\r\n>>> asinh(2*I + x)._eval_as_leading_term(x, cdir = -1)\r\n-I*asin(2) + I*pi\r\n>>> asinh(-2*I + x)._eval_as_leading_term(x, cdir = -1)\r\n-I*asin(2)\r\n>>> asinh(r*I + x)._eval_as_leading_term(x, cdir = -1)\r\n⎧         ⅈ⋅asin(r)           for θ(r + 1, 0) = 0\r\n⎨\r\n⎩ⅈ⋅π⋅θ(r + 1, 0) - ⅈ⋅asin(r)       otherwise\r\n>>> expr = _\r\n>>> expr.subs(r, 2)\r\n-I*asin(2) + I*pi\r\n>>> expr.subs(r, -2)\r\n-I*asin(2)\r\n```\r\nSo it's not that we can't get the correct answers , but the same Heaviside function won't work the same for both `cdir`. So a diff like this could be the case\r\n```\r\n@@ -1189,10 +1191,13 @@ def _eval_as_leading_term(self, x, logx=None, cdir=0):\r\n             return self.rewrite(log)._eval_as_leading_term(x, logx=logx, cdir=cdir)\r\n         if cdir != 0:\r\n             cdir = arg.dir(x, cdir)\r\n-        if re(cdir) > 0 and re(x0).is_zero and im(x0) < S.NegativeOne:\r\n-            return -self.func(x0) - I*pi\r\n-        elif re(cdir) < 0 and re(x0).is_zero and im(x0) > S.One:\r\n-            return -self.func(x0) + I*pi\r\n+        if re(x0).is_zero:\r\n+            if re(cdir) > 0:\r\n+                return Piecewise((self.func(x0), Eq(Heaviside(-1 - im(x0), 0), S.Zero)),\r\n+                                 (-self.func(x0) - I*pi*Heaviside(-1 - im(x0), 0), True))\r\n+            if re(cdir) < 0:\r\n+                return Piecewise((self.func(x0), Eq(Heaviside(im(x0) - 1, 0), S.Zero)),\r\n+                                 (-self.func(x0) + I*pi*Heaviside(im(x0) - 1, 0), True))\r\n         return self.func(x0)\r\n```\r\nI'll try this out for all other cases too !\r\n"", 'comment_created': datetime.datetime(2022, 7, 6, 5, 11, 13, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 914451174, 'comment_body': 'Heaviside is probably overkill here. How about using rewrite(log) as in the case of trigonometric functions (possibly only when `re(x0).is_zero`)?\r\n\r\nBTW, this would be easier to review if the name of the function were added in a comment like\r\n\r\n    def _eval_as_leading_term(self, x, logx=None, cdir=0):  # asinh', 'comment_created': datetime.datetime(2022, 7, 6, 6, 14, 45, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 914493585, 'comment_body': ""This is what finally what it pans out to for `asinh` from my side ( after carefully reviewing all cases)\r\n```\r\n    def _eval_as_leading_term(self, x, logx=None, cdir=0):\r\n        from sympy import Piecewise, Heaviside\r\n        arg = self.args[0]\r\n        x0 = arg.subs(x, 0).cancel()\r\n        if x0.is_zero:\r\n            return arg.as_leading_term(x)\r\n        # Handling branch points (-I*oo, -I) U (I, I*oo)\r\n        if x0 in (-S.ImaginaryUnit, S.ImaginaryUnit, S.ComplexInfinity):\r\n            return self.rewrite(log)._eval_as_leading_term(x, logx=logx, cdir=cdir)\r\n        if cdir != 0:\r\n            cdir = arg.dir(x, cdir)\r\n        if re(x0).is_zero:\r\n            if re(cdir) > 0:\r\n                return Piecewise((-self.func(x0) - I*pi*Heaviside(-1 - im(x0), 1), Eq(Heaviside(-1 - im(x0), 1), S.One)),\r\n                                 (self.func(x0), True))\r\n            if re(cdir) < 0:\r\n                return Piecewise((-self.func(x0) + I*pi*Heaviside(-1 - im(x0), 1), Eq(Heaviside(im(x0) - 1, 1), S.One)),\r\n                                 (self.func(x0), True))\r\n        return self.func(x0)\r\n```\r\nI feel we could have maybe tried this , the general cases would surely need condition or `Heaviside` . But yeah this is surely not required , as these would get much more complicated for cases involving `acoth, asech, acsch` (which have cases like `(x0) < S.One and (x0) > S.Zero`) and then we would need two `Heaviside` base conditions to implement this check which we should be avoiding !\r\n\r\nI wrote this and ran tests , so like obviously everything works but don't think its truly necessary here ."", 'comment_created': datetime.datetime(2022, 7, 6, 7, 16, 19, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 914499208, 'comment_body': ""> BTW, this would be easier to review if the name of the function were added in a comment like\r\n\r\nSure will do !\r\n\r\nYeah I had tried log rewrites in this comment above (https://github.com/sympy/sympy/pull/23715#discussion_r913782499) . Though it expresses a lot of cases , we would also miss out of some cases based on `cdir` is what I had deduced. Though I'll try out what you've suggested ! \r\n\r\nDo you suggest something along these lines\r\n```\r\n--- a/sympy/functions/elementary/hyperbolic.py\r\n+++ b/sympy/functions/elementary/hyperbolic.py\r\n@@ -1189,10 +1189,13 @@ def _eval_as_leading_term(self, x, logx=None, cdir=0):\r\n             return self.rewrite(log)._eval_as_leading_term(x, logx=logx, cdir=cdir)\r\n         if cdir != 0:\r\n             cdir = arg.dir(x, cdir)\r\n-        if re(cdir) > 0 and re(x0).is_zero and im(x0) < S.NegativeOne:\r\n-            return -self.func(x0) - I*pi\r\n-        elif re(cdir) < 0 and re(x0).is_zero and im(x0) > S.One:\r\n-            return -self.func(x0) + I*pi\r\n+        if re(x0).is_zero:\r\n+            if re(cdir) > 0 and (im(x0) + 1).is_negative:\r\n+                return -self.func(x0) - I*pi\r\n+            elif re(cdir) < 0 and (im(x0) - 1).is_positive:\r\n+                return -self.func(x0) + I*pi\r\n+            else:\r\n+                return self.rewrite(log)._eval_as_leading_term(x, logx=logx, cdir=cdir)\r\n```"", 'comment_created': datetime.datetime(2022, 7, 6, 7, 23, 30, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 914717785, 'comment_body': 'Would the (last) rewrite line alone suffice when re(x0).is_zero?', 'comment_created': datetime.datetime(2022, 7, 6, 11, 14, 7, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 914810412, 'comment_body': 'There should probably be a separate PR for this fix. It is possible to avoid introducing `Float` by using `is_Float`. Also, it is better to use a proper name like `c` for the coefficient instead of `_`.', 'comment_created': datetime.datetime(2022, 7, 6, 13, 0, 31, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 914813578, 'comment_body': ""Yeah correct, will address this in the next commit . Though as the change was small , like not too tedious so I thought , I'll get it done here itself. But if you feel otherwise I'll make a separate Pr for this !"", 'comment_created': datetime.datetime(2022, 7, 6, 13, 3, 46, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 914820554, 'comment_body': ""In that case we could just do something like the following for all the cases :) and everything would work fine \r\n```\r\n    def _eval_as_leading_term(self, x, logx=None, cdir=0):\r\n        return self.rewrite(log)._eval_as_leading_term(x, logx=logx, cdir=cdir)\r\n```\r\n\r\nBut like this would make the function computationally expensive ! So I would say the general cases should like the ones you've pointed out should be done using `self.func(x0)` which is more than enough for the doing the numerical cases , yeah but if we have something where we deal with a variable like `r` which can cover all set of real numbers, yeah then definitly in that case we should use log rewrite as I've shown in the diff ! \r\n\r\nAlso as I said in a comment earlier , the log rewrite won't be like doing justice for all cases involving `r`, for eg\r\n```\r\n>>> asin(2 + I*x).rewrite(log).as_leading_term(x, cdir=1)\r\n-I*(log(2 - sqrt(3)) + I*pi/2)\r\n>>> _.n()\r\n1.5707963267949 + 1.31695789692482*I\r\n>>> asin(r + I*x).rewrite(log).as_leading_term(x, cdir=1)\r\n-I*log(I*x + sqrt(1 - x**2))\r\n>>> _.subs(r, 2).n()\r\n1.5707963267949 - 1.31695789692482*I\r\n```\r\nSo it's not like this expression ( `-I*log(I*x + sqrt(1 - x**2))`) is capable enough to address all values of `r`\r\n "", 'comment_created': datetime.datetime(2022, 7, 6, 13, 10, 38, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 914971513, 'comment_body': '>  this would make the function computationally expensive\r\n\r\nThat may be true. Hence I think that rewrite(log) could be used only in some cases like x0.is_imaginary (or re(x0) == 0).', 'comment_created': datetime.datetime(2022, 7, 6, 15, 21, 7, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 915376004, 'comment_body': ""Okay, maybe we could try this .As I wrote above , we don't really need the log rewrite for all `x0` where `re(x0) == 0`, most of the cases would suffice using `self.func(x0)` . Just the case involving `r` might be needing a log rewrite , but  yeah we can try that . \r\nSo should I do this for all inverse trig/hyperbolic functions ? Like each of these have a block which is basically responsible for handling points inside the branch cuts (and not on them) like for `asinh`\r\n```\r\n        if cdir != 0:\r\n            cdir = arg.dir(x, cdir)\r\n        if re(cdir) > 0 and re(x0).is_zero and im(x0) < S.NegativeOne:\r\n            return -self.func(x0) - I*pi\r\n        elif re(cdir) < 0 and re(x0).is_zero and im(x0) > S.One:\r\n            return -self.func(x0) + I*pi\r\n```\r\nWe have such a block in all inverse functions . If we want to replace this by a log rewrite we could maybe try that all functions ! Our functions (eg asinh) would look like this after the change\r\n```\r\n    def _eval_as_leading_term(self, x, logx=None, cdir=0):\r\n        arg = self.args[0]\r\n        x0 = arg.subs(x, 0).cancel()\r\n        if x0.is_zero:\r\n            return arg.as_leading_term(x)\r\n        if re(x0).is_zero or x0 is S.S.ComplexInfinity:\r\n            return self.rewrite(log)._eval_as_leading_term(x, logx=logx, cdir=cdir)\r\n        return self.func(x0)\r\n```\r\nThough I still say that all cases (specially where `im(x0) > 1` and `im(x0) < -1`) don't need a log rewrite as it's only at branch cuts where sympy find it difficult to deal with series/limits , otherwise `self.func(x0)` is good enough ! \r\nAm I missing something here what you're pointing out , how is a simple log rewrite beneficial for all cases where `re(x0) == 0` ? \r\nI am only able to see a usecase in the example above using `r` that too not fully sure about that as it is won't work for all cases .\r\nI like this block better where we keep log rewrite as the last resort .\r\n```\r\n        if re(x0).is_zero:\r\n            if re(cdir) > 0 and (im(x0) + 1).is_negative:\r\n                return -self.func(x0) - I*pi\r\n            elif re(cdir) < 0 and (im(x0) - 1).is_positive:\r\n                return -self.func(x0) + I*pi\r\n            else:\r\n                return self.rewrite(log)._eval_as_leading_term(x, logx=logx, cdir=cdir)\r\n```\r\nAlso from the point of presenting the output , I would like to have the first one instead of returning  `log(sqrt(c1) + c2)` for such cases .\r\n```\r\n>>> asinh(-2*I + x).as_leading_term(x, cdir = 1)\r\n-I*pi + I*asin(2)\r\n>>> asinh(-2*I + x).as_leading_term(x, cdir = 1)\r\nlog(sqrt(3) + 2) - I*pi/2\r\n```\r\nI guess I maybe missing something here ?!"", 'comment_created': datetime.datetime(2022, 7, 7, 1, 40, 14, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 915569777, 'comment_body': 'What will happen on the branch cut when `arg.dir(x, cdir)` is purely imaginary as in `asinh(2*I + I*x - x**2)`?', 'comment_created': datetime.datetime(2022, 7, 7, 7, 51, 28, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 915745191, 'comment_body': ""This seems to be a really nice catch , my patch and log rewrites both work for `asinh(2*I - x**2)` and `asinh(2*I + x - x**2)` but not for `asinh(2*I + I*x - x**2)`\r\n```\r\n>>> expr = asinh(2*I + I*x - x**2)\r\n>>> expr.as_leading_term(x, cdir = 1)\r\n I*asin(2)\r\n>>> _.n()\r\n1.31695789692482 + 1.5707963267949*I\r\n>>> expr.rewrite(log).as_leading_term(x, cdir = 1)\r\nlog(sqrt(3) + 2) + I*pi/2\r\n>>> _.n()\r\n1.31695789692482 + 1.5707963267949*I\r\n```\r\nThe expected answer here is \r\n```\r\n>>> expr.as_leading_term(x, cdir = 1)\r\nI*pi - asin(2)\r\n>>> _.n()\r\n-1.31695789692482 + 1.5707963267949*I\r\n>>> expr.subs(x, 0.00000000000000001)\r\n-1.31695789692482 + 1.5707963267949*I\r\n```\r\nI'm somewhat surprised that both methods failed here , specially the log one. I started looking into it , as of now I haven't been able to locate what are we missing .\r\n```\r\n>>> expr.rewrite(log)\r\nlog(-x**2 + I*x + sqrt((-x**2 + I*x + 2*I)**2 + 1) + 2*I)\r\n```\r\n\r\n\r\n"", 'comment_created': datetime.datetime(2022, 7, 7, 11, 3, 13, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 915748498, 'comment_body': 'We can break this to a  simpler example\r\n```\r\n>>> log(sqrt((-x**2 + I*x + 2*I)**2 + 1) + 2*I).as_leading_term(x, cdir = 1)\r\nlog(sqrt(3) + 2) + I*pi/2   # expected log(2 - sqrt(3)) + I*pi/2\r\n```\r\nNot sure where we went wrong with `log._eval_as_leading_term()`\r\n', 'comment_created': datetime.datetime(2022, 7, 7, 11, 7, 15, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 917903025, 'comment_body': 'Could this be just `x0.is_negative`?', 'comment_created': datetime.datetime(2022, 7, 11, 13, 2, 9, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 917917834, 'comment_body': 'The branch cut of acosh seems to be the interval (-oo, 1) by the wikipedia. The condition should probably be something like `(x0 - 1).is_negative`.', 'comment_created': datetime.datetime(2022, 7, 11, 13, 17, 18, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 918537576, 'comment_body': 'Yeah correct , thanks for mentioning this . Have made the change !', 'comment_created': datetime.datetime(2022, 7, 12, 4, 30, 25, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 918788397, 'comment_body': ""Shouldn't this be something like `((x0 + 1)/(x0 - 1)).is_negative` or `x0.is_real and (1 - x0**2).is_positive` ? (`x0` could be purely imaginary.)"", 'comment_created': datetime.datetime(2022, 7, 12, 10, 4, 50, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 918845616, 'comment_body': 'Thanks for pointing this out , had forgotten about the Imaginary case , will make the change soon . The second option looks better here .', 'comment_created': datetime.datetime(2022, 7, 12, 11, 13, 53, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 918882251, 'comment_body': ""Ahh I now remember the purpose of the `re(x0)` that you had pointed out earlier( which we ended up removing) ! The purpose of using re(x0) on the lines shown was to negate this exact case you've reported \r\n```\r\n        if (1 - x0**2).is_positive:\r\n            if im(ndir).is_negative:\r\n                if re(x0).is_positive:    # here\r\n                    return self.func(x0) + I*pi\r\n            elif im(ndir).is_positive:\r\n                if re(x0).is_negative:   # here\r\n                    return self.func(x0) - I*pi\r\n```\r\nThough `x0.is_positive/negative` would also negate that and not really lead to wrong answers, we could add the re(x0) term back"", 'comment_created': datetime.datetime(2022, 7, 12, 11, 57, 49, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 919018564, 'comment_body': 'Even `asec`, `acsc` should have these changes (i.e. x0.is_real ) along with `acoth` which have been made in the latest commit .', 'comment_created': datetime.datetime(2022, 7, 12, 14, 7, 38, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 920969711, 'comment_body': 'It seems that this block is redundant. It `x0` is not positive then `self.func(x0)` will be returned on the last line.', 'comment_created': datetime.datetime(2022, 7, 14, 9, 49, 14, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 921068441, 'comment_body': ""Yeah correct , that's the case with some like `acosh, asech, acos` a couple others where leading term through one direction of approach at the branch cut would be `self.func(x0)` and from the other direction is `self.func(x0) - 2*I*pi` . So yeah I just thought of sticking to what might be technically correct (that would be to differentiate between both cases and return for both) but surely we can optimize here . I'll look into these cases and maybe just remove such blocks !"", 'comment_created': datetime.datetime(2022, 7, 14, 11, 51, 27, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 921114469, 'comment_body': 'Maybe `not im(ndir).is_positive`. That will also handle the case when the sign is unknown.', 'comment_created': datetime.datetime(2022, 7, 14, 12, 46, 28, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 921150457, 'comment_body': ""ahh I was just about to commit with what you've said .... I ended up going with the other option but you're correct ."", 'comment_created': datetime.datetime(2022, 7, 14, 13, 23, 31, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 921179212, 'comment_body': 'What if `x0` is positive (and < 1)?', 'comment_created': datetime.datetime(2022, 7, 14, 13, 50, 45, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 921301921, 'comment_body': ""Nice catch , my implementation essentially mimics a function having branch cuts from `(-oo, 0)` but for `acosh` we need  `(-oo, 1)` , so we need handling in the block you've pointed out . Will add code and tests for the same ."", 'comment_created': datetime.datetime(2022, 7, 14, 15, 41, 59, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 921393994, 'comment_body': 'Thanks for pointing this out @jksuom . I was essentially missing out on few corner cases which the latest commit fixes . So \r\n1) `acosh` having branch cuts from `(-oo, 1)` was being treated as `(-oo, 0)`\r\n2) `asech` having branch cuts from `(-oo, 0] U (1, oo)` was being treated as `(-oo, -1] U (1, oo)` \r\nHence I was missing some bit of portion in both . I have fixed this now by adding some handling along with test cases for both these functions . I now feel that we can answer all possible cases involved with `acosh` and `asech` correctly !', 'comment_created': datetime.datetime(2022, 7, 14, 17, 14, 24, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 921811744, 'comment_body': 'There should be one blank line above this line. ', 'comment_created': datetime.datetime(2022, 7, 15, 5, 0, 5, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 921813364, 'comment_body': 'an other value', 'comment_created': datetime.datetime(2022, 7, 15, 5, 4, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 921820691, 'comment_body': '`x0.is_imaginary and (1 + x0**2).is_positive` to exclude real values of `x0`.', 'comment_created': datetime.datetime(2022, 7, 15, 5, 20, 35, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 921828773, 'comment_body': ""Yeah this should be added, if we look into the block , real values of `x0` won't make a difference\r\n```\r\n        if (1 + x0**2).is_positive:\r\n            if re(ndir).is_positive:\r\n                if im(x0).is_positive:\r\n                    return -self.func(x0) - I*pi\r\n```\r\nBut as our primary focus is branch cuts taking execution till the last line shouldn't be the case and rather we should reject such case at the first if condition only !"", 'comment_created': datetime.datetime(2022, 7, 15, 5, 40, 28, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 921831243, 'comment_body': 'x0.is_imaginary and... ', 'comment_created': datetime.datetime(2022, 7, 15, 5, 45, 52, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 921832799, 'comment_body': 'Is `str` necessary? ', 'comment_created': datetime.datetime(2022, 7, 15, 5, 49, 23, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 921840733, 'comment_body': ""Yes , `dir` is of type `Symbol`  after getting it through `e, z, z0, dir = self.args` , so a type conversion is needed here . Actually if you have a look in `limits.py` , most of the times you'll find `str(dir)` being used for this reason. Resolving !"", 'comment_created': datetime.datetime(2022, 7, 15, 6, 4, 8, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 922695900, 'comment_body': ""It's a bad idea to include line numbers like this. Those will become out of date as soon as anyone edits the code above here."", 'comment_created': datetime.datetime(2022, 7, 16, 16, 11, 33, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 922758737, 'comment_body': ""Ahh sorry , yeah I missed that . I am going to make a pr today for implementing series for some functions where I'll address this too , thanks for pointing this out @oscarbenjamin !"", 'comment_created': datetime.datetime(2022, 7, 17, 2, 2, 3, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}]","[{'commit_sha': 'd90e8a815ae96e298e024fc0c6638941ffca677c', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'affd85f4c669053f2588c1bc66a041bc27bc081e', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}, {'commit_sha': '614274d61b8c86fd2ee66e1ef591209773d3811d', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}, {'commit_sha': '13038189a002d7f224d40243b3c80fa27306ab9b', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}, {'commit_sha': '892257165698b4814b765041d69149ab65a94328', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}, {'commit_sha': '18062de502cc6354113c8652f0464dcdf9419a8c', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'c27f927cad9848818841e75efd1f13995044c598', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'ccb81308e2c2813960fcd6c338bf972c225a1e9c', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}]",Anutosh Bhat,87052487,,User,,45,,25,34
998615654,[GSoC Pr3] Fixing/Implementing nseries methods for inverse hyperbolic/trig and log functions  ,"<!-- Your title above should be a short description of what
was changed. Do not include the issue number in the title. -->

#### References to other Issues or PRs
<!-- If this pull request fixes an issue, write ""Fixes #NNNN"" in that exact
format, e.g. ""Fixes #1234"" (see
https://tinyurl.com/auto-closing for more information). Also, please
write a comment on that issue linking back to this pull request once it is
open. -->
Fixes #9158

#### Brief description of what is fixed or changed
This pr is attempting to complete nseries implementation for all pending inverse functions and refactor nseries for the log function on the way.

#### Other comments


#### Release Notes

<!-- Write the release notes for this release below between the BEGIN and END
statements. The basic format is a bulleted list with the name of the subpackage
and the release note for this PR. For example:

* solvers
  * Added a new solver for logarithmic equations.

* functions
  * Fixed a bug with log of integers.

or if no release note(s) should be included use:

NO ENTRY

See https://github.com/sympy/sympy/wiki/Writing-Release-Notes for more
information on how to write release notes. The bot will check your release
notes automatically to see if they are formatted correctly. -->

<!-- BEGIN RELEASE NOTES -->
* series
  * Fixed log._eval_nseries method to perform correctly while dealing with points on branch cuts.
  * Implemented _eval_nseries method for all inverse hyperbolic functions along with atan, acot function.
  * Refactored series method in expr.py to use the cdir parameter effectively.
  * Fixed leading term method for floor and ceiling function to handle arguments of type AccumBounds.
<!-- END RELEASE NOTES -->
",True,23798,https://api.github.com/repos/sympy/sympy/pulls/23798,https://github.com/sympy/sympy/pull/23798,closed,554,96,12,4,8,21,2,0,"[{'name': 'series'}, {'name': 'GSoC'}]",2022-07-17 10:50:08+00:00,2022-07-26 07:15:27+00:00,764719.0,"8 days, 20:25:19","[{'comment_id': 922831730, 'comment_body': 'If cdir != 1, then `log(k*t**l)` will not be `log(k) + l*logx` as `log(x) = log(cdir) + log(t)`.', 'comment_created': datetime.datetime(2022, 7, 17, 13, 11, 24, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 922934788, 'comment_body': 'Yeah , I think we should use `r = log(k) - l*log(cdir) + l*logx` rather !', 'comment_created': datetime.datetime(2022, 7, 18, 2, 14, 56, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 922942374, 'comment_body': ""The simplest case which this block would  be addressing is `nseries` for `log(1/x)` and extrapolating the half ray logic( `x = cdir*t` where t is positive) that we used for leading term improves basic series result too .\r\n```\r\n>>> log(1/x)._eval_nseries(x, 4, logx=-p, cdir=1)\r\np\r\n>>> log(1/x)._eval_nseries(x, 4, logx=-p, cdir=-1)     # on master p\r\np + 2*I*pi\r\n```\r\nI've also added some test for for log._eval_nseries that have been fixed now that we introduce this change ."", 'comment_created': datetime.datetime(2022, 7, 18, 2, 50, 40, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 922995039, 'comment_body': 'It seems that `match` does not make use of `t` being positive. The original code with `r = arg.match(k*x**l)` can be used and there is no need to even define the dummy `t` yet. The substitution `z = arg.subs(x, cdir*t)` could be done after this block.', 'comment_created': datetime.datetime(2022, 7, 18, 6, 7, 31, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 923130148, 'comment_body': ""I guess we can use the dummy for the match block too , otherwise we won't necessarily have correct results for the basic cases\r\n```\r\n>>> log(1/x)._eval_nseries(x, 4, logx=-p, cdir=1)\r\np\r\n>>> log(1/x)._eval_nseries(x, 4, logx=-p, cdir=-1)     # expected p + 2*I*pi\r\np\r\n>>> log(-x)._eval_nseries(x, 4, logx=-p, cdir=1)\r\n-p + I*pi\r\n>>> log(-x)._eval_nseries(x, 4, logx=-p, cdir=-1)  # expected  -p - I*pi\r\n-p + I*pi\r\n```\r\nTimes when `arg` would be of the form `k*x**l`, we might not necessarily expect a series expansion out of it , so atleast we can comply to what limits/leading terms say in that case \r\n```\r\n>>> log(1/x).as_leading_term(x, cdir=1)\r\n-log(x)\r\n>>> log(1/x).as_leading_term(x, cdir=-1)\r\n-log(x) + 2*I*pi\r\n```"", 'comment_created': datetime.datetime(2022, 7, 18, 9, 17, 46, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 923206967, 'comment_body': 'Itt seems that `- l*log(cdir)` will be needed in addition to `l*logx`. Could that be included in the definition of `logx`?', 'comment_created': datetime.datetime(2022, 7, 18, 10, 34, 49, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 923244671, 'comment_body': ""Yes a log(cdir) will be involved here and I've made a commit too adding it according to our conversation here. I like the suggestion of appending `cdir` with `logx` . Will look into it and see how I can make that work .\r\n\r\n**EDIT1:** Not sure if that would be best thing to do in all cases . I see it working well in cases where `logx` is `None` . There are lines really which need the `-l*log(cdir)` term\r\n```\r\nr = log(k) - l*log(cdir) + l*logx       line 994\r\nres = log(a) - b*log(cdir) + b*logx       line 1034\r\nres = log(a) - b*log(cdir) + b*logx        line 1075\r\n```\r\nI had added these changes in one of the previous commits and I see this comfortably addressing series for logarithmic expression that were going through by  a single term like `I*pi` or related which would be fixing by adding a `log(cdir)` term \r\n"", 'comment_created': datetime.datetime(2022, 7, 18, 11, 13, 49, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 923334318, 'comment_body': 'Maybe the name could be `logt` instead of `logx`. Then there would probably be no need for `_logx`.', 'comment_created': datetime.datetime(2022, 7, 18, 12, 48, 46, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 924080299, 'comment_body': 'This looks inefficient: computing two power series and dividing them to get `I` or `-I`. There must be a way to determine the multiplier before calling `_eval_nseries`.', 'comment_created': datetime.datetime(2022, 7, 19, 5, 44, 14, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 924336396, 'comment_body': ""Yeah , I had thought of improving this later on . We can get the multiplier by using the `dir` function passing `cdir` along as the parameter.\r\nThough I caught some improvements in `pow._eval_nseries` as I was looking into few examples .So series from both directions for inverse functions at branch cuts are mostly same except in some cases , `acosh` being one of them ! Log rewrites show that too\r\n```\r\n>>> acosh(x + 1).rewrite(log).series(x, 0, 4, cdir = 1)\r\n-sqrt(2)*I*sqrt(-x) - sqrt(2)*I*(-x)**(3/2)/12 - 3*sqrt(2)*I*(-x)**(5/2)/160 - 5*sqrt(2)*I*(-x)**(7/2)/896 + O(x**4)\r\n>>> acosh(x + 1).rewrite(log).series(x, 0, 4, cdir = -1)\r\n-sqrt(2)*I*sqrt(-x) - sqrt(2)*I*(-x)**(3/2)/12 - 3*sqrt(2)*I*(-x)**(5/2)/160 - 5*sqrt(2)*I*(-x)**(7/2)/896 + O(x**4)\r\n>>> # expected \r\nsqrt(2)*I*sqrt(-x) + sqrt(2)*I*(-x)**(3/2)/12 + 3*sqrt(2)*I*(-x)**(5/2)/160 + 5*sqrt(2)*I*(-x)**(7/2)/896 + O(x**4)\r\n\r\n\r\n```\r\nBut what we get from both sides is same . And now that `acos(x + 1).series(x)` is same from both sides . It tells me that \r\nseries for `sqrt(x)/sqrt(-x)` is at fault (from one of the direction)\r\n```\r\n>>> expr = sqrt(x)/sqrt(-x)\r\n>>> expr._eval_nseries(x, 4, None, cdir = 1)\r\n-I\r\n>>> expr._eval_nseries(x, 4, None, cdir = -1)   # expected I or I + O(x**4)\r\n-I\r\n```\r\nThis can be fixed through\r\n```\r\n--- a/sympy/core/power.py\r\n+++ b/sympy/core/power.py\r\n@@ -1692,7 +1692,13 @@ def _eval_nseries(self, x, n, logx, cdir=0):\r\n             return Order(x**(m*e), x)\r\n\r\n         if g.is_zero:\r\n-            r = f**e\r\n+            from sympy import im\r\n+            ndir = f.dir(x, cdir=cdir)\r\n+            if im(ndir).is_negative:\r\n+                r = - f**e\r\n+            else:\r\n+                r = f**e\r\n```\r\nAfter making the change we get the correct result !\r\n\r\nThough I'll make use of `dir` function to get the multiplier here , I'll include the change in the power.py too , to address the issue caught !\r\n\r\n**EDIT1:** Some statements written above might be wrong , will be addressing them soon ."", 'comment_created': datetime.datetime(2022, 7, 19, 10, 34, 58, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 926583805, 'comment_body': 'We could probably use the private `_eval_nseries` as the arguments have been sympified.', 'comment_created': datetime.datetime(2022, 7, 21, 11, 53, 47, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 926589036, 'comment_body': 'Sure , will try it out ! Yeah that might be a better option here .', 'comment_created': datetime.datetime(2022, 7, 21, 12, 0, 13, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 926632693, 'comment_body': 'When does logx have t? ', 'comment_created': datetime.datetime(2022, 7, 21, 12, 47, 29, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 926689944, 'comment_body': ""No it doesn't and also there's no use of `_logx` now , this check would have come in play if we would have not used the sustitution `z.subs(x, cdir*t)` and whenver `log(x)` would be `x` rather than other symbols like `p`. Now that you've pointed this out , i'll check if there are cases which we won't really need after the substitution "", 'comment_created': datetime.datetime(2022, 7, 21, 13, 40, 35, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 926732326, 'comment_body': ""In the last two commits , I've removed whatever code wouldn't come into play and also added some spacing to keep blocks responsible for similar operations together as the code overall was looking to clumsy !"", 'comment_created': datetime.datetime(2022, 7, 21, 14, 15, 38, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 928124320, 'comment_body': 'Not all errors should be caught.', 'comment_created': datetime.datetime(2022, 7, 23, 13, 33, 42, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 928124796, 'comment_body': 'Yeah I had changed it to (`ValueError, NotImplementedError, PoleError`) in the latest commit ! Not sure if you missed that , maybe you could refresh ?', 'comment_created': datetime.datetime(2022, 7, 23, 13, 39, 4, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 928554726, 'comment_body': 'Where does the order term of `co1` come from? Is it the order term of `p`? What if that is removed from the loop:\r\n\r\n    for term in Add.make_args(p.removeO()):', 'comment_created': datetime.datetime(2022, 7, 25, 7, 32, 52, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 928568471, 'comment_body': 'Storing twice to a dict (and also loading twice from) is inefficient. A temporary storage is preferable:\r\n\r\n                _ = terms.get(ex, S.Zero) + coeff*pk[ex]\r\n                terms[ex] = _.nsimplify()', 'comment_created': datetime.datetime(2022, 7, 25, 7, 49, 21, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 928630583, 'comment_body': 'Yes it does look like that ! Will make the change.', 'comment_created': datetime.datetime(2022, 7, 25, 8, 56, 53, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 1206885958, 'comment_body': 'This use of `nsimplify` here causes wrong results (see gh-25175)', 'comment_created': datetime.datetime(2023, 5, 26, 14, 37, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}]","[{'commit_sha': '5dcadcff8b4a401bc9d9e89d886fcc18b67e4b53', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}, {'commit_sha': '631b4ab9b2a06c15a172ff4ba42477f189f8a68d', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}, {'commit_sha': '242bd32f81299c80c6f7739dbd86c0caf35d3cfd', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}, {'commit_sha': '1ddcc74af8851c08af27a0e1bd91430afe461be6', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}]",Anutosh Bhat,87052487,,User,,45,,25,34
1009725347,[GSoC PR4.1] Implemented/Fixed a few series methods for bessel functions ,"<!-- Your title above should be a short description of what
was changed. Do not include the issue number in the title. -->

#### References to other Issues or PRs
<!-- If this pull request fixes an issue, write ""Fixes #NNNN"" in that exact
format, e.g. ""Fixes #1234"" (see
https://tinyurl.com/auto-closing for more information). Also, please
write a comment on that issue linking back to this pull request once it is
open. -->
Fixes #22911 
Fixes #6052
Fixes #6350
Fixes #19154
Fixes #14196
Fixes #22334

#### Brief description of what is fixed or changed
As of now , the pr implements leading term method for the besseli function and fixes series expansions for bessely function. The bessely function on master if neglecting few terms . For eg
```
>>> # On master
>>> bessely(1, x).series(x, 0, 3)  # first term -2/(pi*x) is missing
x*(log(x)/pi - log(2)/pi - (1 - 2*EulerGamma)/(2*pi)) + O(x**3*log(x))
>>>
>>> bessely(2, x).series(x, 0, 3) # second term -1/pi  is missing
-4/(pi*x**2) + x**2*(log(x)/(4*pi) - log(2)/(4*pi) - (3/2 - 2*EulerGamma)/(8*pi)) + O(x**3*log(x))
>>>
>>> bessely(3, x).series(x, 0, 3)   # Second term is wrong and also missing 3rd term x/(4*pi)
-16/(pi*x**3) - 4/(pi*x) + O(x**3*(-log(x) + log(2)))
>>>
>>> # On branch
>>> bessely(1, x).series(x, 0, 3)
-2/(pi*x) + x*(log(x)/pi - log(2)/pi - (1 - 2*EulerGamma)/(2*pi)) + O(x**3*log(x))
>>> bessely(2, x).series(x, 0, 3)
-4/(pi*x**2) - 1/pi + x**2*(log(x)/(4*pi) - log(2)/(4*pi) - (3/2 - 2*EulerGamma)/(8*pi)) + O(x**3*log(x))
>>> bessely(3, x).series(x, 0, 3)
-16/(pi*x**3) - 2/(pi*x) - x/(4*pi) + O(x**3*(-log(x) + log(2)))
```

#### Other comments
References for asymptotic approximations added in the leading term methods
1) besselj - [link](https://functions.wolfram.com/Bessel-TypeFunctions/BesselJ/06/02/02/02/0005/)
2) bessely - [link](https://functions.wolfram.com/Bessel-TypeFunctions/BesselY/06/02/02/02/0006/)
3) besseli - [link](https://functions.wolfram.com/Bessel-TypeFunctions/BesselI/06/02/02/02/0006/)
4) besselk - [link](https://functions.wolfram.com/Bessel-TypeFunctions/BesselK/06/02/01/02/0005/)

References for nseries expansions for bessel functions
1) besselj - [link](https://functions.wolfram.com/Bessel-TypeFunctions/BesselJ/06/01/04/01/01/0003/)
2) bessely - [link](https://functions.wolfram.com/Bessel-TypeFunctions/BesselY/06/01/04/01/02/0008/)
3) besseli - [link](https://functions.wolfram.com/Bessel-TypeFunctions/BesselI/06/01/04/01/01/0003/)
4) besselk - [link](https://functions.wolfram.com/Bessel-TypeFunctions/BesselK/06/01/04/01/02/0008/)


#### Release Notes

<!-- Write the release notes for this release below between the BEGIN and END
statements. The basic format is a bulleted list with the name of the subpackage
and the release note for this PR. For example:

* solvers
  * Added a new solver for logarithmic equations.

* functions
  * Fixed a bug with log of integers.

or if no release note(s) should be included use:

NO ENTRY

See https://github.com/sympy/sympy/wiki/Writing-Release-Notes for more
information on how to write release notes. The bot will check your release
notes automatically to see if they are formatted correctly. -->

<!-- BEGIN RELEASE NOTES -->
* series
  * Fixed series expansions for bessely functions where terms from series were missing.
  * Implemented leading term and nseries methods for besseli and besselk functions.
  * Refactored `mrv_leadterm` function of gruntz.py to use the leadterm method rather than the calculate_series method , which can further be deprecated.
  * Implemented use cases of logx parameter in leading term methods of Ci and polygamma function.
  * Fixed errors arising for limits at infinites other than oo/-oo.
  * Removed calculate_series function from gruntz.
  * Removed compute_leading_term function's usage through the codebase.
  * Fixed few limits at infinites with respect to harmonic functions.
<!-- END RELEASE NOTES -->
",True,23844,https://api.github.com/repos/sympy/sympy/pulls/23844,https://github.com/sympy/sympy/pull/23844,closed,487,108,23,7,20,88,2,0,"[{'name': 'series'}, {'name': 'GSoC'}]",2022-07-27 14:14:45+00:00,2022-09-06 10:31:47+00:00,3529022.0,"40 days, 20:17:02","[{'comment_id': 933508240, 'comment_body': 'What if `nu` is zero?', 'comment_created': datetime.datetime(2022, 7, 29, 18, 9, 14, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 933915108, 'comment_body': 'Nothing much actually. The series is given by \r\n<img width=""634"" alt=""image"" src=""https://user-images.githubusercontent.com/87052487/182006733-6f64a107-a38f-40c5-b96d-5dc12b14ed0e.png"">\r\nAnd `nu` being zero only means that we won\'t be able to get any terms out of the second summation cause the upper limit (nu - 1 falls to -1 then) and other things remain the same. So we get our answers as we would expect them to be\r\n```\r\n>>> bessely(0, x).series(x, 0, 3)\r\n2*EulerGamma/pi - 2*log(2)/pi + 2*log(x)/pi + x**2*(-log(x)/(2*pi) + (2 - 2*EulerGamma)/(4*pi) + log(2)/(2*pi)) + O(x**3*log(x))\r\n>>> bessely(0, sin(x)).series(x, 0, 3)\r\n2*EulerGamma/pi - 2*log(2)/pi + 2*log(x)/pi + x**2*(-log(x)/(2*pi) - 1/(3*pi) + (2 - 2*EulerGamma)/(4*pi) + log(2)/(2*pi)) + O(x**3*log(x))\r\n```\r\n', 'comment_created': datetime.datetime(2022, 7, 31, 2, 23, 39, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 933935625, 'comment_body': 'So could we have `nu >= 0` here? ', 'comment_created': datetime.datetime(2022, 7, 31, 6, 50, 31, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 933937014, 'comment_body': ""No right , when `nu = 0`, we would have something like\r\n```\r\n>>> Sum(f(x), (x, 0, -1)).doit()\r\n```\r\nAnd like we don't want this , when `nu = 0` we don't expect it to enter the for loop which calculates the second summation, it should just skip that block. Otherwise we land up with something like\r\n```\r\n>>> bessely(0, x).series(x, 0, 3)\r\nzoo + O(x**3*log(x))\r\n```"", 'comment_created': datetime.datetime(2022, 7, 31, 7, 2, 52, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 933939954, 'comment_body': '> it should just skip that block. \r\n\r\nWould we get the correct result for `nu == 0` if the sum block is skipped?', 'comment_created': datetime.datetime(2022, 7, 31, 7, 28, 50, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 933945696, 'comment_body': 'Yes !', 'comment_created': datetime.datetime(2022, 7, 31, 8, 11, 30, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 943165390, 'comment_body': 'Can e be positive if x is not in arg.free_symbols?', 'comment_created': datetime.datetime(2022, 8, 11, 7, 15, 35, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 943167156, 'comment_body': 'Is there a reference for this expression? Is it valid in all directions? ', 'comment_created': datetime.datetime(2022, 8, 11, 7, 17, 57, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 944059209, 'comment_body': ""Yes, It works for all `abs(z)-> oo` . I'll make sure to add references for all asymptotic approximations used in the OP."", 'comment_created': datetime.datetime(2022, 8, 12, 1, 54, 35, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 944070082, 'comment_body': ""No it can't , I thought something like leading terms calls of `besselj(1, 1/y)` or `besselj(1,  y)` would end up having `e` as `1 ` for some reason but I see it will be 0 , which means I need to change the order of evaluation a bit .  I'll make the relevant change .\r\n\r\nActually we won't need to explicitly handle them the `super(besselj, self)._eval_as_leading_term` would take care of that "", 'comment_created': datetime.datetime(2022, 8, 12, 2, 30, 35, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 944153072, 'comment_body': 'Can you give a reference for this expansion? ', 'comment_created': datetime.datetime(2022, 8, 12, 6, 32, 32, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 944197537, 'comment_body': ""I've added references for all bessel functions in the pr template (https://github.com/sympy/sympy/pull/23844#issue-1319631793) . So you can refer that if you want or could go through this [link](https://functions.wolfram.com/Bessel-TypeFunctions/BesselJ/06/02/02/02/0005/)."", 'comment_created': datetime.datetime(2022, 8, 12, 7, 42, 54, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 944232598, 'comment_body': ""There are two expressions in Wolfram. It looks like one is for the lower and the other one for the upper half-plane. I'm not sure either one of those will work for `x -> oo`. DLMF and Wikipedia would be better references."", 'comment_created': datetime.datetime(2022, 8, 12, 8, 27, 51, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 944259970, 'comment_body': ""Yeah I've seen that wolfram sort of give 2 to 3 expressions for such cases and the first one in all cases is what we want . I had tested out limits of some expressions involving `besselj` to see if everything was in place and I didn't see anything go wrong as of now but I'll surely cross check with wikipedia and DLMF"", 'comment_created': datetime.datetime(2022, 8, 12, 9, 0, 26, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 944333841, 'comment_body': ""It's also good to have references and definitions etc in the code and docs rather than in a PR."", 'comment_created': datetime.datetime(2022, 8, 12, 10, 33, 27, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 945022819, 'comment_body': ""That's correct , specially in case of bessel functions where almost everything related to series expansions and limits has been implemented through some reference from wolfram etc."", 'comment_created': datetime.datetime(2022, 8, 13, 2, 25, 46, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 945092299, 'comment_body': '> DLMF and Wikipedia would be better references.\r\n\r\nEven Wolfram returns more than one expression based on `arg(z)` , just like what wolfram does.\r\n<img width=""297"" alt=""image"" src=""https://user-images.githubusercontent.com/87052487/184471729-a7973d79-a05b-4439-8fec-04e11fd1145c.png"">\r\n\r\n Actually after reading through the text, I realize that the answers/outputs won\'t really change even if we change expressions. It\'s just that based on `arg(z)` we can improve the approximations furthur. For eg , let\'s check the limit we\'re trying to fix through both expressions we have.\r\n\r\n<img width=""373"" alt=""image"" src=""https://user-images.githubusercontent.com/87052487/184471818-b128e015-d5bb-4524-bc1e-ea662b40ec55.png"">\r\n\r\nWe get correct answers from both expressions.\r\n```\r\n>>> limit(besseli(1, 3 *x)/(x *besseli(1, x)**3), x , oo)\r\n2*sqrt(3)*pi/3\r\n>>> limit(besseli(1, 3 *x)/(x *besseli(1, x)**3), x , -oo)\r\n-2*sqrt(3)*pi/3\r\n```\r\nSo after going through some resources I realize that for the output both expressions would do but in different cases 1 expression is a better approximation than the other one\r\n\r\n', 'comment_created': datetime.datetime(2022, 8, 13, 6, 32, 51, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 945093126, 'comment_body': 'So after implementing (https://github.com/sympy/sympy/pull/23844#issuecomment-1213730451)  I guess we could try implementing two expressions for the same based on cdir (we would either come across cdir as `1` or `-1`) .', 'comment_created': datetime.datetime(2022, 8, 13, 6, 42, 29, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 945109515, 'comment_body': 'The failing tests are unrelated I think . These tests seem to fail on every pull request as of now .', 'comment_created': datetime.datetime(2022, 8, 13, 7, 52, 3, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 945219091, 'comment_body': ""> So after implementing ([#23844 (comment)](https://github.com/sympy/sympy/pull/23844#issuecomment-1213730451)) I guess we could try implementing two expressions for the same based on cdir (we would either come across cdir as `1` or `-1`) .\r\n\r\nI was wrong here, as once we've implemented the comment below , we would be transforming all infinities to `S.Infinity` and dealing with the limit as x tends to `oo` . \r\nHence now something like `limit(besselj(1, x), x, I*oo)` would enter the `besselj.as_leading_term()` block with a `cdir = 1`(as `I*oo` was transformed to `oo` with `cdir = -1` and `oo` will then be transformed to `0` with `cdir = -(-1)` ) .\r\n\r\nHence we won't be needing 2 or 3 expressions . We would just need the expression which satisfies `arg(z) = 0` which represents `x` tending to `S.Infinity` . And that's what is already implemented , hence I am quite certain we can stick to these approximations now . We can also check for limits of all bessel functions at all kinds of infinties\r\n```\r\n>>> limit(besselj(1, x), x, oo)\r\n0\r\n>>> limit(besselj(1, x), x, -oo)\r\n0\r\n>>> limit(besselj(1, x), x, I*oo)\r\noo*I\r\n>>> limit(besselj(1, x), x, -I*oo)\r\n-oo*I\r\n>>> limit(bessely(1, x), x, oo)\r\n0\r\n>>> limit(bessely(1, x), x, -oo)\r\n0\r\n>>> limit(bessely(1, x), x, I*oo)\r\n-oo*I*sign(I**(3/2))\r\n>>> limit(bessely(1, x), x, I*oo).n()\r\n-oo\r\n>>> limit(bessely(1, x), x, -I*oo)\r\n-oo*I*sign(1/sqrt(-I))\r\n>>> limit(bessely(1, x), x, -I*oo).n()\r\n-oo\r\n>>> limit(besseli(1, x), x, oo)\r\noo\r\n>>> limit(besseli(1, x), x, -oo)\r\n-oo\r\n>>> limit(besseli(1, x), x, I*oo)\r\n0\r\n>>> limit(besseli(1, x), x, -I*oo)\r\n0\r\n>>> limit(besselk(1, x), x, oo)\r\n0\r\n>>> limit(besselk(1, x), x, -oo)\r\n-oo*I\r\n>>> limit(besselk(1, x), x, I*oo)\r\n0\r\n>>> limit(besselk(1, x), x, -I*oo)\r\n0\r\n```\r\nAll results have been verified from wolfram . There's just this one limit which `limit(bessely(1, x), x, I*oo)` which wolfram straightaway approximates to `-oo` but the answer we get here through `gruntz` isn't wrong . We just might need to use `.n()` to go one step further with our approximation . I guess I should be adding this as a test in `test_limits.py`"", 'comment_created': datetime.datetime(2022, 8, 14, 2, 28, 11, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 945233595, 'comment_body': 'simplify() is fairly expensive. Would a cheaper method suffice? ', 'comment_created': datetime.datetime(2022, 8, 14, 5, 58, 26, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 945269793, 'comment_body': 'Yeah I put that just in case ..... we might not be needing it as of now though as we currently only supported fixed points and not variables ones through the following\r\n```\r\n        if(z0.has(z)):\r\n            raise NotImplementedError(""Limits approaching a variable point are""\r\n                    "" not supported (%s -> %s)"" % (z, z0))\r\n```\r\nSo yeah as we might not need a simplification for that as of now , I\'ll get rid of the `simplify` there.', 'comment_created': datetime.datetime(2022, 8, 14, 10, 58, 5, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 949895220, 'comment_body': 'n=1 may not suffice for the leading term in general. ', 'comment_created': datetime.datetime(2022, 8, 19, 7, 39, 20, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 950651179, 'comment_body': ""I've made some changes , which would work as per what we want I guess . Anyways the `compute_leading_term` function was supposed to be deprecated as per #21843 , hence I've added deprecation warnings for the same . I've also removed it's usage completely from the code base ."", 'comment_created': datetime.datetime(2022, 8, 20, 5, 16, 46, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 950651559, 'comment_body': ""I've now added links/references for the expansions used in the code , hence resolving this conversation ."", 'comment_created': datetime.datetime(2022, 8, 20, 5, 21, 23, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 950655866, 'comment_body': 'This does not seem agree with Wikipedia. It looks like wolfram has a piecewise expression and this is only one of its parts.', 'comment_created': datetime.datetime(2022, 8, 20, 6, 13, 6, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 950661124, 'comment_body': 'Yeah correct but the code ensures the we would only need one branch for all bessel functions and that is the branch which includes `arg(z) == 0` . I had explained this in a comment of mine (https://github.com/sympy/sympy/pull/23844#discussion_r945219091) . As we now use \r\n```\r\n        if z0.is_infinite:\r\n            cdir = sign(z0)\r\n            cdir = cdir/abs(cdir)\r\n            e = e.subs(z, cdir*z)\r\n            dir = ""-""\r\n            z0 = S.Infinity\r\n```\r\nWe don\'t need to care about different branches where `abs(z) -> oo` , we just need to care about `z -> oo` which is given by `arg(z) == 0` (as `arg(oo) == 0`) . Hence expression for any `abs(z) -> oo`  will be transformed to some expression such that `z -> oo` and then enter the `_eval_as_leading_term` block with a `cdir = 1` . Hence we just need the branch handling `oo`. I\'ve added tests for all kind of infinities and everything works perfectly fine .\r\n```\r\n    assert limit(besselj(1, x), x, oo) == 0\r\n    assert limit(besselj(1, x), x, -oo) == 0\r\n    assert limit(besselj(1, x), x, I*oo) == oo*I\r\n    assert limit(besselj(1, x), x, -I*oo) == -oo*I\r\n```', 'comment_created': datetime.datetime(2022, 8, 20, 7, 12, 4, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 950661217, 'comment_body': 'Therefore similarly for all `bessel` functions , we just need to make sure we correctly add the branch including `z->oo` or `arg(z) == 0`', 'comment_created': datetime.datetime(2022, 8, 20, 7, 13, 6, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 950669315, 'comment_body': 'Are you sure that this expression agrees with that of [Wikipedia](https://en.wikipedia.org/wiki/Bessel_function#Asymptotic_forms) as `z -> oo`?', 'comment_created': datetime.datetime(2022, 8, 20, 8, 39, 12, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 950694512, 'comment_body': 'Yeah .... though we can go for something simpler or rather similar to what wikipedia says in terms of `cos`\r\n<img width=""444"" alt=""image"" src=""https://user-images.githubusercontent.com/87052487/185747590-bf8f553c-aa59-4038-9493-25d22916c963.png"">\r\n\r\nWolfram presents the asymptotic approximation in two forms\r\n<img width=""297"" alt=""image"" src=""https://user-images.githubusercontent.com/87052487/185747626-3c24766a-7f1c-4450-b3f8-0d00b6e31db5.png"">\r\n\r\nAnd like we can find the exact corresponding approximation based on trigonometric functions . \r\n\r\n<img width=""234"" alt=""image"" src=""https://user-images.githubusercontent.com/87052487/185747666-c8e7a0ca-8ec6-4892-ab92-9c78392f48b0.png"">\r\n\r\nI see that the `cos` form is more established than the other one in form of exponentials. So yeah for the one going to `oo`, we\'ll be using the first one of this . I said well established , because I could find a couple references for proofs of this form in an e-book and also on maths stackoverflow . Here\'s the [proof](https://math.stackexchange.com/questions/177118/about-the-asymptotic-formula-of-bessel-function) for the approximation. Though as I said at the end both are corresponding forms .I tried limits from both and I get the same results \r\n```\r\n>>> limit(besselj(1, x), x, oo)\r\n0\r\n>>> limit(besselj(1, x), x, I*oo)\r\noo*I\r\n>>> limit(besselj(2, x), x, I*oo)\r\n-oo\r\n>>> limit(besselj(3, x), x, I*oo)\r\n-oo*I\r\n>>> limit(besselj(4, x), x, I*oo)\r\noo\r\n>>> limit(besselj(5, x), x, I*oo)\r\noo*I\r\n```\r\n\r\n', 'comment_created': datetime.datetime(2022, 8, 20, 13, 14, 54, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 950694790, 'comment_body': ""I am fully sure about the modified ones ( because these don't really have trigo forms for their approximations) but if we want to make it simpler or according to what wolfram says (using `sin` and `cos`) we can use this diff\r\n```\r\n--- a/sympy/functions/special/bessel.py\r\n+++ b/sympy/functions/special/bessel.py\r\n@@ -234,8 +234,8 @@ def _eval_as_leading_term(self, x, logx=None, cdir=0):\r\n         elif e.is_negative:\r\n             # Refer https://functions.wolfram.com/Bessel-TypeFunctions/BesselJ/06/02/02/02/0005/\r\n             # for more information on asymptotic approximation of besselj function.\r\n-            return sqrt(2)*(-(-1)**(S(3)/4)*I**nu*exp(-I*pi*nu + I*z) + \\\r\n-                    (-1)**(S(1)/4)*I**nu*exp(-I*z))/(2*sqrt(pi)*sqrt(z))\r\n+            return sqrt(2)*cos(z - pi*(2*nu + 1)/4)/sqrt(pi*z)\r\n\r\n         return super(besselj, self)._eval_as_leading_term(x, logx, cdir)\r\n\r\n@@ -365,7 +365,7 @@ def _eval_as_leading_term(self, x, logx=None, cdir=0):\r\n         elif e.is_negative:\r\n             # Refer https://functions.wolfram.com/Bessel-TypeFunctions/BesselY/06/02/02/02/0006/\r\n             # for more information on asymptotic approximation of bessely function\r\n-            return (-I*exp(-I*pi*nu/2 + I*z - I*pi/4) + I*exp(I*pi*nu/2 - I*z + I*pi/4))/sqrt(2*pi*z)\r\n+            return sqrt(2)*sin(z - pi*nu/2 - pi/4)/sqrt(pi*z)\r\n\r\n"", 'comment_created': datetime.datetime(2022, 8, 20, 13, 17, 34, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 950781963, 'comment_body': 'Yupp , the expansions for `besselj` and `besseli` based on sin and cos are established as shown in Abramowitz and Stegun pg 364\r\n\r\n<img width=""333"" alt=""image"" src=""https://user-images.githubusercontent.com/87052487/185774528-e9526d55-e3dd-4cc7-a45a-dd8d1700fdd6.png"">\r\n\r\nSo probably we can stick with these ', 'comment_created': datetime.datetime(2022, 8, 21, 3, 46, 25, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 950782267, 'comment_body': 'And for the modified bessel functions , these are also established(on pg 377 and 378) in forms of **exponentials** , so our current implementation is perfectly correct for these\r\n<img width=""381"" alt=""image"" src=""https://user-images.githubusercontent.com/87052487/185774617-9a1a07bf-a2c6-4b61-aa19-15dbe39a2cf2.png"">\r\n\r\n<img width=""364"" alt=""image"" src=""https://user-images.githubusercontent.com/87052487/185774626-b35ef75f-2ad5-4c58-8686-44d891c18737.png"">\r\n\r\n', 'comment_created': datetime.datetime(2022, 8, 21, 3, 51, 38, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 950786294, 'comment_body': 'I like the expressions of Abramowitz and Stegun because they are obviously real for real z and nu. It is not clear that Wolframs expression have that property. ', 'comment_created': datetime.datetime(2022, 8, 21, 4, 49, 47, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 950788680, 'comment_body': 'Yeah and I realize that now we we\'re dealing with infinites as \r\n```\r\n        if z0.is_infinite:\r\n            cdir = sign(z0)\r\n            cdir = cdir/abs(cdir)\r\n            e = e.subs(z, cdir*z)\r\n            dir = ""-""\r\n            z0 = S.Infinity\r\n```\r\nWe only need to take care of `z -> oo` and not `abs(z) -> oo` . Hence one of your comments on the gitter channel can now we properly addressed. For asymptotic expansion of besseli you said\r\n> I*exp(I*pi*nu - z) may be needed for some expansions if the dominating term is canceled but it does not seem to be a part of the leading term.\r\n\r\nThis was important for other infinites but not for `oo`, hence all limits shall now pass if we go with what `Abramowitz and Stegun ` say rather than what `Wolfram` says \r\n```\r\n         elif e.is_negative:\r\n             # Refer Abramowitz and Stegun 1965, p. 377 for more information on\r\n             # asymptotic approximation of besseli function.\r\n-            return (exp(z) + I*exp(I*pi*nu - z))/sqrt(2*pi*z)\r\n+            return exp(z)/sqrt(2*pi*z)\r\n```\r\nThis should be good enough \r\n\r\n\r\n', 'comment_created': datetime.datetime(2022, 8, 21, 5, 21, 25, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 950789817, 'comment_body': ""I am quite satisfied with all 4 asymptotic expansions used (we have references for all) and particularly all expressions are built around `z->oo` . Let me know what you think !\r\n\r\nI would also like to know if you can help me out with getting the values of something like `bessel(n, I*oo)`, where n is integer. \r\nFor eg\r\n```\r\n>>> limit(bessely(1, x), x, I*oo)\r\nbessely(1, oo*I)\r\n>>> limit(bessely(2, x), x, I*oo)\r\nbessely(2, oo*I)\r\n```\r\nThese answers aren't wrong but if we could evaluate them then it would obviously be better .\r\nFor eg checkout `besselj`, it forms a repeated chain\r\n```\r\n>>> besselj(1, I*oo)\r\noo*I\r\n>>> besselj(2, I*oo)\r\n-oo\r\n>>> besselj(3, I*oo)\r\n-oo*I\r\n>>> besselj(4, I*oo)\r\noo\r\n>>> besselj(5, I*oo)\r\noo*I\r\n>>> # repeats\r\n```\r\nThis is made possible through \r\n```\r\n            newz = z.extract_multiplicatively(I)\r\n            if newz:  # NOTE we don't want to change the function if z==0\r\n                return I**(-nu)*besselj(nu, -newz)\r\n```\r\nIt seems `bessely` also forms such a cycle and repeats after where 4 integers. Although I have been trying to find some reference for this like the ones we have for `besselj`, I fail to find one for `bessely`.\r\n"", 'comment_created': datetime.datetime(2022, 8, 21, 5, 37, 19, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 950814289, 'comment_body': 'For `bessely`, it might be possible to use https://dlmf.nist.gov/10.17.E4  ', 'comment_created': datetime.datetime(2022, 8, 21, 9, 18, 38, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 951016924, 'comment_body': 'We might not need that though, like the link points out a proper asymptotic series which can be implemented . In this case for leading term a good asymptotic approximation would suffice I would say . And if we analyze this a bit , `aseries` for all `bessel` functions , will be of the form `exp(z)*(Sum(f(k, nu), (k, 0, oo)))` . \r\n\r\nAnd like this was one of the main reasons we switched from 1st approach to 2nd approach ( approaches described below)\r\n\r\nApproach 1) Using `aseries` and `gruntz` but however we try to mold it , this block in `mrv_leadterm` will raise a `PoleError` due to `exp(1/x)`\r\n```\r\n    w = Dummy(""w"", positive=True)\r\n    f, logw = rewrite(exps, Omega, x, w)\r\n    try:\r\n        lt = f.leadterm(w, logx=logw)\r\n    except (NotImplementedError, PoleError, ValueError):\r\n        n0 = 1\r\n        _series = Order(1)\r\n        incr = S.One\r\n        while _series.is_Order:\r\n            _series = f._eval_nseries(w, n=n0+incr, logx=logw)\r\n            incr *= 2\r\n        series = _series.expand().removeO()\r\n        try:\r\n            lt = series.leadterm(w, logx=logw)\r\n        except (NotImplementedError, PoleError, ValueError):\r\n            lt = f.as_coeff_exponent(w)\r\n            if lt[0].has(w):\r\n                base = f.as_base_exp()[0].as_coeff_exponent(w)\r\n                ex = f.as_base_exp()[1]\r\n                lt = (base[0]**ex, base[1]*ex)\r\n    return (lt[0].subs(log(w), logw), lt[1])\r\n```\r\n \r\nApproach 2) Using an asymptotic approximation in leading term and getting the result through this block in `limits.py` (last part)\r\n```\r\n        try:\r\n            coeff, ex = newe.leadterm(z, cdir=cdir)\r\n        except (ValueError, NotImplementedError, PoleError):\r\n            # The NotImplementedError catching is for custom functions\r\n            from sympy.simplify.powsimp import powsimp\r\n            e = powsimp(e)\r\n            if e.is_Pow:\r\n                r = self.pow_heuristics(e)\r\n                if r is not None:\r\n                    return r\r\n            try:\r\n                coeff = newe.as_leading_term(z, cdir=cdir)\r\n                if coeff != newe and coeff.has(exp):\r\n                    return gruntz(coeff, z, 0, ""-"" if re(cdir).is_negative else ""+"")\r\n            except (ValueError, NotImplementedError, PoleError):\r\n                pass\r\n```\r\nSo like `aseries` for let\'s take `besseli` looks something like this \r\n<img width=""190"" alt=""image"" src=""https://user-images.githubusercontent.com/87052487/185842556-3997650f-e298-46a3-b275-b18d6b2e60e7.png"">\r\n\r\nNow implementing this isn\'t like to tedious or something and we can get it through \r\n```\r\n    def _eval_aseries(self, n, args0, x, logx):\r\n        from sympy.series.order import Order\r\n        point = args0[1]\r\n        nu, z = self.args\r\n\r\n        def polynomial_coeff(n, v):\r\n            if n == 0:\r\n                return 1\r\n            else:\r\n                res = (-1)**n*cos(pi*v)*(gamma(n + S.Half + v)*\r\n                    gamma(n + S.Half - v))/(pi* 2**n *gamma(n + 1))\r\n                return res\r\n\r\n        # Expansion at oo\r\n        if point is S.Infinity:\r\n            try:\r\n                _, ex = z.subs(x, 1/x).leadterm(x)\r\n            except (ValueError, NotImplementedError):\r\n                return self\r\n\r\n            if exp.is_positive and nu.is_integer:\r\n                newn = ceiling(n/ex)                \r\n                series = []\r\n\r\n                for k in range(0, (newn + 1)//2):\r\n                    term = polynomial_coeff(k, nu)/z**k\r\n                    if k% 2 == 0:\r\n                        series.append(term/sqrt(2*pi*z))\r\n                    else:\r\n                        series.append(-term/sqrt(2*pi*z))\r\n                series.append(Order(1/z**n, x))\r\n                return exp(z)*(Add(*series))\r\n\r\n        # All other points may not be handled as of now\r\n        return super(self)._eval_aseries(n, args0, x, logx)\r\n```\r\n\r\nBut it won\'t be of much use to us and we won\'t be able to solve any limit issues mentioned in the pr template through it .\r\nNow the link you\'ve pointed out\r\n<img width=""368"" alt=""image"" src=""https://user-images.githubusercontent.com/87052487/185842872-3992edb5-7466-47bb-8516-154c4ee3acd6.png"">\r\n\r\nIs just a breakdown of the `exp(z)` into `sin` and `cos` . Hence we see a form like `sin(z)*Summation1 + cos(z)*Summation2` . At the end it follows the form of aseries for a bessel function which is `exp(z)*(Sum(f(k, nu), (k, 0, oo)))` . \r\nHence now I\'m afraid that even if we implement this , we would follow the same footsteps as we\'ve seen with `exp(1/x)` and end up with a `PoleError` due to `sin(1/x)` or `cos(1/x)` . I\'m quite sure that would be the case eventually because of \r\n```\r\n>>> sin(1/x)._eval_nseries(x, 6, None)\r\nTraceback (most recent call last):\r\n..............\r\nsympy.core.function.PoleError: Cannot expand sin(1/x) around 0\r\n>>>\r\n>>> cos(1/x)._eval_nseries(x, 5, None)\r\nTraceback (most recent call last):\r\n..............\r\nsympy.core.function.PoleError: Cannot expand cos(1/x) around 0\r\n\r\n\r\n', 'comment_created': datetime.datetime(2022, 8, 22, 5, 6, 54, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 951017684, 'comment_body': ""Hence I don't think that we would need a full fledged series for solving any of the limits related to bessel functions at infinities . A good asymptotic approximation would suffice ."", 'comment_created': datetime.datetime(2022, 8, 22, 5, 8, 51, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 951040520, 'comment_body': '> I fail to find one for bessely.\r\n\r\nI gathered that this was referring to the limits and I was hoping that the expansion in DLMF could be used to compute the limits of `bessely` at `I*oo` etc. The first term of the series should probably suffice. I did not expect that the whole series should be implemented. So the question is, what is the limit of `sin(omega)` when `z -> I*oo`.', 'comment_created': datetime.datetime(2022, 8, 22, 6, 1, 14, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 951044013, 'comment_body': ""Ahh sorry for missing out on hint there ! Thanks for pointing this , makes more sense to me how we could make use of `sin` here . I'll try out few things in the direction you're suggesting ! "", 'comment_created': datetime.datetime(2022, 8, 22, 6, 8, 11, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 951189520, 'comment_body': 'Not sure , it will help us out . Like if we apply this diff , based on the first term of the series you mentioned.\r\n```\r\n+++ b/sympy/functions/special/bessel.py\r\n@@ -364,7 +364,7 @@ def _eval_as_leading_term(self, x, logx=None, cdir=0):\r\n         elif e.is_negative:\r\n             # Refer Abramowitz and Stegun 1965, p. 364 for more information on\r\n             # asymptotic approximation of bessely function.\r\n-            return sqrt(2)*sin(z - pi*nu/2 - pi/4)/sqrt(pi*z)\r\n+           return sqrt(2)*(-sin(pi*nu/2 - z + pi/4) + 3*cos(pi*nu/2 - z + pi/4)/(8*z))*sqrt(1/z)/sqrt(pi)\r\n```\r\nNow what happens is in limits.py , first the execution goes to line `coeff, ex = newe.leadterm(z, cdir=cdir)` which obviously gives a `ValueError`\r\n```\r\n        try:\r\n            coeff, ex = newe.leadterm(z, cdir=cdir)\r\n        except (ValueError, NotImplementedError, PoleError):\r\n            e = powsimp(e)\r\n            if e.is_Pow:\r\n                r = self.pow_heuristics(e)\r\n                if r is not None:\r\n                    return r\r\n            try:\r\n                coeff = newe.as_leading_term(z, cdir=cdir)\r\n                if coeff != newe and coeff.has(exp):\r\n                    return gruntz(coeff, z, 0, ""-"" if re(cdir).is_negative else ""+"")\r\n            except (ValueError, NotImplementedError, PoleError):\r\n                pass\r\n```\r\n\r\nNow `newe = bessely(1, I/x)` and `coeff = sqrt(2)*sqrt(-I*x)*(3*I*x*sin(pi/4 - I/x)/8 - cos(pi/4 - I/x))/sqrt(pi)` , now as we\'re just checking for `exp` terms in the expression  so we won\'t really compute `gruntz` of `coeff` here but even if we did.\r\n```\r\n>>> gruntz(sqrt(2)*sqrt(-I*x)*(3*I*x*sin(pi/4 - I/x)/8 - cos(pi/4 - I/x))/sqrt(pi), x, 0)\r\n..................\r\n    raise PoleError(""Cannot expand %s around 0"" % (self))\r\nsympy.core.function.PoleError: Cannot expand sin(pi/4 + I/_w) around 0\r\n```\r\nAlso if we stick to the what we have as of now , we get `coeff = -sqrt(2)*cos(pi/4 - I/x)/(sqrt(pi)*sqrt(I/x))` and applying gruntz we get\r\n```\r\n>>> gruntz(-sqrt(2)*cos(pi/4 - I/x)/(sqrt(pi)*sqrt(I/x)), x, 0)\r\nTraceback (most recent call last):\r\n..............................\r\n    raise PoleError(""Cannot expand %s around 0"" % (self))\r\nsympy.core.function.PoleError: Cannot expand sin(pi/4 + I/_w) around 0\r\n```\r\nTherefore at the end we get to heuristics which can address then if we can find `bessely(n, I*oo)` where n is integer. Something like `besselj`, is never caught up because it uses `besselj(n, I*oo) == I**(n)*besseli(n, oo)` .\r\n\r\nIn simplest form gruntz can\'t help us calculate the following but it correctly calculates results of few close relatives of what we want\r\n```\r\n>>> gruntz(cos(pi/4 - I/x)/sqrt(I/x), x, 0)\r\nTraceback (most recent call last):\r\n..............................\r\n    raise PoleError(""Cannot expand %s around 0"" % (self))\r\nsympy.core.function.PoleError: Cannot expand sin(pi/4 + I/_w) around 0\r\n>>>\r\n>>> gruntz(cos(pi/3 - I/x)/sqrt(I/x), x, 0)\r\nTraceback (most recent call last):\r\n..............................\r\n    raise PoleError(""Cannot expand %s around 0"" % (self))\r\nsympy.core.function.PoleError: Cannot expand sin(pi/6 + I/_w) around 0\r\n>>>\r\n>>> gruntz(cos(-I/x)/sqrt(I/x), x, 0)\r\n-oo*sign(I**(3/2))\r\n>>> gruntz(cos(pi-I/x)/sqrt(I/x), x, 0)\r\noo*sign(I**(3/2))\r\n>>> gruntz(cos(pi/2-I/x)/sqrt(I/x), x, 0)\r\n-oo*I*sign(I**(3/2))\r\n```\r\n\r\n\r\n\r\n', 'comment_created': datetime.datetime(2022, 8, 22, 9, 2, 18, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 951192455, 'comment_body': ""The exponential approximation I was using earlier (from Wolfram) is something which does give us some breakthrough . I was using `(-I*exp(-I*pi*nu/2 + I*z - I*pi/4) + I*exp(I*pi*nu/2 - I*z + I*pi/4))/sqrt(2*pi*z)` . Using this we get `coeff = sqrt(2)*(-I*exp(-3*I*pi/4 - 1/x) + I*exp(3*I*pi/4 + 1/x))/(2*sqrt(pi)*sqrt(I/x))` . Using gruntz on this works\r\n```\r\n>>> gruntz(sqrt(2)*(-I*exp(-3*I*pi/4 - 1/x) + I*exp(3*I*pi/4 + 1/x))/(2*sqrt(pi)*sqrt(I/x)), x, 0)\r\n-oo*I*sign(I**(3/2))\r\n>>> _.n()\r\n-oo\r\n>>> gruntz(sqrt(2)*(-I*exp(-3*I*pi/4 - 1/x) + I*exp(3*I*pi/4 + 1/x))/(2*sqrt(pi)*sqrt(I/x)), x, 0, '-')\r\n-oo*I*sign(1/sqrt(-I))\r\n>>> _.n()\r\n-oo\r\n```\r\nTherefore through this we have some insight on what `limit(bessely(1, x), x, I*oo)` and `limit(bessely(1, x), x, -I*oo)`\r\nshould return ."", 'comment_created': datetime.datetime(2022, 8, 22, 9, 5, 26, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 951206888, 'comment_body': ""Also as `gruntz` was essentially designed to deal with real exp-log functions , I'm not sure if we're demanding more out of it , expecting results for these expressions . But yeah `besseli`, `besselk` have not so complex exponential  approximations and `besselj` has it's relation with `besseli` as follows\r\n```\r\n        if nu.is_integer:\r\n            if nu.could_extract_minus_sign():\r\n                return S.NegativeOne**(-nu)*besselj(-nu, z)\r\n            newz = z.extract_multiplicatively(I)\r\n            if newz:  # NOTE we don't want to change the function if z==0\r\n                return I**(nu)*besseli(nu, newz)\r\n```\r\nHence these would never face any issues around `I*oo`  or other complex infinites, the only one which might find some is `bessely` (unless and untill we can find out what value would a particular `bessely(n, I*oo))` return. If we can find these values , heuristics can easily do the job !"", 'comment_created': datetime.datetime(2022, 8, 22, 9, 20, 6, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 951240699, 'comment_body': 'It seems that the limit of `bessely` at `oo` and `-oo` is computed here: https://github.com/sympy/sympy/blob/88664e6e0b781d0a8b5347896af74b555e92891e/sympy/functions/special/bessel.py#L320-L321\r\nCannot we add similar lines for `I*oo` and `-I*oo`?', 'comment_created': datetime.datetime(2022, 8, 22, 9, 53, 43, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 951282096, 'comment_body': ""Yeah correct but like that's what I've pointed out above ......... I haven't been able to find any reference regarding how could we possibly evaluate this . I surely know there is a must be a well defined formula because of the repeating pattern of results here .\r\n\r\nThese are expected results from wolfram \r\n```\r\n>>> bessely(1, I*oo)\r\n-oo\r\n>>> bessely(2, I*oo)\r\n-I*oo\r\n>>> bessely(3, I*oo)\r\noo\r\n>>> bessely(4, I*oo)\r\nI*oo\r\n>>> bessely(5, I*oo)\r\n-oo\r\n>>> bessely(6, I*oo)\r\n-I*oo\r\n>>> # answer repeat after every 4 integers\r\n```\r\nTo me it looks like like `bessely(n, I*oo) = I**(n + 1)*oo`  ( from the pattern above but like I am not finding any good resource to confirm this ). I see `-I*oo` working out similarly ."", 'comment_created': datetime.datetime(2022, 8, 22, 10, 40, 18, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 951320499, 'comment_body': ""I think that those results would come from the first term of the expansion containing `sin(omega`. If we write `omega = x + I*y` where `x` depends on `nu` and `y -> oo` (or `-oo`), then we get `sin(x)*cos(I*y) + cos(x)*sin(I*y) = sin(x)*cosh(y) + cos(x)*I*sinh(y)`. Now `cosh(y)` and `sinh(y)` agree asymptotically (with `exp(x)/2`) and tend to `oo` when `y -> oo` so it looks like the limit should be `(sin(x) + I*cos(x))*oo = I*(-I*sin(x) + cos(x))*oo = I*exp(-I*x)*oo` (unless I miscalculated, it should be possible to check numerically).\r\n\r\nFrom the leading factor `sqrt(2/pi*z)` we'll also get and additional factor `sqrt(1/I)` as `z -> I*oo`. (`sqrt(2/pi)` is positive and does not matter. `sqrt(1/y)` will be absorbed by `cosh(y) ~ exp(y)/2 ~ sinh(y)`.)\r\n\r\nEdit: Added `I` to `exp(-I*x)` as it should be by Euler's formula."", 'comment_created': datetime.datetime(2022, 8, 22, 11, 22, 42, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 951558728, 'comment_body': 'I can confirm the calculations are correct here . So at the end everything boils down to this expression\r\nexpr = `I*sqrt(-I)*exp(-I*(-pi*nu/2 - pi/4)) * oo`  for `z` tending to `I*oo`.\r\n\r\nWe can also breakdown an expression for `-I*oo` similarly. There we would be using the fact the `cosh(-y)` , `sinh(-y)` and `exp(-y)` all agree asymptotically to be `oo` at `y -> -oo`.\r\nTherefore if we add a check like this\r\n```\r\n        if z in (S.Infinity, S.NegativeInfinity):\r\n            return S.Zero\r\n        if z is S.ImaginaryUnit*S.Infinity:\r\n            coeff = I*sqrt(-I)*exp(-I*(-pi*nu/2 - pi/4))\r\n            return coeff.n() * S.Infinity\r\n        if z is -S.ImaginaryUnit*S.Infinity:\r\n            coeff = sqrt(-I)*exp(I*(-pi*nu/2 - pi/4))\r\n            return coeff.n() * S.Infinity  \r\n```\r\n\r\nWe get all possible correct results\r\n```\r\n>>> bessely(1, I*oo)\r\n-oo\r\n>>> bessely(2, I*oo)\r\n-oo*I\r\n>>> bessely(3, I*oo)\r\noo\r\n>>> bessely(4, I*oo)\r\noo*I\r\n>>> bessely(1, -I*oo)\r\n-oo\r\n>>> bessely(2, -I*oo)\r\noo*I\r\n>>> bessely(3, -I*oo)\r\noo\r\n>>> bessely(4, -I*oo)\r\n-oo*I\r\n```\r\nI made sure to check all these results against wolfram. \r\n\r\n', 'comment_created': datetime.datetime(2022, 8, 22, 15, 7, 31, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 952229732, 'comment_body': ""The expression was derived for the limit at `I*oo`. I don't think that it would work for other infinities with positive imaginary part."", 'comment_created': datetime.datetime(2022, 8, 23, 7, 8, 30, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 952230568, 'comment_body': 'This can be simplified. `sqrt(-I)` is canceled by `exp(I*pi/4)`. Also `I = exp(I*pi/2)` so we get `exp(I*pi*(nu + 1)/2)`. There should be no need for `.n()`.', 'comment_created': datetime.datetime(2022, 8, 23, 7, 9, 28, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 952431555, 'comment_body': ""True i checked this , it won't be true in all cases . I thought our analysis can be extended to all positive im(z) but for now let's stick to `I*oo` and `-I*oo`"", 'comment_created': datetime.datetime(2022, 8, 23, 10, 22, 59, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 952440502, 'comment_body': ""Yeah I put the `.n()` just in case . Surely the expressions can be simplified further. I've made the changes in the latest commit ."", 'comment_created': datetime.datetime(2022, 8, 23, 10, 32, 50, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 955992947, 'comment_body': 'Are the arguments correctly ordered this way? ', 'comment_created': datetime.datetime(2022, 8, 26, 12, 29, 58, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 956002028, 'comment_body': 'Will sympify be needed, if `n0 = S.One` on the line above? ', 'comment_created': datetime.datetime(2022, 8, 26, 12, 41, 5, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 956003270, 'comment_body': 'Probably 1.12.', 'comment_created': datetime.datetime(2022, 8, 26, 12, 42, 36, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 956216546, 'comment_body': ""No like we need this line for the latest limit we've fixed here `limit((n+1)**k/((n+1)**(k+1) - (n)**(k+1)), n, oo)`.\r\n\r\nIn this in a intermediate step we get `min = O(n**(-k - 1))` , therefore `n0 = -k - 1` (through line 1051 - 1052) and we don't enter the `except` block during this operation ."", 'comment_created': datetime.datetime(2022, 8, 26, 16, 34, 40, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 956223584, 'comment_body': 'Maybe we could try using `sympify` in this line of `getn` function.\r\n```\r\n--- a/sympy/core/expr.py\r\n+++ b/sympy/core/expr.py\r\n@@ -1256,7 +1256,7 @@ def getn(self):\r\n             if o.is_Symbol:\r\n                 return S.One\r\n             if o.is_Pow:\r\n-                return o.args[1]\r\n+                return sympify(o.args[1])\r\n```\r\nOther outputs returned by the getn function are mostly returned in sympified form , so maybe we could try using this here .', 'comment_created': datetime.datetime(2022, 8, 26, 16, 44, 16, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 956288099, 'comment_body': ""Shouldn't `o.args[1]` always be a Basic object when `o.is_Pow`?"", 'comment_created': datetime.datetime(2022, 8, 26, 18, 0, 46, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 956524440, 'comment_body': ""Oops yeah , I overlooked this . Yeah we won't be needing `sympify` here "", 'comment_created': datetime.datetime(2022, 8, 27, 2, 12, 53, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 956532756, 'comment_body': 'Certainly... , we\'re just trying to replicate the general case i.e.\r\n```\r\n>>> y = Symbol(\'y\', positive=True)\r\n>>> expr = y + AccumBounds(-1, 1)\r\n>>> lst = [2, 3]\r\n>>> for i in lst:\r\n...     term = expr.subs(y, i)\r\n...     print(term**-1)\r\n...\r\nAccumBounds(1/3, 1)\r\nAccumBounds(1/4, 1/2)\r\n```\r\nI was also thinking about something which could work better than what we have currently . The `__rtruediv__` method and `__pow__` for positive powers are quite consistent with the results they return and I feel we could let these methods handle the general cases. I would expect this diff to maybe return more consistent results.\r\n```\r\n--- a/sympy/calculus/accumulationbounds.py\r\n+++ b/sympy/calculus/accumulationbounds.py\r\n@@ -524,9 +524,7 @@ def __pow__(self, other):\r\n                             return AccumBounds(self.max**other, oo)\r\n                         if self.max.is_zero:\r\n                             return AccumBounds(self.min**other, oo)\r\n-                        if self.has(Symbol):\r\n-                            return AccumBounds(self.max**other, self.min**other)\r\n-                        return AccumBounds(0, oo)\r\n+                        return (1/self)**(-other)\r\n                     return AccumBounds(\r\n                         S.Zero, Max(self.min**other, self.max**other))\r\n                 elif other % 2 == 1:\r\n@@ -535,9 +533,7 @@ def __pow__(self, other):\r\n                             return AccumBounds(self.max**other, oo)\r\n                         if self.max.is_zero:\r\n                             return AccumBounds(-oo, self.min**other)\r\n-                        if self.has(Symbol):\r\n-                            return AccumBounds(self.max**other, self.min**other)\r\n-                        return AccumBounds(-oo, oo)\r\n+                        return (1/self)**(-other)\r\n                     return AccumBounds(self.min**other, self.max**other)\r\n```\r\nThis also ensures consistent outputs /errors being returned overall\r\n```\r\n>>> x = Symbol(\'x\')\r\n>>> y = Symbol(\'y\', positive=True)\r\n>>> expr1 = y + AccumBounds(-1, 1)\r\n>>> expr2 = y + AccumBounds(2, 4)\r\n>>> expr3 = y + AccumBounds(-4, -2)\r\n>>> expr1\r\nAccumBounds(y - 1, y + 1)\r\n>>> expr2\r\nAccumBounds(y + 2, y + 4)\r\n>>> expr3\r\nAccumBounds(y - 4, y - 2)\r\n>>> 1/expr1\r\nTraceback (most recent call last):\r\n....\r\n    raise ValueError(""Only real AccumulationBounds are supported"")\r\nValueError: Only real AccumulationBounds are supported\r\n>>> expr1**-1\r\nTraceback (most recent call last):\r\n....\r\n    raise ValueError(""Only real AccumulationBounds are supported"")\r\nValueError: Only real AccumulationBounds are supported\r\n>>> 1/expr2\r\nAccumBounds(Min(1/(y + 2), 1/(y + 4)), Max(1/(y + 2), 1/(y + 4)))\r\n>>> expr2**-1\r\nAccumBounds(Min(1/(y + 2), 1/(y + 4)), Max(1/(y + 2), 1/(y + 4)))\r\n>>> 1/expr3\r\nTraceback (most recent call last):\r\n....\r\n    raise ValueError(""Only real AccumulationBounds are supported"")\r\nValueError: Only real AccumulationBounds are supported\r\n>>> expr3**-1\r\nTraceback (most recent call last):\r\n....\r\n    raise ValueError(""Only real AccumulationBounds are supported"")\r\nValueError: Only real AccumulationBounds are supported\r\n```\r\n\r\n', 'comment_created': datetime.datetime(2022, 8, 27, 3, 49, 44, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 956533102, 'comment_body': 'This change is being made with respect to this `limit(log(x)/(log(x) + sin(x)), x, oo)` where gruntz should fail and we get the result from simple heuristics . Implementing the diff above would give the exact traceback as we have on master \r\n```\r\n>>> gruntz(log(x)/(log(x) + sin(x)), x, oo)\r\nTraceback (most recent call last):\r\n.....................\r\n  File ""C:\\Users\\91989\\sympy\\sympy\\sympy\\calculus\\accumulationbounds.py"", line 194, in __new__\r\n    raise ValueError(""Only real AccumulationBounds are supported"")\r\nValueError: Only real AccumulationBounds are supported\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n  File ""C:\\Users\\91989\\sympy\\sympy\\sympy\\core\\mul.py"", line 1907, in _eval_nseries\r\n    raise ValueError\r\nValueError\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n.........................\r\n  File ""C:\\Users\\91989\\sympy\\sympy\\sympy\\calculus\\accumulationbounds.py"", line 194, in __new__\r\n    raise ValueError(""Only real AccumulationBounds are supported"")\r\nValueError: Only real AccumulationBounds are supported\r\n```\r\n Hence I see this would maintain consistency with whatever we have on master rather than introducing anything new. I\'ll commit this as I think the general case would best be handled by this and you could let me know if you think otherwise .', 'comment_created': datetime.datetime(2022, 8, 27, 3, 54, 35, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 957264036, 'comment_body': 'It seems that this does not hold for $\\arg z = \\pm\\pi$ so the condition `e.is_negative` will not suffice. \r\n', 'comment_created': datetime.datetime(2022, 8, 29, 12, 29, 1, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 958095750, 'comment_body': 'If the limit of the leading term `c*x**e` is `-oo` then something else should be returned, maybe `self` or `NotImplementedError`. The limit can be determined by setting `x = cdir*t` where `t` is positive. Then the sign of `c*cdir**e*t**e` is given by `c*cdir**e` as `t**e` is positive. The above expression can be returned if `c*cdir**e` is not (real and) negative.', 'comment_created': datetime.datetime(2022, 8, 30, 7, 19, 29, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 959052729, 'comment_body': '> It seems that this does not hold for arg\u2061z=±π so the condition `e.is_negative` will not suffice.\r\n\r\nYeah correct, not sure how much it would matter though as `besselj` always transforms itself .For eg\r\n```\r\n>>> besselj(1, 1/x)\r\nbesselj(1, 1/x)\r\n>>> besselj(1, -1/x)\r\n-besselj(1, 1/x)\r\n>>> besselj(1, I/x)\r\nI*besseli(1, 1/x)\r\n>>> besselj(1, -I/x)\r\n-I*besseli(1, 1/x)\r\n```\r\nSo like at the end all results eventually depend of  `1/x` (or rather leading term from positive side I guess) . Also limits won\'t really be a problem as now we use \r\n```\r\n        if z0.is_infinite:\r\n            cdir = sign(z0)\r\n            cdir = cdir/abs(cdir)\r\n            e = e.subs(z, cdir*z)\r\n            dir = ""-""\r\n            z0 = S.Infinity\r\n```\r\nHence even this would end up on the `1/x` if we are calculating limits . ', 'comment_created': datetime.datetime(2022, 8, 31, 1, 7, 38, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 959052998, 'comment_body': 'But yeah , this look interesting . Will give a thought with respect to other bessel functions too ! Maybe returning self would be a good option here .', 'comment_created': datetime.datetime(2022, 8, 31, 1, 8, 21, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 959093690, 'comment_body': ""Okay I did some testing on what you've pointed out and I see that this is good catch . The `-pi` case isn't disturbing but the `pi` case is... for `besselj` and `besseli` . The other two look fine to me currently (still thinking whether they could go wrong somewhere)\r\nThe simplest wrong result that can be seen is \r\n```\r\n>>> limit(besseli(1, 1/x), x, 0, '-')\r\n0\r\n>>> # It's counterpart gives the correct result\r\n>>>\r\n>>> limit(besseli(1, x), x, -oo)\r\n-oo\r\n```\r\nThis can surely be fixed by returning self for such cases !"", 'comment_created': datetime.datetime(2022, 8, 31, 2, 25, 57, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 959115100, 'comment_body': 'Actually [DLMF](https://dlmf.nist.gov/10.30) gives us some help with this \r\n\r\n<img width=""829"" alt=""image"" src=""https://user-images.githubusercontent.com/87052487/187581401-cbc8f25e-5cbd-430f-b421-13e3cef51e1f.png"">\r\n\r\nSo `besseli(1, 1/x)` is given by \r\n\r\n\r\n\r\n<img width=""292"" alt=""image"" src=""https://user-images.githubusercontent.com/87052487/187581497-df02c5ca-accd-4206-b7cc-48588cddd4c6.png"">\r\n\r\nNow if we only use the current code we have \r\n```\r\n>>> besseli(1, 1/x).as_leading_term(x, cdir=1)\r\nsqrt(2)*exp(1/x)/(2*sqrt(pi)*sqrt(1/x))\r\n>>>\r\n>>> besseli(1, 1/x).as_leading_term(x, cdir=-1)\r\nsqrt(2)*exp(1/x)/(2*sqrt(pi)*sqrt(1/x))\r\n```\r\n\r\nBut `sqrt(2)*exp(1/x)/(2*sqrt(pi)*sqrt(1/x))` isn\'t is sync with the left branch of `besseli(1, 1/x)`\r\n\r\n<img width=""284"" alt=""image"" src=""https://user-images.githubusercontent.com/87052487/187581773-7122bf27-dc13-45ec-bd2b-8d7b0a1e46c7.png"">\r\n\r\nHence the wrong result\r\n```\r\n>>> limit(besseli(1, 1/x), x, 0, \'-\')\r\n0\r\n```\r\nFor the left branch we need to use the new expression which DLMF points out through something like this\r\n```\r\n        elif e.is_negative:\r\n            cdir = 1 if cdir == 0 else cdir\r\n            sign = c*cdir**e\r\n            if not sign.is_negative and sign.is_real:\r\n                # Refer Abramowitz and Stegun 1965, p. 377 for more information on\r\n                # asymptotic approximation of besseli function.\r\n                return exp(z)/sqrt(2*pi*z)\r\n            return exp((nu + S.Half)*pi*I)*exp(-z)/sqrt(2*pi*z)\r\n\r\n        return super(besseli, self)._eval_as_leading_term(x, logx, cdir)\r\n```\r\nThis gives us \r\n```\r\n>>> besseli(1, 1/x).as_leading_term(x)\r\nsqrt(2)*exp(1/x)/(2*sqrt(pi)*sqrt(1/x))\r\n>>>\r\n>>> besseli(1, 1/x).as_leading_term(x, cdir = -1)\r\n-sqrt(2)*I*exp(-1/x)/(2*sqrt(pi)*sqrt(1/x))\r\n```\r\nThis gives us the correct left branch\r\n\r\n<img width=""317"" alt=""image"" src=""https://user-images.githubusercontent.com/87052487/187582252-fff4a542-f6e9-4987-8bce-cdc164f3bafd.png"">\r\n\r\n\r\n\r\n', 'comment_created': datetime.datetime(2022, 8, 31, 2, 54, 5, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 959115622, 'comment_body': 'Hence we would require two different expressions for both branches of `besseli(1, 1/x)`', 'comment_created': datetime.datetime(2022, 8, 31, 2, 54, 53, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 959132427, 'comment_body': 'I did good amount of testing for this and my take on each of the bessel functions is as follows\r\n1) `besselk` is clear as both [wolfram](https://functions.wolfram.com/Bessel-TypeFunctions/BesselK/06/02/01/02/0005/) and [DLMF](https://dlmf.nist.gov/10.25#E3) show only 1 expressions throughout for all `arg(z)`, hence no change is required here.\r\n\r\n2) For `besseli` we can use the alternative expression provided by [DLMF](https://dlmf.nist.gov/10.30) . Wolfram too provides a similar expression\r\n\r\n3) For `besselj` there\'s surely some improvement to be made as you\'ve pointed out . Though DLMF / Abramowitz and Stegun only provide an expression for `|arg(z)| < pi`, hence I checked out [wolfram](https://functions.wolfram.com/Bessel-TypeFunctions/BesselJ/06/02/03/02/0005/) where the `True` part of the piece seems to be working pretty well .\r\n\r\n4) For `bessely`, I currently don\'t see any errors because the leading term we return has similar branches as `bessely` ( just like `besselk` )\r\n\r\n<img width=""345"" alt=""image"" src=""https://user-images.githubusercontent.com/87052487/187586527-fb1b46b9-a7e6-4abe-9fb6-413cd0451c82.png"">\r\n\r\n```\r\n>>> bessely(1, 1/x).as_leading_term(x)\r\nsqrt(2)*sqrt(x)*(-3*x*sin(pi/4 - 1/x)/8 - cos(pi/4 - 1/x))/sqrt(pi)\r\n```\r\n\r\n<img width=""284"" alt=""image"" src=""https://user-images.githubusercontent.com/87052487/187586643-4cb2e810-3783-446f-8674-28146df30b33.png"">\r\n\r\nBut yeah similar to  `besselj`, we could try using the `True` part of the piecewise function provided by [wolfram](https://functions.wolfram.com/Bessel-TypeFunctions/BesselY/06/02/03/02/0008/)\r\n\r\n5) If we aren\'t sure for `besselj` and `besseli` we could obviously return `self`. I\'ll make the commit with `self` for `besselj / bessely/ besseli` and `besselk` need not be changed. Then we can discuss we want to take up any of the above mentioned appraoches.\r\n\r\n\r\n ', 'comment_created': datetime.datetime(2022, 8, 31, 3, 35, 53, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 959264376, 'comment_body': '> [wolfram](https://functions.wolfram.com/Bessel-TypeFunctions/BesselJ/06/02/03/02/0005/) where the True part of the piece seems to be working pretty well\r\n\r\nIt may be good for `-oo` but not necessarily for small positive `arg(z)`.\r\n```\r\nIn [39]: j1 = sqrt(2)/sqrt(pi*z)*cos(z - pi/4)                                  \r\n\r\nIn [40]: j2 = I*sqrt(2)/sqrt(pi*z)*cos(z + pi/4)                                \r\n\r\nIn [43]: besselj(0, 100 + I).n()                                                \r\nOut[43]: 0.0312927864188442 + 0.0906215052004212⋅ⅈ\r\n\r\nIn [44]: j1.subs(z, 100 + I).n()                                                \r\nOut[44]: 0.0314414864729186 + 0.0905904099222782⋅ⅈ\r\n\r\nIn [45]: j2.subs(z, 100 + I).n()                                                \r\nOut[45]: 0.024195849675035 + 0.119033842277378⋅ⅈ\r\n```', 'comment_created': datetime.datetime(2022, 8, 31, 7, 46, 51, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 960247681, 'comment_body': ""Yeah, I was mainly trying to handle the **arg(z) = pi** case ... my arguments became more centric towards these as you mentioned them.\r\n> It seems that this does not hold for  so the condition e.is_negative will not suffice.\r\n\r\nBut yeah I get what you're trying to convey, currently I don't think we have good reference for addressing this, hence as you've mentioned above \r\n> something else should be returned, maybe self or NotImplementedError\r\n\r\ncould be returned. I personally like **self** because I've noticed **heuristics** work well with **bessel** functions and hence there are more chances of getting the value we want as output. As of now I've committed self so looks good."", 'comment_created': datetime.datetime(2022, 9, 1, 6, 0, 59, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 960267369, 'comment_body': 'The true piece of wolfram might also work for - oo. ', 'comment_created': datetime.datetime(2022, 9, 1, 6, 33, 35, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 960277173, 'comment_body': ""Yess they do .All expressions I have referenced above were done keeping `-oo` in mind . I'll give a thought regarding how we could incorporate everything correctly . Let me know if you have something in mind !"", 'comment_created': datetime.datetime(2022, 9, 1, 6, 47, 27, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 960294063, 'comment_body': 'Yeah , strictly speaking with respect to `oo/-oo` , I would prefer the following results \r\n```\r\n>>> besselj(1, 1/x).as_leading_term(x, cdir = 1)\r\n-sqrt(2)*sin(pi/4 - 1/x)/(sqrt(pi)*sqrt(1/x))\r\n>>> besselj(1, 1/x).as_leading_term(x, cdir = -1)\r\nsqrt(2)*I*sqrt(x)*sin(pi/4 + 1/x)/sqrt(pi)\r\n>>> bessely(1, 1/x).as_leading_term(x, cdir = 1)\r\nsqrt(2)*sqrt(x)*(-3*x*sin(pi/4 - 1/x)/8 - cos(pi/4 - 1/x))/sqrt(pi)\r\n>>> bessely(1, 1/x).as_leading_term(x, cdir = -1)\r\n-sqrt(2)*sqrt(x)*(-exp(3*I*pi/4 + I/x) + cos(pi/4 - 1/x))/sqrt(pi)\r\n>>> besseli(1, 1/x).as_leading_term(x, cdir = 1)\r\nsqrt(2)*exp(1/x)/(2*sqrt(pi)*sqrt(1/x))\r\n>>> besseli(1, 1/x).as_leading_term(x, cdir = -1)\r\n-sqrt(2)*I*exp(-1/x)/(2*sqrt(pi)*sqrt(1/x))\r\n```\r\nOver something like\r\n```\r\n>>> besselj(1, 1/x).as_leading_term(x, cdir = 1)\r\n-sqrt(2)*sin(pi/4 - 1/x)/(sqrt(pi)*sqrt(1/x))\r\n>>> besselj(1, 1/x).as_leading_term(x, cdir = -1)\r\nbesselj(1, 1/x)\r\n>>> bessely(1, 1/x).as_leading_term(x, cdir = 1)\r\nsqrt(2)*sqrt(x)*(-3*x*sin(pi/4 - 1/x)/8 - cos(pi/4 - 1/x))/sqrt(pi)\r\n>>> bessely(1, 1/x).as_leading_term(x, cdir = -1)\r\nbessely(1, 1/x)\r\n>>> besseli(1, 1/x).as_leading_term(x, cdir = 1)\r\nsqrt(2)*exp(1/x)/(2*sqrt(pi)*sqrt(1/x))\r\n>>> besseli(1, 1/x).as_leading_term(x, cdir = -1)\r\nbesseli(1, 1/x)\r\n```\r\nI am fully sure about `Besseli` , for others we are using the true parts from wolfram and I see that they work quite well so maybe we could go with this .\r\n```\r\n--- a/sympy/functions/special/bessel.py\r\n+++ b/sympy/functions/special/bessel.py\r\n@@ -238,7 +238,7 @@ def _eval_as_leading_term(self, x, logx=None, cdir=0):\r\n                 # Refer Abramowitz and Stegun 1965, p. 364 for more information on\r\n                 # asymptotic approximation of besselj function.\r\n                 return sqrt(2)*cos(z - pi*(2*nu + 1)/4)/sqrt(pi*z)\r\n-            return self\r\n+            return sqrt(2)*I*sqrt(1/z)*exp(I*pi*nu)*cos(z + pi*(2*nu + 1)/4)/sqrt(pi)\r\n\r\n         return super(besselj, self)._eval_as_leading_term(x, logx, cdir)\r\n\r\n@@ -376,7 +376,7 @@ def _eval_as_leading_term(self, x, logx=None, cdir=0):\r\n                 # Refer Abramowitz and Stegun 1965, p. 364 for more information on\r\n                 # asymptotic approximation of bessely function.\r\n                 return sqrt(2)*(-sin(pi*nu/2 - z + pi/4) + 3*cos(pi*nu/2 - z + pi/4)/(8*z))*sqrt(1/z)/sqrt(pi)\r\n-            return self\r\n+            return -sqrt(2)*(exp(I*pi*nu/2 + I*z + I*pi/4)*cos(pi*nu) + cos(-pi*nu/2 + z + pi/4))*sqrt(1/z)/sqrt(pi)\r\n\r\n         return super(bessely, self)._eval_as_leading_term(x, logx, cdir)\r\n\r\n@@ -551,7 +551,7 @@ def _eval_as_leading_term(self, x, logx=None, cdir=0):\r\n                 # Refer Abramowitz and Stegun 1965, p. 377 for more information on\r\n                 # asymptotic approximation of besseli function.\r\n                 return exp(z)/sqrt(2*pi*z)\r\n-            return self\r\n+            return exp((nu + S.Half)*pi*I)*exp(-z)/sqrt(2*pi*z)\r\n\r\n         return super(besseli, self)._eval_as_leading_term(x, logx, cdir)\r\n```', 'comment_created': datetime.datetime(2022, 9, 1, 7, 10, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 960323460, 'comment_body': 'The true part should work as we already cover `|arg(z)| < pi` through our current implementation and as arg function can take values between `− 𝜋 < 𝜃 ≤ 𝜋` , we might only have to take care of `arg(z) == pi` , which is done correctly from the true part .', 'comment_created': datetime.datetime(2022, 9, 1, 7, 43, 42, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 960487369, 'comment_body': 'Can we try something like the following for `besselj` and `bessely`\r\n```\r\n--- a/sympy/functions/special/bessel.py\r\n+++ b/sympy/functions/special/bessel.py\r\n@@ -222,6 +222,7 @@ def _eval_rewrite_as_jn(self, nu, z, **kwargs):\r\n         return sqrt(2*z/pi)*jn(nu - S.Half, self.argument)\r\n\r\n     def _eval_as_leading_term(self, x, logx=None, cdir=0):\r\n+        from sympy.functions.elementary.complexes import arg as _arg\r\n         nu, z = self.args\r\n         try:\r\n             arg = z.as_leading_term(x)\r\n@@ -232,13 +233,11 @@ def _eval_as_leading_term(self, x, logx=None, cdir=0):\r\n         if e.is_positive:\r\n             return arg**nu/(2**nu*gamma(nu + 1))\r\n         elif e.is_negative:\r\n-            cdir = 1 if cdir == 0 else cdir\r\n-            sign = c*cdir**e\r\n-            if not sign.is_negative and sign.is_real:\r\n-                # Refer Abramowitz and Stegun 1965, p. 364 for more information on\r\n-                # asymptotic approximation of besselj function.\r\n-                return sqrt(2)*cos(z - pi*(2*nu + 1)/4)/sqrt(pi*z)\r\n-            return self\r\n+            if _arg(cdir) == S.Pi:\r\n+                return sqrt(2)*I*sqrt(1/z)*exp(I*pi*nu)*cos(z + pi*(2*nu + 1)/4)/sqrt(pi)\r\n+            # Refer Abramowitz and Stegun 1965, p. 364 for more information on\r\n+            # asymptotic approximation of besselj function.\r\n+            return sqrt(2)*cos(z - pi*(2*nu + 1)/4)/sqrt(pi*z)\r\n\r\n         return super(besselj, self)._eval_as_leading_term(x, logx, cdir)\r\n\r\n@@ -356,6 +355,7 @@ def _eval_rewrite_as_yn(self, nu, z, **kwargs):\r\n         return sqrt(2*z/pi) * yn(nu - S.Half, self.argument)\r\n\r\n     def _eval_as_leading_term(self, x, logx=None, cdir=0):\r\n+        from sympy.functions.elementary.complexes import arg as _arg\r\n         nu, z = self.args\r\n         try:\r\n             arg = z.as_leading_term(x)\r\n@@ -370,13 +370,11 @@ def _eval_as_leading_term(self, x, logx=None, cdir=0):\r\n             arg = Add(*[term_one, term_two, term_three]).as_leading_term(x, logx=logx)\r\n             return arg\r\n         elif e.is_negative:\r\n-            cdir = 1 if cdir == 0 else cdir\r\n-            sign = c*cdir**e\r\n-            if not sign.is_negative and sign.is_real:\r\n-                # Refer Abramowitz and Stegun 1965, p. 364 for more information on\r\n-                # asymptotic approximation of bessely function.\r\n-                return sqrt(2)*(-sin(pi*nu/2 - z + pi/4) + 3*cos(pi*nu/2 - z + pi/4)/(8*z))*sqrt(1/z)/sqrt(pi)\r\n-            return self\r\n+            if _arg(cdir) == S.Pi:\r\n+                return -sqrt(2)*(exp(I*pi*nu/2 + I*z + I*pi/4)*cos(pi*nu) + cos(-pi*nu/2 + z + pi/4))*sqrt(1/z)/sqrt(pi)\r\n+            # Refer Abramowitz and Stegun 1965, p. 364 for more information on\r\n+            # asymptotic approximation of besselj function.\r\n+            return sqrt(2)*(-sin(pi*nu/2 - z + pi/4) + 3*cos(pi*nu/2 - z + pi/4)/(8*z))*sqrt(1/z)/sqrt(pi)\r\n\r\n         return super(bessely, self)._eval_as_leading_term(x, logx, cdir)\r\n```', 'comment_created': datetime.datetime(2022, 9, 1, 10, 34, 17, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 960632277, 'comment_body': ""It isn't safe to use `is` instead of `==` like this. This only works because of the cache."", 'comment_created': datetime.datetime(2022, 9, 1, 13, 7, 8, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 960791121, 'comment_body': ""It looks like this is intended to catch the case where `exp._eval_nseries` would return `self`. But there may be other cases where the nseries is not well defined. I don't think that we should rely too much on `self` as a return value in problematic cases. It is more like a provisional arrangement."", 'comment_created': datetime.datetime(2022, 9, 1, 15, 23, 2, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 962101549, 'comment_body': ""> But there may be other cases where the nseries is not well defined.\r\n\r\nAs in ... Could you maybe give any example ?\r\n\r\n> I don't think that we should rely too much on self as a return value in problematic cases.\r\n\r\nHmm, we return `self`, when `res` is returned back in form `exp(e*log(b))` and `res` if this is not the case . The following test is being answered by the block\r\n```\r\ndef test_issue_14384():\r\n    x, a = symbols('x a')\r\n    assert series(x**a, x) == x**a\r\n    assert series(x**(-2*a), x) == x**(-2*a)\r\n    assert series(exp(a*log(x)), x) == exp(a*log(x))\r\n    assert series(x**I, x) == x**I\r\n    assert series(x**(I + 1), x) == x**(1 + I)\r\n    assert series(exp(I*log(x)), x) == exp(I*log(x))\r\n\r\n    logx = Symbol('logx')\r\n    assert ((sin(x))**y).nseries(x, n=1, logx=logx) == \\\r\n        exp(y*logx) + O(x*exp(y*logx), x)\r\n```` \r\nIn the last one obviously `res != exp(e*log(b))` and hence we return `res`\r\nNot sure how we could improve this . Do you know of some case which we will miss out but should be answered by this block currently .\r\n\r\n"", 'comment_created': datetime.datetime(2022, 9, 3, 4, 25, 17, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 962103819, 'comment_body': 'What do you think of the above pasted comments ? @jksuom ', 'comment_created': datetime.datetime(2022, 9, 3, 4, 52, 44, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 962301384, 'comment_body': 'Could this be `(m - 1).is_nonzero`?', 'comment_created': datetime.datetime(2022, 9, 4, 11, 57, 41, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 962437283, 'comment_body': 'Yeah , might have missed this in a hurry !', 'comment_created': datetime.datetime(2022, 9, 5, 2, 48, 57, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 962440620, 'comment_body': 'I have a little diff that will implement the asymptotic series expansion of `zeta(s,a)` with respect to `a` when the latter is a positive integer greater than 1. However it has to be done _after_ #24012 is merged – that is a big change and its new stuff will likely offer additional opportunities for the `zeta.aseries()` PR.', 'comment_created': datetime.datetime(2022, 9, 5, 2, 59, 57, tzinfo=datetime.timezone.utc), 'commenter': 'Parcly-Taxel', 'type': 'User'}, {'comment_id': 962443159, 'comment_body': ""> However it has to be done after https://github.com/sympy/sympy/pull/24012 is merged\r\n\r\nSure and as you've mentioned , even I feel that we might be able to address a better range of cases once that is implemented fully (and also get more consistent results which I feel we miss out sometimes during calculating limits of such functions that you and I are working on) !"", 'comment_created': datetime.datetime(2022, 9, 5, 3, 8, 54, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 962844856, 'comment_body': 'Could this be `maxpow = n`? ', 'comment_created': datetime.datetime(2022, 9, 5, 12, 16, 43, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 962849826, 'comment_body': ""Would `not sign.is_negative` suffice? I don't think it should necessarily be real. "", 'comment_created': datetime.datetime(2022, 9, 5, 12, 22, 50, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 962943340, 'comment_body': ""Yeah , I thought of doing that first but then `n` is a variable on type `int` and `m*e` is a variable of type `Mul` and eventually `n - m*e` would be a variable of type `Add` . So something like `mapow = n` won't work (probably something like importing sympify and using `mapow = sympify(n)` would be needed). Hence I thought of using this ,\r\n\r\nThe next line of line **1705** is the following which will return an `AttributeError` without n being sympified\r\n```\r\n        if maxpow.is_negative:\r\n            return Order(x**(m*e), x)\r\n```\r\nI'll make the change as of now ."", 'comment_created': datetime.datetime(2022, 9, 5, 14, 5, 59, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 962943524, 'comment_body': ""Yes, even I don't think that it would be required ."", 'comment_created': datetime.datetime(2022, 9, 5, 14, 6, 14, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}]","[{'commit_sha': 'f4913e3d080c5407e380c358d8515a45cda586bd', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}, {'commit_sha': '00d793f04386b516f823f3e55fc27e60ce33184b', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'd48a535854431cecd419f2244a90bf31c50f7bae', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'bb55aa2e870382f2b66df4be3958677b4b52d475', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'af0955a3328094677abfa7ec95a20ac3831f1013', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}, {'commit_sha': '83b756c3d520d04803ae653c97310ddea07d7bec', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'c09d5f4fc80e661abbb8d62ed23a00f32996a11f', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}]",Anutosh Bhat,87052487,,User,,45,,25,34
1047427353,[GSoC PR4.2] Implemented leading term and nseries methods for the frac function,"<!-- Your title above should be a short description of what
was changed. Do not include the issue number in the title. -->

#### References to other Issues or PRs
<!-- If this pull request fixes an issue, write ""Fixes #NNNN"" in that exact
format, e.g. ""Fixes #1234"" (see
https://tinyurl.com/auto-closing for more information). Also, please
write a comment on that issue linking back to this pull request once it is
open. -->


#### Brief description of what is fixed or changed
The `frac` function performs quite poorly while calculating limits . Some wrong results returned from master are as follows

```
>>> x =Symbol('x')
>>> limit(frac(x), x, 0, '+')
frac(_w)
>>> limit(frac(x), x, 0, '-')
0
>>> limit(frac(x + 1), x, 0, '-')
0
>>> limit(frac(-x), x, 0, '+')
0
>>> limit(frac(-x), x, 0, '-')
frac(-_w)
>>> limit(frac(-2*x + 1), x, 0, '+')
0
>>> limit(frac(x), x, 0, '+-')
Traceback (most recent call last):
    raise ValueError(""The limit does not exist since ""
ValueError: The limit does not exist since left hand limit = 0 and right hand limit = frac(_w)
```
All these have been been fixed , also I have implemented the `_eval_nseries` method for `frac` 
On master we had , which isn't wrong but not what one would expect either
```
>>> frac(x).series(x, 0, 6, cdir=1)
x*Subs(Derivative(frac(x), x), x, 0) + x**2*Subs(Derivative(frac(x), (x, 2)), x, 0)/2 + x**3*Subs(Derivative(frac(x), (x, 3)), x, 0)/6 + x**4*Subs(Derivative(frac(x), (x, 4)), x, 0)/24 + x**5*Subs(Derivative(frac(x), (x, 5)), x, 0)/120 + O(x**6)
```
The results for `series/nseries` of `frac` function heavily depend on the direction/`cdir` in which the `series/nseries` is being calculated , hence tests like the following will also be added, for the same.
```
>>> frac(x).series(x)
x + O(x**6)
>>> frac(x)._eval_nseries(x, 6, logx = None, cdir = 1)
x + O(x**6)
>>> frac(x)._eval_nseries(x, 6, logx = None, cdir = 0)
x + O(x**6)
>>> frac(x)._eval_nseries(x, 6, logx = None, cdir = -1)
1 + x + O(x**6)
>>> frac(2*x + 1)._eval_nseries(x, 6, logx = None, cdir = 1)
2*x + O(x**6)
>>> frac(2*x + 2)._eval_nseries(x, 6, logx = None, cdir = 1)
2*x + O(x**6)
>>> frac(x**2)._eval_nseries(x, 6, logx = None, cdir = 1)
x**2 + O(x**6)
>>> frac(x**2)._eval_nseries(x, 6, logx = None, cdir = -1)
x**2 + O(x**6)
>>> frac(x**3 - 1)._eval_nseries(x, 6, logx = None, cdir = -1)
1 + x**3 + O(x**6)
>>> frac(x**3 - 1)._eval_nseries(x, 6, logx = None, cdir = 1)
x**3 + O(x**6)
>>> 
>>> frac(1/x).series(x, 0, 6)
AccumBounds(0, 1) + O(x**6)
>>> frac(1/x).series(x, 0, 0)
O(1)
```
#### Other comments


#### Release Notes

<!-- Write the release notes for this release below between the BEGIN and END
statements. The basic format is a bulleted list with the name of the subpackage
and the release note for this PR. For example:

* solvers
  * Added a new solver for logarithmic equations.

* functions
  * Fixed a bug with log of integers.

or if no release note(s) should be included use:

NO ENTRY

See https://github.com/sympy/sympy/wiki/Writing-Release-Notes for more
information on how to write release notes. The bot will check your release
notes automatically to see if they are formatted correctly. -->

<!-- BEGIN RELEASE NOTES -->
* series
  * Implemented leading term and nseries methods for the frac function
<!-- END RELEASE NOTES -->
",True,24020,https://api.github.com/repos/sympy/sympy/pulls/24020,https://github.com/sympy/sympy/pull/24020,closed,85,18,4,1,6,18,3,0,"[{'name': 'series'}, {'name': 'GSoC'}, {'name': 'limits'}]",2022-09-06 11:19:54+00:00,2022-09-11 15:45:28+00:00,447934.0,"5 days, 4:25:34","[{'comment_id': 963816622, 'comment_body': 'What if ndir is negative? If it is positive, 0 should not be returned. ', 'comment_created': datetime.datetime(2022, 9, 6, 14, 57, 33, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 963823986, 'comment_body': 'This probably not needed as there are no high order terms. ', 'comment_created': datetime.datetime(2022, 9, 6, 15, 3, 51, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 963978534, 'comment_body': 'Could you give an example of this case ?', 'comment_created': datetime.datetime(2022, 9, 6, 17, 13, 9, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 964445265, 'comment_body': 'Two sided limit should be handled by the limit code. Here, and in most other leading term methods, `cdir=0` should be handled in the same way as `cdir=1` (by setting `cdir = 1`). There is no need to compute `ndir1`.', 'comment_created': datetime.datetime(2022, 9, 7, 6, 46, 57, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 964445433, 'comment_body': 'The leading term of `frac(x)` should be `x` if `cdir` is nonnegative and `1` if it is negative.', 'comment_created': datetime.datetime(2022, 9, 7, 6, 47, 13, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 964449916, 'comment_body': 'Yeah I had given a thought on this but then I saw few functions related to `frac` (which I guess would be the `floor` function)  . And such a block forms a core part of `floor.as_leading_term()`. \r\n```\r\n    def _eval_as_leading_term(self, x, logx=None, cdir=0):\r\n        from sympy.calculus.accumulationbounds import AccumBounds\r\n        arg = self.args[0]\r\n        arg0 = arg.subs(x, 0)\r\n        r = self.subs(x, 0)\r\n        if arg0 is S.NaN or isinstance(arg0, AccumBounds):\r\n            arg0 = arg.limit(x, 0, dir=\'-\' if re(cdir).is_negative else \'+\')\r\n            r = floor(arg0)\r\n        if arg0.is_finite:\r\n            if arg0 == r:\r\n                if cdir == 0:\r\n                    ndirl = arg.dir(x, cdir=-1)\r\n                    ndir = arg.dir(x, cdir=1)\r\n                    if ndir != ndirl:\r\n                        raise ValueError(""Two sided limit of %s around 0""\r\n                                    ""does not exist"" % self)\r\n                else:\r\n                    ndir = arg.dir(x, cdir=cdir)\r\n                return r - 1 if ndir.is_negative else r\r\n            else:\r\n                return r\r\n        return arg.as_leading_term(x, logx=logx, cdir=cdir)\r\n```\r\nBut yeah I\'ll try the other way round and maybe refactor floor and ceiling functions too along with the frac function.', 'comment_created': datetime.datetime(2022, 9, 7, 6, 53, 1, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 964508456, 'comment_body': ""For the case where we know `r` is `0`, won't 1 and 0 be the leading terms on both sides ? Maybe something like this might suffice I guess.\r\n```\r\n    def _eval_as_leading_term(self, x, logx=None, cdir=0):\r\n        from sympy.calculus.accumulationbounds import AccumBounds\r\n        arg = self.args[0]\r\n        arg0 = arg.subs(x, 0)\r\n        r = self.subs(x, 0)\r\n\r\n        if arg0.is_finite:\r\n            if r.is_zero:\r\n                ndir = arg.dir(x, cdir=cdir)\r\n                return S.One if ndir.is_negative else S.Zero\r\n            else:\r\n                return r\r\n        elif arg0 in (S.ComplexInfinity, S.Infinity, S.NegativeInfinity):\r\n            return AccumBounds(0, 1)\r\n```"", 'comment_created': datetime.datetime(2022, 9, 7, 7, 54, 54, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 964541654, 'comment_body': '```\r\nIn [1]: frac(x)._eval_as_leading_term(x)                                        \r\nOut[1]: 0  # x expected\r\n```', 'comment_created': datetime.datetime(2022, 9, 7, 8, 26, 24, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 964618119, 'comment_body': ""I've fixed this now !"", 'comment_created': datetime.datetime(2022, 9, 7, 9, 36, 52, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 964619783, 'comment_body': 'Some examples being\r\n```\r\n>>> frac(sin(x)).as_leading_term(x, cdir=1)\r\nsin(x)\r\n>>> frac(sin(x)).as_leading_term(x, cdir=-1)\r\n1\r\n>>> frac(sin(x**2)).as_leading_term(x, cdir=1)\r\nsin(x**2)\r\n>>> frac(sin(x**2)).as_leading_term(x, cdir=-1)\r\nsin(x**2)\r\n```\r\nThe examples I tried out looks fine to me !', 'comment_created': datetime.datetime(2022, 9, 7, 9, 38, 32, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 964624123, 'comment_body': 'arg could be sin(x). ', 'comment_created': datetime.datetime(2022, 9, 7, 9, 42, 45, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 964631289, 'comment_body': 'Ohh okay , do you mean that rather than `arg` ,we should do something with `arg.as_leading_term` ? Are the following answers correct ?\r\n```\r\n>>> frac(sin(x)).as_leading_term(x, cdir=1)\r\nsin(x)\r\n>>> frac(sin(x)).as_leading_term(x, cdir=-1)\r\n1\r\n>>> frac(sin(x**2)).as_leading_term(x, cdir=1)\r\nsin(x**2)\r\n>>> frac(sin(x**2)).as_leading_term(x, cdir=-1)\r\nsin(x**2)\r\n```\r\n', 'comment_created': datetime.datetime(2022, 9, 7, 9, 49, 53, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 964685698, 'comment_body': 'We should take only the leading term of arg instead of all of it. ', 'comment_created': datetime.datetime(2022, 9, 7, 10, 48, 33, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 965473116, 'comment_body': 'Actually it won\'t be `arg.as_leading_term(x)`, that we would be using . We would be using `(arg - arg0).as_leading_term(x)` . This is because consider `frac(-2*x + 1)` . Now if `ndir` is `nonnegative`, if we use arg\'s (-2*x + 1) leading term we get `1`. **Which is obviously incorrect .**\r\n\r\nThe graph is something like this \r\n<img width=""396"" alt=""image"" src=""https://user-images.githubusercontent.com/87052487/189028920-68de533a-11ee-44ed-b917-9bfecd216794.png"">\r\n\r\nHence we want `-2*x` as our answer. This can be explained through the following\r\n```\r\n>>> frac(-2*x + 1).rewrite(floor)\r\n-2*x - floor(-2*x)\r\n>>> frac(-2*x).rewrite(floor)\r\n-2*x - floor(-2*x)\r\n>>> _.as_leading_term(x)\r\n-2*x\r\n```\r\n\r\n', 'comment_created': datetime.datetime(2022, 9, 8, 3, 42, 25, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 965474779, 'comment_body': 'Some other cases where this logic plays a role \r\n```\r\n>>> frac(-2*x + 1).as_leading_term(x)\r\n-2*x\r\n>>> frac(2*x + 1).as_leading_term(x)\r\n2*x\r\n>>> frac(sin(x) + 5).as_leading_term(x)\r\nx\r\n>>> frac(sin(x) + 5).as_leading_term(x, cdir = -1)\r\n1\r\n```', 'comment_created': datetime.datetime(2022, 9, 8, 3, 47, 4, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 965511253, 'comment_body': ""> We would be using (arg - arg0).as_leading_term(x) . \r\n\r\nYes, that's right."", 'comment_created': datetime.datetime(2022, 9, 8, 5, 20, 44, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 965810310, 'comment_body': ""Shouldn't this be a (truncated) series in x? "", 'comment_created': datetime.datetime(2022, 9, 8, 10, 55, 37, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 967573975, 'comment_body': 'yes, it should . My bad ! Have made the changes .', 'comment_created': datetime.datetime(2022, 9, 10, 3, 21, 42, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}]","[{'commit_sha': 'd08ad9981061886fb1b98b0ebc66810bbb997a4d', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}]",Anutosh Bhat,87052487,,User,,45,,25,34
1048195398,[GSoC PR4.3] Implemented some series methods for gamma and error functions,"<!-- Your title above should be a short description of what
was changed. Do not include the issue number in the title. -->

#### References to other Issues or PRs
<!-- If this pull request fixes an issue, write ""Fixes #NNNN"" in that exact
format, e.g. ""Fixes #1234"" (see
https://tinyurl.com/auto-closing for more information). Also, please
write a comment on that issue linking back to this pull request once it is
open. -->


#### Brief description of what is fixed or changed
While implementing leading term for `expint(nu, z)` function, we don't really have to take care of cases where `nu < 1` and as the already implemented `_eval_nseries` method shows  we essentially only need to focus on cases where nu >=1.
Because expint(nu, z) when nu < 1 will be rewritten in forms of exponentials.
```
>>> expint(0, x)
exp(-x)/x
>>> expint(-1, x)
exp(-x)/x + exp(-x)/x**2
>>> expint(-2, x)
exp(-x)/x + 2*exp(-x)/x**2 + 2*exp(-x)/x**3
```

#### Other comments


#### Release Notes

<!-- Write the release notes for this release below between the BEGIN and END
statements. The basic format is a bulleted list with the name of the subpackage
and the release note for this PR. For example:

* solvers
  * Added a new solver for logarithmic equations.

* functions
  * Fixed a bug with log of integers.

or if no release note(s) should be included use:

NO ENTRY

See https://github.com/sympy/sympy/wiki/Writing-Release-Notes for more
information on how to write release notes. The bot will check your release
notes automatically to see if they are formatted correctly. -->

<!-- BEGIN RELEASE NOTES -->
* series
  * Implemented leading term methods for expint and Si function.
  * Implemented leading term methods for uppergamma and lowergamma fucntion.
<!-- END RELEASE NOTES -->
",False,24027,https://api.github.com/repos/sympy/sympy/pulls/24027,https://github.com/sympy/sympy/pull/24027,open,46,1,3,1,5,0,3,0,"[{'name': 'series'}, {'name': 'GSoC'}, {'name': 'Merge conflict'}]",2022-09-07 02:46:55+00:00,,0.0,,[],"[{'commit_sha': '8ac9ad14b76407b1a32dd314a45a7a1d6a9aeb9d', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}]",Anutosh Bhat,87052487,,User,,45,,25,34
754635808,"Fixed methods like extract_leading_term , Order and is_convergent for the expression (1 - cos(1/x)) , which weren't functioning as required .","<!-- Your title above should be a short description of what
was changed. Do not include the issue number in the title. -->

#### References to other Issues or PRs
<!-- If this pull request fixes an issue, write ""Fixes #NNNN"" in that exact
format, e.g. ""Fixes #1234"" (see
https://tinyurl.com/auto-closing for more information). Also, please
write a comment on that issue linking back to this pull request once it is
open. -->
Closes #21315 
Closes #21434 
Closes #12544


#### Brief description of what is fixed or changed
Digging in a bit , I realized that sympy's Order implementation for points around `oo` in a way depends on what result would we obtain if we substitute `1/x `in place of `x `and the point changes from `oo` to `0` . For eg 
```
>>> Order(x**2 + 1 + 1/x**5 , (x, oo))
O(x**2, (x, oo))
>>> Order(1/x**2 + 1 + x**5 , (x, 0))
O(x**(-2))
```
Just replacing x by 1/x and switching the point would imply inversion of the result and that's what is happening in this case too , 
```
>>> Order(1 - cos(x), (x, 0))
O(1)
>>> Order(1 - cos(1/x), (x, oo))
O(1, (x, oo))
```
And the method which deals with this inversion is the `extract_leading_order()` method in `sympy/core/add.py` so `(1 - cos(x)).extract_eading_order(x)` was not returning the expected result ,hence the error . It gives `((-cos(x), O(1)), (1, O(1)))` which shouldn't be the answer as once `cos(x)` is expanded 1 should cancel out and the answer should be `((x**2/2, O(x**2)),)`. Hence I have fixed this and added appropriate tests for the same 
```
>>> (1 - cos(x)).extract_leading_order(x)
((x**2/2, O(x**2)),)
>>> from sympy import oo
>>> O(1 - cos(1/x), (x, oo)) 
O(x**(-2), (x, oo)) # result of inversion of above obtained ((x**2/2, O(x**2)),)
>>> from sympy import Sum
>>> Sum( 1 - cos(1/x) , (x, 1, oo)).is_convergent()
True
```
p-test wasn't working for this which now will be working as we have the correct order of the expression.
#### Other comments


#### Release Notes

<!-- Write the release notes for this release below between the BEGIN and END
statements. The basic format is a bulleted list with the name of the subpackage
and the release note for this PR. For example:

* solvers
  * Added a new solver for logarithmic equations.

* functions
  * Fixed a bug with log of integers.

or if no release note(s) should be included use:

NO ENTRY

See https://github.com/sympy/sympy/wiki/Writing-Release-Notes for more
information on how to write release notes. The bot will check your release
notes automatically to see if they are formatted correctly. -->

<!-- BEGIN RELEASE NOTES -->
* series
  * Fixed methods like extract_leading_term , Order and is_convergent for the expression (1 - cos(1/x)) , which weren't functioning as required.
<!-- END RELEASE NOTES -->
",False,22247,https://api.github.com/repos/sympy/sympy/pulls/22247,https://github.com/sympy/sympy/pull/22247,open,79,71,4,9,28,9,2,0,"[{'name': 'series'}, {'name': 'Merge conflict'}]",2021-10-10 05:23:39+00:00,,0.0,,"[{'comment_id': 726022954, 'comment_body': ""Why is the try except needed? Where is the exception raised from and why? Is the exception actually being raised because of a bug?\r\n\r\nPlease don't use try/except like this. In general try/except masks bugs. ValueError can be raised by all kinds of bugs so we should not raise and catch it.\r\n\r\nThere are too many lines in between the `try` and the `except`. The `try` suite should contain only the exact function call that raises the exception.\r\n\r\nAt minimum catching a common error like ValueError needs to have comments that clearly explain where the expected ValueError is being raised from and what codepath leads to catching the exception.\r\n\r\nIt is almost always better to rewrite something like this by using an explicit check.\r\n\r\nThe control flow above is already confusing and this makes it worse."", 'comment_created': datetime.datetime(2021, 10, 11, 11, 16, 4, tzinfo=datetime.timezone.utc), 'commenter': 'oscarbenjamin', 'type': 'User'}, {'comment_id': 726065273, 'comment_body': 'Hey @oscarbenjamin Yeah I totally understand , It\'s confusing honestly , sorry for that . I\'ll make the required changes . So I wasn\'t sure how many terms should be calculated for the series . Like for `1-cos(x)` expanding cos(x) till 2 terms would do , but for `1- x**2/2 -cos(x)` we would need more terms to get the required leading order right ! so yeah that the confusing part which lead me to put the `try except `block in the first place . \r\nThis also lead to one or two tests failing in the first commit , like for eg one of the test which failed was this one. Obviously this fails because I wasn\'t quite sure how to calculate n and hence I felt that till I figure that out I could use the` except ValueError ` block . Hence that\'s not the correct use of the `try except `block (also try except block was a bit new to me before this , hence will keep this in mind )\r\n\r\n```\r\n>>> from sympy import limit, Symbol, gruntz\r\n>>> x = Symbol(\'x\')\r\n>>> from sympy import log,  exp, oo \r\n>>> gruntz(exp(exp(2*log(x**5 + x)*log(log(x))))/exp(exp(10*log(x)*log(log(x)))), x, oo)\r\n \r\n ValueError: Could not calculate 6 terms for 10*_p + O(_w**4)\r\n```\r\nThe Workflow also wasn\'t complicated actually untill the try except block came in and was easy to understand . I\'ll also think how to get the number of terms till which the series has to be expanded . If you have any idea what I could do , I would be glad to know !\r\nAnd anyways as others pointed out above we could , I was trying to replace `extracted_leading_order` by `as_leading_term` in order.py to get the desired result . Git diff shown below !\r\n--- a/sympy/series/order.py\r\n+++ b/sympy/series/order.py\r\n```\r\n@@ -221,7 +221,8 @@ def _new_(cls, expr, *args, **kwargs):\r\n             while old_expr != expr:\r\n                 old_expr = expr\r\n                 if expr.is_Add:\r\n-                    lst = expr.extract_leading_order(args)\r\n+                    leading_term = expr.as_leading_term(args)\r\n+                    lst = list((leading_term, Order(leading_term)))\r\n                     expr = Add(*[f.expr for (e, f) in lst])\r\n\r\n                 elif expr:\r\n```\r\nJust this would be enough to pass all tests having one variable as I already ran the tests locally . But this would give us trouble for multi-symbol/variate cases because our logic of using the` leading_term` followed by it\'s `order` would fail here .\r\n```\r\n>>> (x + y).extract_leading_order((x,y))\r\n((y, O(y, x, y)), (x, O(x, x, y)))\r\n>>> (x+y).as_leading_term((x,y))\r\ny\r\n```\r\nI have been trying to figure this out since an hour or two now cause if we have to address this we would have to extend `as_leading_term` but should it being giving(x, y) ??? cause at the end the name suggests that it would be returning the leading ""term"" and not terms .Hence wasn\'t fully convinced how to go about this! Any suggestion from your side would be really great !\r\n', 'comment_created': datetime.datetime(2021, 10, 11, 12, 18, 38, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 743102569, 'comment_body': 'The order of a sum cannot in general be derived from the orders of its arguments. The leading terms of the arguments may cancel each other, and then a series expansion has to be used to find the first non-canceled term. That is what is done by `Add._eval_as_leading_term`. The same procedure is needed here.', 'comment_created': datetime.datetime(2021, 11, 4, 18, 28, 58, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 743326236, 'comment_body': ""Ohh okay that maybe the case , I haven't changed much of the core code yet and this patch was also used originally . I'm not sure ,will have to go through the debug again but I feel this has been taken care of . This is what is happening in the issue referenced above.\r\n```\r\n>>> Order(1 - cos(1/x), (x, oo))\r\nO(x**(-2), (x, oo))\r\n\r\n>>> Order(1 - 1/(2*x**2) - cos(1/x), (x, oo))\r\nO(x**(-4), (x, oo)) \r\n\r\n>>> Order(sin(1/x)*x - cos(1/x), (x, oo)) # here 1 cancels out and the second term of the cos and sin terms\r\nO(x**(-2), (x, oo))               # is correctly evaluated to give the following result\r\n\r\n>>> Order(sin(1/x) - cos(1/x)/x, (x, oo))\r\nO(x**(-3), (x, oo))\r\n```\r\nThis wasn't working before as `extract_leading_term()` was not functioning as required. Could you give some examples where you feel this could go wrong . `Add._eval_as_leading_term` would function similarly\r\n```\r\n>>> Add._eval_as_leading_term(1 - cos(x), x)\r\nx**2/2\r\n\r\n>>> Add._eval_as_leading_term(1 - x**2/2 - cos(x), x)\r\n-x**4/24\r\n\r\n>>> Add._eval_as_leading_term(sin(x)/x - cos(x), x)\r\nx**2/3\r\n```\r\n\r\n"", 'comment_created': datetime.datetime(2021, 11, 5, 1, 6, 21, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 744689136, 'comment_body': 'Are there examples where these are needed?', 'comment_created': datetime.datetime(2021, 11, 8, 12, 44, 46, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 744733901, 'comment_body': ""Yeah surely ! I remember correctly that @0sidharth had assisted me with this patch and its only after discussing with him for a while I had pushed the code . I'll update this message with some cases in a while ! Until then you could let me know if you have other doubts regarding the Pr."", 'comment_created': datetime.datetime(2021, 11, 8, 13, 41, 36, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 744801344, 'comment_body': 'Are there examples where this line (247) is executed?', 'comment_created': datetime.datetime(2021, 11, 8, 14, 54, 2, tzinfo=datetime.timezone.utc), 'commenter': 'jksuom', 'type': 'User'}, {'comment_id': 745262027, 'comment_body': ""Not anything particular that I could think of, off the topic of my head . Not sure it's required or not cause I hadn't changed this patch as it was originally used. Will check some examples from the tests !\r\n\r\n**EDIT1**: Nope, I don't think so that's required !!! The only cases which enter the concerned code block as of now are \r\n```\r\nOrder(x*exp(1/x)).expr == x*exp(1/x)\r\n(Order(2*x)*x*exp(1/x)/log(x)**3).expr == x**2*exp(1/x)*log(x)**-3\r\nOrder(x*exp(1/y)).expr == x*exp(1/y)\r\nOrder(exp(x), (x, oo)).expr == Order(2*exp(x), (x, oo)).expr == exp(x)\r\n```\r\nSo its basically cases involing `exp(x)` at `oo` or `exp(1/x)` and `exp(x)` at `oo` would also be dealt as `exp(1/x)` eventually . So mostly all cases would be addressed by line 251(`expr.is_Mul` check) and couple by line 253(`expr.is_Pow `check). These cases are pretty exhaustive and cover all associated aspects . We could happily get rid of line 247!\r\n\r\n**EDIT2**: \r\nI somehow found couple of examples which would need that one particular line 247 which is the following\r\n`Order(exp(1/x) + x**n)` where n is any integer . This would fail without that block and return self instead of  `Order(exp(1/x)` which is the correct result mathematically !"", 'comment_created': datetime.datetime(2021, 11, 9, 3, 29, 53, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}, {'comment_id': 745335488, 'comment_body': ""All blocks are needed here, I'll tell you why . So the `c.is_Add` somewhat replicates what the following block (which has been removed by us) used to do for multivariable cases . We need to somehow split and Add subparts together as was done below \r\n```\r\n if expr.is_Add:\r\n           lst = expr.extract_leading_order(args)\r\n           expr = Add(*[f.expr for (e, f) in lst])\r\n```\r\nIf we don't have these blocks and stick to the original code which is written below\r\n```\r\nself = c\r\nfor x in symbols:\r\n      c = c.as_leading_term(x, logx=logx, cdir=cdir)\r\n      return c\r\n```\r\nwe won't be getting desired results for multivariable cases as the form in which self is passed here isn't split up already . For example on master something like `O(x + y) ` or `O(1/x**2 + 2*y) ` would always enter the `as_leading_term()` code either as` x` or `y` but not `x+y` , but now that we have removed the above code , we need to do that split up in `as_leading_term()` . I am not the best while explaining but I hope you understand !\r\n\r\nI just added a print statement(print(self, 'this is self') as the first line in `as_leading_term()` to show what I meant and we get the following\r\n\r\nOn Master\r\n![image](https://user-images.githubusercontent.com/87052487/140876446-f28bdb99-9fcd-4d28-93b2-ed14f4ff1e36.png)\r\n\r\nOn Branch\r\n![image](https://user-images.githubusercontent.com/87052487/140876527-b8e912d1-4e32-41d5-ba01-a92e2be77e45.png)\r\n\r\nHere we can see that it enters as` x+y` multiple time and the `c.is_add` block deals with this just as it should be !\r\n"", 'comment_created': datetime.datetime(2021, 11, 9, 7, 3, 59, tzinfo=datetime.timezone.utc), 'commenter': 'anutosh491', 'type': 'User'}]","[{'commit_sha': 'af7a5c3bf1224dceec833c893acdf69842747e53', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}, {'commit_sha': '3a95670a0d71477b3c1e26f0eaf8a5d6ec6ff4db', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}, {'commit_sha': '30f43db193bfd44087fe3a69437c7d05449d670b', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'fc1a8633e647729ec8dc285683643b5949c3dc6e', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'c26a9ee06860222f28ca778f455f14c9cfcfc8c1', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}, {'commit_sha': '29a56b424fee70ba36764a55e96053eee6296744', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'f2c872f8bad1c88bbf13ad3d59c5f2e4e41626ed', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}, {'commit_sha': '61ab724cf1abae43bd5c427e3cbb6ba28fe47dda', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}, {'commit_sha': 'aa0e3148f6dd973c7f31576e5746b078b5f35669', 'committer_username': 'anutosh491', 'committer_name': 'Anutosh Bhat', 'committer_email': None, 'commit_date': datetime.datetime(2021, 7, 7, 3, 0, 26, tzinfo=datetime.timezone.utc)}]",Anutosh Bhat,87052487,,User,,45,,25,34

Project_ID,Name,Full_name,Language,Forks,Stars,Watchers,contributors,commits,issues,branches,PRs_count,contributor pullrequests
640534,sympy,sympy/sympy,Python,4364,12697,293,1320,58684,5120,14,716,"[{'id': 2025006514, 'number': 26980, 'closed': datetime.datetime(2024, 8, 19, 10, 26, 8, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2024, 8, 19, 7, 47, 9, tzinfo=datetime.timezone.utc), 'time_taken': 9539.0, 'time_delta': '2:38:59', 'additions': 7, 'deletions': 1, 'state': 'closed'}, {'id': 2016754319, 'number': 26955, 'closed': datetime.datetime(2024, 8, 13, 10, 28, 4, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2024, 8, 13, 9, 36, 12, tzinfo=datetime.timezone.utc), 'time_taken': 3112.0, 'time_delta': '0:51:52', 'additions': 9, 'deletions': 0, 'state': 'closed'}, {'id': 2016337284, 'number': 26954, 'closed': datetime.datetime(2024, 8, 13, 12, 30, 37, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2024, 8, 13, 5, 31, 50, tzinfo=datetime.timezone.utc), 'time_taken': 25127.0, 'time_delta': '6:58:47', 'additions': 12, 'deletions': 3, 'state': 'closed'}, {'id': 1720447495, 'number': 26209, 'closed': datetime.datetime(2024, 2, 11, 6, 48, 6, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2024, 2, 10, 12, 33, 31, tzinfo=datetime.timezone.utc), 'time_taken': 65675.0, 'time_delta': '18:14:35', 'additions': 20, 'deletions': 0, 'state': 'closed'}, {'id': 1403066339, 'number': 25279, 'closed': datetime.datetime(2023, 6, 26, 12, 30, 16, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2023, 6, 22, 8, 6, 57, tzinfo=datetime.timezone.utc), 'time_taken': 361399.0, 'time_delta': '4 days, 4:23:19', 'additions': 62, 'deletions': 7, 'state': 'closed'}, {'id': 1048195398, 'number': 24027, 'closed': None, 'created': datetime.datetime(2022, 9, 7, 2, 46, 55, tzinfo=datetime.timezone.utc), 'time_taken': 0.0, 'time_delta': '', 'additions': 46, 'deletions': 1, 'state': 'open'}, {'id': 1047427353, 'number': 24020, 'closed': datetime.datetime(2022, 9, 11, 15, 45, 28, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2022, 9, 6, 11, 19, 54, tzinfo=datetime.timezone.utc), 'time_taken': 447934.0, 'time_delta': '5 days, 4:25:34', 'additions': 85, 'deletions': 18, 'state': 'closed'}, {'id': 1009725347, 'number': 23844, 'closed': datetime.datetime(2022, 9, 6, 10, 31, 47, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2022, 7, 27, 14, 14, 45, tzinfo=datetime.timezone.utc), 'time_taken': 3529022.0, 'time_delta': '40 days, 20:17:02', 'additions': 487, 'deletions': 108, 'state': 'closed'}, {'id': 998615654, 'number': 23798, 'closed': datetime.datetime(2022, 7, 26, 7, 15, 27, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2022, 7, 17, 10, 50, 8, tzinfo=datetime.timezone.utc), 'time_taken': 764719.0, 'time_delta': '8 days, 20:25:19', 'additions': 554, 'deletions': 96, 'state': 'closed'}, {'id': 985431714, 'number': 23715, 'closed': datetime.datetime(2022, 7, 16, 16, 0, 18, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2022, 7, 2, 1, 41, 15, tzinfo=datetime.timezone.utc), 'time_taken': 1261143.0, 'time_delta': '14 days, 14:19:03', 'additions': 662, 'deletions': 218, 'state': 'closed'}, {'id': 960093773, 'number': 23595, 'closed': datetime.datetime(2024, 8, 13, 13, 13, 5, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2022, 6, 7, 8, 57, 10, tzinfo=datetime.timezone.utc), 'time_taken': 68962555.0, 'time_delta': '798 days, 4:15:55', 'additions': 33, 'deletions': 2, 'state': 'closed'}, {'id': 959935796, 'number': 23592, 'closed': datetime.datetime(2022, 7, 1, 15, 2, 36, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2022, 6, 7, 6, 20, 19, tzinfo=datetime.timezone.utc), 'time_taken': 2104937.0, 'time_delta': '24 days, 8:42:17', 'additions': 286, 'deletions': 76, 'state': 'closed'}, {'id': 883545989, 'number': 23258, 'closed': datetime.datetime(2022, 3, 28, 10, 51, 16, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2022, 3, 18, 15, 22, 57, tzinfo=datetime.timezone.utc), 'time_taken': 847699.0, 'time_delta': '9 days, 19:28:19', 'additions': 58, 'deletions': 4, 'state': 'closed'}, {'id': 879826325, 'number': 23241, 'closed': datetime.datetime(2022, 3, 16, 16, 57, 42, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2022, 3, 15, 7, 4, 32, tzinfo=datetime.timezone.utc), 'time_taken': 121990.0, 'time_delta': '1 day, 9:53:10', 'additions': 20, 'deletions': 7, 'state': 'closed'}, {'id': 878185506, 'number': 23229, 'closed': None, 'created': datetime.datetime(2022, 3, 12, 14, 51, 53, tzinfo=datetime.timezone.utc), 'time_taken': 0.0, 'time_delta': '', 'additions': 94, 'deletions': 1, 'state': 'open'}, {'id': 867885747, 'number': 23190, 'closed': None, 'created': datetime.datetime(2022, 3, 1, 13, 48, 31, tzinfo=datetime.timezone.utc), 'time_taken': 0.0, 'time_delta': '', 'additions': 28, 'deletions': 5, 'state': 'open'}, {'id': 858668790, 'number': 23127, 'closed': datetime.datetime(2022, 2, 20, 8, 46, 30, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2022, 2, 19, 18, 43, 52, tzinfo=datetime.timezone.utc), 'time_taken': 50558.0, 'time_delta': '14:02:38', 'additions': 52, 'deletions': 3, 'state': 'closed'}, {'id': 858653312, 'number': 23124, 'closed': datetime.datetime(2022, 2, 19, 18, 16, 22, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2022, 2, 19, 17, 18, 29, tzinfo=datetime.timezone.utc), 'time_taken': 3473.0, 'time_delta': '0:57:53', 'additions': 66, 'deletions': 34, 'state': 'closed'}, {'id': 854690931, 'number': 23087, 'closed': datetime.datetime(2022, 2, 19, 18, 44, 47, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2022, 2, 16, 18, 14, 40, tzinfo=datetime.timezone.utc), 'time_taken': 261007.0, 'time_delta': '3 days, 0:30:07', 'additions': 52, 'deletions': 3, 'state': 'closed'}, {'id': 842869288, 'number': 23044, 'closed': datetime.datetime(2023, 8, 15, 4, 8, 1, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2022, 2, 8, 14, 22, 58, tzinfo=datetime.timezone.utc), 'time_taken': 47742303.0, 'time_delta': '552 days, 13:45:03', 'additions': 127, 'deletions': 4, 'state': 'closed'}, {'id': 840868401, 'number': 23019, 'closed': None, 'created': datetime.datetime(2022, 2, 5, 13, 46, 53, tzinfo=datetime.timezone.utc), 'time_taken': 0.0, 'time_delta': '', 'additions': 14, 'deletions': 1, 'state': 'open'}, {'id': 838238455, 'number': 22995, 'closed': datetime.datetime(2022, 7, 16, 16, 0, 17, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2022, 2, 2, 12, 12, 19, tzinfo=datetime.timezone.utc), 'time_taken': 14183278.0, 'time_delta': '164 days, 3:47:58', 'additions': 66, 'deletions': 8, 'state': 'closed'}, {'id': 833408501, 'number': 22934, 'closed': datetime.datetime(2022, 2, 7, 20, 23, 28, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2022, 1, 27, 13, 13, 30, tzinfo=datetime.timezone.utc), 'time_taken': 976198.0, 'time_delta': '11 days, 7:09:58', 'additions': 11, 'deletions': 1, 'state': 'closed'}, {'id': 829786486, 'number': 22905, 'closed': datetime.datetime(2022, 2, 16, 13, 37, 59, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2022, 1, 23, 16, 35, 26, tzinfo=datetime.timezone.utc), 'time_taken': 2062953.0, 'time_delta': '23 days, 21:02:33', 'additions': 61, 'deletions': 9, 'state': 'closed'}, {'id': 824152537, 'number': 22870, 'closed': datetime.datetime(2022, 2, 3, 13, 36, 46, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2022, 1, 17, 4, 18, 17, tzinfo=datetime.timezone.utc), 'time_taken': 1502309.0, 'time_delta': '17 days, 9:18:29', 'additions': 27, 'deletions': 6, 'state': 'closed'}, {'id': 815282405, 'number': 22806, 'closed': None, 'created': datetime.datetime(2022, 1, 6, 7, 7, 18, tzinfo=datetime.timezone.utc), 'time_taken': 0.0, 'time_delta': '', 'additions': 110, 'deletions': 7, 'state': 'open'}, {'id': 815198164, 'number': 22804, 'closed': None, 'created': datetime.datetime(2022, 1, 6, 3, 24, 32, tzinfo=datetime.timezone.utc), 'time_taken': 0.0, 'time_delta': '', 'additions': 307, 'deletions': 71, 'state': 'open'}, {'id': 805503443, 'number': 22698, 'closed': None, 'created': datetime.datetime(2021, 12, 17, 16, 18, 55, tzinfo=datetime.timezone.utc), 'time_taken': 0.0, 'time_delta': '', 'additions': 1205, 'deletions': 2, 'state': 'open'}, {'id': 805028821, 'number': 22695, 'closed': None, 'created': datetime.datetime(2021, 12, 17, 4, 14, 12, tzinfo=datetime.timezone.utc), 'time_taken': 0.0, 'time_delta': '', 'additions': 34, 'deletions': 1, 'state': 'open'}, {'id': 799990304, 'number': 22639, 'closed': None, 'created': datetime.datetime(2021, 12, 10, 14, 56, 12, tzinfo=datetime.timezone.utc), 'time_taken': 0.0, 'time_delta': '', 'additions': 67, 'deletions': 35, 'state': 'open'}, {'id': 795720669, 'number': 22614, 'closed': datetime.datetime(2021, 12, 6, 21, 38, 26, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2021, 12, 6, 10, 11, 58, tzinfo=datetime.timezone.utc), 'time_taken': 41188.0, 'time_delta': '11:26:28', 'additions': 17, 'deletions': 4, 'state': 'closed'}, {'id': 789925648, 'number': 22555, 'closed': None, 'created': datetime.datetime(2021, 11, 27, 12, 29, 9, tzinfo=datetime.timezone.utc), 'time_taken': 0.0, 'time_delta': '', 'additions': 188, 'deletions': 7, 'state': 'open'}, {'id': 783722221, 'number': 22521, 'closed': datetime.datetime(2022, 7, 16, 16, 0, 17, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2021, 11, 18, 13, 3, 36, tzinfo=datetime.timezone.utc), 'time_taken': 20746601.0, 'time_delta': '240 days, 2:56:41', 'additions': 110, 'deletions': 22, 'state': 'closed'}, {'id': 780027065, 'number': 22491, 'closed': datetime.datetime(2021, 11, 20, 7, 40, 12, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2021, 11, 14, 6, 20, 56, tzinfo=datetime.timezone.utc), 'time_taken': 523156.0, 'time_delta': '6 days, 1:19:16', 'additions': 20, 'deletions': 9, 'state': 'closed'}, {'id': 778188142, 'number': 22463, 'closed': None, 'created': datetime.datetime(2021, 11, 11, 3, 9, 45, tzinfo=datetime.timezone.utc), 'time_taken': 0.0, 'time_delta': '', 'additions': 132, 'deletions': 37, 'state': 'open'}, {'id': 773333046, 'number': 22422, 'closed': datetime.datetime(2022, 5, 4, 22, 27, 16, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2021, 11, 4, 13, 48, 51, tzinfo=datetime.timezone.utc), 'time_taken': 15669505.0, 'time_delta': '181 days, 8:38:25', 'additions': 24, 'deletions': 2, 'state': 'closed'}, {'id': 770342857, 'number': 22403, 'closed': datetime.datetime(2021, 11, 2, 10, 37, 51, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2021, 11, 1, 9, 31, 51, tzinfo=datetime.timezone.utc), 'time_taken': 90360.0, 'time_delta': '1 day, 1:06:00', 'additions': 4, 'deletions': 1, 'state': 'closed'}, {'id': 763337426, 'number': 22339, 'closed': None, 'created': datetime.datetime(2021, 10, 21, 14, 26, 33, tzinfo=datetime.timezone.utc), 'time_taken': 0.0, 'time_delta': '', 'additions': 27, 'deletions': 2, 'state': 'open'}, {'id': 757320467, 'number': 22264, 'closed': datetime.datetime(2022, 2, 18, 5, 8, 57, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2021, 10, 13, 11, 51, 28, tzinfo=datetime.timezone.utc), 'time_taken': 11035049.0, 'time_delta': '127 days, 17:17:29', 'additions': 16, 'deletions': 1, 'state': 'closed'}, {'id': 754635808, 'number': 22247, 'closed': None, 'created': datetime.datetime(2021, 10, 10, 5, 23, 39, tzinfo=datetime.timezone.utc), 'time_taken': 0.0, 'time_delta': '', 'additions': 79, 'deletions': 71, 'state': 'open'}, {'id': 753086801, 'number': 22230, 'closed': datetime.datetime(2021, 10, 8, 3, 8, 57, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2021, 10, 7, 11, 25, 16, tzinfo=datetime.timezone.utc), 'time_taken': 56621.0, 'time_delta': '15:43:41', 'additions': 9, 'deletions': 0, 'state': 'closed'}, {'id': 748064097, 'number': 22200, 'closed': datetime.datetime(2024, 8, 19, 10, 26, 10, tzinfo=datetime.timezone.utc), 'created': datetime.datetime(2021, 10, 2, 6, 27, tzinfo=datetime.timezone.utc), 'time_taken': 90907150.0, 'time_delta': '1052 days, 3:59:10', 'additions': 21, 'deletions': 4, 'state': 'closed'}, {'id': 747226072, 'number': 22193, 'closed': None, 'created': datetime.datetime(2021, 10, 1, 3, 52, 6, tzinfo=datetime.timezone.utc), 'time_taken': 0.0, 'time_delta': '', 'additions': 65, 'deletions': 6, 'state': 'open'}, {'id': 743645907, 'number': 22161, 'closed': None, 'created': datetime.datetime(2021, 9, 27, 16, 50, 24, tzinfo=datetime.timezone.utc), 'time_taken': 0.0, 'time_delta': '', 'additions': 95, 'deletions': 0, 'state': 'open'}]"
